<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>晓风残月的博客</title>
    <link>http://www.baiyp.ren/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>个人技术的一些积累</description>
    <pubDate>Fri, 09 Aug 2019 05:07:19 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>java并发工具类-Exchanger</title>
      <link>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-06.html</link>
      <guid>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-06.html</guid>
      <pubDate>Wed, 07 Aug 2019 10:04:39 GMT</pubDate>
      <description>
      
        java并发工具类-Exchanger的使用
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="java并发工具类-Exchanger"><a href="#java并发工具类-Exchanger" class="headerlink" title="java并发工具类-Exchanger"></a>java并发工具类-Exchanger</h2><p><img src="../images/exchanger01.png" alt></p><h3 id="Exchanger-简介"><a href="#Exchanger-简介" class="headerlink" title="Exchanger 简介"></a>Exchanger 简介</h3><p>​ Exchange位于JUC包下面，主要是用于线程之间数据交换的工具类，经常用于管道设计和遗传算法中，Exchanger用于进行线程间的数据交换，它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange 方法交换数据，如果第一个线程先执行exchange 方法，它会一直等待第二个线程也执行exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据。</p><p>可以将Exchange看做是一个双向数据传输的SynchronousQueue。</p><ul><li>此类提供对外的操作是同步的；</li><li>用于成对出现的线程之间交换数据；</li><li>可以视作双向的同步队列；</li><li>可应用于基因算法、流水线设计等场景。</li></ul><h3 id="Exchanger-提供的方法"><a href="#Exchanger-提供的方法" class="headerlink" title="Exchanger 提供的方法"></a>Exchanger 提供的方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new Exchanger.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      participant = <span class="keyword">new</span> Participant();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>创建一个新的Exchange。</p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>这个类提供对外的接口非常简洁，一个无参构造函数，两个重载的范型exchange方法：</p><blockquote><p>等待另外一个线程到达此交换点（除非当前线程被中断），将给定的对象x传送给该线程，并且接收该线程的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><blockquote><p>等待另外一个线程到达此交换点（除非当前线程被中断，或者超出了指定的等待时间），将指定的对象x传送给该线程，同时接收该线程的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br></pre></td></tr></table></figure><h3 id="Exchanger的应用场景"><a href="#Exchanger的应用场景" class="headerlink" title="Exchanger的应用场景"></a>Exchanger的应用场景</h3><p>​ Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。</p><p>​ 只要用于两个线程之间交换数据。</p><p>​ 如果两个线程有一个没有到达exchange方法，则会一直等待,如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, long timeout, TimeUnit unit)设置最大等待时长。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>​ 比如生活中两个人，一个人有零食，另一个人有钱，他们两个想等价交换，对好口号在某个地方相见，一个人先到了之后，必须等另一个人带着需要的东西来了之后，才能开始交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Exchanger exchanger = <span class="keyword">new</span> Exchanger();</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//线程1 拿着零食来交换</span></span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            String data1 = <span class="string">"零食"</span>;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">"正在把数据 "</span> + data1 + <span class="string">" 换出去"</span>);</span><br><span class="line">            String data2 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"正在交换等待10s"</span>);</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) Math.random() * <span class="number">10000</span>);</span><br><span class="line">                <span class="comment">//开始交换数</span></span><br><span class="line">                data2 = (String) exchanger.exchange(data1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">"换回的数据为 "</span> + data2);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程2 拿着钱来交换</span></span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            String data1 = <span class="string">"钱"</span>;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">"正在把数据 "</span> + data1 + <span class="string">" 交换出去"</span>);</span><br><span class="line">            String data2 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"正在交换等待10s"</span>);</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                <span class="comment">//开始交换数</span></span><br><span class="line">                data2 = (String) exchanger.exchange(data1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">"交换回来的数据是: "</span> + data2);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">1</span>正在把数据 零食 换出去</span><br><span class="line">正在交换等待<span class="number">10</span>s</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">2</span>正在把数据 钱 交换出去</span><br><span class="line">正在交换等待<span class="number">10</span>s</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span>交换回来的数据是: 零食</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span>换回的数据为 钱</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-06.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>java变得牛逼的方法</title>
      <link>http://www.baiyp.ren/%E5%8F%98%E5%BE%97%E7%89%9B%E9%80%BC%E7%9A%84%E6%96%B9%E6%B3%95.html</link>
      <guid>http://www.baiyp.ren/%E5%8F%98%E5%BE%97%E7%89%9B%E9%80%BC%E7%9A%84%E6%96%B9%E6%B3%95.html</guid>
      <pubDate>Mon, 05 Aug 2019 13:51:08 GMT</pubDate>
      <description>
      
        java变得牛逼的方法
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="变得牛逼的方法"><a href="#变得牛逼的方法" class="headerlink" title="变得牛逼的方法"></a>变得牛逼的方法</h2><p><img src="../images/nb01.jpg" alt></p><h3 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h3><h4 id="习惯使用百度"><a href="#习惯使用百度" class="headerlink" title="习惯使用百度"></a>习惯使用百度</h4><blockquote><p>让周围人都认为你习惯于使用百度</p></blockquote><h4 id="多关注些大咖的微博"><a href="#多关注些大咖的微博" class="headerlink" title="多关注些大咖的微博"></a>多关注些大咖的微博</h4><blockquote><p>让周围人都认为你的知识都是从大咖那里学来的，不要让周围人找到学习的重点</p></blockquote><h3 id="知识学习和技能训练"><a href="#知识学习和技能训练" class="headerlink" title="知识学习和技能训练"></a>知识学习和技能训练</h3><h4 id="混淆认识-知识幻觉"><a href="#混淆认识-知识幻觉" class="headerlink" title="混淆认识 知识幻觉"></a>混淆认识 知识幻觉</h4><blockquote><p>给周围人灌输知识很容易获取，通过很简单的方式就可以掌握，把各种不一样的知识混淆视听，让他们找不到重点，感觉自己很牛逼的样子。</p></blockquote><h4 id="培养他人学习使用碎片化时间"><a href="#培养他人学习使用碎片化时间" class="headerlink" title="培养他人学习使用碎片化时间"></a>培养他人学习使用碎片化时间</h4><blockquote><p>培养周围人在工作期间，多看CSDN，博客等文章，让他们感觉自己在学习，在进步。</p></blockquote><h4 id="不断提供各种各样看起来有价值的学习资料"><a href="#不断提供各种各样看起来有价值的学习资料" class="headerlink" title="不断提供各种各样看起来有价值的学习资料"></a>不断提供各种各样看起来有价值的学习资料</h4><blockquote><p>大量提供几十个G的学习视频和资料，不要告诉他们重点是什么，让他们看到资料就头大，学几节课就放弃的那种。</p></blockquote><h4 id="让他们去看一些枯燥的书，基础知识"><a href="#让他们去看一些枯燥的书，基础知识" class="headerlink" title="让他们去看一些枯燥的书，基础知识"></a>让他们去看一些枯燥的书，基础知识</h4><blockquote><p>提供一些JAVA基础书籍，JAVA核心技术上下卷，让他们学完后忘记，忘记后继续学，到怀疑自己是不是学JAVA的料，到怀疑人生。</p></blockquote><h4 id="框架只要使用"><a href="#框架只要使用" class="headerlink" title="框架只要使用"></a>框架只要使用</h4><blockquote><p>培养周围人框架只用论，不要探究原理，并且嘲讽那些探究原理的人。</p></blockquote><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/%E5%8F%98%E5%BE%97%E7%89%9B%E9%80%BC%E7%9A%84%E6%96%B9%E6%B3%95.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>git生成并添加SSH key</title>
      <link>http://www.baiyp.ren/git%E7%94%9F%E6%88%90%E5%B9%B6%E6%B7%BB%E5%8A%A0SSH-key.html</link>
      <guid>http://www.baiyp.ren/git%E7%94%9F%E6%88%90%E5%B9%B6%E6%B7%BB%E5%8A%A0SSH-key.html</guid>
      <pubDate>Mon, 05 Aug 2019 12:36:43 GMT</pubDate>
      <description>
      
        git生成并添加SSH-key
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="git生成并添加SSH-key"><a href="#git生成并添加SSH-key" class="headerlink" title="git生成并添加SSH key"></a>git生成并添加SSH key</h2><p><img src="../images/git01.jpg" alt></p><h3 id="下载安装git"><a href="#下载安装git" class="headerlink" title="下载安装git"></a>下载安装git</h3><blockquote><p>下载地址</p></blockquote><p><a href="https://git-scm.com/downloads" rel="external nofollow noopener noreferrer" target="_blank">https://git-scm.com/downloads</a></p><h3 id="启动git-bash"><a href="#启动git-bash" class="headerlink" title="启动git bash"></a>启动git bash</h3><p><img src="../images/git02.png" alt></p><h3 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h3><h4 id="配置你的用户信息"><a href="#配置你的用户信息" class="headerlink" title="配置你的用户信息"></a>配置你的用户信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name "xxx"       //配置你的账户名字 注意用户后面的空格</span><br><span class="line">git config --global user.email "xxx@qq.com"    //配置你的创建github账户的邮箱；</span><br></pre></td></tr></table></figure><h4 id="查看已经配置好的用户信息"><a href="#查看已经配置好的用户信息" class="headerlink" title="查看已经配置好的用户信息"></a>查看已经配置好的用户信息</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><p><img src="../images/git03.png" alt></p><h4 id="生成SSH-key"><a href="#生成SSH-key" class="headerlink" title="生成SSH key"></a>生成SSH key</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C "xxx@qq.com"</span><br></pre></td></tr></table></figure><p><img src="../images/git04.png" alt></p><h4 id="获取SSH-key"><a href="#获取SSH-key" class="headerlink" title="获取SSH key"></a>获取SSH key</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p><img src="../images/git05.png" alt></p><h4 id="将-SSH-key-配置到码云"><a href="#将-SSH-key-配置到码云" class="headerlink" title="将 SSH key  配置到码云"></a>将 SSH key 配置到码云</h4><p><img src="../images/git06.png" alt></p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/git%E7%94%9F%E6%88%90%E5%B9%B6%E6%B7%BB%E5%8A%A0SSH-key.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>java并发工具类-Callable、Future 和FutureTask</title>
      <link>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-05.html</link>
      <guid>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-05.html</guid>
      <pubDate>Mon, 05 Aug 2019 10:04:33 GMT</pubDate>
      <description>
      
        java并发工具类-Callable、Future 和FutureTask的使用
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="java并发工具类-Callable、Future-和FutureTask"><a href="#java并发工具类-Callable、Future-和FutureTask" class="headerlink" title="java并发工具类-Callable、Future 和FutureTask"></a>java并发工具类-Callable、Future 和FutureTask</h2><p><img src="../images/fututetask02.png" alt></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。</p></blockquote><p>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。<br>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>而自从<strong>Java 1.5</strong>开始，就提供了<strong>Callable</strong>和<strong>Future</strong>，通过它们可以在任务执行完毕之后得到任务执行结果</p><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>Callable位于JUC包下，它也是一个接口，在它里面也只声明了一个方法叫做call()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ Callable接口代表一段可以调用并返回结果的代码。</p><p>​ Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p><p>​ Callable接口使用泛型去定义它的返回类型。</p><p>​ <strong>Executors</strong>类提供了一些有用的方法在线程池中执行Callable内的任务。由于<strong>Callable</strong>任务是并行的（并行就是整体看上去是并行的，其实在某个时间点只有一个线程在执行），我们必须等待它返回的结果。<br>​ <code>java.util.concurrent.Future</code>对象为我们解决了这个问题。在线程池提交<strong>Callable</strong>任务后返回了一个<strong>Future</strong>对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。<strong>Future</strong>提供了<strong>get()</strong>方法让我们可以等待Callable结束并获取它的执行结果。</p><p>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><p>第一个方法：submit提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future。</p><p>第二个方法：submit提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象。</p><p>第三个方法：submit提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</p><p>因此我们只要创建好我们的线程对象（实现Callable接口或者Runnable接口），然后通过上面3个方法提交给线程池去执行即可。</p><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>​ Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，<strong>该方法会阻塞直到任务返回结果</strong>。</p><p>​ Future<v>接口是用来获取异步计算结果的，说白了就是对具体的Runnable或者Callable对象任务执行的结果进行获取(get())，取消(cancel())，判断是否完成等操作。我们看看Future接口的源码：</v></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Future接口中声明了5个方法，下面依次解释每个方法的作用</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>cance(boolean mayInterruptIfRunning)</td><td>试图取消执行的任务，参数为true时直接中断正在执行的任务，否则直到当前任务执行完成，成功取消后返回true，否则返回false</td></tr><tr><td>isCancelled()</td><td>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</td></tr><tr><td>isDone()</td><td>方法表示任务是否已经完成，若任务完成，则返回true；</td></tr><tr><td>get()</td><td>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</td></tr><tr><td>get(long timeout, TimeUnit unit)</td><td>设定计算结果的返回时间，如果在规定时间内没有返回计算结果则抛出TimeOutException</td></tr></tbody></table><h4 id="Future提供了三种功能"><a href="#Future提供了三种功能" class="headerlink" title="Future提供了三种功能"></a>Future提供了三种功能</h4><ul><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ul><p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p><h3 id="RunnableFuture接口"><a href="#RunnableFuture接口" class="headerlink" title="RunnableFuture接口"></a>RunnableFuture接口</h3><p>RunnableFuture<strong>实现了Runnable和Future</strong>。因此FutureTask可以传递到线程对象Thread或Excutor(线程池)来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>我们先来看一下FutureTask的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>FutureTask除了实现了Future接口外还实现了Runnable接口，因此FutureTask也可以直接提交给Executor执行。 当然也可以调用线程直接执行（FutureTask.run()）。接下来我们根据FutureTask.run()的执行时机来分析其所处的3种状态：</p><ol><li><p>未启动，FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，而且没有执行FutureTask.run()方法前，这个FutureTask也处于未启动状态。</p></li><li><p>已启动，FutureTask.run()被执行的过程中，FutureTask处于已启动状态。</p></li><li><p>已完成，FutureTask.run()方法执行完正常结束，或者被取消或者抛出异常而结束，FutureTask都处于完成状态。</p></li></ol><p><img src="../images/fututetask01.png" alt></p><p>下面我们再来看看FutureTask的方法执行示意图（方法和Future接口基本是一样的，这里就不过多描述了）</p><p><img src="../images/fututetask03.png" alt></p><ul><li><p>当FutureTask处于未启动或已启动状态时，如果此时我们执行FutureTask.get()方法将导致调用线程阻塞；当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。</p></li><li><p>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会执行。当FutureTask处于已启动状态时，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果任务取消成功，cancel(…)返回true；但如果执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时cancel(…)返回false。当任务已经完成，执行cancel(…)方法将返回false。</p></li></ul><p>最后我们给出FutureTask的两种构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，FutureTask是Future接口的一个唯一实现类。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>​ 通过上面的介绍，我们对Callable，Future，RunnableFuture，FutureTask都有了比较清晰的了解了，那么它们到底有什么用呢？我们前面说过通过这样的方式去创建线程的话，最大的好处就是能够返回结果，加入有这样的场景，我们现在需要计算一个数据，而这个数据的计算比较耗时，而我们后面的程序也要用到这个数据结果，那么这个时Callable岂不是最好的选择？我们可以开设一个线程去执行计算，而主线程继续做其他事，而后面需要使用到这个数据时，我们再使用Future获取不就可以了吗？下面我们就来编写一个这样的实例。</p><h4 id="Callable-Future-获取执行结果"><a href="#Callable-Future-获取执行结果" class="headerlink" title="Callable+Future 获取执行结果"></a>Callable+Future 获取执行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">     <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">     ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">     <span class="comment">//创建Callable对象任务</span></span><br><span class="line">     Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">         System.out.println(<span class="string">"Callable子线程在进行计算"</span>);</span><br><span class="line">         Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">             sum += i;</span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//提交任务并获取执行结果</span></span><br><span class="line">     Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">     <span class="comment">//关闭线程池</span></span><br><span class="line">     executor.shutdown();</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"主线程开始走到这里,耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">     <span class="comment">//get方法会阻塞线程执行</span></span><br><span class="line">     Integer value = result.get();</span><br><span class="line">     System.out.println(<span class="string">"获取值："</span> + value + <span class="string">"，共耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程开始走到这里,耗时<span class="number">139</span></span><br><span class="line">Callable子线程在进行计算</span><br><span class="line">获取值：<span class="number">4950</span>，共耗时：<span class="number">3169</span></span><br></pre></td></tr></table></figure><h4 id="Callable-FutureTask获取执行结果"><a href="#Callable-FutureTask获取执行结果" class="headerlink" title="Callable+FutureTask获取执行结果"></a>Callable+FutureTask获取执行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line"> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"> <span class="comment">//创建Callable对象任务</span></span><br><span class="line"> Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">     System.out.println(<span class="string">"Callable子线程在进行计算"</span>);</span><br><span class="line">     Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">         sum += i;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的,需要创建FutureTask对象</span></span><br><span class="line"> FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line"> <span class="comment">//提交任务并获取执行结果</span></span><br><span class="line"> <span class="comment">// Future future = executor.submit(task);</span></span><br><span class="line"> executor.submit(futureTask);</span><br><span class="line"> <span class="comment">//关闭线程池</span></span><br><span class="line"> executor.shutdown();</span><br><span class="line"> System.out.println(<span class="string">"主线程开始走到这里,耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line"> <span class="comment">//get方法会阻塞线程执行</span></span><br><span class="line"> Integer value = futureTask.get();</span><br><span class="line"> System.out.println(<span class="string">"获取值："</span> + value + <span class="string">"，共耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Callable子线程在进行计算</span><br><span class="line">主线程开始走到这里,耗时：<span class="number">89</span></span><br><span class="line">获取值：<span class="number">4950</span>，共耗时：<span class="number">3089</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="实现Runnable接口和实现Callable接口的区别："><a href="#实现Runnable接口和实现Callable接口的区别：" class="headerlink" title="实现Runnable接口和实现Callable接口的区别："></a>实现Runnable接口和实现Callable接口的区别：</h4><ol><li><p>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的。</p></li><li><p>Callable规定的方法是call(),Runnable规定的方法是run()。</p></li><li><p>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)。</p></li><li><p>call方法可以抛出异常，run方法不可以。</p></li><li><p>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p></li><li><p>加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。</p></li></ol><h4 id="Callable、Runnable、Future和FutureTask-的区别"><a href="#Callable、Runnable、Future和FutureTask-的区别" class="headerlink" title="Callable、Runnable、Future和FutureTask 的区别"></a>Callable、Runnable、Future和FutureTask 的区别</h4><ol><li><p>Callable、Runnable、Future和FutureTask 做为java 线程池运行的重要载体，有必要深入理解。</p></li><li><p>Callable 和 Runnable 都是执行的任务的接口，区别在于Callable有返回值，而Runnable无返回值。</p></li><li><p>Future 表示异步任务返回结果的接口</p></li><li><p>RunnableFuture 继承了Runnable， Future，表示可以带有返回值的run接口</p></li><li><p>FutureTask是一个实现类，实现了RunnableFuture接口，既能接受Runnable类型的任务，也可以接受Callable类型的任务，这个类的作用主要是 有一个protected void done()方法用来扩展使用，作为一个回调方法</p></li></ol><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-05.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>java并发工具类-Semaphore</title>
      <link>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-04.html</link>
      <guid>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-04.html</guid>
      <pubDate>Sat, 03 Aug 2019 05:45:13 GMT</pubDate>
      <description>
      
        java并发工具类-Semaphore使用
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="java并发工具类-Semaphore"><a href="#java并发工具类-Semaphore" class="headerlink" title="java并发工具类-Semaphore"></a>java并发工具类-Semaphore</h2><p><img src="../images/semaphore01.png" alt></p><h3 id="Semaphore简介"><a href="#Semaphore简介" class="headerlink" title="Semaphore简介"></a>Semaphore简介</h3><p>​ <strong>Semaphore</strong>也叫信号量，在<strong>JDK1.5</strong>被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。</p><p>Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。</p><ul><li>访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。</li><li>访问资源后，使用release释放许可。</li></ul><p>Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。</p><h4 id="通俗的讲"><a href="#通俗的讲" class="headerlink" title="通俗的讲"></a>通俗的讲</h4><p><strong>Semaphore</strong>是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。Semaphore是一种计数信号量，用于管理一组资源，内部是基于AQS的共享模式。它相当于给线程规定一个量从而控制允许活动的线程数。</p><p>是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>​ Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量。就这一点而言，单纯的synchronized 关键字是实现不了的。</p><p>​ Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>​ 以一个停车场是运作为例。为了简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。这个停车系统中，每辆车就好比一个线程，看门人就好比一个信号量，看门人限制了可以活动的线程。假如里面依然是三个车位，但是看门人改变了规则，要求每次只能停两辆车，那么一开始进入两辆车，后面得等到有车离开才能有车进入，但是得保证最多停两辆车。对于Semaphore类而言，就如同一个看门人，限制了可活动的线程数。</p><h4 id="Semaphore主要方法"><a href="#Semaphore主要方法" class="headerlink" title="Semaphore主要方法"></a>Semaphore主要方法</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><blockquote><p>创建具有给定许可数的计数信号量并设置为非公平信号量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span></span><br></pre></td></tr></table></figure><h5 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h5><blockquote><p>从此信号量获取一个许可前线程将一直阻塞。相当于一辆车占了一个车位</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><blockquote><p>从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞。比如n=2，就相当于一辆车占了两个车位。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><blockquote><p>释放一个许可，将其返回给信号量。就如同车开走返回一个车位。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><blockquote><p>释放n个许可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span></span></span><br></pre></td></tr></table></figure><blockquote><p>获取当前可用许可数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">availablePermits</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//阻塞队列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> BlockingQueue&lt;String&gt; parks = <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;(<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Semaphore semaphore)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个随机数</span></span><br><span class="line">        <span class="keyword">long</span> sleepTime = random.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">        String park = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 获取许可，首先判断semaphore内部的数字是否大于0，如果大于0，</span></span><br><span class="line"><span class="comment">             * 才能获得许可，然后将初始值5减去1，线程才会接着去执行；如果没有</span></span><br><span class="line"><span class="comment">             * 获得许可(原因是因为已经有5个线程获得到许可，semaphore内部的数字为0)，</span></span><br><span class="line"><span class="comment">             * 线程会阻塞直到已经获得到许可的线程，调用release()方法，释放掉许可，</span></span><br><span class="line"><span class="comment">             * 也就是将semaphore内部的数字加1，该线程才有可能获得许可。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            semaphore.acquire();</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             *  对应的线程会到阻塞对，对应车辆去获取到车位，如果没有拿到一致阻塞，</span></span><br><span class="line"><span class="comment">             *  直到其他车辆归还车位。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            park = parks.take();</span><br><span class="line">            System.out.println(<span class="string">"线程ID"</span> + threadId + <span class="string">",开始占用车位:"</span> + park + <span class="string">"，当前剩余车位"</span> + semaphore.availablePermits());</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠随机秒</span></span><br><span class="line">            Thread.sleep(sleepTime * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//归还车位</span></span><br><span class="line">        parks.offer(park);</span><br><span class="line">        System.out.println(<span class="string">"线程ID"</span> + threadId + <span class="string">",开始归还车位:"</span> + park + <span class="string">",共占用"</span> + sleepTime + <span class="string">"秒"</span>);</span><br><span class="line">        <span class="comment">//线程释放掉许可，通俗来将就是将semaphore内部的数字加1</span></span><br><span class="line">        semaphore.release();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化线程数量</span></span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">100</span>;</span><br><span class="line">        parks.offer(<span class="string">"车位一"</span>);</span><br><span class="line">        parks.offer(<span class="string">"车位二"</span>);</span><br><span class="line">        parks.offer(<span class="string">"车位三"</span>);</span><br><span class="line">        parks.offer(<span class="string">"车位四"</span>);</span><br><span class="line">        parks.offer(<span class="string">"车位五"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化5个许可证</span></span><br><span class="line">        Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            executorService.submit(() -&gt; &#123;</span><br><span class="line">                execute(semaphore);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><blockquote><p>我们知道可以通过信号量控制共享资源的访问，底层还是AQS这一套，这没什么难的。但是有一点可能被大家忽略：声明信号量的时候，比如只有3个许可证，但是运行过程中，某个时刻的许可证数量是没有限制的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//初始化线程数量</span></span><br><span class="line">       <span class="keyword">int</span> threadNum = <span class="number">100</span>;</span><br><span class="line">       parks.offer(<span class="string">"车位一"</span>);</span><br><span class="line">       parks.offer(<span class="string">"车位二"</span>);</span><br><span class="line">       parks.offer(<span class="string">"车位三"</span>);</span><br><span class="line">       parks.offer(<span class="string">"车位四"</span>);</span><br><span class="line">       parks.offer(<span class="string">"车位五"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 初始化 0 个许可证 应该是不可以 放行的</span></span><br><span class="line">       Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 释放了5个许可证，Semaphore(5) 效果是一样的</span></span><br><span class="line"><span class="comment">        * 实际使用中注意不能过多的释放release</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       semaphore.release(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">           executorService.submit(() -&gt; &#123;</span><br><span class="line">               execute(semaphore);</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​ 即使创建信号量的时候，指定了信号量的大小。但是在通过 release()操作释放信号量任然能超过配置的大小。也就有可能同时执行的线程数量比最开始设置的要大。<br>没有任何线程获取信号量的时候，依然能够释放并且释放的有效。</p><p>​ 推荐的做法是一个线程先 acquire 然后 release。如果释放线程和获取线程不是同一个，那么最好保证这种对应关系。不要释放过多的许可证。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-04.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>ThreadLocal引发的内存泄漏分析</title>
      <link>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal-02.html</link>
      <guid>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal-02.html</guid>
      <pubDate>Sat, 03 Aug 2019 01:23:46 GMT</pubDate>
      <description>
      
        什么是ThreadLocal
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="ThreadLocal引发的内存泄漏分析"><a href="#ThreadLocal引发的内存泄漏分析" class="headerlink" title="ThreadLocal引发的内存泄漏分析"></a>ThreadLocal引发的内存泄漏分析</h2><p><img src="../images/threadlocal16.gif" alt></p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>引用</p><p>Object o = new Object();</p><p>这个o，我们可以称之为对象引用，而new Object()我们可以称之为在内存中产生了一个对象实例。</p><p><img src="../images/threadlocal06.png" alt></p><p>当写下 <strong>o=null</strong>时，只是表示o不再指向堆中object的对象实例，不代表这个对象实例不存在了。</p><ul><li><p><strong>强引用:</strong> 就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。</p></li><li><p><strong>软引用:</strong> 是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。</p></li><li><p><strong>弱引用:</strong> 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在JDK 1.2之后，提供了WeakReference类来实现弱引用。</p></li><li><p><strong>虚引用:</strong> 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在之后，提供了类来实现虚引用</p></li></ul><h4 id="内存泄漏的现象"><a href="#内存泄漏的现象" class="headerlink" title="内存泄漏的现象"></a>内存泄漏的现象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 类说明：ThreadLocal造成的内存泄漏演示</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalOOM</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TASK_LOOP_SIZE = <span class="number">500</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ThreadPoolExecutor poolExecutor</span><br><span class="line">            = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">5</span>,</span><br><span class="line">            <span class="number">1</span>,</span><br><span class="line">            TimeUnit.MINUTES,</span><br><span class="line">            <span class="keyword">new</span> LinkedBlockingQueue&lt;&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LocalVariable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>*<span class="number">1024</span>*<span class="number">5</span>];<span class="comment">/*5M大小的数组*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;LocalVariable&gt; localVariable</span><br><span class="line">            = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Object o = <span class="keyword">new</span> Object();</span><br><span class="line">        <span class="comment">/*5*5=25*/</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; TASK_LOOP_SIZE; ++i) &#123;</span><br><span class="line">            poolExecutor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//localVariable.set(new LocalVariable());</span></span><br><span class="line">                    <span class="keyword">new</span> LocalVariable();</span><br><span class="line">                    System.out.println(<span class="string">"use local varaible"</span>);</span><br><span class="line">                    <span class="comment">//localVariable.remove();</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"pool execute over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先只简单的在每个任务中new出一个数组</p><p><img src="../images/threadlocal07.png" alt></p><p>可以看到内存的实际使用控制在25M左右：因为每个任务中会不断new出一个5M的数组，5*5=25M，这是很合理的。</p><p><img src="../images/threadlocal08.png" alt></p><p>当我们启用了ThreadLocal以后：</p><p><img src="../images/threadlocal09.png" alt></p><p><img src="../images/threadlocal10.png" alt></p><p>内存占用最高升至150M，一般情况下稳定在90M左右，那么加入一个ThreadLocal后，内存的占用真的会这么多？</p><p>于是，我们加入一行代码：</p><p><img src="../images/threadlocal11.png" alt></p><p>再执行，看看内存情况:</p><p><img src="../images/threadlocal12.png" alt></p><p>可以看见最高峰的内存占用也在25M左右，完全和我们不加ThreadLocal表现一样。</p><p>这就充分说明，确实发生了内存泄漏。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>根据我们前面对ThreadLocal的分析，我们可以知道每个Thread 维护一个 ThreadLocalMap，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object，也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。仔细观察ThreadLocalMap，这个map是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。</p><p>因此使用了ThreadLocal后，引用链如图所示</p><p><img src="../images/threadlocal02.png" alt></p><p>图中的虚线表示弱引用。</p><p>​ 这样，当把threadlocal变量置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被gc回收。这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：</p><p>​ Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，而这块value永远不会被访问到了，所以存在着内存泄露。</p><p>​ 只有当前thread结束以后，current thread就不会存在栈中，强引用断开，Current Thread、Map value将全部被GC回收。最好的做法是不在需要使用ThreadLocal变量后，都调用它的remove()方法，清除数据。</p><p>​ 其实考察ThreadLocal的实现，我们可以看见，无论是get()、set()在某些时候，调用了expungeStaleEntry方法用来清除Entry中Key为null的Value，但是这是不及时的，也不是每次都会执行的，所以一些情况下还是会发生内存泄露。只有remove()方法中显式调用了expungeStaleEntry方法。</p><p>​ 从表面上看内存泄漏的根源在于使用了弱引用，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？</p><p>下面我们分两种情况讨论：</p><p>​ <strong>key 使用强引用</strong>：引用ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal的对象实例不会被回收，导致Entry内存泄漏。</p><p>​ <strong>key 使用弱引用</strong>：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal的对象实例也会被回收。value在下一次ThreadLocalMap调用set，get，remove都有机会被回收。</p><p>​ 比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障。</p><p>​ 因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。</p><h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>​ JVM利用设置ThreadLocalMap的Key为弱引用，来避免内存泄露。</p><p>JVM利用调用remove、get、set方法的时候，回收弱引用。</p><p>当ThreadLocal存储很多Key为null的Entry的时候，而不再去调用remove、get、set方法，那么将导致内存泄漏。</p><p>使用<strong>线程池</strong>+ <strong>ThreadLocal</strong> 时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了value可能造成累积的情况。</p><h4 id="错误使用ThreadLocal导致线程不安全"><a href="#错误使用ThreadLocal导致线程不安全" class="headerlink" title="错误使用ThreadLocal导致线程不安全"></a>错误使用ThreadLocal导致线程不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 类说明：ThreadLocal的线程不安全演示</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalUnsafe</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Number number = <span class="keyword">new</span> Number(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//每个线程计数加一</span></span><br><span class="line">        number.setNum(number.getNum()+<span class="number">1</span>);</span><br><span class="line">      <span class="comment">//将其存储到ThreadLocal中</span></span><br><span class="line">        value.set(number);</span><br><span class="line">        SleepTools.ms(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//输出num值</span></span><br><span class="line">        System.out.println(Thread.currentThread().getName()+<span class="string">"="</span>+value.get().getNum());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;Number&gt; value = <span class="keyword">new</span> ThreadLocal&lt;Number&gt;() &#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(<span class="keyword">new</span> ThreadLocalUnsafe()).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Number</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Number</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Number [num="</span> + num + <span class="string">"]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后的结果为</p><p><img src="../images/threadlocal13.png" alt></p><p>如果我们加入SleepTools.ms(2);会看的更明显</p><p><img src="../images/threadlocal14.png" alt></p><p>​ 为什么每个线程都输出5？难道他们没有独自保存自己的Number副本吗？为什么其他线程还是能够修改这个值？仔细考察ThreadLocal和Thead的代码，我们发现ThreadLocalMap中保存的其实是对象的一个引用，这样的话，当有其他线程对这个引用指向的对象实例做修改时，其实也同时影响了所有的线程持有的对象引用所指向的同一个对象实例。这也就是为什么上面的程序为什么会输出一样的结果：5个线程中保存的是同一Number对象的引用，在线程睡眠的时候，其他线程将num变量进行了修改，而修改的对象Number的实例是同一份，因此它们最终输出的结果是相同的。</p><p>而上面的程序要正常的工作，应该的用法是让每个线程中的ThreadLocalNumber</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal-02.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>java并发工具类 CyclicBarrier</title>
      <link>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-03.html</link>
      <guid>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-03.html</guid>
      <pubDate>Thu, 01 Aug 2019 05:45:08 GMT</pubDate>
      <description>
      
        java并发工具类 CyclicBarrier 使用
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="java并发工具类-CyclicBarrier"><a href="#java并发工具类-CyclicBarrier" class="headerlink" title="java并发工具类 CyclicBarrier"></a>java并发工具类 CyclicBarrier</h2><p><img src="../images/CyclicBarrier01.png" alt></p><h3 id="CyclicBarrier简介"><a href="#CyclicBarrier简介" class="headerlink" title="CyclicBarrier简介"></a>CyclicBarrier简介</h3><p>CyclicBarrier，是JDK1.5的java.util.concurrent并发包中提供的一个并发工具类。</p><p>所谓Cyclic即 循环 的意思，所谓Barrier即 屏障 的意思。</p><p>所以综合起来，CyclicBarrier指的就是 循环屏障，虽然这个叫法很奇怪，但是确能很好地表示它的作用。</p><p>它的作用就是会让所有线程都等待完成后才会继续下一步行动。</p><p>​ 举个例子，就像生活中我们会约朋友们到某个餐厅一起吃饭，有些朋友可能会早到，有些朋友可能会晚到，但是这个餐厅规定必须等到所有人到齐之后才会让我们进去。这里的朋友们就是各个线程，餐厅就是 CyclicBarrier。</p><h3 id="CyclicBarrier栅栏"><a href="#CyclicBarrier栅栏" class="headerlink" title="CyclicBarrier栅栏"></a>CyclicBarrier栅栏</h3><p><img src="../images/CyclicBarrier02.png" alt></p><p>​ <strong>CyclicBarrier</strong>和<strong>CountDownLatch</strong>是非常类似的，<strong>CyclicBarrier</strong>核心的概念是在于设置一个等待线程的数量边界，到达了此边界之后进行执行。</p><p><strong>CyclicBarrier</strong>类是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点（Common Barrier Point）。</p><p>​ <strong>CyclicBarrier</strong>类是一种同步机制，它能够对处理一些算法的线程实现同。换句话讲，它就是一个所有线程必须等待的一个栅栏，直到所有线程都到达这里，然后所有线程才可以继续做其他事情。</p><p>​ 通过调用<strong>CyclicBarrier</strong>对象的<strong>await()</strong>方法，两个线程可以实现互相等待。一旦N个线程在等待<strong>CyclicBarrier</strong>达成，所有线程将被释放掉去继续执行。</p><h3 id="怎么使用-CyclicBarrier"><a href="#怎么使用-CyclicBarrier" class="headerlink" title="怎么使用 CyclicBarrier"></a>怎么使用 CyclicBarrier</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br></pre></td></tr></table></figure><p><strong>parties</strong> : 是参与线程的个数</p><p>​ 其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p><p>*<em>barrierAction *</em> : 优先执行线程</p><p>​ 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。</p><p>CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。</p><p><img src="../images/CyclicBarrier03.png" alt></p><h4 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></span><br></pre></td></tr></table></figure><ul><li>线程调用 await() 表示自己已经到达栅栏</li><li>BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><blockquote><p>一个线程组的线程需要等待所有线程完成任务后再继续执行下一次任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(CyclicBarrier barrier)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个随机数</span></span><br><span class="line">        <span class="keyword">long</span> sleepTime = random.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠随机秒</span></span><br><span class="line">            Thread.sleep(sleepTime * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程ID"</span> + threadId + <span class="string">",准备任务完成耗时："</span> + sleepTime + <span class="string">"当前时间"</span> + System.currentTimeMillis());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程等待其他任务完成后唤醒</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            barrier.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程ID"</span> + threadId + <span class="string">",开始执行任务，当前时间："</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//初始化线程数量</span></span><br><span class="line">        <span class="keyword">int</span> threadNum = <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//初始化一般的线程</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">5</span>, () -&gt; System.out.println(<span class="string">"整理任务开始..."</span>));</span><br><span class="line">        ExecutorService executor = Executors.newFixedThreadPool(threadNum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadNum; i++) &#123;</span><br><span class="line">            executor.submit(() -&gt; &#123;</span><br><span class="line">                execute(barrier);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">线程ID12,准备任务完成耗时：<span class="number">0</span>当前时间<span class="number">1565163947881</span></span><br><span class="line">线程ID17,准备任务完成耗时：<span class="number">0</span>当前时间<span class="number">1565163947881</span></span><br><span class="line">线程ID16,准备任务完成耗时：<span class="number">0</span>当前时间<span class="number">1565163947881</span></span><br><span class="line">线程ID20,准备任务完成耗时：<span class="number">3</span>当前时间<span class="number">1565163950881</span></span><br><span class="line">线程ID14,准备任务完成耗时：<span class="number">3</span>当前时间<span class="number">1565163950881</span></span><br><span class="line">整理任务开始...</span><br><span class="line">线程ID14,开始执行任务，当前时间：<span class="number">1565163950881</span></span><br><span class="line">线程ID12,开始执行任务，当前时间：<span class="number">1565163950881</span></span><br><span class="line">线程ID17,开始执行任务，当前时间：<span class="number">1565163950881</span></span><br><span class="line">线程ID16,开始执行任务，当前时间：<span class="number">1565163950881</span></span><br><span class="line">线程ID20,开始执行任务，当前时间：<span class="number">1565163950881</span></span><br><span class="line">线程ID18,准备任务完成耗时：<span class="number">4</span>当前时间<span class="number">1565163951881</span></span><br><span class="line">线程ID13,准备任务完成耗时：<span class="number">5</span>当前时间<span class="number">1565163952881</span></span><br><span class="line">线程ID21,准备任务完成耗时：<span class="number">7</span>当前时间<span class="number">1565163954881</span></span><br><span class="line">线程ID19,准备任务完成耗时：<span class="number">9</span>当前时间<span class="number">1565163956882</span></span><br><span class="line">线程ID15,准备任务完成耗时：<span class="number">9</span>当前时间<span class="number">1565163956882</span></span><br><span class="line">整理任务开始...</span><br><span class="line">线程ID15,开始执行任务，当前时间：<span class="number">1565163956882</span></span><br><span class="line">线程ID18,开始执行任务，当前时间：<span class="number">1565163956882</span></span><br><span class="line">线程ID13,开始执行任务，当前时间：<span class="number">1565163956882</span></span><br><span class="line">线程ID21,开始执行任务，当前时间：<span class="number">1565163956882</span></span><br><span class="line">线程ID19,开始执行任务，当前时间：<span class="number">1565163956882</span></span><br></pre></td></tr></table></figure><p>​ 从打印结果可以看出，所有线程会等待全部线程到达栅栏之后才会继续执行，并且最后到达的线程会完成 Runnable 的任务。</p><h4 id="CyclicBarrier-使用场景"><a href="#CyclicBarrier-使用场景" class="headerlink" title="CyclicBarrier 使用场景"></a>CyclicBarrier 使用场景</h4><p>可以用于多线程计算数据，最后合并计算结果的场景。</p><h3 id="CyclicBarrier-与-CountDownLatch-区别"><a href="#CyclicBarrier-与-CountDownLatch-区别" class="headerlink" title="CyclicBarrier 与 CountDownLatch 区别"></a>CyclicBarrier 与 CountDownLatch 区别</h3><ul><li>CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的</li><li>CountDownLatch.await一般阻塞工作线程，所有的进行预备工作的线程执行countDown，而CyclicBarrier通过工作线程调用await从而自行阻塞，直到所有工作线程达到指定屏障，再大家一起往下走。</li><li>CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的。</li><li>在控制多个线程同时运行上，CountDownLatch可以不限线程数量，而CyclicBarrier是固定线程数。</li><li>同时，CyclicBarrier还可以提供一个barrierAction，合并多线程计算结果。</li></ul><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-03.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>什么是ThreadLocal</title>
      <link>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal-01.html</link>
      <guid>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal-01.html</guid>
      <pubDate>Thu, 01 Aug 2019 01:23:46 GMT</pubDate>
      <description>
      
        什么是ThreadLocal
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="什么是ThreadLocal"><a href="#什么是ThreadLocal" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h2><p><img src="../images/threadlocal15.png" alt></p><h3 id="什么是ThreadLocal-1"><a href="#什么是ThreadLocal-1" class="headerlink" title="什么是ThreadLocal"></a>什么是ThreadLocal</h3><p>​ 早在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p><p>当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。</p><p>​ 所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。</p><h3 id="与Synchonized的比较"><a href="#与Synchonized的比较" class="headerlink" title="与Synchonized的比较"></a>与Synchonized的比较</h3><p>​ ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程访问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。</p><p>​ Spring的事务就借助了ThreadLocal类。Spring会从数据库连接池中获得一个connection，然会把connection放进ThreadLocal中，也就和线程绑定了，事务需要提交或者回滚，只要从ThreadLocal中拿到connection进行操作。为何Spring的事务要借助ThreadLocal类？</p><p>以JDBC为例，正常的事务代码可能如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">dbc = <span class="keyword">new</span> DataBaseConnection();<span class="comment">//第1行</span></span><br><span class="line"></span><br><span class="line">Connection con = dbc.getConnection();<span class="comment">//第2行</span></span><br><span class="line"></span><br><span class="line">con.setAutoCommit(<span class="keyword">false</span>);<span class="comment">// //第3行</span></span><br><span class="line"></span><br><span class="line">con.executeUpdate(...);<span class="comment">//第4行</span></span><br><span class="line"></span><br><span class="line">con.executeUpdate(...);<span class="comment">//第5行</span></span><br><span class="line"></span><br><span class="line">con.executeUpdate(...);<span class="comment">//第6行</span></span><br><span class="line"></span><br><span class="line">con.commit();<span class="comment">////第7行</span></span><br></pre></td></tr></table></figure><p>上述代码，可以分成三个部分:</p><p>事务准备阶段：第1～3行</p><p>业务处理阶段：第4～6行</p><p>事务提交阶段：第7行</p><p>可以很明显的看到，不管我们开启事务还是执行具体的sql都需要一个具体的数据库连接。</p><p>​ 现在我们开发应用一般都采用三层结构，如果我们控制事务的代码都放在DAO(DataAccessObject)对象中，在DAO对象的每个方法当中去打开事务和关闭事务，当Service对象在调用DAO时，如果只调用一个DAO，那我们这样实现则效果不错，但往往我们的Service会调用一系列的DAO对数据库进行多次操作，那么，这个时候我们就无法控制事务的边界了，因为实际应用当中，我们的Service调用的DAO的个数是不确定的，可根据需求而变化，而且还可能出现Service调用Service的情况。</p><p>​ 但是需要注意一个问题，如何让三个DAO使用同一个数据源连接呢？我们就必须为每个DAO传递同一个数据库连接，要么就是在DAO实例化的时候作为构造方法的参数传递，要么在每个DAO的实例方法中作为方法的参数传递。这两种方式无疑对我们的Spring框架或者开发人员来说都不合适。为了让这个数据库连接可以跨阶段传递，又不显示的进行参数传递，就必须使用别的办法。</p><p>​ Web容器中，每个完整的请求周期会由一个线程来处理。因此，如果我们能将一些参数绑定到线程的话，就可以实现在软件架构中跨层次的参数共享（是隐式的共享）。而JAVA中恰好提供了绑定的方法–使用ThreadLocal。</p><p>结合使用Spring里的IOC和AOP，就可以很好的解决这一点。</p><p>只要将一个数据库连接放入ThreadLocalThreadLocal</p><h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：</p><ul><li>void set(Object value)</li></ul><p>设置当前线程的线程局部变量的值。</p><ul><li>public Object get()</li></ul><p>该方法返回当前线程所对应的线程局部变量。</p><ul><li>public void remove()</li></ul><p>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。</p><ul><li>protected Object initialValue()</li></ul><p>返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; RESOURCE = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br></pre></td></tr></table></figure><p>RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。</p><h3 id="实现解析"><a href="#实现解析" class="headerlink" title="实现解析"></a>实现解析</h3><p><img src="../images/threadlocal01.png" alt></p><p>threadLo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       Thread t = Thread.currentThread();</span><br><span class="line">       ThreadLocalMap map = getMap(t);</span><br><span class="line">       <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">               T result = (T)e.value;</span><br><span class="line">               <span class="keyword">return</span> result;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> setInitialValue();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​ 上面先取到当前线程，然后调用getMap方法获取对应的ThreadLocalMap，ThreadLocalMap是ThreadLocal的静态内部类，然后Thread类中有一个这样类型成员，所以getMap是直接返回Thread的成员。</p><p>看下ThreadLocal的内部类ThreadLocalMap源码：</p><p><img src="../images/threadlocal03.png" alt></p><p>​ 可以看到有个Entry内部静态类，它继承了WeakReference，总之它记录了两个信息，一个是ThreadLocal&lt;?&gt;类型，一个是Object类型的值。getEntry方法则是获取某个ThreadLocal对应的值，set方法就是更新或赋值相应的ThreadLocal对应的值。</p><p><img src="../images/threadlocal04.png" alt></p><p><img src="../images/threadlocal05.png" alt></p><p>​ 回顾我们的get方法，其实就是拿到<strong>每个线程独有的ThreadLocalMap</strong></p><p>然后再用ThreadLocal的当前实例，拿到Map中的相应的Entry，然后就可以拿到相应的值返回出去。当然，如果Map为空，还会先进行map的创建，初始化等工作。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B-ThreadLocal-01.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>java并发工具类-CountDownLatch</title>
      <link>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-02.html</link>
      <guid>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-02.html</guid>
      <pubDate>Sun, 28 Jul 2019 05:45:01 GMT</pubDate>
      <description>
      
        java并发工具类-CountDownLatch的使用
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="java并发工具类-CountDownLatch"><a href="#java并发工具类-CountDownLatch" class="headerlink" title="java并发工具类-CountDownLatch"></a>java并发工具类-CountDownLatch</h2><p><img src="../images/CountDownLatch03.gif" alt></p><h3 id="CountDownLatch的简介"><a href="#CountDownLatch的简介" class="headerlink" title="CountDownLatch的简介"></a>CountDownLatch的简介</h3><p>CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、 ConcurrentHashMap和BlockingQueue，它们都存在于JUC (java.util.concurrent)包下</p><h3 id="CountDownLatch原理"><a href="#CountDownLatch原理" class="headerlink" title="CountDownLatch原理"></a>CountDownLatch原理</h3><p>​ CountDownLatch是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1（<code>CountDownLatch.countDown()</code>方法）。当计数器到达0时，表示所有的线程都已完成任务,，然后在闭锁上等待<code>CountDownLatch.await()</code>方法的线程就可以恢复执行任务。</p><p><strong>注意</strong>：这是一个一次性操作 - 计数无法重置。 如果你需要一个重置的版本计数，考虑使用CyclicBarrier。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>​ <strong>实现最大的并行性</strong>：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。</p><p>​ <strong>开始执行前等待n个线程完成各自任务</strong>：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了，例如处理excel中多个表单。</p><p><img src="../images/CountDownLatch01.png" alt></p><p><strong>注意</strong>：一个线程不一定只能做countDown一次，也可以countDown多次</p><h3 id="CountDownLatch的示例"><a href="#CountDownLatch的示例" class="headerlink" title="CountDownLatch的示例"></a>CountDownLatch的示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThreadPoolExecutor threadPool = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">5</span>, <span class="number">10</span>, <span class="number">100</span>, TimeUnit.SECONDS, <span class="keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="number">5</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Random random = <span class="keyword">new</span> Random();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(CountDownLatch countDownLatch)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取一个随机数</span></span><br><span class="line">        <span class="keyword">long</span> sleepTime = random.nextInt(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">        System.out.println(<span class="string">"线程ID"</span> + threadId + <span class="string">",开始执行--countDown"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//睡眠随机秒</span></span><br><span class="line">            Thread.sleep(sleepTime * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计数器减1</span></span><br><span class="line">        countDownLatch.countDown();</span><br><span class="line">        System.out.println(<span class="string">"线程ID"</span> + threadId + <span class="string">",准备任务完成耗时："</span> + sleepTime + <span class="string">"当前时间"</span> + System.currentTimeMillis());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//线程等待其他任务完成后唤醒</span></span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"线程ID"</span> + threadId + <span class="string">",开始执行任务，当前时间："</span> + System.currentTimeMillis());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            threadPool.submit(() -&gt; &#123;</span><br><span class="line">                execute(countDownLatch);</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//线程等待其他任务完成后唤醒</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        threadPool.shutdown();</span><br><span class="line">        System.out.println(<span class="string">"全部任务执行完成"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><p>线程ID13,开始执行–countDown<br>线程ID16,开始执行–countDown<br>线程ID15,开始执行–countDown<br>线程ID12,开始执行–countDown<br>线程ID14,开始执行–countDown<br>线程ID14,准备任务完成耗时：3当前时间1565159118048<br>线程ID16,准备任务完成耗时：4当前时间1565159119047<br>线程ID12,准备任务完成耗时：4当前时间1565159119048<br>线程ID15,准备任务完成耗时：6当前时间1565159121047<br>线程ID13,准备任务完成耗时：7当前时间1565159122048<br>线程ID13,开始执行任务，当前时间：1565159122048<br>线程ID14,开始执行任务，当前时间：1565159122048<br>线程ID12,开始执行任务，当前时间：1565159122048<br>线程ID16,开始执行任务，当前时间：1565159122048<br>线程ID15,开始执行任务，当前时间：1565159122049<br>全部任务执行完成</p><h3 id="使用CountDownLatch压测"><a href="#使用CountDownLatch压测" class="headerlink" title="使用CountDownLatch压测"></a>使用CountDownLatch压测</h3><p><img src="../images/CountDownLatch05.gif" alt></p><p>​ 在实战项目中，我们除了使用 jemter 等工具进行压测外，还可以自己动手使用 CountDownLatch 类编写压测代码。可以说 jemter 的并发压测背后也是使用的 CountDownLatch。可见掌握 CountDownLatch 类的使用是有多么的重要。</p><p>​ <strong>CountDownLatch</strong>是Java多线程同步器的四大金刚之一，CountDownLatch能够使一个线程等待其他线程完成各自的工作后再执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span>  <span class="keyword">void</span> <span class="title">latchTest</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">      <span class="comment">//压测线程数</span></span><br><span class="line">      <span class="keyword">int</span> testThreads = <span class="number">300</span>;</span><br><span class="line">      <span class="keyword">final</span> CountDownLatch start = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">      <span class="keyword">final</span> CountDownLatch end = <span class="keyword">new</span> CountDownLatch(testThreads);</span><br><span class="line">      <span class="comment">//创建线程池</span></span><br><span class="line">      ExecutorService exce = Executors.newFixedThreadPool(testThreads);</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; testThreads; i++) &#123;</span><br><span class="line">          exce.submit(() -&gt; &#123;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">//启动后等待 唤醒</span></span><br><span class="line">                  start.await();</span><br><span class="line">                  <span class="comment">//压测具体方法</span></span><br><span class="line">                  testLoad();</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                  e.printStackTrace();</span><br><span class="line">              &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">//结束CountDownLatch -1</span></span><br><span class="line">                  end.countDown();</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;);</span><br><span class="line"></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//连接池线程初始化完成 开始压测</span></span><br><span class="line">      start.countDown();</span><br><span class="line">      <span class="comment">//压测完成后结束</span></span><br><span class="line">      end.await();</span><br><span class="line">      exce.shutdown();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>简简单单的几行代码就可以实现300的压测。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-02.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>线程间的协作</title>
      <link>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-05.html</link>
      <guid>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-05.html</guid>
      <pubDate>Wed, 24 Jul 2019 23:23:07 GMT</pubDate>
      <description>
      
        java多线程的协作方式
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="线程间的协作"><a href="#线程间的协作" class="headerlink" title="线程间的协作"></a>线程间的协作</h2><p><img src="../images/thread05.png" alt></p><h3 id="线程间的协作-1"><a href="#线程间的协作-1" class="headerlink" title="线程间的协作"></a>线程间的协作</h3><p>​ 线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。却存在如下问题：</p><p>1） 难以确保及时性。</p><p>2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。</p><h4 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待/通知机制"></a>等待/通知机制</h4><p>​ 是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p><p><strong>notify()：</strong></p><p>​ 通知一个在对象上等待的线程,使其从wait方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING状态。</p><p><strong>notifyAll()：</strong></p><p>​ 通知所有等待在该对象上的线程</p><p><strong>wait()</strong></p><p>​ 调用该方法的线程进入 WAITING状态,只有等待另外线程的通知或被中断才会返回.需要注意,调用wait()方法后,会释放对象的锁</p><p><strong>wait(long)</strong></p><p>​ 超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n毫秒,如果没有通知就超时返回</p><p><strong>wait (long,int)</strong></p><p>​ 对于超时时间更细粒度的控制,可以达到纳秒</p><h4 id="等待和通知的标准范式"><a href="#等待和通知的标准范式" class="headerlink" title="等待和通知的标准范式"></a>等待和通知的标准范式</h4><h5 id="等待方遵循如下原则。"><a href="#等待方遵循如下原则。" class="headerlink" title="等待方遵循如下原则。"></a>等待方遵循如下原则。</h5><p>1）获取对象的锁。</p><p>2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。</p><p>3）条件满足则执行对应的逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line">      <span class="keyword">while</span>(条件不满足)&#123;</span><br><span class="line">          对象.wait();</span><br><span class="line">      &#125;</span><br><span class="line">      对应的处理逻辑</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="通知方遵循如下原则。"><a href="#通知方遵循如下原则。" class="headerlink" title="通知方遵循如下原则。"></a>通知方遵循如下原则。</h5><p>1）获得对象的锁。</p><p>2）改变条件。</p><p>3）通知所有等待在对象上的线程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (对象)&#123;</span><br><span class="line">    改变条件</span><br><span class="line">    对象.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 在调用<strong>wait()</strong>、<strong>notify()</strong>系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用<strong>wait()</strong>方法、<strong>notify()</strong>系列方法，进入wait()方法后，<strong>当前线程释放锁</strong>，在从wait()返回前，<strong>线程与其他线程竞争重新获得锁</strong>， 执行notify()系列方法的线程退出调用了notifyAll的synchronized代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。</p><h5 id="notify和notifyAll应该用谁"><a href="#notify和notifyAll应该用谁" class="headerlink" title="notify和notifyAll应该用谁"></a>notify和notifyAll应该用谁</h5><p>​ 尽可能用notifyall()，谨慎使用notify()，因为notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程，具体表现参见代码。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-05.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程的同步</title>
      <link>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-04.html</link>
      <guid>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-04.html</guid>
      <pubDate>Fri, 19 Jul 2019 23:23:07 GMT</pubDate>
      <description>
      
        Java多线程的同步
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="Java多线程的同步"><a href="#Java多线程的同步" class="headerlink" title="Java多线程的同步"></a>Java多线程的同步</h2><p><img src="../images/thread06.jpg" alt></p><h3 id="使用线程锁"><a href="#使用线程锁" class="headerlink" title="使用线程锁"></a>使用线程锁</h3><h4 id="synchronized内置锁"><a href="#synchronized内置锁" class="headerlink" title="synchronized内置锁"></a>synchronized内置锁</h4><p>​ 线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。</p><p>​ Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。</p><h4 id="对象锁和类锁"><a href="#对象锁和类锁" class="headerlink" title="对象锁和类锁"></a>对象锁和类锁</h4><p>​ 当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放，对象锁是用于对象实例方法，或者一个对象实例上的。</p><p>同步静态方法/静态变量互斥体<br>由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只由一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。一旦一个静态变量被作为synchronized block的mutex。进入此同步区域时，都要先获得此静态变量的对象锁</p><p>​ 用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。</p><p>​ 但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。</p><h5 id="对象锁实例1"><a href="#对象锁实例1" class="headerlink" title="对象锁实例1"></a>对象锁实例1</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法锁 不同的方法可以并行的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test111"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test222"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test333"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunableTest RunableTest = <span class="keyword">new</span> RunableTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                RunableTest.test1();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                RunableTest.test2();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                RunableTest.test3();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">int</span> sec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(sec * <span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="对象锁实例2"><a href="#对象锁实例2" class="headerlink" title="对象锁实例2"></a>对象锁实例2</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  对象锁 用一个对象锁的话 先获取锁在执行 </span></span><br><span class="line"><span class="comment"> *   如果是多个对象可以并行的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"test111"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"test222"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"test333"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="类锁"><a href="#类锁" class="headerlink" title="类锁"></a>类锁</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *类锁 用一个对象锁的话 先获取锁在执行</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RunableTest.class) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"test111"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RunableTest.class) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"test222"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (RunableTest.class) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            System.out.println(<span class="string">"test333"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="错误的加锁和原因分析"><a href="#错误的加锁和原因分析" class="headerlink" title="错误的加锁和原因分析"></a>错误的加锁和原因分析</h4><p>​ 我们常常在程序中使用多线程来处理任务，这个时候是否正确使用加锁就很重要了，有时候看着代码没啥问题，但是执行起来发现结果并不是看到的那样，比如我们看下面的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Integer num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (num) &#123;</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            num++;</span><br><span class="line">            System.out.println(<span class="string">"test111"</span>+Thread.currentThread().getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​ 这个时候我们再去看代码，我们对Integer对象num进行加锁，这个时候就有个一个Java基础知识在里面，Integer是不可变对象，是实例对象，对象一但被创建就不能被修改，比如赋值是1，就是1，如果让它变成2，需要重新创建一个Integer对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>.num) &#123;</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        Integer var2 = <span class="keyword">this</span>.num;</span><br><span class="line">        Integer var3 = <span class="keyword">this</span>.num = <span class="keyword">this</span>.num + <span class="number">1</span>;</span><br><span class="line">        System.out.println(<span class="string">"test111"</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><p>​ 然后下面循环中进行num++,其实这里Java对这个进行了内部转换（ Java封箱拆箱） ，其实是执行的这个语句<code>java Integer var3 = this.num = this.num + 1;</code>，我们看反编译后的代码，它会返回一个Integer实例，因此num ++本质是创建一个Integer对象，并将它的引用赋值给num 。</p><p>本质上是返回了一个新的Integer对象。也就是每个线程实际加锁的是不同的Integer对象。</p><h3 id="volatile，最轻量的同步机制"><a href="#volatile，最轻量的同步机制" class="headerlink" title="volatile，最轻量的同步机制"></a>volatile，最轻量的同步机制</h3><p>​ volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的</p><p>​ 不加volatile时，子线程无法感知主线程修改了ready的值，从而不会退出循环，而加了volatile后，子线程可以感知主线程修改了ready的值，迅速退出循环。</p><p>但是volatile不能保证数据在多个线程下同时写时的线程安全</p><p>volatile最适用的场景：一个线程写，多个线程读。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-04.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>Java多线程更多了解</title>
      <link>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-03.html</link>
      <guid>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-03.html</guid>
      <pubDate>Wed, 17 Jul 2019 23:23:07 GMT</pubDate>
      <description>
      
        java多线程
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="对Java里的线程再多一点点认识"><a href="#对Java里的线程再多一点点认识" class="headerlink" title="对Java里的线程再多一点点认识"></a>对Java里的线程再多一点点认识</h2><p><img src="../images/thread03.png" alt></p><h3 id="深入理解run-和start"><a href="#深入理解run-和start" class="headerlink" title="深入理解run()和start()"></a>深入理解run()和start()</h3><p>​ Thread类是Java里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。</p><p>​ start()方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用，如果重复调用会抛出异常。</p><p>​ 而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。</p><h3 id="其他的线程相关方法"><a href="#其他的线程相关方法" class="headerlink" title="其他的线程相关方法"></a>其他的线程相关方法</h3><p>​ yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行yield( )的线程不一定就会持有锁，我们完全可以在释放锁后再调用yield方法。</p><p>所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。</p><p>wait()/notify()/notifyAll()：后面会单独讲述</p><h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><p>​ 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。(此处为常见面试考点)</p><p>看个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">Thread thread1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">"11111111111"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">           <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">               &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                   e.printStackTrace();</span><br><span class="line">               &#125;</span><br><span class="line">               System.out.println(<span class="string">"222222222222"</span>);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       thread1.start();</span><br><span class="line">       <span class="comment">//在此处join 其他线程会等待thread1 执行完成后在执行thread2</span></span><br><span class="line">       thread1.join();</span><br><span class="line">       thread2.start();</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br></pre></td></tr></table></figure><p>第二种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">     thread1.start();</span><br><span class="line">     thread2.start();</span><br><span class="line">     <span class="comment">//在此处join 因为下面没有等待启动的线程，所以和不加thread1.join();一样，是交替执行的</span></span><br><span class="line">     thread1.join();</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">222222222222</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">222222222222</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">222222222222</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">222222222222</span></span><br><span class="line"><span class="number">222222222222</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">11111111111</span></span><br><span class="line"><span class="number">222222222222</span></span><br></pre></td></tr></table></figure><h3 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h3><p>​ 在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。</p><p>​ 设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。</p><h3 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h3><p>​ Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在<strong>非</strong>Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。</p><p>​ Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-03.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>java流式计算Stream详解</title>
      <link>http://www.baiyp.ren/java%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97Stream%E8%AF%A6%E8%A7%A3.html</link>
      <guid>http://www.baiyp.ren/java%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97Stream%E8%AF%A6%E8%A7%A3.html</guid>
      <pubDate>Wed, 17 Jul 2019 09:57:36 GMT</pubDate>
      <description>
      
        使用java流式计算简化开发
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="java流式计算Stream详解"><a href="#java流式计算Stream详解" class="headerlink" title="java流式计算Stream详解"></a>java流式计算Stream详解</h2><p><img src="../images/stream01.png" alt></p><h3 id="Stream-是什么"><a href="#Stream-是什么" class="headerlink" title="Stream 是什么"></a>Stream 是什么</h3><p>​ Stream是Java 8新增的重要特性, 它提供函数式编程支持并允许以管道方式操作集合. 流操作会遍历数据源, 使用管道式操作处理数据后生成结果集合, 这个过程通常不会对数据源造成影响.</p><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>​ 使用Stream进行函数式编程时经常需要将操作作为参数传入流方法中, 函数对象即将方法或lambda表达式作为对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strArray =  Arrays.asList(stringArrays).stream().filter(x&gt;x.contains(<span class="string">"Tomas"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上述示例中<code>filter</code>的参数<code>x&gt;x.contains(&quot;Tomas&quot;)</code>即为一个lambda表达式.</p><h3 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h3><p>可以使用集合类的<code>stream()</code>或者<code>parallelStream()</code>方法创建流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream1 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).stream();</span><br><span class="line">Stream&lt;Integer&gt; stream2 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).parallelStream();</span><br></pre></td></tr></table></figure><p><code>java.util.stream.Stream</code>是一个<code>interface</code>, 各种管道中间操作的返回值都是它的实现类, 这允许我们方便地进行参数传递。</p><p><code>Stream</code>的静态方法<code>of()</code>也可以用来创建流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 =   Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>&#125;);</span><br></pre></td></tr></table></figure><p>`</p><p>Arrays<code>也提供了创建流的静态方法</code>stream()`:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>一些类也提供了创建流的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(start, stop);</span><br><span class="line">BufferedReader.lines();</span><br><span class="line">Random.ints();</span><br></pre></td></tr></table></figure><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>​ 流操作是惰性执行的, 中间操作会返回一个新的流对象, 当执行终点操作时才会真正进行计算，下面介绍流的中间操作，除非传入的操作函数有副作用, 函数本身不会对数据源进行任何修改。</p><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>保证数据源中的重复元素在结果中只出现一次, 它使用<code>equals()</code>方法判断两个元素是否相等.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">System.out.println(stream3.distinct().collect(Collectors.toList()));</span><br></pre></td></tr></table></figure><p>输出<br>[1, 2, 3, 4]</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p><code>filter</code>根据传入的断言函数对所有元素进行检查, 只有使断言函数返回真的元素才会出现在结果中. <code>filter</code>不会对数据源进行修改.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;);</span><br><span class="line">List&lt;String&gt; stringList = stream3.filter(x-&gt; Integer.parseInt(x)%<span class="number">2</span>==<span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(stringList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[2, 4, 6, 8]</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>​ <strong>map</strong>方法根据传入的mapper函数对元素进行一对一映射, 即数据源中的每一个元素都会在结果中被替换(映射)为mapper函数的返回值，也可以根据处理返回不同的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;);</span><br><span class="line">List&lt;Integer&gt; integerList = stream3.map(x -&gt; Integer.parseInt(x)).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[1, 2, 3, 4, 6, 7, 8, 9]</p><h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><p>​ <strong>peek</strong>方法会对数据源中所有元素进行给定操作, 但在结果中仍然是数据源中的元素. 通常我们利用操作的副作用, 修改其它数据或进行输入输出.</p><p>​ <strong>peek</strong>接收一个没有返回值的λ表达式，可以做一些输出，外部处理等。map接收一个有返回值的λ表达式，之后Stream的泛型类型将转换为map参数λ表达式返回的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt;  stream3 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">List&lt;Integer&gt;  integerList = stream3.peek(x-&gt; System.out.println(x)).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>1 …</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9]</p><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>与<code>map</code>不同<code>flatMap</code>进行多对一映射, 它要求若数据源的元素类型为<code>R</code>, 则mapper函数的返回值必须为<code>Stream&lt;R&gt;</code>.</p><p><code>flatMap</code>会使用mapper函数将数据源中的元素一一映射为<code>Stream</code>对象, 然后把这些<code>Stream</code>拼装成一个流.因此我们可以使用<code>flatMap</code>进行合并列表之类的操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt;  stream3 = Stream.of(Arrays.asList(<span class="number">1</span>), Arrays.asList(<span class="number">2</span>, <span class="number">3</span>), Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">List&lt;Integer&gt;  integerList = stream3.flatMap(x-&gt;x.stream()).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[1, 2, 3, 4, 5, 6]</p><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted</code>方法用于对数据源进行排序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">        List&lt;Integer&gt; integerList = stream3.sorted((x, y) -&gt; x - y).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[0, 1, 2, 3, 4, 5, 6, 6, 8, 9]</p><p>使用<code>java.util.Comparator</code>是更方便的方法, 默认进行升序排序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">Stream&lt;Item&gt; stream3 = Stream.of(<span class="keyword">new</span> Item(<span class="number">4</span>), <span class="keyword">new</span> Item(<span class="number">3</span>), <span class="keyword">new</span> Item(<span class="number">6</span>), <span class="keyword">new</span> Item(<span class="number">9</span>));</span><br><span class="line">List&lt;Item&gt; itemList = stream3.sorted(Comparator.comparingInt(Item::getValue)).collect(Collectors.toList());</span><br><span class="line">itemList.forEach(x -&gt; System.out.print(x.getValue()+<span class="string">","</span>));</span><br></pre></td></tr></table></figure><p>输出</p><p>3,4,6,9,</p><p>使用<code>reversed()</code>方法进行降序排序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Item&gt; stream3 = Stream.of(<span class="keyword">new</span> Item(<span class="number">4</span>), <span class="keyword">new</span> Item(<span class="number">3</span>), <span class="keyword">new</span> Item(<span class="number">6</span>), <span class="keyword">new</span> Item(<span class="number">9</span>));</span><br><span class="line">List&lt;Item&gt; itemList = stream3.sorted(Comparator.comparingInt(Item::getValue).reversed()).collect(Collectors.toList());</span><br><span class="line">itemList.forEach(x -&gt; System.out.print(x.getValue()+<span class="string">","</span>));</span><br></pre></td></tr></table></figure><p>输出</p><p>9,6,4,3,</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit(int n)</code>当流中元素数大于n时丢弃超出的元素, 否则不进行处理, 达到限制流长度的目的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br><span class="line">List&lt;Integer&gt; integerList = stream3.limit(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[3, 5, 1]</p><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p><code>skip(int)</code>返回丢弃了前n个元素的流. 如果流中的元素小于或者等于n，则返回空的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br><span class="line">List&lt;Integer&gt; integerList = stream3.skip(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[4, 2, 6, 8, 7]</p><h3 id="终点操作"><a href="#终点操作" class="headerlink" title="终点操作"></a>终点操作</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce(accumulator)</code>是最基本的终点操作之一, 操作函数<code>accumulator</code>接受两个参数<code>x</code>,<code>y</code>返回<code>r</code>.</p><p><code>reduce</code>首先将数据源中的两个元素<code>x1</code>和<code>x2</code>传给<code>accumulator</code>得到<code>r1</code>, 然后将<code>r1</code>和<code>x3</code>传入得到<code>r2</code>. 如此进行直到处理完整个数据流.</p><p><code>reduce</code>方法还可以接受一个参数代替<code>x1</code>作为起始值:</p><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p><code>collect</code>是使用最广泛的终点操作, 也上文中多次出现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;)</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList())</span><br></pre></td></tr></table></figure><p><code>toList()</code>将流转换为<code>List</code>实例, 是最常见的用法, <code>java.util.Collectors</code>类中还有求和, 计算均值, 取最值, 字符串连接等多种收集方法.</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p><code>forEach</code>方法对流中所有元素执行给定操作, 没有返回值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(1,2,3,4,5).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><code>count()</code> 返回流中的元素数</li><li><code>toArray()</code>: 转换为数组</li></ul><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>除非显式地创建并行流, 否则默认创建的都是串行流.<code>Collection.stream()</code>为集合创建串行流,而<code>Collection.parallelStream()</code>创建并行流.</p><p><code>stream.parallel()</code>方法可以将串行流转换成并行流,<code>stream.sequential()</code>方法将流转换成串行流.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">stream3.forEach(x-&gt; System.out.print(x+<span class="string">","</span>));</span><br></pre></td></tr></table></figure><p>输出</p><p>1,2,3,4,5,6,7,8,9,</p><p>流可以在非线程安全的集合上创建, 流操作不应该对非线程安全的数据源产生任何副作用, 否则将发生<code>java.util.ConcurrentModificationException</code>异常.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList(Arrays.asList(&quot;x&quot;, &quot;y&quot;));</span><br><span class="line">list.stream().forEach(x-&gt; list.add(&quot;z&quot;));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:<span class="number">1388</span>)</span><br><span class="line">at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:<span class="number">580</span>)</span><br><span class="line">at com.test.lambda.LambdaTest.main(LambdaTest.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>对于线程安全的容器不会存在这个问题:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList(Arrays.asList(<span class="string">"x"</span>, <span class="string">"y"</span>));</span><br><span class="line">list.stream().forEach(x-&gt;&#123;</span><br><span class="line">list.add(<span class="string">"z"</span>);</span><br><span class="line">System.out.println(list);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出</p><p>[x, y, z]<br>[x, y, z, z]</p><p>当然作者建议Stream操作不要对数据源进行任何修改. 当然, 修改其它数据或者输入输出是允许的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> CopyOnWriteArrayList(Arrays.asList(<span class="string">"x"</span>, <span class="string">"y"</span>));</span><br><span class="line">list.stream().forEach(x-&gt;&#123;</span><br><span class="line">    set.add(x);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>理想的管道操作应该是无状态且与访问顺序无关的. 无状态是指操作的结果只与输入有关, 下面即是一个有状态的操作示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">State state = getState();</span><br><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>));</span><br><span class="line">list = list.stream().map(s -&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (state.isReady()) &#123;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无状态的操作保证无论系统状态如何管道的行为不变, 与顺序无关则有利于进行并行计算.</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口会将签名匹配的函数对象(lambda表达式或方法)视作接口的实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Greeter</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口中有且只有一个非抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greeter greeter = message -&gt; System.out.println(<span class="string">"Hello "</span> + message);</span><br></pre></td></tr></table></figure><p>这在 Java 8 之前通常使用匿名内部类实现的:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Greeter greeter = <span class="keyword">new</span> Greeter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hello</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Hello "</span> + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>Java 8 将已有的一些接口实现为函数式接口:</p><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.util.Comparator</li><li>java.lang.reflect.InvocationHandler</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher</li></ul><p><code>java.util.function</code>中定义了一些常用的函数式接口:</p><ul><li>Consumer: 接受参数无返回<ul><li><code>Consumer&lt;T&gt;</code> -&gt; <code>void accept(T t)</code>;</li><li><code>BiConsumer&lt;T,U&gt;</code> -&gt; <code>void accept(T t, U u);</code></li><li><code>DoubleConsumer</code> -&gt; <code>void accept(double value);</code></li></ul></li><li>Supplier: 不接受参数有返回<ul><li><code>Supplier&lt;T&gt;</code> -&gt; <code>T get();</code></li><li><code>DoubleSupplier</code> -&gt; <code>double getAsDouble();</code></li></ul></li><li>Function: 接受参数并返回<ul><li><code>Function&lt;T, R&gt;</code> -&gt; <code>R apply(T t);</code></li><li><code>BiFunction&lt;T, U, R&gt;</code> -&gt; <code>R apply(T t, U u);</code></li><li><code>DoubleFunction&lt;R&gt;</code> -&gt; <code>R apply(double value);</code></li><li><code>DoubleToIntFunction</code> -&gt; <code>int applyAsInt(double value);</code></li><li><code>BinaryOperator&lt;T&gt;</code> extends <code>BiFunction&lt;T,T,T&gt;</code></li></ul></li><li>Predicate: 接受参数返回boolean<ul><li><code>Predicate&lt;T&gt;</code> -&gt; <code>boolean test(T t);</code></li><li><code>BiPredicate&lt;T, U&gt;</code> -&gt; <code>boolean test(T t, U u);</code></li><li><code>DoublePredicate</code> -&gt; <code>boolean test(double value);</code></li></ul></li></ul><p>默认构造器可以作为supplier: <code>Supplier&lt;Item&gt; supplier = Item::new;</code></p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E6%B5%81%E5%BC%8F%E8%AE%A1%E7%AE%97Stream%E8%AF%A6%E8%A7%A3.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>认识Java里的线程</title>
      <link>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-02.html</link>
      <guid>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-02.html</guid>
      <pubDate>Sun, 14 Jul 2019 23:23:07 GMT</pubDate>
      <description>
      
        认识Java里的线程
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="认识Java里的线程"><a href="#认识Java里的线程" class="headerlink" title="认识Java里的线程"></a>认识Java里的线程</h2><p><img src="../images/thread01.png" alt></p><h3 id="Java程序天生就是多线程的"><a href="#Java程序天生就是多线程的" class="headerlink" title="Java程序天生就是多线程的"></a>Java程序天生就是多线程的</h3><p>​ 一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。</p><ul><li><p>[6] Monitor Ctrl-Break //监控Ctrl-Break中断信号的</p></li><li><p>[5] Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等</p></li><li><p>[4] Signal Dispatcher // 分发处理发送给JVM信号的线程</p></li><li><p>[3] Finalizer // 调用对象finalize方法的线程</p></li><li><p>[2] Reference Handler//清除Reference的线程</p></li><li><p>[1] main //main线程，用户程序入口</p></li><li></li></ul><h3 id="线程的启动与中止"><a href="#线程的启动与中止" class="headerlink" title="线程的启动与中止"></a>线程的启动与中止</h3><h4 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h4><p>启动线程的方式有：</p><p>1、X extends Thread;，然后X.start</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//todo 处理业务</span></span><br><span class="line">        System.out.println(<span class="string">"xxxxxxxxxxxxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ThreadTest().start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、X implements Runnable；然后交给Thread运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//todo 处理业务</span></span><br><span class="line">        System.out.println(<span class="string">"xxxxxxxxxxxxx"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunableTest runableTest = <span class="keyword">new</span> RunableTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(runableTest).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Thread和Runnable的区别"><a href="#Thread和Runnable的区别" class="headerlink" title="Thread和Runnable的区别"></a>Thread和Runnable的区别</h4><p>​ Thread才是Java里对线程的唯一抽象，<strong>Runnable只是对任务（业务逻辑）的抽象</strong>。Thread可以接受任意一个Runnable的实例并执行。</p><h4 id="中止"><a href="#中止" class="headerlink" title="中止"></a>中止</h4><h5 id="线程自然终止"><a href="#线程自然终止" class="headerlink" title="线程自然终止"></a>线程自然终止</h5><p>要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。</p><h5 id="stop"><a href="#stop" class="headerlink" title="stop"></a>stop</h5><p>​ 暂停、恢复和停止操作对应在线程Thread的API就是<strong>suspend()</strong>、<strong>resume()</strong>和<strong>stop()</strong>。但是这些API是<strong>过期的</strong>，也就是<strong>不建议使用</strong>的。不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。</p><h5 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h5><p>​ 安全的中止则是其他线程通过调用某个线程A的<strong>interrupt()</strong>方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应，</p><p>​ 线程通过方法<strong>isInterrupted()</strong>来进行判断是否被中断，也可以调用静态方法<strong>Thread.interrupted()</strong>来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。</p><p>​ 如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait等），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。</p><p>​ 不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，</p><ol><li><p>一般的阻塞方法，如sleep等本身就支持中断的检查，</p></li><li><p>检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。</p></li></ol><p><strong>注意：处于死锁状态的线程无法被中断</strong></p><p>样例代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTest</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="comment">//todo 处理业务</span></span><br><span class="line">            System.out.println(<span class="string">"xxxxxxxxxxxxx"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">10</span>) &#123;</span><br><span class="line">                Thread.currentThread().interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        RunableTest runableTest = <span class="keyword">new</span> RunableTest();</span><br><span class="line">        <span class="keyword">new</span> Thread(runableTest).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-02.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>java多线程概述</title>
      <link>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-01.html</link>
      <guid>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-01.html</guid>
      <pubDate>Wed, 10 Jul 2019 08:05:00 GMT</pubDate>
      <description>
      
        Java的多线程概述
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="多线程概述"><a href="#多线程概述" class="headerlink" title="多线程概述"></a>多线程概述</h2><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread02.png" alt></p><h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><blockquote><p><strong>进程是程序运行资源分配的最小单位</strong></p></blockquote><p>​ 进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘IO等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。</p><p>​ 进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。</p><blockquote><p><strong>线程是CPU调度的最小单位,必须依赖于进程而存在</strong></p></blockquote><p>​ 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。</p><blockquote><p><strong>线程无处不在</strong></p></blockquote><p>​ 任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。</p><h3 id="CPU核心数和线程数的关系"><a href="#CPU核心数和线程数的关系" class="headerlink" title="CPU核心数和线程数的关系"></a>CPU核心数和线程数的关系</h3><p>​ <strong>多核心</strong>:也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理</p><p><strong>多线程</strong>: Simultaneous Multithreading.简称SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。</p><p><strong>核心数、线程数</strong>:目前主流CPU都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/computer_core_num.png" alt></p><h3 id="CPU时间片轮转机制"><a href="#CPU时间片轮转机制" class="headerlink" title="CPU时间片轮转机制"></a>CPU时间片轮转机制</h3><p>​ 我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。</p><p>​ 时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。</p><p>百度百科对CPU时间片轮转机制原理解释如下:</p><p>​ 如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾</p><p>​ 时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。</p><p>​ 为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发</p><p>​ 结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。</p><p>​ 在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KILL掉的,我想也正是因为这种机制的缘故。</p><h3 id="澄清并行和并发"><a href="#澄清并行和并发" class="headerlink" title="澄清并行和并发"></a>澄清并行和并发</h3><p>​ 我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的<strong>并行</strong>车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。</p><p>当谈论<strong>并发</strong>的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。</p><p>​ 俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。</p><p>综合来说：</p><p>​ <strong>并发</strong>:指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.</p><p>​ <strong>并行</strong>:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行</p><p>两者区别:一个是交替执行,一个是同时执行.</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/concurrent_and_parallel.jpg" alt></p><h3 id="高并发编程的意义、好处和注意事项"><a href="#高并发编程的意义、好处和注意事项" class="headerlink" title="高并发编程的意义、好处和注意事项"></a>高并发编程的意义、好处和注意事项</h3><p>​ 由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。</p><h4 id="1-充分利用CPU的资源"><a href="#1-充分利用CPU的资源" class="headerlink" title="1. 充分利用CPU的资源"></a>1. 充分利用CPU的资源</h4><p>​ 从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU,如果还是使用单线程的技术做思路,明显就out了。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。</p><p>​ 就像我们平时坐地铁一样,很多人坐长线地铁的时候都在认真看书,而不是为了坐地铁而坐地铁,到家了再去看书,这样你的时间就相当于有了两倍。这就是为什么有些人时间很充裕,而有些人老是说没时间的一个原因,工作也是这样,有的时候可以并发地去做几件事情,充分利用我们的时间,CPU也是一样,也要充分利用。</p><h4 id="2-加快响应用户的时间"><a href="#2-加快响应用户的时间" class="headerlink" title="2. 加快响应用户的时间"></a>2. 加快响应用户的时间</h4><p>​ 比如我们经常用的迅雷下载,都喜欢多开几个线程去下载,谁都不愿意用一个线程去下载,为什么呢?答案很简单,就是多个线程下载快啊。</p><p>​ 我们在做程序开发的时候更应该如此,特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。</p><h4 id="3-可以使你的代码模块化-异步化-简单化"><a href="#3-可以使你的代码模块化-异步化-简单化" class="headerlink" title="3. 可以使你的代码模块化,异步化,简单化"></a>3. 可以使你的代码模块化,异步化,简单化</h4><p>​ 例如我们实现电商系统，下订单和给用户发送短信、邮件就可以进行拆分，将给用户发送短信、邮件这两个步骤独立为单独的模块，并交给其他线程去执行。这样既增加了异步的操作，提升了系统性能，又使程序模块化,清晰化和简单化。</p><p>多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。</p><h3 id="多线程程序需要注意事项"><a href="#多线程程序需要注意事项" class="headerlink" title="多线程程序需要注意事项"></a>多线程程序需要注意事项</h3><h4 id="1-线程之间的安全性"><a href="#1-线程之间的安全性" class="headerlink" title="1. 线程之间的安全性"></a>1. 线程之间的安全性</h4><p>​ 从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。</p><h4 id="2-线程之间的死锁"><a href="#2-线程之间的死锁" class="headerlink" title="2. 线程之间的死锁"></a>2. 线程之间的死锁</h4><p>​ 为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。</p><p>假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生</p><h4 id="3-线程太多了会将服务器资源耗尽形成死机当机"><a href="#3-线程太多了会将服务器资源耗尽形成死机当机" class="headerlink" title="3. 线程太多了会将服务器资源耗尽形成死机当机"></a>3. 线程太多了会将服务器资源耗尽形成死机当机</h4><p>​ 线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢?</p><p>​ 某些系统资源是有限的,如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。</p><p>多线程应用开发的注意事项很多,希望大家在日后的工作中可以慢慢体会它的危险所在。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80-01.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>java并发工具类-Fork-Join</title>
      <link>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-01.html</link>
      <guid>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-01.html</guid>
      <pubDate>Fri, 05 Jul 2019 23:10:45 GMT</pubDate>
      <description>
      
        java并发工具类Fork-Join的使用
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="java并发工具类-Fork-Join"><a href="#java并发工具类-Fork-Join" class="headerlink" title="java并发工具类-Fork-Join"></a>java并发工具类-Fork-Join</h2><p><img src="../images/fork-join01.png" alt></p><h3 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork-Join"></a>Fork-Join</h3><p>​ java下多线程的开发可以我们自己启用多线程，线程池，还可以使用forkjoin，forkjoin可以让我们不去了解诸如Thread,Runnable等相关的知识，只要遵循forkjoin的开发模式，就可以写出很好的多线程并发程序，</p><h4 id="Fork-Join-是什么"><a href="#Fork-Join-是什么" class="headerlink" title="Fork-Join 是什么"></a>Fork-Join 是什么</h4><p>​ Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</p><h3 id="分而治之"><a href="#分而治之" class="headerlink" title="分而治之"></a>分而治之</h3><p>​ “分而治之” 一直是一个有效的处理大量数据的方法。著名的 MapReduce 也是采取了分而治之的思想。简单来说，就是如果你要处理1000个数据，但是你并不具备处理1000个数据的能力，那么你可以只处理其中的10个，然后，分阶段处理100次，将100次的结果进行合成，那就是最终想要的对原始的1000个数据的处理结果。</p><p>​ 同时forkjoin在处理某一类问题时非常的有用，哪一类问题？分而治之的问题。十大计算机经典算法：快速排序、堆排序、归并排序、二分查找、线性查找、</p><p>深度优先、广度优先、Dijkstra、动态规划、朴素贝叶斯分类，有几个属于分而治之？3个，快速排序、归并排序、二分查找，还有大数据中M/R都是。</p><p>分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。</p><p>分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，<strong>这些子问题互相独立且与原问题形式相同</strong>(<strong>子问题相互之间有联系就会变为动态规范算法</strong>)，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。</p><h4 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h4><p><img src="../images/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F.png" alt></p><p>​ 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</p><p>若将两个有序表合并成一个有序表，称为2-路归并，与之对应的还有多路归并。</p><p>​ 对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大的有序序列。</p><p>​ 为了提升性能，有时我们在半子表的个数小于某个数（比如15）的情况下，对半子表的排序采用其他排序算法，比如插入排序。</p><h3 id="Fork-Join原理"><a href="#Fork-Join原理" class="headerlink" title="Fork-Join原理"></a>Fork-Join原理</h3><p>Fork/Join框架要完成两件事情：</p><h4 id="任务分割"><a href="#任务分割" class="headerlink" title="任务分割"></a>任务分割</h4><p>​ Fork/Join框架的基本思想就是将一个大任务分解（<strong>Fork</strong>）成一系列子任务，子任务可以继续往下分解，当多个不同的子任务都执行完成后，可以将它们各自的结果合并（<strong>Join</strong>）成一个大结果，最终合并成大任务的结果：</p><p><img src="../images/fork-join02.png" alt></p><h5 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h5><p>基本任务，使用forkjoin框架必须创建的对象，提供fork,join操作，常用的两个子类</p><ul><li><strong>RecursiveAction</strong> : 无结果返回的任务</li><li><strong>RecursiveTask</strong> : 有返回结果的任务</li></ul><h5 id="说明："><a href="#说明：" class="headerlink" title="说明："></a>说明：</h5><ul><li><p><strong>fork</strong> : 让task异步执行</p></li><li><p><strong>join</strong> : 让task同步执行，可以获取返回值</p></li><li><p><strong>ForkJoinTask</strong> 在不显示使用ForkJoinPool.execute/invoke/submit()方法进行执行的情况下，也可以使用自己的fork/invoke方法进行执行</p></li></ul><h4 id="结果合并"><a href="#结果合并" class="headerlink" title="结果合并"></a>结果合并</h4><h5 id="ForkJoinPool-执行-ForkJoinTask"><a href="#ForkJoinPool-执行-ForkJoinTask" class="headerlink" title="ForkJoinPool 执行 ForkJoinTask"></a>ForkJoinPool 执行 ForkJoinTask</h5><ul><li>任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。</li><li>当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务</li></ul><h5 id="三中提交方式："><a href="#三中提交方式：" class="headerlink" title="三中提交方式："></a>三中提交方式：</h5><ul><li><p><strong>execute</strong>： 异步，无返回结果</p></li><li><p><strong>submit</strong> ：异步，有返回结果 （返回<code>Future&lt;T&gt;</code>）</p></li><li><p><strong>invoke</strong> ：同步，有返回结果 （会阻塞）</p></li></ul><h3 id="工作密取"><a href="#工作密取" class="headerlink" title="工作密取"></a>工作密取</h3><p>​ 即当前线程的Task已经全被执行完毕，则自动取到其他线程的Task池中取出Task继续执行。</p><p>ForkJoinPool中维护着多个线程（一般为CPU核数）在不断地执行Task，每个线程除了执行自己职务内的Task之外，还会根据自己工作线程的闲置情况去获取其他繁忙的工作线程的Task，如此一来就能能够减少线程阻塞或是闲置的时间，提高CPU利用率。</p><p><img src="../images/fork-join03.png" alt></p><h3 id="Fork-Join使用"><a href="#Fork-Join使用" class="headerlink" title="Fork/Join使用"></a>Fork/Join使用</h3><p>​ 我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork和join的操作机制，通常我们不直接继承ForkjoinTask类，只需要直接继承其子类。</p><ol><li><p>RecursiveAction，用于没有返回结果的任务</p></li><li><p>RecursiveTask，用于有返回值的任务</p><p>task要通过ForkJoinPool来执行，使用submit 或 invoke 提交，两者的区别是：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行。</p></li></ol><p>join()和get方法当任务完成的时候返回计算结果。</p><p><img src="../images/fork-join04.png" alt></p><p>​ 在我们自己实现的compute方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用invokeAll方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。</p><h4 id="Fork-Join的使用"><a href="#Fork-Join的使用" class="headerlink" title="Fork/Join的使用"></a>Fork/Join的使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubmitTask</span> <span class="keyword">extends</span> <span class="title">RecursiveTask</span>&lt;<span class="title">Long</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 起始值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 结束值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 阈值</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> threshold = <span class="number">10L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SubmitTask</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.start = start;</span><br><span class="line">        <span class="keyword">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算逻辑</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Long <span class="title">compute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//校验是否达到了阈值</span></span><br><span class="line">        <span class="keyword">if</span> (isLessThanThreshold()) &#123;</span><br><span class="line">            <span class="comment">//处理并返回结果</span></span><br><span class="line">            <span class="keyword">return</span> handle();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//没有达到阈值 计算一个中间值</span></span><br><span class="line">            <span class="keyword">long</span> mid = (start + end) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//拆分 左边的</span></span><br><span class="line">            SubmitTask left = <span class="keyword">new</span> SubmitTask(start, mid);</span><br><span class="line">            <span class="comment">//拆分右边的</span></span><br><span class="line">            SubmitTask right = <span class="keyword">new</span> SubmitTask(mid + <span class="number">1</span>, end);</span><br><span class="line">            <span class="comment">//添加到任务列表</span></span><br><span class="line">            invokeAll(left, right);</span><br><span class="line">            <span class="comment">//合并结果并返回</span></span><br><span class="line">            <span class="keyword">return</span> left.join() + right.join();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 处理的任务</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">handle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*是否达到了阈值*/</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isLessThanThreshold</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> end - start &lt;= threshold;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * forkJoin 方式调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forkJoinInvok</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//创建ForkJoinPool 连接池</span></span><br><span class="line">        ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">        <span class="comment">//创建初始化任务</span></span><br><span class="line">        SubmitTask submitTask = <span class="keyword">new</span> SubmitTask(start, end);</span><br><span class="line">        <span class="comment">//讲初始任务扔进连接池中执行</span></span><br><span class="line">        forkJoinPool.invoke(submitTask);</span><br><span class="line">        <span class="comment">//等待返回结果</span></span><br><span class="line">        sum = submitTask.join();</span><br><span class="line">        System.out.println(<span class="string">"forkJoin调用：result:"</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">"forkJoin调用耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 普通方式调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">normalInvok</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = start; i &lt;= end; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"普通调用：result:"</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">"普通调用耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//起始值的大小</span></span><br><span class="line">        <span class="keyword">long</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//结束值的大小</span></span><br><span class="line">        <span class="keyword">long</span> end = <span class="number">10000</span>;</span><br><span class="line">        <span class="comment">//forkJoin 调用</span></span><br><span class="line">        forkJoinInvok(start, end);</span><br><span class="line">        System.out.println(<span class="string">"========================"</span>);</span><br><span class="line">        <span class="comment">//普通调用</span></span><br><span class="line">        normalInvok(start, end);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果</p><p>forkJoin调用：result:50005000</p><p>forkJoin调用耗时：2286</p><hr><p>普通调用：result:50005000<br>普通调用耗时：17038</p><h5 id="Fork-Join-同步用法"><a href="#Fork-Join-同步用法" class="headerlink" title="Fork/Join 同步用法"></a>Fork/Join 同步用法</h5><blockquote><p>同步用法就是将初始化的任务扔进连接池，如果没有执行完成会阻塞</p><p>forkJoinPool.invoke(submitTask);</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * forkJoin 方式调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forkJoinInvok</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//创建ForkJoinPool 连接池</span></span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">//创建初始化任务</span></span><br><span class="line">    SubmitTask submitTask = <span class="keyword">new</span> SubmitTask(start, end);</span><br><span class="line">    <span class="comment">//讲初始任务扔进连接池中执行 同步用法</span></span><br><span class="line">    forkJoinPool.invoke(submitTask);</span><br><span class="line">    System.out.println(<span class="string">"同步方式，任务结束才会调用该方法,当前耗时"</span>+(System.currentTimeMillis() - currentTime));</span><br><span class="line">    <span class="comment">//等待返回结果</span></span><br><span class="line">    sum = submitTask.join();</span><br><span class="line">    System.out.println(<span class="string">"任务执行完成，当前耗时："</span>+(System.currentTimeMillis() - currentTime));</span><br><span class="line">    System.out.println(<span class="string">"forkJoin调用：result:"</span> + sum);</span><br><span class="line">    System.out.println(<span class="string">"forkJoin调用耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打进结果</p><p>同步方式，任务结束才会调用该方法,当前耗时2367<br>任务执行完成，当前耗时：2368<br>forkJoin调用：result:50005000<br>forkJoin调用耗时：2368</p><h5 id="Fork-Join-异步用法"><a href="#Fork-Join-异步用法" class="headerlink" title="Fork/Join 异步用法"></a>Fork/Join 异步用法</h5><blockquote><p>异步用法就是将初始化的任务扔进连接池，然后继续其他任务</p><p>forkJoinPool.submit(submitTask);</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * forkJoin 方式调用</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> start</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> end</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">forkJoinInvok</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">//创建ForkJoinPool 连接池</span></span><br><span class="line">    ForkJoinPool forkJoinPool = <span class="keyword">new</span> ForkJoinPool();</span><br><span class="line">    <span class="comment">//创建初始化任务</span></span><br><span class="line">    SubmitTask submitTask = <span class="keyword">new</span> SubmitTask(start, end);</span><br><span class="line">    <span class="comment">//讲初始任务扔进连接池中执行 异步方式</span></span><br><span class="line">    forkJoinPool.submit(submitTask);</span><br><span class="line">    System.out.println(<span class="string">"异步方式，任务结束才会调用该方法,当前耗时"</span>+(System.currentTimeMillis() - currentTime));</span><br><span class="line">    <span class="comment">//等待返回结果</span></span><br><span class="line">    sum = submitTask.join();</span><br><span class="line">    System.out.println(<span class="string">"任务执行完成，当前耗时："</span>+(System.currentTimeMillis() - currentTime));</span><br><span class="line">    System.out.println(<span class="string">"forkJoin调用：result:"</span> + sum);</span><br><span class="line">    System.out.println(<span class="string">"forkJoin调用耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果</p><p>异步方式，任务结束才会调用该方法,当前耗时3<br>任务执行完成，当前耗时：2315<br>forkJoin调用：result:50005000<br>forkJoin调用耗时：2315</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="关于ForkJoinPool"><a href="#关于ForkJoinPool" class="headerlink" title="关于ForkJoinPool"></a>关于ForkJoinPool</h4><ul><li><p>可以使用ForkJoinPool.execute(异步，不返回结果)/invoke(同步，返回结果)/submit(异步，返回结果)方法，来执行ForkJoinTask。</p></li><li><p>ForkJoinPool有一个方法commonPool()，这个方法返回一个ForkJoinPool内部声明的静态ForkJoinPool实例。</p><ul><li>文档上说，这个方法适用于大多数的应用。这个静态实例的初始线程数，为“CPU核数-1 ”，<code>（Runtime.getRuntime().availableProcessors() - 1）</code></li><li>ForkJoinTask自己启动时，使用的就是这个静态实例。</li></ul></li></ul><h4 id="关于ForkJoinTask"><a href="#关于ForkJoinTask" class="headerlink" title="关于ForkJoinTask"></a>关于ForkJoinTask</h4><ul><li><p>可以使用invokeAll(task)方法，主动执行其它的ForkJoinTask，并等待Task完成。（是同步的）</p></li><li><p>还可以使用fork方法，让一个task执行（这个方法是异步的）</p></li><li><p>还可以使用join方法，让一个task执行（这个方法是同步的，它和fork不同点是同步或者异步的区别）</p></li><li><p>可以使用join来取得ForkJoinTask的返回值。由于RecursiveTask类实现了Future接口，所以也可以使用get()取得返回值。</p><ul><li>get()和join()有两个主要的区别：<ul><li>join()方法不能被中断。</li><li>如果你中断调用join()方法的线程，这个方法将抛出InterruptedException异常。</li><li>如果任务抛出任何未受检异常，get()方法将返回一个ExecutionException异常，而join()方法将返回一个RuntimeException异常。</li></ul></li></ul></li><li><p>ForkJoinTask在不显示使用ForkJoinPool.execute/invoke/submit()方法进行执行的情况下，也可以使用自己的fork/invoke方法进行执行。</p></li><li><p>使用fork/invoke方法执行时，其实原理也是在ForkJoinPool里执行，只不过使用的是一个“在ForkJoinPool内部生成的静态的”ForkJoinPool。</p></li><li><p>ForkJoinTask有两个子类，RecursiveAction和RecursiveTask。</p><ul><li>他们之间的区别是，RecursiveAction没有返回值，RecursiveTask有返回值。</li></ul></li></ul><ul><li><p>看看ForkjoinTask的Complete方法的使用场景<br>这个方法好要是用来使一个任务结束。这个方法被用在结束异步任务上，或者为那些能不正常结束的任务，提供一个选择。</p></li><li><p>Task的completeExceptionally方法是怎么回事。</p><ul><li>这个方法被用来，在异步的Task中产生一个exception，或者强制结束那些“不会结束”的任务<br>这个方法是在Task想要“自己结束自己”时，可以被使用。而cancel方法，被设计成被其它TASK调用。</li><li>当你在一个任务中抛出一个未检查异常时，它也影响到它的父任务（把它提交到ForkJoinPool类的任务）和父任务的父任务，以此类推。</li></ul></li></ul><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-01.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用lambda表达式简化开发</title>
      <link>http://www.baiyp.ren/%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91.html</link>
      <guid>http://www.baiyp.ren/%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91.html</guid>
      <pubDate>Sat, 15 Jun 2019 09:57:36 GMT</pubDate>
      <description>
      
        使用lambda表达式简化开发
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="使用lambda表达式简化开发"><a href="#使用lambda表达式简化开发" class="headerlink" title="使用lambda表达式简化开发"></a>使用lambda表达式简化开发</h2><p><img src="../images/lambda01.jpg" alt></p><h3 id="什么是lambda表达式"><a href="#什么是lambda表达式" class="headerlink" title="什么是lambda表达式"></a>什么是lambda表达式</h3><blockquote><p>​ “Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。</p></blockquote><p>​ 将一个变量传入一个匿名函数然后对传入函数进行操作。由于java中并没有脱离类而存在的函数，所以通常<strong>独立函数是以一个匿名内部类+一个方法构成的</strong>。lambda表达式代替的函数既没有方法名也没有访问修饰符、明确的返回类型声明。</p><h3 id="Lambda-表达式的语法"><a href="#Lambda-表达式的语法" class="headerlink" title="Lambda 表达式的语法"></a>Lambda 表达式的语法</h3><p><strong>Lambda 表达式需要“函数式接口”的支持</strong></p><h4 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h4><p>​ 接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰 可以检查是否是函数式接口</p><h4 id="Lambda-表达式的基础语法"><a href="#Lambda-表达式的基础语法" class="headerlink" title="Lambda 表达式的基础语法"></a>Lambda 表达式的基础语法</h4><blockquote><p>Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符。</p></blockquote><p>箭头操作符将 Lambda 表达式拆分成两部分</p><ul><li>左侧：Lambda 表达式的参数列表</li><li>右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体</li></ul><h4 id="语法格式一"><a href="#语法格式一" class="headerlink" title="语法格式一"></a>语法格式一</h4><blockquote><p>无参数，无返回值</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">() -&gt; System.out.println(&quot;Hello Lambda!&quot;);</span><br></pre></td></tr></table></figure><h4 id="语法格式二"><a href="#语法格式二" class="headerlink" title="语法格式二"></a>语法格式二</h4><blockquote><p>有一个参数，并且无返回值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x) -&gt; System.out.println(x)</span><br></pre></td></tr></table></figure><h4 id="语法格式三"><a href="#语法格式三" class="headerlink" title="语法格式三"></a>语法格式三</h4><blockquote><p>若只有一个参数，小括号可以省略不写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x -&gt; System.out.println(x)</span><br></pre></td></tr></table></figure><h4 id="语法格式四"><a href="#语法格式四" class="headerlink" title="语法格式四"></a>语法格式四</h4><blockquote><p>有两个以上的参数，有返回值，并且 Lambda 体中有多条语句</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123;</span><br><span class="line">          System.out.println(<span class="string">"函数式接口"</span>);</span><br><span class="line">          <span class="keyword">return</span> Integer.compare(x, y);</span><br><span class="line">      &#125;;</span><br></pre></td></tr></table></figure><h4 id="语法格式五"><a href="#语法格式五" class="headerlink" title="语法格式五"></a>语法格式五</h4><blockquote><p>若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure><h4 id="语法格式六"><a href="#语法格式六" class="headerlink" title="语法格式六"></a>语法格式六</h4><blockquote><p>Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Comparator&lt;Integer&gt; comparator = (Integer x, Integer y) -&gt; Integer.compare(x, y);</span><br></pre></td></tr></table></figure><h3 id="Lambda-表达式的语法的使用"><a href="#Lambda-表达式的语法的使用" class="headerlink" title="Lambda 表达式的语法的使用"></a>Lambda 表达式的语法的使用</h3><h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><h4 id="LIST"><a href="#LIST" class="headerlink" title="LIST"></a>LIST</h4><blockquote><p>原始的代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>));</span><br><span class="line"><span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">   System.out.println(str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Lambda 表达式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Arrays.asList(<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>, <span class="string">"e"</span>));</span><br><span class="line"><span class="comment">//使用Lambda 表达式</span></span><br><span class="line"> list.forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure><h4 id="MAP"><a href="#MAP" class="headerlink" title="MAP"></a>MAP</h4><blockquote><p>原始代码</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;() &#123;&#123;</span><br><span class="line">          put(<span class="string">"11"</span>, <span class="string">":11"</span>);</span><br><span class="line">          put(<span class="string">"22"</span>, <span class="string">":22"</span>);</span><br><span class="line">          put(<span class="string">"33"</span>, <span class="string">":33"</span>);</span><br><span class="line">          put(<span class="string">"44"</span>, <span class="string">":44"</span>);</span><br><span class="line">      &#125;&#125;;</span><br><span class="line"><span class="comment">//打印 key+value</span></span><br><span class="line">      <span class="keyword">for</span>(Map.Entry&lt;String,String&gt; m:map.entrySet())&#123;</span><br><span class="line">          System.out.println(m.getKey()+m.getValue());</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><blockquote><p>Lambda 表达式</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用Lambda 更简单</span></span><br><span class="line"> map.forEach((k, v) -&gt; System.out.println(k + v));</span><br></pre></td></tr></table></figure><h4 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LambdaTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        LambdaTest lambdaTest = <span class="keyword">new</span> LambdaTest();</span><br><span class="line">        <span class="comment">//原始关键代码进行回调并返回值</span></span><br><span class="line">        <span class="comment">/*int num = lambdaTest.invok(new CallBack() &#123;</span></span><br><span class="line"><span class="comment">            @Override</span></span><br><span class="line"><span class="comment">            public int call(int x, int y) &#123;</span></span><br><span class="line"><span class="comment">                return x + y;</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">        &#125;);*/</span></span><br><span class="line">       <span class="comment">// ------------------------------</span></span><br><span class="line">        <span class="comment">//使用Lambda 更简单更简洁</span></span><br><span class="line">        <span class="keyword">int</span> num = lambdaTest.invok((x, y) -&gt; x + y);</span><br><span class="line">        System.out.println(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> callBack</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">invok</span><span class="params">(CallBack callBack)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"方法执行前"</span>);</span><br><span class="line">        <span class="keyword">int</span> num = callBack.call(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"方法执行后"</span>);</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 匿名内部类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">CallBack</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">call</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Java-线程创建"><a href="#Java-线程创建" class="headerlink" title="Java 线程创建"></a>Java 线程创建</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通方式创建线程</span></span><br><span class="line">    Thread thread1 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"我是普通线程"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Lambda表达式创建线程</span></span><br><span class="line">    Thread thread2 = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"我是Lambda线程"</span>));</span><br><span class="line"></span><br><span class="line">thread1.start();</span><br><span class="line">    thread2.start();</span><br></pre></td></tr></table></figure><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">String[] stringArrays = &#123;<span class="string">"Rafael Nadal"</span>, <span class="string">"Novak Djokovic"</span>,</span><br><span class="line">                <span class="string">"Stanislas Wawrinka"</span>, <span class="string">"David Ferrer"</span>,</span><br><span class="line">                <span class="string">"Roger Federer"</span>, <span class="string">"Andy Murray"</span>,</span><br><span class="line">                <span class="string">"Tomas Berdych"</span>, <span class="string">"Juan Martin Del Potro"</span>,</span><br><span class="line">                <span class="string">"Richard Gasquet"</span>, <span class="string">"John Isner"</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用匿名内部类根据 name 排序 stringArrays</span></span><br><span class="line">        Arrays.sort(stringArrays, <span class="keyword">new</span> Comparator&lt;String&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(String s1, String s2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> (s1.compareTo(s2));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用Lambda 表达式进行排序</span></span><br><span class="line">        Arrays.sort(stringArrays,(x,y)-&gt;x.compareTo(y));</span><br></pre></td></tr></table></figure><p>就是这样,简洁又直观。 在下一节中我们将探索更多lambdas的能力,并将其与 stream 结合起来使用。</p><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E5%BC%80%E5%8F%91.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>JsonValidator工具类</title>
      <link>http://www.baiyp.ren/JsonValidator%E5%B7%A5%E5%85%B7%E7%B1%BB.html</link>
      <guid>http://www.baiyp.ren/JsonValidator%E5%B7%A5%E5%85%B7%E7%B1%BB.html</guid>
      <pubDate>Sat, 19 May 2018 23:08:50 GMT</pubDate>
      <description>
      
        用于检测字符串是否是JSON格式的
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h3 id="JsonValidator工具类"><a href="#JsonValidator工具类" class="headerlink" title="JsonValidator工具类"></a>JsonValidator工具类</h3><blockquote><p>JsonValidator 是用来校验字符串是否是JSON格式</p></blockquote><p>​ 是我用来加前后端段解密时候用到的，前端加密成JSON格式后端需要解密，所以需要对JSON格式做一个校验，网上找到了这个工具类，比较好用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 用于校验一个字符串是否是合法的JSON格式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.Cache;</span><br><span class="line"><span class="keyword">import</span> com.google.common.cache.CacheBuilder;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.text.CharacterIterator;</span><br><span class="line"><span class="keyword">import</span> java.text.StringCharacterIterator;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonValidator</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(JsonValidator.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Cache&lt;String, JsonValidator&gt; jsonValidatorCache = CacheBuilder.newBuilder()</span><br><span class="line">            <span class="comment">//设置cache的初始大小为10，要合理设置该值</span></span><br><span class="line">            .initialCapacity(<span class="number">10</span>)</span><br><span class="line">            <span class="comment">//设置并发数为5，即同一时间最多只能有5个线程往cache执行写入操作</span></span><br><span class="line">            .concurrencyLevel(<span class="number">10</span>)</span><br><span class="line">            <span class="comment">//构建cache实例</span></span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">private</span> CharacterIterator it;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> col;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">JsonValidator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonValidator <span class="title">getJsonValidator</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getJsonValidator(<span class="string">"JsonValidator"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> JsonValidator <span class="title">getJsonValidator</span><span class="params">(<span class="keyword">final</span> String key)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> jsonValidatorCache.get(key, <span class="keyword">new</span> Callable&lt;JsonValidator&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> JsonValidator <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                logger.info(<span class="string">"[RBRequestParameter] - [getJsonValidator] - key:&#123;&#125;  - 创建对象"</span>, key);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> JsonValidator();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">error</span><span class="params">(String type, <span class="keyword">int</span> col)</span> </span>&#123;</span><br><span class="line">        System.out.printf(<span class="string">"type: %s, col: %s%s"</span>, type, col, System.getProperty(<span class="string">"line.separator"</span>));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> n = JsonValidator.getJsonValidator().validate(<span class="string">"[\"703502\",\"703502\",\"703502\",\"703502\",\"703502\",\"703502\",\"703502\",\"703502\"]"</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">        n = JsonValidator.getJsonValidator().validate(<span class="string">"[\"906102\",\"906102\",\"906102\",\"906102\",\"906101\",\"906101\",\"906101\",\"906101\",\"906101\",\"906101\"]"</span>);</span><br><span class="line">        System.out.println(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 验证一个字符串是否是合法的JSON串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> input 要验证的字符串</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true-合法 ，false-非法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validate</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        input = input.trim();</span><br><span class="line">        <span class="keyword">boolean</span> ret = valid(input);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">valid</span><span class="params">(String input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">""</span>.equals(input)) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        it = <span class="keyword">new</span> StringCharacterIterator(input);</span><br><span class="line">        c = it.first();</span><br><span class="line">        col = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (!value()) &#123;</span><br><span class="line">            ret = error(<span class="string">"value"</span>, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            skipWhiteSpace();</span><br><span class="line">            <span class="keyword">if</span> (c != CharacterIterator.DONE) &#123;</span><br><span class="line">                ret = error(<span class="string">"end"</span>, col);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> literal(<span class="string">"true"</span>) || literal(<span class="string">"false"</span>) || literal(<span class="string">"null"</span>) || string() || number() || object() || array();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">literal</span><span class="params">(String text)</span> </span>&#123;</span><br><span class="line">        CharacterIterator ci = <span class="keyword">new</span> StringCharacterIterator(text);</span><br><span class="line">        <span class="keyword">char</span> t = ci.first();</span><br><span class="line">        <span class="keyword">if</span> (c != t) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = col;</span><br><span class="line">        <span class="keyword">boolean</span> ret = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (t = ci.next(); t != CharacterIterator.DONE; t = ci.next()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (t != nextCharacter()) &#123;</span><br><span class="line">                ret = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nextCharacter();</span><br><span class="line">        <span class="keyword">if</span> (!ret) error(<span class="string">"literal "</span> + text, start);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">array</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate(<span class="string">'['</span>, <span class="string">']'</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">object</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aggregate(<span class="string">'&#123;'</span>, <span class="string">'&#125;'</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">aggregate</span><span class="params">(<span class="keyword">char</span> entryCharacter, <span class="keyword">char</span> exitCharacter, <span class="keyword">boolean</span> prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c != entryCharacter) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        nextCharacter();</span><br><span class="line">        skipWhiteSpace();</span><br><span class="line">        <span class="keyword">if</span> (c == exitCharacter) &#123;</span><br><span class="line">            nextCharacter();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prefix) &#123;</span><br><span class="line">                <span class="keyword">int</span> start = col;</span><br><span class="line">                <span class="keyword">if</span> (!string()) <span class="keyword">return</span> error(<span class="string">"string"</span>, start);</span><br><span class="line">                skipWhiteSpace();</span><br><span class="line">                <span class="keyword">if</span> (c != <span class="string">':'</span>) <span class="keyword">return</span> error(<span class="string">"colon"</span>, col);</span><br><span class="line">                nextCharacter();</span><br><span class="line">                skipWhiteSpace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (value()) &#123;</span><br><span class="line">                skipWhiteSpace();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="string">','</span>) &#123;</span><br><span class="line">                    nextCharacter();</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == exitCharacter) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> error(<span class="string">"comma or "</span> + exitCharacter, col);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> error(<span class="string">"value"</span>, col);</span><br><span class="line">            &#125;</span><br><span class="line">            skipWhiteSpace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nextCharacter();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">number</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!Character.isDigit(c) &amp;&amp; c != <span class="string">'-'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> start = col;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'-'</span>) nextCharacter();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'0'</span>) &#123;</span><br><span class="line">            nextCharacter();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">            <span class="keyword">while</span> (Character.isDigit(c))</span><br><span class="line">                nextCharacter();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">"number"</span>, start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'.'</span>) &#123;</span><br><span class="line">            nextCharacter();</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (Character.isDigit(c))</span><br><span class="line">                    nextCharacter();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> error(<span class="string">"number"</span>, start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'e'</span> || c == <span class="string">'E'</span>) &#123;</span><br><span class="line">            nextCharacter();</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">'+'</span> || c == <span class="string">'-'</span>) &#123;</span><br><span class="line">                nextCharacter();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Character.isDigit(c)) &#123;</span><br><span class="line">                <span class="keyword">while</span> (Character.isDigit(c))</span><br><span class="line">                    nextCharacter();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> error(<span class="string">"number"</span>, start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">string</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'"'</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = col;</span><br><span class="line">        <span class="keyword">boolean</span> escaped = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (nextCharacter(); c != CharacterIterator.DONE; nextCharacter()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!escaped &amp;&amp; c == <span class="string">'\\'</span>) &#123;</span><br><span class="line">                escaped = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (escaped) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!escape()) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                escaped = <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c == <span class="string">'"'</span>) &#123;</span><br><span class="line">                nextCharacter();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> error(<span class="string">"quoted string"</span>, start);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">escape</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = col - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">" \\\"/bfnrtu"</span>.indexOf(c) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> error(<span class="string">"escape sequence  \\\",\\\\,\\/,\\b,\\f,\\n,\\r,\\t  or  \\uxxxx "</span>, start);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'u'</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!ishex(nextCharacter()) || !ishex(nextCharacter()) || !ishex(nextCharacter())</span><br><span class="line">                    || !ishex(nextCharacter())) &#123;</span><br><span class="line">                <span class="keyword">return</span> error(<span class="string">"unicode escape sequence  \\uxxxx "</span>, start);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">ishex</span><span class="params">(<span class="keyword">char</span> d)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"0123456789abcdefABCDEF"</span>.indexOf(c) &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">char</span> <span class="title">nextCharacter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        c = it.next();</span><br><span class="line">        ++col;</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">skipWhiteSpace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (Character.isWhitespace(c)) &#123;</span><br><span class="line">            nextCharacter();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/JsonValidator%E5%B7%A5%E5%85%B7%E7%B1%BB.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>HttpClient工具类</title>
      <link>http://www.baiyp.ren/HttpClient%E5%B7%A5%E5%85%B7%E7%B1%BB.html</link>
      <guid>http://www.baiyp.ren/HttpClient%E5%B7%A5%E5%85%B7%E7%B1%BB.html</guid>
      <pubDate>Thu, 03 May 2018 23:00:42 GMT</pubDate>
      <description>
      
        收藏的一个HttpClient工具类
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h3 id="HttpClient工具类"><a href="#HttpClient工具类" class="headerlink" title="HttpClient工具类"></a>HttpClient工具类</h3><blockquote><p>HttpClient 是用来远程访问页面或者调用Http接口的，可以用来调用接口喝着爬虫都可以</p></blockquote><p>​</p><p>收藏好久的工具类展示以下，用了很长时间，也是从其他地方收集过来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.net.URISyntaxException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.alibaba.fastjson.JSON;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.httpclient.HttpStatus;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.HttpResponse;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.NameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.ClientProtocolException;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.HttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.config.RequestConfig;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.entity.UrlEncodedFormEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpGet;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpPost;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.methods.HttpRequestBase;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.client.utils.URLEncodedUtils;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.entity.StringEntity;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.CloseableHttpClient;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.DefaultHttpRequestRetryHandler;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.client.HttpClientBuilder;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.impl.conn.PoolingHttpClientConnectionManager;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicHeader;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.message.BasicNameValuePair;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.protocol.HTTP;</span><br><span class="line"><span class="keyword">import</span> org.apache.http.util.EntityUtils;</span><br><span class="line"><span class="keyword">import</span> org.springframework.util.Assert;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpClientUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HttpClientUtils</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连接超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONNECTION_TIMEOUT_MS = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读取数据超时时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SO_TIMEOUT_MS = <span class="number">5000</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String utf8 = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String application_json = <span class="string">"application/json"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String gbk = <span class="string">"GBK"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单get调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClientProtocolException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String url, Map&lt;String, String&gt; params)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, URISyntaxException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> get(url, params, utf8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单get调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClientProtocolException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">get</span><span class="params">(String url, Map&lt;String, String&gt; params, String charset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IOException, URISyntaxException </span>&#123;</span><br><span class="line">        HttpClient client = buildHttpClient(<span class="keyword">true</span>);</span><br><span class="line">        HttpGet get = buildHttpGet(url, params, charset);</span><br><span class="line">        HttpResponse response = client.execute(get);</span><br><span class="line">        assertStatus(response);</span><br><span class="line"></span><br><span class="line">        HttpEntity entity = response.getEntity();</span><br><span class="line">        <span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EntityUtils.toString(entity, charset);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单post调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClientProtocolException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">post</span><span class="params">(String url, Map&lt;String, String&gt; params)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> post(url, params, utf8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">postJSON</span><span class="params">(String url, Map&lt;String, String&gt; params)</span> <span class="keyword">throws</span> IOException, URISyntaxException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> postJSON(url, params, utf8);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 简单post调用</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClientProtocolException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IOException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">post</span><span class="params">(String url, Map&lt;String, String&gt; params, String charset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpClient client = buildHttpClient(<span class="keyword">true</span>);</span><br><span class="line">        HttpPost postMethod = buildHttpPost(url, params, charset);</span><br><span class="line">        HttpResponse response = client.execute(postMethod);</span><br><span class="line">        assertStatus(response);</span><br><span class="line">        HttpEntity entity = response.getEntity();</span><br><span class="line">        <span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EntityUtils.toString(entity, charset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">postJSON</span><span class="params">(String url, Map params, String charset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> URISyntaxException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        HttpClient client = buildHttpClient(<span class="keyword">true</span>);</span><br><span class="line">        HttpPost postMethod = buildHttpJSONPost(url, params, charset);</span><br><span class="line">        HttpResponse response = client.execute(postMethod);</span><br><span class="line">        assertStatus(response);</span><br><span class="line">        HttpEntity entity = response.getEntity();</span><br><span class="line">        <span class="keyword">if</span> (entity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> EntityUtils.toString(entity, charset);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建HttpClient</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> isMultiThread</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpClient <span class="title">buildHttpClient</span><span class="params">(<span class="keyword">boolean</span> isMultiThread)</span> </span>&#123;</span><br><span class="line">        CloseableHttpClient client;</span><br><span class="line">        <span class="keyword">if</span> (isMultiThread)</span><br><span class="line">            client = HttpClientBuilder</span><br><span class="line">                    .create().setDefaultRequestConfig(buildRequestConfig())</span><br><span class="line">                    .setRetryHandler(<span class="keyword">new</span> DefaultHttpRequestRetryHandler())</span><br><span class="line">                    .setConnectionManager(</span><br><span class="line">                            <span class="keyword">new</span> PoolingHttpClientConnectionManager()).build();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            client = HttpClientBuilder.create().build();</span><br><span class="line">        <span class="keyword">return</span> client;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建httpPost对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> UnsupportedEncodingException</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpPost <span class="title">buildHttpPost</span><span class="params">(String url, Map&lt;String, String&gt; params, String charset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnsupportedEncodingException, URISyntaxException </span>&#123;</span><br><span class="line">        Assert.notNull(url, <span class="string">"构建HttpPost时,url不能为null"</span>);</span><br><span class="line">        HttpPost post = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">        setCommonHttpMethod(post);</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;NameValuePair&gt; formparams = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">                formparams.add(<span class="keyword">new</span> BasicNameValuePair(entry.getKey(), entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            HttpEntity he = <span class="keyword">new</span> UrlEncodedFormEntity(formparams, charset);</span><br><span class="line">            post.setEntity(he);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpPost <span class="title">buildHttpJSONPost</span><span class="params">(String url, Map&lt;String, String&gt; params, String charset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> UnsupportedEncodingException, URISyntaxException </span>&#123;</span><br><span class="line">        Assert.notNull(url, <span class="string">"构建HttpPost时,url不能为null"</span>);</span><br><span class="line">        HttpPost post = <span class="keyword">new</span> HttpPost(url);</span><br><span class="line">        setJSONHttpMethod(post);</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String json = JSON.toJSONString(params);</span><br><span class="line">            System.out.println(json);</span><br><span class="line">            StringEntity stringEntity = <span class="keyword">new</span> StringEntity(json, utf8);</span><br><span class="line">            stringEntity.setContentEncoding(<span class="keyword">new</span> BasicHeader(HTTP.CONTENT_TYPE, application_json));</span><br><span class="line">            post.setEntity(stringEntity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> post;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建httpGet对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> URISyntaxException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HttpGet <span class="title">buildHttpGet</span><span class="params">(String url, Map&lt;String, String&gt; params, String chatset)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> URISyntaxException </span>&#123;</span><br><span class="line">        Assert.notNull(url, <span class="string">"构建HttpGet时,url不能为null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HttpGet(buildGetUrl(url, params, chatset));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * build getUrl str</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title">buildGetUrl</span><span class="params">(String url, Map&lt;String, String&gt; params, String charset)</span> </span>&#123;</span><br><span class="line">        StringBuilder uriStr = <span class="keyword">new</span> StringBuilder(url);</span><br><span class="line">        <span class="keyword">if</span> (params != <span class="keyword">null</span>) &#123;</span><br><span class="line">            List&lt;NameValuePair&gt; ps = <span class="keyword">new</span> ArrayList&lt;NameValuePair&gt;();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123;</span><br><span class="line">                ps.add(<span class="keyword">new</span> BasicNameValuePair(entry.getKey(), entry.getValue()));</span><br><span class="line">            &#125;</span><br><span class="line">            uriStr.append(<span class="string">"?"</span>);</span><br><span class="line">            uriStr.append(URLEncodedUtils.format(ps, charset));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> uriStr.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置HttpMethod通用配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpMethod</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setCommonHttpMethod</span><span class="params">(HttpRequestBase httpMethod)</span> </span>&#123;</span><br><span class="line">        httpMethod.setHeader(HTTP.CONTENT_ENCODING, utf8);<span class="comment">// setting</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置HttpMethod通用配置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">             * @param httpMethod</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setJSONHttpMethod</span><span class="params">(HttpRequestBase httpMethod)</span> </span>&#123;</span><br><span class="line">        httpMethod.setHeader(HTTP.CONTENT_ENCODING, utf8);<span class="comment">// setting</span></span><br><span class="line">        httpMethod.setHeader(HTTP.CONTENT_TYPE, application_json);<span class="comment">// setting</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置成消息体的长度 setting MessageBody length</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpMethod</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> he</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContentLength</span><span class="params">(HttpRequestBase httpMethod, HttpEntity he)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (he == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        httpMethod.setHeader(HTTP.CONTENT_LEN, String.valueOf(he.getContentLength()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建公用RequestConfig</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestConfig <span class="title">buildRequestConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置请求和传输超时时间</span></span><br><span class="line">        <span class="keyword">return</span> RequestConfig.custom()</span><br><span class="line">                .setSocketTimeout(SO_TIMEOUT_MS)</span><br><span class="line">                .setConnectTimeout(CONNECTION_TIMEOUT_MS).build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 强验证必须是200状态否则报异常</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> res</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> HttpException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertStatus</span><span class="params">(HttpResponse res)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Assert.notNull(res, <span class="string">"http响应对象为null"</span>);</span><br><span class="line">        Assert.notNull(res.getStatusLine(), <span class="string">"http响应对象的状态为null"</span>);</span><br><span class="line">        <span class="keyword">switch</span> (res.getStatusLine().getStatusCode()) &#123;</span><br><span class="line">            <span class="keyword">case</span> HttpStatus.SC_OK:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"服务器响应状态异常,失败."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClientProtocolException, IOException, URISyntaxException </span>&#123;</span><br><span class="line">        System.out.println(get(<span class="string">"http://www.baidu.com"</span>, <span class="keyword">new</span> HashMap&lt;String, String&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/HttpClient%E5%B7%A5%E5%85%B7%E7%B1%BB.html#disqus_thread</comments>
    </item>
    
    <item>
      <title>携程Apollo(阿波罗)安装部署以及java整合</title>
      <link>http://www.baiyp.ren/%E6%90%BA%E7%A8%8BApollo-%E9%98%BF%E6%B3%A2%E7%BD%97-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8Ajava%E6%95%B4%E5%90%88.html</link>
      <guid>http://www.baiyp.ren/%E6%90%BA%E7%A8%8BApollo-%E9%98%BF%E6%B3%A2%E7%BD%97-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8Ajava%E6%95%B4%E5%90%88.html</guid>
      <pubDate>Mon, 02 Apr 2018 21:48:53 GMT</pubDate>
      <description>
      
        apollo分布式配置中心的部署和使用
      
      </description>
      
      <content:encoded><![CDATA[<!-- build time:Fri Aug 09 2019 14:01:01 GMT+0800 (GMT+08:00) --><h2 id="携程Apollo（阿波罗）安装部署以及java整合"><a href="#携程Apollo（阿波罗）安装部署以及java整合" class="headerlink" title="携程Apollo（阿波罗）安装部署以及java整合"></a>携程Apollo（阿波罗）安装部署以及java整合</h2><h3 id="服务器部署"><a href="#服务器部署" class="headerlink" title="服务器部署"></a>服务器部署</h3><p>可以按照apollo wiki 进行部署<br><a href="https://github.com/ctripcorp/apollo/wiki/Quick-Start" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ctripcorp/apollo/wiki/Quick-Start</a></p><h4 id="安装-Java-环境"><a href="#安装-Java-环境" class="headerlink" title="安装 Java 环境"></a>安装 Java 环境</h4><p>java</p><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><p>Apollo服务端共需要两个数据库：ApolloPortalDB和ApolloConfigDB，我们把数据库、表的创建和样例数据都分别准备了sql文件，只需要导入数据库即可。<br>执行两个sql文件<br>sql/apolloportaldb.sql<br>sql/apolloconfigdb.sql<br>会创建两个数据库</p><h4 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h4><p><a href="https://github.com/nobodyiam/apollo-build-scripts" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/nobodyiam/apollo-build-scripts</a></p><h4 id="服务器部署-1"><a href="#服务器部署-1" class="headerlink" title="服务器部署"></a>服务器部署</h4><p>将快速部署包apollo-quick-start放进服务器<br>解压文件</p><h4 id="服务器配置"><a href="#服务器配置" class="headerlink" title="服务器配置"></a>服务器配置</h4><p>Apollo服务端需要知道如何连接到你前面创建的数据库，所以需要编辑demo.sh，修改ApolloPortalDB和ApolloConfigDB相关的数据库连接串信息。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#apollo config db info</span></span><br><span class="line">apollo_config_db_url=jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8</span><br><span class="line">apollo_config_db_username=用户名</span><br><span class="line">apollo_config_db_password=密码（如果没有密码，留空即可）</span><br><span class="line"></span><br><span class="line"><span class="comment"># apollo portal db info</span></span><br><span class="line">apollo_portal_db_url=jdbc:mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8</span><br><span class="line">apollo_portal_db_username=用户名</span><br><span class="line">apollo_portal_db_password=密码（如果没有密码，留空即可）</span><br></pre></td></tr></table></figure><p>修改服务器端口地址信息</p><h1 id="meta-server-url"><a href="#meta-server-url" class="headerlink" title="meta server url"></a>meta server url</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">config_server_url=http://10.168.16.125:8080</span><br><span class="line">admin_server_url=http://10.168.16.125:8090</span><br><span class="line">portal_url=http://10.168.16.125:8070</span><br></pre></td></tr></table></figure><blockquote><p>如果部署在linux服务器上需要将地址改为服务器IP地址<br>注意：不要修改demo.sh的其它部分</p></blockquote><h4 id="确保端口未被占用"><a href="#确保端口未被占用" class="headerlink" title="确保端口未被占用"></a>确保端口未被占用</h4><p>Quick Start脚本会在本地启动3个服务，分别使用8070, 8080, 8090端口，请确保这3个端口当前没有被使用。</p><p>例如，在Linux/Mac下，可以通过如下命令检查：</p><blockquote><p>lsof -i:8080</p></blockquote><h4 id="执行启动脚本"><a href="#执行启动脚本" class="headerlink" title="执行启动脚本"></a>执行启动脚本</h4><blockquote><p>./demo.sh start</p></blockquote><p>当看到如下输出后，就说明启动成功了！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">==== starting service ====</span><br><span class="line">Service logging file is ./service/apollo-service.log</span><br><span class="line">Started [10768]</span><br><span class="line">Waiting for config service startup.......</span><br><span class="line">Config service started. You may visit http://localhost:8080 for service status now!</span><br><span class="line">Waiting for admin service startup....</span><br><span class="line">Admin service started</span><br><span class="line">==== starting portal ====</span><br><span class="line">Portal logging file is ./portal/apollo-portal.log</span><br><span class="line">Started [10846]</span><br><span class="line">Waiting for portal startup......</span><br><span class="line">Portal started. You can visit http://localhost:8070 now!</span><br></pre></td></tr></table></figure><h3 id="使用Apollo配置中心"><a href="#使用Apollo配置中心" class="headerlink" title="使用Apollo配置中心"></a>使用Apollo配置中心</h3><p>访问 服务器的IP:8070 可以进行访问<br>例如 ：<a href="http://10.168.16.125:8070" rel="external nofollow noopener noreferrer" target="_blank">http://10.168.16.125:8070</a></p><p><img src="../images/apollo-pzzx1.png" alt><br>默认 用户名密码是 apollo admin<br>登陆后如下界面</p><p><img src="../images/apollo-pzzx2.png" alt></p><p>可以创建自己的项目<br><img src="../images/apollo-pzzx3.png" alt></p><h4 id="添加namespace"><a href="#添加namespace" class="headerlink" title="添加namespace"></a>添加namespace</h4><p>namespace 相当于配置文件名称<br>在namespace中添加属性，可以以文本形式添加</p><blockquote><p>可以自己研究琢磨下</p></blockquote><h3 id="java服务整合"><a href="#java服务整合" class="headerlink" title="java服务整合"></a>java服务整合</h3><h4 id="pom整合"><a href="#pom整合" class="headerlink" title="pom整合"></a>pom整合</h4><p>官方提供的maven</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.ctrip.framework.apollo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>apollo-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.9.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>发现拉不下来jar包<br>解决方案<br>下载源代码<br><a href="https://github.com/ctripcorp/apollo.git" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/ctripcorp/apollo.git</a><br>编译其中的 apollo-client 包并安装到本地<br>引入编译后的jar包即可</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;apollo-client&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;0.10.0-SNAPSHOT&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h4 id="现有应用接入"><a href="#现有应用接入" class="headerlink" title="现有应用接入"></a>现有应用接入</h4><p>在应用接入Apollo之后，这些配置是可以非常方便的迁移到Apollo的，具体步骤如下：</p><p>在Apollo为应用新建项目<br>在应用中配置好META-INF/app.properties<br>把原先配置（必须是properties格式）复制一下，然后通过Apollo提供的文本编辑模式全部粘帖到应用的application namespace，发布配置<br>如果原来是其它格式，如yml，请先转成properties格式<br>把原先的配置文件如bootstrap.properties, application.properties从项目中删除</p><blockquote><p>app.properties 内容是创建项目的APPID（应用ID）如前面创建的12345</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># test</span><br><span class="line">app.id=12345</span><br></pre></td></tr></table></figure><p>并在resources 下加入apollo-env.properties 各环境的服务器地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">local.meta=http://10.168.16.125:8080</span><br><span class="line">dev.meta=http://10.168.16.125:8080</span><br><span class="line">fat.meta=$&#123;fat_meta&#125;</span><br><span class="line">uat.meta=$&#123;uat_meta&#125;</span><br><span class="line">lpt.meta=$&#123;lpt_meta&#125;</span><br><span class="line">pro.meta=$&#123;pro_meta&#125;</span><br></pre></td></tr></table></figure><h4 id="修改环境"><a href="#修改环境" class="headerlink" title="修改环境"></a>修改环境</h4><p>修改/opt/settings/server.properties（Mac/Linux）或C:\opt\settings\server.properties（Windows）文件，设置env为DEV：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env=DEV</span><br></pre></td></tr></table></figure><h4 id="Spring-整合"><a href="#Spring-整合" class="headerlink" title="Spring 整合"></a>Spring 整合</h4><h4 id="apollo启动配置"><a href="#apollo启动配置" class="headerlink" title="apollo启动配置"></a>apollo启动配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;apollo:config/&gt;</span><br></pre></td></tr></table></figure><h4 id="apollo加载namespace配置"><a href="#apollo加载namespace配置" class="headerlink" title="apollo加载namespace配置"></a>apollo加载namespace配置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;apollo:config namespaces=&quot;dubbo&quot; order=&quot;1&quot;/&gt;</span><br></pre></td></tr></table></figure><p>####官方配置如下<br>Apollo也支持和Spring整合（Spring 3.1.1+），只需要做一些简单的配置就可以了。</p><p>Apollo目前既支持比较传统的基于XML的配置，也支持目前比较流行的基于Java（推荐）的配置。</p><p>需要注意的是，如果之前有使用org.springframework.beans.factory.config.PropertyPlaceholderConfigurer的，请替换成org.springframework.context.support.PropertySourcesPlaceholderConfigurer。Spring 3.1以后就不建议使用PropertyPlaceholderConfigurer了，要改用PropertySourcesPlaceholderConfigurer。</p><p>基于XML的配置<br>注：需要把apollo相关的xml namespace加到配置文件头上，不然会报xml语法错误。</p><p>1.注入默认namespace的配置到Spring中</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:apollo</span>=<span class="string">"http://www.ctrip.com/schema/apollo"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">       http://www.ctrip.com/schema/apollo http://www.ctrip.com/schema/apollo.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个是最简单的配置形式，一般应用用这种形式就可以了，用来指示Apollo注入application namespace的配置到Spring环境中 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">apollo:config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"com.ctrip.framework.apollo.spring.TestXmlBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"timeout"</span> <span class="attr">value</span>=<span class="string">"$&#123;timeout:100&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"batch"</span> <span class="attr">value</span>=<span class="string">"$&#123;batch:200&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2.注入多个namespace的配置到Spring中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">       xmlns:apollo=&quot;http://www.ctrip.com/schema/apollo&quot;</span><br><span class="line">       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="line">       http://www.ctrip.com/schema/apollo http://www.ctrip.com/schema/apollo.xsd&quot;&gt;</span><br><span class="line">    &lt;!-- 这个是最简单的配置形式，一般应用用这种形式就可以了，用来指示Apollo注入application namespace的配置到Spring环境中 --&gt;</span><br><span class="line">    &lt;apollo:config/&gt;</span><br><span class="line">    &lt;!-- 这个是稍微复杂一些的配置形式，指示Apollo注入FX.apollo和FX.soa namespace的配置到Spring环境中 --&gt;</span><br><span class="line">    &lt;apollo:config namespaces=&quot;FX.apollo,FX.soa&quot;/&gt;</span><br><span class="line">    &lt;bean class=&quot;com.ctrip.framework.apollo.spring.TestXmlBean&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;timeout&quot; value=&quot;$&#123;timeout:100&#125;&quot;/&gt;</span><br><span class="line">        &lt;property name=&quot;batch&quot; value=&quot;$&#123;batch:200&#125;&quot;/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h4 id="dubbo服务整合"><a href="#dubbo服务整合" class="headerlink" title="dubbo服务整合"></a>dubbo服务整合</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">apollo:config</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">apollo:config</span> <span class="attr">namespaces</span>=<span class="string">"dubbo"</span> <span class="attr">order</span>=<span class="string">"1"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--     公共信息，也可以用dubbo.properties配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"$&#123;dubbo.application.name&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--     需要强制指定地址，配置文件默认可以不配置 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"$&#123;dubbo.registry.address&#125;"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxxService"</span> <span class="attr">class</span>=<span class="string">"com.xxx.cache.service.impl.RedisServiceImpl"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.xxx.xxx.service.RedisService"</span> <span class="attr">ref</span>=<span class="string">"redisService"</span></span></span><br><span class="line"><span class="tag">                   <span class="attr">version</span>=<span class="string">"$&#123;dubbo.version&#125;"</span>/&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>dubbo 默认没有不需要配置，但使用apollo后没有自动注入dubbo注册地址，需要手动声明,原因待定</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;dubbo:registry address=&quot;$&#123;dubbo.registry.address&#125;&quot;/&gt;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content:encoded>
      
      <comments>http://www.baiyp.ren/%E6%90%BA%E7%A8%8BApollo-%E9%98%BF%E6%B3%A2%E7%BD%97-%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2%E4%BB%A5%E5%8F%8Ajava%E6%95%B4%E5%90%88.html#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
