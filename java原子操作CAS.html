<!-- build time:Sat Aug 17 2019 15:00:51 GMT+0800 (GMT+08:00) --><!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="晓风残月的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><meta name="theme-version" content="1.2.3"><meta name="root" content="/"><link rel="dns-prefetch" href="http://www.baiyp.ren"><meta name="keywords" content="{{ page.keywords }}"><meta name="description" content="java原子操作CAS什么是CASCAS（Compare and Swap），即比较并替换，是用于实现多线程同步的原子指令。​ 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时..."><meta name="robots" content="all"><meta name="google" content="all"><meta name="googlebot" content="all"><meta name="verify" content="all"><title>java原子操作CAS | 晓风残月的博客</title><link rel="alternate" href="/rss2.xml" title="晓风残月的博客" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0"><link rel="stylesheet" href="/css/style.css?rev=@@hash"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a475efbbf07ecf405a82aa9bd596d186";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]--><!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]--><body><header class="main-header" style="background-image:url(./img/banner5.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="晓风残月"><img src="img/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>学而时习之,不亦说乎</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span> <i class="fa fa-bars"></i> </span><a class="navbar-brand" href="http://www.baiyp.ren">晓风残月的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i>首页</a></li><li role="presentation" class="text-center"><a href="/categories/java/"><i class="fa"></i>基础</a></li><li role="presentation" class="text-center"><a href="/categories/arch/"><i class="fa"></i>架构</a></li><li role="presentation" class="text-center"><a href="/categories/source/"><i class="fa"></i>源码</a></li><li role="presentation" class="text-center"><a href="/categories/code/"><i class="fa"></i>片段</a></li><li role="presentation" class="text-center"><a href="/archives/"><i class="fa"></i>时间轴</a></li><li role="presentation" class="text-center"><a href="/about.html"><i class="fa"></i>关于我</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="java原子操作CAS">java原子操作CAS</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a class="category-link" href="categories/java/">java</a> <a class="category-link" href="categories/java/并发/">并发</a> <a class="category-link" href="categories/java/并发/工具类/">工具类</a> </span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a class="tag-link" href="tags/java/">java</a> <a class="tag-link" href="tags/工具类/">工具类</a> <a class="tag-link" href="tags/并发/">并发</a> </span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2019/08/09</span> </span><span class="fa-wrap"><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></span><div style="margin-top:10px"><span class="post-time" style="margin-right:0"><span class="post-meta-item-icon" style="margin-right:0"><i class="fa fa-keyboard-o"></i> <span class="post-meta-item-text" style="margin-right:0">字数统计: </span><span class="post-count" style="margin-right:0">2.5k字</span> </span></span><span class="post-time" style="margin-right:0">&nbsp; | &nbsp; <span class="post-meta-item-icon" style="margin-right:0"><i class="fa fa-hourglass-half"></i> <span class="post-meta-item-text" style="margin-right:0">阅读时长: </span><span class="post-count" style="margin-right:0">9分</span></span></span></div></div></div><div class="post-body post-content"><h2 id="java原子操作CAS"><a href="#java原子操作CAS" class="headerlink" title="java原子操作CAS"></a>java原子操作CAS</h2><p><img src="../images/cas04.png" alt></p><h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><blockquote><p>CAS（Compare and Swap），即比较并替换，是用于实现多线程同步的原子指令。</p></blockquote><p>​ 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p><p>​ 实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，<strong>synchronized</strong>关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，</p><p>​ 这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p><p>​ 实现原子操作还可以使用当前的<strong>处理器</strong>基本都支持CAS的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p><p>​ CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。</p><p>​ CAS是怎么实现线程的安全呢？语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。</p><p><img src="../images/cas01.png" alt></p><h3 id="悲观锁，乐观锁"><a href="#悲观锁，乐观锁" class="headerlink" title="悲观锁，乐观锁"></a>悲观锁，乐观锁</h3><p>说到CAS，不得不提到两个专业词语：悲观锁，乐观锁。我们先来看看什么是悲观锁，什么是乐观锁。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​ 顾名思义，就是比较悲观的锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁思想的实现。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​ 反之，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。我们今天讲的CAS就是乐观锁。</p><h3 id="CAS-的优点"><a href="#CAS-的优点" class="headerlink" title="CAS 的优点"></a>CAS 的优点</h3><p>​ 非阻塞的轻量级乐观锁, 通过CPU指令实现, 在资源竞争不激烈的情况下性能高, 相比synchronize重量级悲观锁, synchronize有复杂的加锁, 解锁和唤醒线程操作.。</p><h3 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><img src="../images/cas02.png" alt></p><p>​ 因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>​ 就像上图描述的一样，线程A原来的值是10，线程B修改为了20，但是线程C又将值修改为了10，这个时候线程A来读取了，与旧值做判断，发现还是10，没有修改过，就做了更新操作，但是我们知道，值有过变更。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>​ 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p><p>​ 还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h3 id="Jdk中相关原子操作类的使用"><a href="#Jdk中相关原子操作类的使用" class="headerlink" title="Jdk中相关原子操作类的使用"></a>Jdk中相关原子操作类的使用</h3><p>JDK的CAS原子操作类在JUC包下 我看看下</p><p><img src="../images/cas03.png" alt></p><h4 id="JAVA中如何实现CAS操作"><a href="#JAVA中如何实现CAS操作" class="headerlink" title="JAVA中如何实现CAS操作"></a>JAVA中如何实现CAS操作</h4><blockquote><p>先来一波操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  private static AtomicInteger count = new AtomicInteger(0);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cas 自旋操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accumulation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//获取旧值</span></span><br><span class="line">            <span class="keyword">int</span> oldValue = count.get();</span><br><span class="line">            <span class="comment">//比较并且交换</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = count.compareAndSet(oldValue, oldValue + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果成功退出自旋</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//失败打印信息再来一次</span></span><br><span class="line">            System.out.println(<span class="string">"数据已被修改自旋再来一次"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//五个线程再跑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每个线程让count自增100次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) &#123;</span><br><span class="line">                    accumulation();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据已被修改自旋再来一次</span><br><span class="line">数据已被修改自旋再来一次</span><br><span class="line">数据已被修改自旋再来一次</span><br><span class="line">数据已被修改自旋再来一次</span><br><span class="line"><span class="number">500</span></span><br></pre></td></tr></table></figure><p>这个是我们自己实现了累加操作，但是实际上JDK给我们提供了累加操作方法</p><p>将public static void accumulation() 方法替换为下面的方法就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count.incrementAndGet();</span><br></pre></td></tr></table></figure><p>我们进去看看他是怎么操作的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在进入getAndAddInt 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           v = getIntVolatile(o, offset);</span><br><span class="line">       &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">       <span class="keyword">return</span> v;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们发现，JDK也是通过自旋来实现的，和我们的效果一摸一样，他的核心方法是<strong>compareAndSwapInt</strong></p><h3 id="我们常用的CAS操作类"><a href="#我们常用的CAS操作类" class="headerlink" title="我们常用的CAS操作类"></a>我们常用的CAS操作类</h3><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>•int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</p><p>•boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</p><p>•int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</p><p>•int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</p><h4 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h4><p>主要是提供原子的方式更新数组里的整型，其常用方法如下。</p><p>•int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</p><p>•boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</p><p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p><h3 id="更新引用类型"><a href="#更新引用类型" class="headerlink" title="更新引用类型"></a>更新引用类型</h3><p>​ 原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p><h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>原子更新引用类型。</p><h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>​ 利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在ABA问题了。这就是AtomicStampedReference的解决方案。AtomicMarkableReference跟AtomicStampedReference差不多， AtomicStampedReference是使用pair的int stamp作为计数器使用，AtomicMarkableReference的pair使用的是boolean mark。 还是那个水的例子，AtomicStampedReference可能关心的是动过几次，AtomicMarkableReference关心的是有没有被人动过，方法都比较简单。</p><h4 id="AtomicMarkableReference："><a href="#AtomicMarkableReference：" class="headerlink" title="AtomicMarkableReference："></a>AtomicMarkableReference：</h4><p>​ 原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，booleaninitialMark）。</p><h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>​ 如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p><p>​ 要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p><h4 id="AtomicIntegerFieldUpdater："><a href="#AtomicIntegerFieldUpdater：" class="headerlink" title="AtomicIntegerFieldUpdater："></a>AtomicIntegerFieldUpdater：</h4><p>原子更新整型的字段的更新器。</p><h4 id="AtomicLongFieldUpdater："><a href="#AtomicLongFieldUpdater：" class="headerlink" title="AtomicLongFieldUpdater："></a>AtomicLongFieldUpdater：</h4><p>原子更新长整型字段的更新器。</p><h4 id="AtomicReferenceFieldUpdater："><a href="#AtomicReferenceFieldUpdater：" class="headerlink" title="AtomicReferenceFieldUpdater："></a>AtomicReferenceFieldUpdater：</h4><p>原子更新引用类型里的字段。</p></div><div class="reward" ontouchstart><div class="reward-wrap">赏<div class="reward-box"><span class="reward-type"><img class="alipay" src="./img/alipay.jpg"><b>支付宝打赏</b> </span><span class="reward-type"><img class="wechat" src="./img/wechatpay.png"><b>微信打赏</b></span></div></div><p class="reward-tip">赞赏是不耍流氓的鼓励</p></div><div class="post-footer"><div>转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">Snippet</a></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="java中的AQS-01.html" class="pre-post btn btn-default" title="java中的AQS"><i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span> <span class="hidden-xs">java中的AQS</span> </a><a href="java并发工具类-06.html" class="next-post btn btn-default" title="java并发工具类-Exchanger"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">java并发工具类-Exchanger</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NTg2Ny8yMjM3OA"><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></main><aside id="article-toc" role="navigation" class="col-md-4"><div class="widget"><h3 class="title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java原子操作CAS"><span class="toc-text">java原子操作CAS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是CAS"><span class="toc-text">什么是CAS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#悲观锁，乐观锁"><span class="toc-text">悲观锁，乐观锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#悲观锁"><span class="toc-text">悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#乐观锁"><span class="toc-text">乐观锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS-的优点"><span class="toc-text">CAS 的优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAS实现原子操作的三大问题"><span class="toc-text">CAS实现原子操作的三大问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ABA问题"><span class="toc-text">ABA问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环时间长开销大"><span class="toc-text">循环时间长开销大</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#只能保证一个共享变量的原子操作"><span class="toc-text">只能保证一个共享变量的原子操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Jdk中相关原子操作类的使用"><span class="toc-text">Jdk中相关原子操作类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JAVA中如何实现CAS操作"><span class="toc-text">JAVA中如何实现CAS操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#我们常用的CAS操作类"><span class="toc-text">我们常用的CAS操作类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicInteger"><span class="toc-text">AtomicInteger</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicIntegerArray"><span class="toc-text">AtomicIntegerArray</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新引用类型"><span class="toc-text">更新引用类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicReference"><span class="toc-text">AtomicReference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicStampedReference"><span class="toc-text">AtomicStampedReference</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicMarkableReference："><span class="toc-text">AtomicMarkableReference：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原子更新字段类"><span class="toc-text">原子更新字段类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicIntegerFieldUpdater："><span class="toc-text">AtomicIntegerFieldUpdater：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicLongFieldUpdater："><span class="toc-text">AtomicLongFieldUpdater：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AtomicReferenceFieldUpdater："><span class="toc-text">AtomicReferenceFieldUpdater：</span></a></li></ol></li></ol></li></ol></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi">访问量: <strong id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i> </strong>&nbsp; | &nbsp; 访客数: <strong id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></strong></div></div><div class="col-sm-12"><span>Copyright &copy; 2019 </span>| <span>Powered by <a href="//baiyp.ren" class="copyright-links" target="_blank" rel="nofollow">baiyp</a></span></div></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="js/app.js?rev=@@hash"></script></body><!-- rebuild by neat -->