<!-- build time:Sun Aug 18 2019 18:27:45 GMT+0800 (GMT+08:00) --><!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="晓风残月的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><meta name="theme-version" content="1.2.3"><meta name="root" content="/"><link rel="dns-prefetch" href="http://www.baiyp.ren"><meta name="keywords" content="{{ page.keywords }}"><meta name="description" content="JAVA中的分布式事务01-简介事务的具体定义​ 事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一..."><meta name="robots" content="all"><meta name="google" content="all"><meta name="googlebot" content="all"><meta name="verify" content="all"><title>JAVA中的分布式事务01-简介 | 晓风残月的博客</title><link rel="alternate" href="/rss2.xml" title="晓风残月的博客" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0"><link rel="stylesheet" href="/css/style.css?rev=@@hash"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a475efbbf07ecf405a82aa9bd596d186";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]--><!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]--><body><header class="main-header" style="background-image:url(./img/banner5.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="晓风残月"><img src="img/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>学而时习之,不亦说乎</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span> <i class="fa fa-bars"></i> </span><a class="navbar-brand" href="http://www.baiyp.ren">晓风残月的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i>首页</a></li><li role="presentation" class="text-center"><a href="/categories/java/"><i class="fa"></i>基础</a></li><li role="presentation" class="text-center"><a href="/categories/arch/"><i class="fa"></i>架构</a></li><li role="presentation" class="text-center"><a href="/categories/source/"><i class="fa"></i>源码</a></li><li role="presentation" class="text-center"><a href="/categories/code/"><i class="fa"></i>片段</a></li><li role="presentation" class="text-center"><a href="/archives/"><i class="fa"></i>时间轴</a></li><li role="presentation" class="text-center"><a href="/about.html"><i class="fa"></i>关于我</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="JAVA中的分布式事务01-简介">JAVA中的分布式事务01-简介</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a class="category-link" href="categories/arch/">arch</a> <a class="category-link" href="categories/arch/分布式事务/">分布式事务</a> </span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a class="tag-link" href="tags/arch/">arch</a> <a class="tag-link" href="tags/分布式事务/">分布式事务</a> <a class="tag-link" href="tags/分布式事务简介/">分布式事务简介</a> </span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2019/07/13</span> </span><span class="fa-wrap"><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></span><div style="margin-top:10px"><span class="post-time" style="margin-right:0"><span class="post-meta-item-icon" style="margin-right:0"><i class="fa fa-keyboard-o"></i> <span class="post-meta-item-text" style="margin-right:0">字数统计: </span><span class="post-count" style="margin-right:0">5k字</span> </span></span><span class="post-time" style="margin-right:0">&nbsp; | &nbsp; <span class="post-meta-item-icon" style="margin-right:0"><i class="fa fa-hourglass-half"></i> <span class="post-meta-item-text" style="margin-right:0">阅读时长: </span><span class="post-count" style="margin-right:0">17分</span></span></span></div></div></div><div class="post-body post-content"><h2 id="JAVA中的分布式事务01-简介"><a href="#JAVA中的分布式事务01-简介" class="headerlink" title="JAVA中的分布式事务01-简介"></a>JAVA中的分布式事务01-简介</h2><h3 id="事务的具体定义"><a href="#事务的具体定义" class="headerlink" title="事务的具体定义"></a>事务的具体定义</h3><p>​ 事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制</p><p><img src="../images/transaction01.png" alt></p><h3 id="数据库本地事务"><a href="#数据库本地事务" class="headerlink" title="数据库本地事务"></a>数据库本地事务</h3><blockquote><p>说到数据库事务就不得不说，数据库事务中的四大特性，ACID</p></blockquote><h4 id="A-原子性-Atomicity"><a href="#A-原子性-Atomicity" class="headerlink" title="A:原子性(Atomicity)"></a>A:原子性(Atomicity)</h4><p>​ 一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。</p><p>​ 就像你买东西要么交钱收货一起都执行，要么要是发不出货，就退钱。</p><h4 id="C-一致性-Consistency"><a href="#C-一致性-Consistency" class="headerlink" title="C:一致性(Consistency)"></a>C:一致性(Consistency)</h4><p>​ 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。</p><h4 id="I-隔离性-Isolation"><a href="#I-隔离性-Isolation" class="headerlink" title="I:隔离性(Isolation)"></a>I:隔离性(Isolation)</h4><p>​ 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。</p><p>打个比方，你买东西这个事情，是不影响其他人的</p><h4 id="D-持久性-Durability"><a href="#D-持久性-Durability" class="headerlink" title="D:持久性(Durability)"></a>D:持久性(Durability)</h4><p>​ 指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。</p><p>打个比方，你买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。</p><p><img src="../images/transaction02.png" alt></p><p>简单而言，ACID是从不同维度描述事务的特性：</p><ul><li>原子性 —— 事务操作的整体性</li><li>一致性 —— 事务操作下数据的正确性</li><li>隔离性 —— 事务并发操作下数据的正确性</li><li>持久性 —— 事务对数据修改的可靠性</li></ul><p>一个支持事务（Transaction）的数据库，需要具有这4种特性，否则在事务过程当中无法保证数据的正确性，处理结果极可能达不到请求方的要求。</p><h3 id="什么时候使用数据库事务"><a href="#什么时候使用数据库事务" class="headerlink" title="什么时候使用数据库事务"></a>什么时候使用数据库事务</h3><p>​ 在介绍完事务基本概念之后，什么时候该使用数据库事务？<br>简单而言，就是业务上有一组数据操作，需要如果其中有任何一个操作执行失败，整组操作全部不执行并恢复到未执行状态，要么全部成功，要么全部失败。</p><p>​ 在使用数据库事务时需要注意，尽可能短的保持事务，修改多个不同表的数据的冗长事务会严重妨碍系统中的所有其他用户，这很有可能导致一些性能问题。</p><h3 id="什么是分布式事务"><a href="#什么是分布式事务" class="headerlink" title="什么是分布式事务"></a>什么是分布式事务</h3><h4 id="分布式产生背景与概念"><a href="#分布式产生背景与概念" class="headerlink" title="分布式产生背景与概念"></a>分布式产生背景与概念</h4><p>​ 随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。</p><p>​ 有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种<strong>跨系统的事务为分布式事务</strong>，具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。</p><p>举个互联网常用的交易业务为例：</p><p><img src="../images/transaction03.png" alt></p><p>​ 上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。</p><p><img src="../images/transaction04.png" alt></p><p>可以看到，如果多个数据库之间的数据更新没有保证事务，将会导致出现子系统数据不一致，业务出现问题。</p><h4 id="分布式事务的难点"><a href="#分布式事务的难点" class="headerlink" title="分布式事务的难点"></a>分布式事务的难点</h4><h5 id="事务的原子性"><a href="#事务的原子性" class="headerlink" title="事务的原子性"></a>事务的原子性</h5><pre><code>事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的**要么什么都不做，要么做全套（All or Nothing）**的原子性。</code></pre><h5 id="事务的一致性"><a href="#事务的一致性" class="headerlink" title="事务的一致性"></a>事务的一致性</h5><p>​ 当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。</p><h5 id="事务的隔离性"><a href="#事务的隔离性" class="headerlink" title="事务的隔离性"></a>事务的隔离性</h5><p>​ 事务隔离性的本质就是如何正确多个并发事务的处理的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。</p><h4 id="分布式系统的一致性"><a href="#分布式系统的一致性" class="headerlink" title="分布式系统的一致性"></a>分布式系统的一致性</h4><p>​ 前面介绍到的分布式事务的难点涉及的问题，最终影响是导致数据出现不一致，下面对分布式系统的一致性问题进行理论分析，后面将基于这些理论进行分布式方案的介绍。</p><h5 id="可用性和一致性的冲突-——-CAP理论"><a href="#可用性和一致性的冲突-——-CAP理论" class="headerlink" title="可用性和一致性的冲突 —— CAP理论"></a>可用性和一致性的冲突 —— CAP理论</h5><p><img src="../images/transaction05.png" alt></p><p>​ CAP 定理又被称作布鲁尔定理，是加州大学的计算机科学家布鲁尔在 2000 年提出的一个猜想。2002 年，麻省理工学院的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为分布式计算领域公认的一个定理。</p><p>​ 布鲁尔在提出CAP猜想时并没有具体定义 Consistency、Availability、Partition Tolerance 这3个词的含义，不同资料的具体定义也有差别，为了更好地解释，下面选择<a href="http://robertgreiner.com/about/" rel="external nofollow noopener noreferrer" target="_blank">Robert Greiner</a>的文章<a href="http://robertgreiner.com/2014/08/cap-theorem-revisited/" rel="external nofollow noopener noreferrer" target="_blank">《CAP Theorem》</a>作为参考基础。</p><h3 id="CAP理论的定义"><a href="#CAP理论的定义" class="headerlink" title="CAP理论的定义"></a>CAP理论的定义</h3><blockquote><p>在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（PartitionTolerance）三者中的两个，另外一个必须被牺牲。</p></blockquote><p>Consistency、Availability、Partition Tolerance具体解释如下：</p><h4 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C - Consistency 一致性"></a>C - Consistency 一致性</h4><blockquote><p>A read is guaranteed to return the most recent write for a given client.<br>对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。</p></blockquote><p>​ 这里并不是强调同一时刻拥有相同的数据，对于系统执行事务来说，在事务执行过程中，系统其实处于一个不一致的状态，不同的节点的数据并不完全一致。</p><p>​ 一致性强调客户端读操作能够获取最新的写操作结果，是因为事务在执行过程中，客户端是无法读取到未提交的数据的，只有等到事务提交后，客户端才能读取到事务写入的数据，而如果事务失败则会进行回滚，客户端也不会读取到事务中间写入的数据。</p><h4 id="A-Availability-可用性"><a href="#A-Availability-可用性" class="headerlink" title="A - Availability 可用性"></a>A - Availability 可用性</h4><blockquote><p>A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout).<br>非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。</p></blockquote><p>​ 这里强调的是合理的响应，不能超时，不能出错。注意并没有说“正确”的结果，例如，应该返回 100 但实际上返回了 90，肯定是不正确的结果，但可以是一个合理的结果。</p><h4 id="P-Partition-Tolerance-分区容忍性"><a href="#P-Partition-Tolerance-分区容忍性" class="headerlink" title="P - Partition Tolerance 分区容忍性"></a>P - Partition Tolerance 分区容忍性</h4><blockquote><p>The system will continue to function when network partitions occur.<br>当出现<strong>网络分区</strong>后，系统能够继续“履行职责”。</p></blockquote><p>这里<strong>网络分区</strong>是指：<br>一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障（节点间网络连接断开、节点宕机），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中。</p><h3 id="一致性、可用性、分区容忍性的选择"><a href="#一致性、可用性、分区容忍性的选择" class="headerlink" title="一致性、可用性、分区容忍性的选择"></a>一致性、可用性、分区容忍性的选择</h3><p>​ 虽然 CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来思考，我们会发现必须选择 P（分区容忍）要素，因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象。</p><p>​ 如果我们选择了 CA（一致性 + 可用性） 而放弃了 P（分区容忍性），那么当发生分区现象时，为了保证 C（一致性），系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A(可用性) 冲突了，因为 A（可用性）要求返回 no error 和 no timeout。</p><p>因此，分布式系统理论上不可能选择 CA （一致性 + 可用性）架构，<strong>只能选择 CP（一致性 + 分区容忍性） 或者 AP （可用性 + 分区容忍性）架构，在一致性和可用性做折中选择</strong>。</p><p><strong>CP - Consistency + Partition Tolerance （一致性 + 分区容忍性）</strong></p><p><img src="../images/transaction06.png" alt></p><p>​ 如上图所示，因为Node1节点和Node2节点连接中断导致分区现象，Node1节点的数据已经更新到y，但是Node1 和 Node2 之间的复制通道中断，数据 y 无法同步到 Node2，Node2 节点上的数据还是旧数据x。</p><p>​ 这时客户端C 访问 Node2 时，Node2 需要返回 Error，提示客户端 “系统现在发生了错误”，这种处理方式违<br>背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。</p><p><strong>AP - Availability + Partition Tolerance （可用性 + 分区容忍性）</strong></p><p><img src="../images/transaction07.png" alt></p><p>​ 同样是Node2 节点上的数据还是旧数据x，这时客户端C 访问 Node2 时，Node2 将当前自己拥有的数据 x 返回给客户端 了，而实际上当前最新的数据已经是 y 了，这就不满足一致性（Consistency）的要求了，因此 CAP 三者只能满足 AP。</p><p>​ <strong>注意</strong>：这里 Node2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据。</p><p>​ 值得补充的是，CAP理论告诉我们<strong>分布式系统只能选择AP或者CP</strong>，但实际上并不是说整个系统只能选择AP或者CP，在 CAP 理论落地实践时，我们需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（CP 还是 AP），而不是直接限定整个系统所有数据都是同一策略。</p><p>​ 另外，只能选择CP或者AP是指系统发生分区现象时无法同时保证C（一致性）和A（可用性），但不是意味着什么都不做，当分区故障解决后，系统还是要保持保证CA。</p><h3 id="CAP理论的延伸——BASE理论"><a href="#CAP理论的延伸——BASE理论" class="headerlink" title="CAP理论的延伸——BASE理论"></a>CAP理论的延伸——BASE理论</h3><p><img src="../images/transaction08.png" alt></p><p>​ BASE 是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。</p><h4 id="BA-Basically-Available-基本可用"><a href="#BA-Basically-Available-基本可用" class="headerlink" title="BA - Basically Available 基本可用"></a>BA - Basically Available 基本可用</h4><blockquote><p>分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。</p></blockquote><p>​ 这里的关键词是“<strong>部分</strong>”和“<strong>核心</strong>”，实际实践上，哪些是核心需要根据具体业务来权衡。例如登录功能相对注册功能更加核心，注册不了最多影响流失一部分用户，如果用户已经注册但无法登录，那就意味用户无法使用系统，造成的影响范围更大。</p><h4 id="S-Soft-State-软状态"><a href="#S-Soft-State-软状态" class="headerlink" title="S - Soft State  软状态"></a>S - Soft State 软状态</h4><p>​ 允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。</p><h4 id="E-Eventual-Consistency-最终一致性"><a href="#E-Eventual-Consistency-最终一致性" class="headerlink" title="E - Eventual Consistency 最终一致性"></a>E - Eventual Consistency 最终一致性</h4><blockquote><p>系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。</p></blockquote><p>​ 这里的关键词是“一定时间” 和 “最终”，“<strong>一定时间</strong>”和数据的特性是强关联的，不同业务不同数据能够容忍的不一致时间是不同的。例如支付类业务是要求秒级别内达到一致，因为用户时时关注；用户发的最新微博，可以容忍30分钟内达到一致的状态，因为用户短时间看不到明星发的微博是无感知的。而“<strong>最终</strong>”的含义就是不管多长时间，最终还是要达到一致性的状态。</p><p>BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充：</p><ul><li><p><strong>CP 理论是忽略延时的，而实际应用中延时是无法避免的。</strong></p><pre><code>这一点就意味着完美的 CP 场景是不存在的，即使是几毫秒的数据复制延迟，在这几毫秒时间间隔内，系统是不符合 CP 要求的。因此 CAP 中的 CP 方案，实际上也是实现了最终一致性，只是“一定时间”是指几毫秒而已。</code></pre></li><li><p><strong>AP 方案中牺牲一致性只是指发生分区故障期间，而不是永远放弃一致性。</strong></p><pre><code>这一点其实就是 BASE 理论延伸的地方，分区期间牺牲一致性，但分区故障恢复后，系统应该达到最终一致性。</code></pre></li></ul><h3 id="数据一致性模型"><a href="#数据一致性模型" class="headerlink" title="数据一致性模型"></a>数据一致性模型</h3><blockquote><p>前面介绍的BASE模型提过“强一致性”和“最终一致性”，下面对这些一致性模型展开介绍。</p></blockquote><p>​ 分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器上，由于维护数据副本的一致性代价很高，因此许多系统采用弱一致性来提高性能，下面介绍常见的一致性模型：</p><h4 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h4><pre><code>要求无论更新操作是在哪个数据副本上执行，之后所有的读操作都要能获得最新的数据。对于单副本数据来说，读写操作是在同一数据上执行的，容易保证强一致性。对多副本数据来说，则需要使用分布式事务协议。</code></pre><h4 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h4><pre><code>在这种一致性下，用户读到某一操作对系统特定数据的更新需要一段时间，我们将这段时间称为&quot;不一致性窗口&quot;。</code></pre><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>​ 是弱一致性的一种特例，在这种一致性下系统保证用户最终能够读取到某操作对系统特定数据的更新（读取操作之前没有该数据的其他更新操作）。”不一致性窗口”的大小依赖于交互延迟、系统的负载，以及数据的副本数等。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​ 系统选择哪种一致性模型取决于应用对一致性的需求，所选取的一致性模型还会影响到系统如何处理用户的请求以及对副本维护技术的选择等。后面将基于上面介绍的一致性模型分别介绍分布式事务的解决方案。</p><h3 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h3><h4 id="柔性事务的概念"><a href="#柔性事务的概念" class="headerlink" title="柔性事务的概念"></a>柔性事务的概念</h4><p>​ 在电商等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于CAP理论以及BASE理论，有人就提出了<strong>柔性事务</strong>的概念。</p><p>​ 基于BASE理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。<strong>并不是完全放弃了ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐</strong>。</p><h4 id="实现柔性事务的一些特性"><a href="#实现柔性事务的一些特性" class="headerlink" title="实现柔性事务的一些特性"></a>实现柔性事务的一些特性</h4><blockquote><p>下面介绍的是实现柔性事务的一些常见特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样。</p></blockquote><h5 id="可见性-对外可查询"><a href="#可见性-对外可查询" class="headerlink" title="可见性(对外可查询)"></a>可见性(对外可查询)</h5><p>​ 在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。</p><p>​ 为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。</p><h5 id="操作幂等性"><a href="#操作幂等性" class="headerlink" title="操作幂等性"></a>操作幂等性</h5><p>​ 幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。</p><p>​ 之所以需要操作幂等性，是因为为了保证数据的最终一致性，很多事务协议都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。</p><h3 id="常见分布式事务解决方案"><a href="#常见分布式事务解决方案" class="headerlink" title="常见分布式事务解决方案"></a>常见分布式事务解决方案</h3><p>​ 介绍完分布式系统的一致性相关理论，下面基于不同的一致性模型介绍分布式事务的常见解决方案，后面会再介绍各个方案的使用场景。</p><p>​ 分布式事务的实现有许多种，其中较经典是由Tuxedo提出的XA分布式事务协议，XA协议包含二阶段提交（2PC）和三阶段提交（3PC）两种实现。</p></div><div class="reward" ontouchstart><div class="reward-wrap">赏<div class="reward-box"><span class="reward-type"><img class="alipay" src="./img/alipay.jpg"><b>支付宝打赏</b> </span><span class="reward-type"><img class="wechat" src="./img/wechatpay.png"><b>微信打赏</b></span></div></div><p class="reward-tip">赞赏是不耍流氓的鼓励</p></div><div class="post-footer"><div>转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">Snippet</a></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="java多线程基础-02.html" class="pre-post btn btn-default" title="认识Java里的线程"><i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span> <span class="hidden-xs">认识Java里的线程</span> </a><a href="java多线程基础-01.html" class="next-post btn btn-default" title="java多线程概述"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">java多线程概述</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NTg2Ny8yMjM3OA"><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></main><aside id="article-toc" role="navigation" class="col-md-4"><div class="widget"><h3 class="title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA中的分布式事务01-简介"><span class="toc-text">JAVA中的分布式事务01-简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#事务的具体定义"><span class="toc-text">事务的具体定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库本地事务"><span class="toc-text">数据库本地事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#A-原子性-Atomicity"><span class="toc-text">A:原子性(Atomicity)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#C-一致性-Consistency"><span class="toc-text">C:一致性(Consistency)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#I-隔离性-Isolation"><span class="toc-text">I:隔离性(Isolation)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#D-持久性-Durability"><span class="toc-text">D:持久性(Durability)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候使用数据库事务"><span class="toc-text">什么时候使用数据库事务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是分布式事务"><span class="toc-text">什么是分布式事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式产生背景与概念"><span class="toc-text">分布式产生背景与概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式事务的难点"><span class="toc-text">分布式事务的难点</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#事务的原子性"><span class="toc-text">事务的原子性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事务的一致性"><span class="toc-text">事务的一致性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#事务的隔离性"><span class="toc-text">事务的隔离性</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#分布式系统的一致性"><span class="toc-text">分布式系统的一致性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#可用性和一致性的冲突-——-CAP理论"><span class="toc-text">可用性和一致性的冲突 —— CAP理论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP理论的定义"><span class="toc-text">CAP理论的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#C-Consistency-一致性"><span class="toc-text">C - Consistency 一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#A-Availability-可用性"><span class="toc-text">A - Availability 可用性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#P-Partition-Tolerance-分区容忍性"><span class="toc-text">P - Partition Tolerance 分区容忍性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#一致性、可用性、分区容忍性的选择"><span class="toc-text">一致性、可用性、分区容忍性的选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CAP理论的延伸——BASE理论"><span class="toc-text">CAP理论的延伸——BASE理论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#BA-Basically-Available-基本可用"><span class="toc-text">BA - Basically Available 基本可用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#S-Soft-State-软状态"><span class="toc-text">S - Soft State 软状态</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#E-Eventual-Consistency-最终一致性"><span class="toc-text">E - Eventual Consistency 最终一致性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据一致性模型"><span class="toc-text">数据一致性模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#强一致性"><span class="toc-text">强一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#弱一致性"><span class="toc-text">弱一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#最终一致性"><span class="toc-text">最终一致性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#柔性事务"><span class="toc-text">柔性事务</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#柔性事务的概念"><span class="toc-text">柔性事务的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实现柔性事务的一些特性"><span class="toc-text">实现柔性事务的一些特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#可见性-对外可查询"><span class="toc-text">可见性(对外可查询)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#操作幂等性"><span class="toc-text">操作幂等性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常见分布式事务解决方案"><span class="toc-text">常见分布式事务解决方案</span></a></li></ol></li></ol></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi">访问量: <strong id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i> </strong>&nbsp; | &nbsp; 访客数: <strong id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></strong></div></div><div class="col-sm-12"><span>Copyright &copy; 2019 </span>| <span>Powered by <a href="//baiyp.ren" class="copyright-links" target="_blank" rel="nofollow">baiyp</a></span></div></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="js/app.js?rev=@@hash"></script></body><!-- rebuild by neat -->