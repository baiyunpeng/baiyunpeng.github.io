<!-- build time:Sat Sep 21 2019 18:23:55 GMT+0800 (GMT+08:00) --><!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><title>HashMap实现原理 | 晓风残月的博客</title><meta name="keywords" content="集合,HashMap,实现原理, java,多线程,高并发,架构"><meta name="description" content="HashMap实现原理, 个人技术的一些积累"><link rel="alternate" href="atom.xml" title="晓风残月的博客"><meta name="HandheldFriendly" content="True"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.10.1/css/all.min.css"><link rel="shortcut icon" type="image/x-icon" href="/images/website/favicon.ico"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9.2/css/style.css"><script>function setLoadingBarProgress(e){document.getElementById("loading-bar").style.width=e+"%"}</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a475efbbf07ecf405a82aa9bd596d186";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head><body><header class="l_header pure"><div id="loading-bar-wrapper"><div id="loading-bar" class="pure"></div></div><div class="wrapper"><div class="nav-main container container--flex"><a class="logo flat-box" href="index.html">晓风残月的博客</a><div class="menu navgation"><ul class="h-list"><li><a class="nav flat-box" href="index.html" id="index.html"><i class="fas fa-newspaper fa-fw"></i>&nbsp;博文</a></li><li><a class="nav flat-box" href="categories/" rel="nofollow" id="categories"><i class="fas fa-grip-horizontal fa-fw"></i>&nbsp;分类</a></li><li><a class="nav flat-box" href="tags/" rel="nofollow" id="tags"><i class="fas fa-tags fa-fw"></i>&nbsp;标签</a></li><li><a class="nav flat-box" href="archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw"></i>&nbsp;归档</a></li></ul></div><div class="m_search"><form name="searchform" class="form u-search-form"><input type="text" class="input u-search-input" placeholder="搜索"> <i class="icon fas fa-search fa-fw"></i></form></div><ul class="switcher h-list"><li class="s-search"><a class="fas fa-search fa-fw" href="javascript:void(0)"></a></li><li class="s-menu"><a class="fas fa-bars fa-fw" href="javascript:void(0)"></a></li></ul></div><div class="nav-sub container container--flex"><a class="logo flat-box"></a><ul class="switcher h-list"><li class="s-comment"><a class="flat-btn fas fa-comments fa-fw" href="javascript:void(0)"></a></li><li class="s-toc"><a class="flat-btn fas fa-list fa-fw" href="javascript:void(0)"></a></li></ul></div></div></header><aside class="menu-phone"><header><nav class="menu navgation"><ul><li><a class="nav flat-box" href="index.html" id="index.html"><i class="fas fa-clock fa-fw"></i>&nbsp;近期文章</a></li><li><a class="nav flat-box" href="archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw"></i>&nbsp;文章归档</a></li><li><a class="nav flat-box" href="categories/" id="categories"><i class="fas fa-grip-horizontal fa-fw"></i>&nbsp;文章分类</a></li><li><a class="nav flat-box" href="/friends.html" rel="nofollow" id="friends.html"><i class="fas fa-link fa-fw"></i>&nbsp;我的友链</a></li><li><a class="nav flat-box" href="/about.html" rel="nofollow" id="about.html"><i class="fas fa-info-circle fa-fw"></i>&nbsp;关于小站</a></li></ul></nav></header></aside><script>setLoadingBarProgress(40)</script><div class="l_body nocover"><div class="body-wrapper"><div class="l_main"><article id="post" class="post white-box article-type-post" itemscope itemprop="blogPost"><section class="meta"><div class="meta" id="header-meta"><h1 class="title"><a href>HashMap实现原理</a></h1><div class="new-meta-box"><div style="margin-top:10px"><span class="post-time"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> <span class="post-meta-item-text">字数统计：</span> <span class="post-count">6.6k字</span> </span></span><span class="post-time">&nbsp; | &nbsp; <span class="post-meta-item-icon"><i class="far fa-clock"></i> <span class="post-meta-item-text">阅读时长 ≈</span> <span class="post-count">27分</span></span></span></div></div><div class="new-meta-box"><div class="new-meta-item author"><a href="http://www.baiyp.ren" rel="nofollow"><img src="/images/website/avatar.jpg"><p>晓风残月</p></a></div><div class="new-meta-item date"><a class="notlink"><i class="fas fa-calendar-alt" aria-hidden="true"></i><p>2019-09-12</p></a></div><div class="new-meta-item category"><a href rel="nofollow"><i class="fas fa-folder-open" aria-hidden="true"></i><p>源码&nbsp;/&nbsp;HashMap</p></a></div><div class="new-meta-item browse busuanzi"><a class="notlink"><i class="fas fa-eye" aria-hidden="true"></i><p><span id="busuanzi_value_page_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span></p></a></div></div><hr></div></section><section class="article typo"><div class="article-entry" itemprop="articleBody"><h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><p><img src="../images/map/hashmap/hashmap01.png" alt></p><p>​ HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​ HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列号，序列化的时候使用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">/**默认容量，1向左移位4个，00000001变成00010000，也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。**/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//最大容量，2的30次方。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//负载因子，用于扩容使用。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">//当某个桶节点数量大于8时，会转换为红黑树。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">//存储元素的数组，transient关键字表示该属性不能被序列化</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">//将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">//元素数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//统计该map修改的次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">//临界值，也就是元素数量达到临界值时，会进行扩容。</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">//也是负载因子，只不过这个是变量。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里讲讲为什么默认容量大小为16，负载因子为0.75，主要原因是这两个常量的值都是经过大量的计算和统计得出来的最优解，仅仅是这样而已。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>HashMap提供了三个构造函数：</p><ul><li><p>HashMap()：构造一个具有默认初始容量 (16) 和默认负载因子 (0.75) 的空 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DEFAULT_LOAD_FACTOR = 0.75f</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashMap(int initialCapacity)：构造一个带指定初始容量和默负载因子 (0.75) 的空 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和负载因子的空 HashMap。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote><p>调用构造方法进行初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor      扩容因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//容量参数不合理 报错</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                   initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="comment">//扩容因子不合理报错</span></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                   loadFactor);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//初始化扩容因子</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="comment">//设置下次扩容阈值</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​ 在这里提到了两个参数：初始容量，负载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，负载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p><h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h4><blockquote><p>根据参数返回最近的2的n次幂的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//是返回大于输入参数且最近的2的整数次幂的数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//　让cap-1再赋值给n的目的是另找到的目标值大于或等于原值</span></span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种方法的效率非常高，可见Java8对容器优化了很多</p><h3 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><blockquote><p>Node是 HashMap的静态内部，HashMap主干是一个Node数组，Node是HashMap的最基本组成单位。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap 的Node 节点元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; 元素的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 元素的Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 这个节点所在位置的hash值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="comment">//这个节点的Key</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="comment">//这个节点的value</span></span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">//后继节点</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取HashCode</span></span><br><span class="line"><span class="comment">         * key和value 的hash做异或运算 防止hash冲突</span></span><br><span class="line"><span class="comment">          * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> newValue</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            <span class="comment">//替换当前node的value</span></span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="comment">//返回旧的value</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * equals 比较</span></span><br><span class="line"><span class="comment">         * 如果 key和value都一致 判断equals相等</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在jdk8之前HashMap是数组加链表的形式实现，但是在1.8之后为提高哈希冲突后链表的查询速度，当桶内链表长度超过<strong>树化阀值</strong>且总长度超过<strong>最小树化容量</strong>后会将链表转换为红黑树。</p><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><h5 id="查询与修改"><a href="#查询与修改" class="headerlink" title="查询与修改"></a>查询与修改</h5><p>先用散列函数对键进行散列，没有冲突的情况下查询是下标查询，时间复杂度是 O(1),速度很快。</p><p>存在哈希冲突的情况，需要对链表/红黑树进行遍历，equals比对查询。</p><p>性能上，考虑是链表/红黑树上的元素越是越好，越均匀越好；此外HashMap主干未必越长越好，会有用不到的桶浪费空间。</p><h5 id="增加与删除"><a href="#增加与删除" class="headerlink" title="增加与删除"></a>增加与删除</h5><p>​ 由于查询速度快，而桶里用链表/红黑树实现，所以添加和删除效率也很高。HashMap会在size超过阀值后进行调整大下(resize)，所以根据具体情况提前给HashMap一个合适的初始长度是个不错的习惯。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><blockquote><p>put方法是一个重点方法，这里有 HashMap初始化，数据在 HashMap中是如何储存的，什么情况下链表会转换为红黑树等内容，需要仔细研究。</p></blockquote><p><img src="../images/map/hashmap/hashmap03.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里继续调用putVal方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal 方法"></a>putVal 方法</h4><blockquote><p>putVal是final修饰的方法，子类 LinkedHashMap也是用的这各方法，evict（看下面的的第5个参数）就是给 LinkedHashMap使用的，HashMap中并没有什么用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * putVal 方法 真正进行插入操作的方法，</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash         传入key的哈希值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent 如果该值是true,如果存在值就不会进行修改操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict        LinekdHashMap尾操作使用，这里暂无用途</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K, V&gt;[] tab;</span><br><span class="line">       Node&lt;K, V&gt; p;</span><br><span class="line">       <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**********初始化********/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果table长度是0或table是null会调整一次大小</span></span><br><span class="line">       <span class="comment">// 这时tab会指向调整大下后的Node&lt;K,V&gt;[](主干数组)</span></span><br><span class="line">       <span class="comment">// n被赋值为新数组长度</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果没有调整大小，tab指向table</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/********开始查找键的位置，并存储value*******/</span></span><br><span class="line">       <span class="comment">// i = (n - 1) &amp; hash这个是获取key应该在哪个桶里,下面详说</span></span><br><span class="line">       <span class="comment">// 这里将p指向当前key所需要的那个桶</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果空桶，也就是无哈希冲突的情况，直接丢个Node进去。</span></span><br><span class="line">           <span class="comment">// 此时的tab就是table</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//存在冲突，开始寻找我们要找的节点</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">           Node&lt;K, V&gt; e;</span><br><span class="line">           K k;</span><br><span class="line">           <span class="comment">// 判断第一个节点是不是我们找的</span></span><br><span class="line">           <span class="comment">// 此时k储存了 p.key</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">               <span class="comment">// hash值相等，key值相等，定位完成,是修改操作</span></span><br><span class="line">               <span class="comment">// e来储存p这个节点，一会修改</span></span><br><span class="line">               e = p;</span><br><span class="line">               <span class="comment">// 判断是否是红黑树节点</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">               <span class="comment">// 是红黑树节点，存在就返回那个节点，不存在就返回null</span></span><br><span class="line">               e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">               <span class="comment">// 最终，是链表了，开始对链表遍历查找</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">// 上面知道第一个接点不是我们要的，直接获取下一个，并储存给e</span></span><br><span class="line">                   <span class="comment">// 下一个是空，直接丢个Node在这里，然后p.next指向这里</span></span><br><span class="line">                   <span class="comment">// 这里下一个节点地址给了e</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// ！大于树化阀值，开始树化</span></span><br><span class="line">                       <span class="comment">// 注意-1是因为binCount是索引而不是长度</span></span><br><span class="line">                       <span class="comment">// 其实此时链表长度已经是7+1（索引） + 1（新进来的Node）</span></span><br><span class="line">                       <span class="comment">// 已经大于树化阀值8，也就是说链表长度为8时是不会树化的</span></span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//树化</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="comment">//加进去就跳出循环了</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 下个节点有值，且是我们找的节点，跳出去</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//下一个节点不是我们找的节点继续编历</span></span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 上面说了，这有修改操作e才能不是null</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="comment">// 给e新值</span></span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 这个是LinkedHashMap用的，HashMap里是个空实现</span></span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="comment">// 修改就会把旧值返回去</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*********修改完成的后续操作**********/</span></span><br><span class="line">       <span class="comment">// 修改次数加1</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">// 如果size大于阀值，会执行resize()方法调整大小</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold) &#123;</span><br><span class="line">           resize();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 这个是给LinkedHashMap用的，HashMap里也是个空实现</span></span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="comment">// 添加成功返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash 运算</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  key是null就返回0，key不是null就先取hashCode（）</span></span><br><span class="line"><span class="comment">     *  然后与这个hashCode（）无符号右移进行亦或运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为什么要使用异或运算"><a href="#为什么要使用异或运算" class="headerlink" title="为什么要使用异或运算"></a>为什么要使用异或运算</h5><ul><li>这是因为找key的位置时，<code>(n - 1) &amp; hash</code>是table的索引，n的长度不够大时，只和hashCode()的低16位有关，这样发生冲突的概率就变高。</li><li>为减少这种影响，设计者权衡了speed, utility, and quality，将高16位与低16位异或来减少这种影响。设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，既减少了系统的开销，也不会造成的因为高16位没有参与下标的计算(table长度比较小时)而引起的碰撞。</li></ul><p><img src="../images/map/hashmap/hashmap04.jpg" alt></p><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><blockquote><p>这也是一个很重要的方法，主要包括两部分，第一部分是根据size是否超过阀值判断是否需要进行扩容，第二部分是扩容后将原Node[]中数据复制到扩容后的Node[]中</p></blockquote><p><img src="../images/map/hashmap/hashmap05.png" alt></p><h5 id="扩容的三种情况"><a href="#扩容的三种情况" class="headerlink" title="扩容的三种情况"></a>扩容的三种情况</h5><ul><li><p>使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12。</p></li><li><p>指定初始容量的构造方法初始化HashMap。那么从下面源码可以看到初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。</p></li><li><p>HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍</p></li></ul><p>这边也可以引申到一个问题就是HashMap是先插入数据再进行扩容的，但是如果是刚刚初始化容器的时候是先扩容再插入数据。</p><h5 id="扩容部分"><a href="#扩容部分" class="headerlink" title="扩容部分"></a>扩容部分</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 扩容方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">// 原容量，table为null返回0，否则返回table长度</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">//原始阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="comment">//新容量，新阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// table已经初始化，旧容量&gt;0</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 容量已经超过最大容量，直接返回去</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">               <span class="comment">// 2倍扩容后小于最大容量，并且原容量大于默认初始化容量(我还没想清楚为什么要大于默认初始容量)</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">               <span class="comment">// 阀值加倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 原数组容量为0，未初始化，但阀值不为0</span></span><br><span class="line">           <span class="comment">// 也就是构造方法里threshold = tableSizeFor(initialCapacity）这个步骤</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">           <span class="comment">// 啥都没有，默认构造</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 新数组阀值未被赋值</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 使用新的容量*负载因子计算阀值</span></span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">           <span class="comment">// 取计算后阀值和最大容量里较小的那个</span></span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br></pre></td></tr></table></figure><h5 id="复制数据部分"><a href="#复制数据部分" class="headerlink" title="复制数据部分"></a>复制数据部分</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的数组</span></span><br><span class="line">   Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">   table = newTab;</span><br><span class="line">   <span class="comment">//开始复制数据</span></span><br><span class="line">   <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//开始遍历</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">           Node&lt;K, V&gt; e;</span><br><span class="line">           <span class="comment">// 获取桶的第一个节点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//没有后继节点，说明为空，直接移过去</span></span><br><span class="line">               <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//如果是红黑树，分裂放入新数组</span></span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                   ((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">//链表操作在下面</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                   <span class="comment">// 不是直接进行计算元素在新数组中的位置，而是原位置加原数组长度</span></span><br><span class="line">                   Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K, V&gt; next;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="comment">// 把链表下一个节点放在 next里</span></span><br><span class="line">                       next = e.next;</span><br><span class="line">                       <span class="comment">// 该节点不需要移动</span></span><br><span class="line">                       <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">// 尾元素为空，说明链表为空，确定为首元素</span></span><br><span class="line">                           <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               loHead = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 尾元素有就将元素放进尾元素的后继节点</span></span><br><span class="line">                               loTail.next = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 确定尾元素</span></span><br><span class="line">                           loTail = e;</span><br><span class="line">                           <span class="comment">// 该节点需要移动</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">// 尾元素为空，说明链表为空，确定为首元素</span></span><br><span class="line">                           <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               hiHead = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 尾元素有就将元素放进尾元素的后继节点</span></span><br><span class="line">                               hiTail.next = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 确定尾元素</span></span><br><span class="line">                           hiTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//直到遍历完链表跳出</span></span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                   <span class="comment">// 把两个首元素放在两个桶里就可以了</span></span><br><span class="line">                   <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j] = loHead;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j + oldCap] = hiHead;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回新的数组</span></span><br><span class="line">   <span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure><p>复制过程，a过去，假设计算后位置不边，进到i,此时i为null，a进去后即是head，又是tail</p><p>然后循环，到b，假设计算后还是i，i中已经有a，所以b直接丢到a后面，a任是head,单tail已经变成了b</p><p>以此类推，a,b,c,d都会放在i,j中</p><p>其实是先拼完链表才装进桶里的，这里只是方便描述，说成是一个一个过去</p><p>至此，put方法已经说完了，重点是putVal,hash和resize三个方法。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p><img src="../images/map/hashmap/hashmap06.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定的key映射的value，如果value为null，则返回null</span></span><br><span class="line"><span class="comment">     * get可以分为三个步骤：</span></span><br><span class="line"><span class="comment">     * 1.通过hash(Object key)方法计算key的哈希值hash。</span></span><br><span class="line"><span class="comment">     * 2.通过getNode( int hash, Object key)方法获取node。</span></span><br><span class="line"><span class="comment">     * 3.如果node为null，返回null，否则返回node.value。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        <span class="comment">//根据key及其hash值查询node节点，如果存在，则返回该节点的value值</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其最终是调用了 <code>getNode</code> 函数。 其逻辑如下</p><h4 id="getNode方法"><a href="#getNode方法" class="headerlink" title="getNode方法"></a>getNode方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getNode 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 指定参数key的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  指定参数的 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回node，如果没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; first, e;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空，而且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点就和指定参数hash和key匹配上了</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">//返回第一个元素</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点没有匹配上，而且有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                <span class="comment">//如果当前的桶采用红黑树，则调用红黑树的get方法去获取节点</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前的桶不采用红黑树，即桶中节点结构为链式结构</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//匹配上key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    <span class="comment">//返回节点</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历元素直到 没有后继节点</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到 返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><blockquote><p>remove就是先找到节点位置，然后移除,核心方法是removeNode()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 所要删除元素的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除Node节点</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash       要删除元素的hash</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key        删除元素的key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value      remove方法重载时使用，只有同时匹配key-value时移除该节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> matchValue 为true时才会同时匹配key-value进行删除</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> movable    删除节点后是否改变红黑树的结构，般都为true只有在iterator的时候才为false</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*******查找节点的部分*******/</span></span><br><span class="line"></span><br><span class="line">     Node&lt;K, V&gt;[] tab;</span><br><span class="line">     Node&lt;K, V&gt; p;</span><br><span class="line">     <span class="keyword">int</span> n, index;</span><br><span class="line">     <span class="comment">// 1.原数组不为null</span></span><br><span class="line">     <span class="comment">// 2. 原数组长度大于0</span></span><br><span class="line">     <span class="comment">// 3.key数组中的位置不为空</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 声明两个节点node，e</span></span><br><span class="line">         Node&lt;K, V&gt; node = <span class="keyword">null</span>, e;</span><br><span class="line">         K k;</span><br><span class="line">         V v;</span><br><span class="line">         <span class="comment">// 第一个节点就我们要找的节点</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">             <span class="comment">// 先给node，在下面删掉</span></span><br><span class="line">             node = p;</span><br><span class="line">             <span class="comment">//如果第一个不是则向后查找</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果是红黑树，获取该接点并给node</span></span><br><span class="line">             <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">do</span> &#123;</span><br><span class="line">                     <span class="comment">// 如果是要找的节点就把这个节点给node</span></span><br><span class="line">                     <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                         node = e;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 不是把节点给p记录</span></span><br><span class="line">                     p = e;</span><br><span class="line">                     <span class="comment">//遍历节点一直到没有后继节点</span></span><br><span class="line">                 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/**********删除节点的部分*********/</span></span><br><span class="line">         <span class="comment">//节点不为空</span></span><br><span class="line">         <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">             <span class="comment">// 如果是红黑树节点，使用removeTreeNode移除</span></span><br><span class="line">             <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                 ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                 <span class="comment">// 这里执行的就是上面的第一种情况，桶里的第一个节点就是要移除的</span></span><br><span class="line">                 tab[index] = node.next;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 直接将移除的上个节点指向下一个节点</span></span><br><span class="line">                 p.next = node.next;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 修改次数再加1</span></span><br><span class="line">             ++modCount;</span><br><span class="line">             <span class="comment">// 长度 -1</span></span><br><span class="line">             --size;</span><br><span class="line">             <span class="comment">// 给LinkedList使用，这里没啥用</span></span><br><span class="line">             afterNodeRemoval(node);</span><br><span class="line">             <span class="comment">// 删除的值返回去</span></span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 根本没有这个</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p><p>1.什么时候会使用HashMap？他有什么特点？</p><blockquote><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p></blockquote><p>2.你知道HashMap的工作原理吗？</p><blockquote><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p></blockquote><p>3.你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</p><blockquote><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p></blockquote><p>4.你知道hash的实现吗？为什么要这样实现？</p><blockquote><p>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p></blockquote><p>5.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p><blockquote><p>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。<br>关于Java集合的小抄中是这样描述的：<br>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。<br>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。<br>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。<br>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。<br>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。<br>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p></blockquote><p>6.当两个对象的hashcode相同会发生什么？</p><blockquote><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p></blockquote><p>7.如果两个键的hashcode相同，你如何获取值对象？</p><blockquote><p>找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。因此，设计HashMap的key类型时，如果使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择</p></blockquote><p>8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p><blockquote><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置</p></blockquote><p>9.你了解重新调整HashMap大小存在什么问题吗？</p><blockquote><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。因此在并发环境下，我们使用CurrentHashMap来替代HashMap</p></blockquote><p>10.为什么String, Interger这样的wrapper类适合作为键？</p><blockquote><p>因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能</p></blockquote></div><section class="meta" id="footer-meta"><hr><div class="new-meta-box"><div class="new-meta-item date" itemprop="dateUpdated" datetime="2019-09-15T16:47:34+08:00"><a class="notlink"><i class="fas fa-clock" aria-hidden="true"></i><p>更新于 2019年9月15日</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="tags/源码/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>源码</p></a></div><div class="new-meta-item meta-tags"><a class="tag" href="tags/HashMap/" rel="nofollow"><i class="fas fa-hashtag" aria-hidden="true"></i>&nbsp;<p>HashMap</p></a></div><div class="new-meta-item share -mob-share-list"><div class="-mob-share-list share-body"><a class="-mob-share-qq" title="QQ好友" rel="external nofollow noopener noreferrer" href="http://connect.qq.com/widget/shareqq/index.html?url=http://www.baiyp.ren/HashMap实现原理.html&title=HashMap实现原理 | 晓风残月的博客&pics=/images/website/avatar.jpg&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qq.png"> </a><a class="-mob-share-qzone" title="QQ空间" rel="external nofollow noopener noreferrer" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.baiyp.ren/HashMap实现原理.html&title=HashMap实现原理 | 晓风残月的博客&pics=/images/website/avatar.jpg&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/qzone.png"> </a><a class="-mob-share-weibo" title="微博" rel="external nofollow noopener noreferrer" href="http://service.weibo.com/share/share.php?url=http://www.baiyp.ren/HashMap实现原理.html&title=HashMap实现原理 | 晓风残月的博客&pics=/images/website/avatar.jpg&summary=" target="_blank"><img src="https://cdn.jsdelivr.net/gh/xaoxuu/assets@19.1.9/logo/128/weibo.png"></a></div></div></div></section><div class="prev-next"><section class="prev"><span class="art-item-left"><h6><i class="fas fa-chevron-left" aria-hidden="true"></i>&nbsp;上一页</h6><h4><a href="MYBATIS源码解析-04反射模块01.html" rel="prev" title="MYBATIS源码解析-反射模块01">MYBATIS源码解析-反射模块01</a></h4><h6 class="tags"><a class="tag" href="tags/mybatis/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>mybatis</a> <a class="tag" href="tags/源码/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>源码</a> <a class="tag" href="tags/反射模块/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>反射模块</a></h6></span></section><section class="next"><span class="art-item-right" aria-hidden="true"><h6>下一页&nbsp;<i class="fas fa-chevron-right" aria-hidden="true"></i></h6><h4><a href="JVM垃圾回收机制.html" rel="prev" title="JVM垃圾回收机制">JVM垃圾回收机制</a></h4><h6 class="tags"><a class="tag" href="tags/jvm/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>jvm</a> <a class="tag" href="tags/垃圾回收/"><i class="fas fa-hashtag fa-fw" aria-hidden="true"></i>垃圾回收</a></h6></span></section></div></section></article><article class="post white-box comments"><section class="article typo"><h4><i class="fas fa-comments fa-fw" aria-hidden="true"></i>&nbsp;评论</h4><section id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NTg2Ny8yMjM3OA"><noscript><div><i class="fas fa-exclamation-triangle">&nbsp;无法加载Livere评论系统，请确保您的网络能够正常访问。</i></div></noscript></div></section></section></article><script>window.subData={title:"HashMap实现原理",tools:!0}</script></div><aside class="l_side"><section class="widget author"><div class="content pure"><div class="avatar"><img class="avatar" src="../../images/website/avatar.jpg"></div><div class="text"><p><span id="jinrishici-sentence">柳暗花明又一村</span></p><script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script></div><div class="social-wrapper"><a href="atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:baiyunpeng42@126.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/baiyunpeng" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=1973042285" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div></div></section><section class="widget plain"><header class="pure"><div><i class="fa fa-book-open fa-fw fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;格言</div></header><div class="content pure"><p>日拱一卒无有尽,功不唐捐终入海</p></div></section><section class="widget toc-wrapper"><header class="pure"><div><i class="fas fa-list fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;本文目录</div><div class="wrapper"><a class="s-toc rightBtn" rel="external nofollow noopener noreferrer" href="javascript:void(0)"><i class="fas fa-thumbtack fa-fw"></i></a></div></header><div class="content pure"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap实现原理"><span class="toc-text">HashMap实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#定义"><span class="toc-text">定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#初始化"><span class="toc-text">初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#tableSizeFor"><span class="toc-text">tableSizeFor</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部数据结构"><span class="toc-text">内部数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Node"><span class="toc-text">Node</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#速度"><span class="toc-text">速度</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#查询与修改"><span class="toc-text">查询与修改</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#增加与删除"><span class="toc-text">增加与删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#put方法"><span class="toc-text">put方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#putVal-方法"><span class="toc-text">putVal 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#hash-方法"><span class="toc-text">hash 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#为什么要使用异或运算"><span class="toc-text">为什么要使用异或运算</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#resize方法"><span class="toc-text">resize方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#扩容的三种情况"><span class="toc-text">扩容的三种情况</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#扩容部分"><span class="toc-text">扩容部分</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#复制数据部分"><span class="toc-text">复制数据部分</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get方法"><span class="toc-text">get方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#getNode方法"><span class="toc-text">getNode方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-方法"><span class="toc-text">remove 方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#removeNode"><span class="toc-text">removeNode</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol></li></ol></div></section><section class="widget plain"><header class="pure"><div><i class="fa fa-bullhorn fa-fw fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;公告</div></header><div class="content pure"><p>自己记录和梳理下架构的知识，从高并发开始。</p></div></section><section class="widget grid"><header class="pure"><div><i class="fas fa-map-signs fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;站内导航</div></header><div class="content pure"><ul class="grid navgation"><li><a class="flat-box" title="index.html" href="index.html" id="index.html"><i class="fas fa-clock fa-fw" aria-hidden="true"></i> 近期文章</a></li><li><a class="flat-box" title="archives/" href="archives/" rel="nofollow" id="archives"><i class="fas fa-archive fa-fw" aria-hidden="true"></i> 文章归档</a></li><li><a class="flat-box" title="categories/" href="categories/" id="categories"><i class="fas fa-grip-horizontal fa-fw" aria-hidden="true"></i> 文章分类</a></li><li><a class="flat-box" title="categories/" href="categories/" id="categories"><i class="fas fa-book fa-fw fa-fw" aria-hidden="true"></i> 专题文章</a></li><li><a class="flat-box" title="/friends.html" href="/friends.html" rel="nofollow" id="friends.html"><i class="fas fa-link fa-fw" aria-hidden="true"></i> 我的友链</a></li><li><a class="flat-box" title="/about.html" href="/about.html" rel="nofollow" id="about.html"><i class="fas fa-info-circle fa-fw" aria-hidden="true"></i> 关于小站</a></li></ul></div></section><section class="widget category"><header class="pure"><div><i class="fas fa-folder-open fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;文章分类</div><a class="rightBtn" rel="nofollow" href="categories/" title="categories/"><i class="fas fa-expand-arrows-alt fa-fw"></i></a></header><div class="content pure"><ul class="entry"><li><a class="flat-box" title="categories/jvm/" href="categories/jvm/"><div class="name">jvm</div><div class="badge">(8)</div></a></li><li><a class="flat-box child" title="categories/jvm/内存结构/" href="categories/jvm/内存结构/"><div class="name">内存结构</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/jvm/垃圾回收/" href="categories/jvm/垃圾回收/"><div class="name">垃圾回收</div><div class="badge">(2)</div></a></li><li><a class="flat-box child" title="categories/jvm/对象分配/" href="categories/jvm/对象分配/"><div class="name">对象分配</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/jvm/指令/" href="categories/jvm/指令/"><div class="name">指令</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/jvm/运行时数据区/" href="categories/jvm/运行时数据区/"><div class="name">运行时数据区</div><div class="badge">(3)</div></a></li><li><a class="flat-box" title="categories/lambda/" href="categories/lambda/"><div class="name">lambda</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="categories/mybatis/" href="categories/mybatis/"><div class="name">mybatis</div><div class="badge">(10)</div></a></li><li><a class="flat-box child" title="categories/mybatis/源码/" href="categories/mybatis/源码/"><div class="name">源码</div><div class="badge">(9)</div></a></li><li><a class="flat-box child" title="categories/mybatis/源码/代理封装/" href="categories/mybatis/源码/代理封装/"><div class="name">代理封装</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/mybatis/源码/初始化流程/" href="categories/mybatis/源码/初始化流程/"><div class="name">初始化流程</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/mybatis/源码/反射模块/" href="categories/mybatis/源码/反射模块/"><div class="name">反射模块</div><div class="badge">(4)</div></a></li><li><a class="flat-box child" title="categories/mybatis/源码/数据库连接池/" href="categories/mybatis/源码/数据库连接池/"><div class="name">数据库连接池</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/mybatis/源码/日志/" href="categories/mybatis/源码/日志/"><div class="name">日志</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/mybatis/源码/缓存模块/" href="categories/mybatis/源码/缓存模块/"><div class="name">缓存模块</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="categories/代码片段/" href="categories/代码片段/"><div class="name">代码片段</div><div class="badge">(2)</div></a></li><li><a class="flat-box" title="categories/加密/" href="categories/加密/"><div class="name">加密</div><div class="badge">(4)</div></a></li><li><a class="flat-box" title="categories/并发/" href="categories/并发/"><div class="name">并发</div><div class="badge">(27)</div></a></li><li><a class="flat-box child" title="categories/并发/ThreadLocal/" href="categories/并发/ThreadLocal/"><div class="name">ThreadLocal</div><div class="badge">(2)</div></a></li><li><a class="flat-box child" title="categories/并发/final/" href="categories/并发/final/"><div class="name">final</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/synchronized/" href="categories/并发/synchronized/"><div class="name">synchronized</div><div class="badge">(2)</div></a></li><li><a class="flat-box child" title="categories/并发/volatile/" href="categories/并发/volatile/"><div class="name">volatile</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/伪共享/" href="categories/并发/伪共享/"><div class="name">伪共享</div><div class="badge">(2)</div></a></li><li><a class="flat-box child" title="categories/并发/多线程基础/" href="categories/并发/多线程基础/"><div class="name">多线程基础</div><div class="badge">(5)</div></a></li><li><a class="flat-box child" title="categories/并发/工具类/" href="categories/并发/工具类/"><div class="name">工具类</div><div class="badge">(6)</div></a></li><li><a class="flat-box child" title="categories/并发/并发安全/" href="categories/并发/并发安全/"><div class="name">并发安全</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/死锁/" href="categories/并发/死锁/"><div class="name">死锁</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/线程安全/" href="categories/并发/线程安全/"><div class="name">线程安全</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/面试题/" href="categories/并发/面试题/"><div class="name">面试题</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/高级/" href="categories/并发/高级/"><div class="name">高级</div><div class="badge">(4)</div></a></li><li><a class="flat-box child" title="categories/并发/高级/CAS/" href="categories/并发/高级/CAS/"><div class="name">CAS</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/高级/显示锁/" href="categories/并发/高级/显示锁/"><div class="name">显示锁</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/高级/读写锁/" href="categories/并发/高级/读写锁/"><div class="name">读写锁</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/并发/高级/队列锁/" href="categories/并发/高级/队列锁/"><div class="name">队列锁</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="categories/架构/" href="categories/架构/"><div class="name">架构</div><div class="badge">(13)</div></a></li><li><a class="flat-box child" title="categories/架构/apollo/" href="categories/架构/apollo/"><div class="name">apollo</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/架构/git/" href="categories/架构/git/"><div class="name">git</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/架构/分布式事务/" href="categories/架构/分布式事务/"><div class="name">分布式事务</div><div class="badge">(8)</div></a></li><li><a class="flat-box child" title="categories/架构/动态追踪/" href="categories/架构/动态追踪/"><div class="name">动态追踪</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/架构/布隆过滤器/" href="categories/架构/布隆过滤器/"><div class="name">布隆过滤器</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/架构/装逼/" href="categories/架构/装逼/"><div class="name">装逼</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="categories/流式计算/" href="categories/流式计算/"><div class="name">流式计算</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/流式计算/stream/" href="categories/流式计算/stream/"><div class="name">stream</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="categories/源码/" href="categories/源码/"><div class="name">源码</div><div class="badge">(11)</div></a></li><li><a class="flat-box child" title="categories/源码/HashMap/" href="categories/源码/HashMap/"><div class="name">HashMap</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/源码/ThreadLocal/" href="categories/源码/ThreadLocal/"><div class="name">ThreadLocal</div><div class="badge">(2)</div></a></li><li><a class="flat-box child" title="categories/源码/动态代理/" href="categories/源码/动态代理/"><div class="name">动态代理</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/源码/并发/" href="categories/源码/并发/"><div class="name">并发</div><div class="badge">(3)</div></a></li><li><a class="flat-box child" title="categories/源码/并发/高级/" href="categories/源码/并发/高级/"><div class="name">高级</div><div class="badge">(3)</div></a></li><li><a class="flat-box child" title="categories/源码/并发/高级/AQS/" href="categories/源码/并发/高级/AQS/"><div class="name">AQS</div><div class="badge">(3)</div></a></li><li><a class="flat-box child" title="categories/源码/线程池/" href="categories/源码/线程池/"><div class="name">线程池</div><div class="badge">(3)</div></a></li><li><a class="flat-box child" title="categories/源码/阻塞队列/" href="categories/源码/阻塞队列/"><div class="name">阻塞队列</div><div class="badge">(1)</div></a></li><li><a class="flat-box" title="categories/设计模式/" href="categories/设计模式/"><div class="name">设计模式</div><div class="badge">(10)</div></a></li><li><a class="flat-box child" title="categories/设计模式/代理模式/" href="categories/设计模式/代理模式/"><div class="name">代理模式</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/单例模式/" href="categories/设计模式/单例模式/"><div class="name">单例模式</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/工厂模式/" href="categories/设计模式/工厂模式/"><div class="name">工厂模式</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/建造者模式/" href="categories/设计模式/建造者模式/"><div class="name">建造者模式</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/模板模式/" href="categories/设计模式/模板模式/"><div class="name">模板模式</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/装饰器模式/" href="categories/设计模式/装饰器模式/"><div class="name">装饰器模式</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/观察者模式/" href="categories/设计模式/观察者模式/"><div class="name">观察者模式</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/设计原则/" href="categories/设计模式/设计原则/"><div class="name">设计原则</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/责任链模式/" href="categories/设计模式/责任链模式/"><div class="name">责任链模式</div><div class="badge">(1)</div></a></li><li><a class="flat-box child" title="categories/设计模式/适配器模式/" href="categories/设计模式/适配器模式/"><div class="name">适配器模式</div><div class="badge">(1)</div></a></li></ul></div></section><section class="widget tagcloud"><header class="pure"><div><i class="fas fa-fire fa-fw" aria-hidden="true"></i>&nbsp;&nbsp;热门标签</div><a class="rightBtn" rel="nofollow" href="tags/" title="tags/"><i class="fas fa-expand-arrows-alt fa-fw"></i></a></header><div class="content pure"><a href="tags/2PC/" style="font-size:14px;color:#999">2PC</a> <a href="tags/3PC/" style="font-size:14px;color:#999">3PC</a> <a href="tags/AQS/" style="font-size:15.82px;color:#8d8d8d">AQS</a> <a href="tags/ArrayBlockingQueue/" style="font-size:14px;color:#999">ArrayBlockingQueue</a> <a href="tags/BloomFilter/" style="font-size:14px;color:#999">BloomFilter</a> <a href="tags/CAS/" style="font-size:14px;color:#999">CAS</a> <a href="tags/HashMap/" style="font-size:14px;color:#999">HashMap</a> <a href="tags/JsonValidator/" style="font-size:14px;color:#999">JsonValidator</a> <a href="tags/MQ/" style="font-size:14px;color:#999">MQ</a> <a href="tags/Saga/" style="font-size:14px;color:#999">Saga</a> <a href="tags/TCC/" style="font-size:14px;color:#999">TCC</a> <a href="tags/ThreadLocal/" style="font-size:16.73px;color:#868686">ThreadLocal</a> <a href="tags/ThreadPoolExecutor/" style="font-size:15.82px;color:#8d8d8d">ThreadPoolExecutor</a> <a href="tags/apollo/" style="font-size:14px;color:#999">apollo</a> <a href="tags/binding模块/" style="font-size:14px;color:#999">binding模块</a> <a href="tags/final/" style="font-size:14px;color:#999">final</a> <a href="tags/httpClient/" style="font-size:14px;color:#999">httpClient</a> <a href="tags/json/" style="font-size:14px;color:#999">json</a> <a href="tags/jvm/" style="font-size:20.36px;color:#6e6e6e">jvm</a> <a href="tags/lambda/" style="font-size:14px;color:#999">lambda</a> <a href="tags/mybatis/" style="font-size:21.27px;color:#686868">mybatis</a> <a href="tags/ssh-key/" style="font-size:14px;color:#999">ssh key</a> <a href="tags/stream/" style="font-size:14px;color:#999">stream</a> <a href="tags/synchronized/" style="font-size:14.91px;color:#939393">synchronized</a> <a href="tags/volatile/" style="font-size:14px;color:#999">volatile</a> <a href="tags/三阶段提交/" style="font-size:14px;color:#999">三阶段提交</a> <a href="tags/代理封装/" style="font-size:14px;color:#999">代理封装</a> <a href="tags/代理模式/" style="font-size:14px;color:#999">代理模式</a> <a href="tags/代码片段/" style="font-size:14.91px;color:#939393">代码片段</a> <a href="tags/伪共享/" style="font-size:14.91px;color:#939393">伪共享</a> <a href="tags/元空间/" style="font-size:14px;color:#999">元空间</a> <a href="tags/分布式事务/" style="font-size:20.36px;color:#6e6e6e">分布式事务</a> <a href="tags/初始化流程/" style="font-size:14px;color:#999">初始化流程</a> <a href="tags/加密/" style="font-size:16.73px;color:#868686">加密</a> <a href="tags/动态代理/" style="font-size:14px;color:#999">动态代理</a> <a href="tags/动态追踪/" style="font-size:14px;color:#999">动态追踪</a> <a href="tags/单例模式/" style="font-size:14px;color:#999">单例模式</a> <a href="tags/反射模块/" style="font-size:16.73px;color:#868686">反射模块</a> <a href="tags/垃圾回收/" style="font-size:14.91px;color:#939393">垃圾回收</a> <a href="tags/多线程基础/" style="font-size:17.64px;color:grey">多线程基础</a> <a href="tags/实现原理/" style="font-size:15.82px;color:#8d8d8d">实现原理</a> <a href="tags/对象分配/" style="font-size:14px;color:#999">对象分配</a> <a href="tags/工具类/" style="font-size:18.55px;color:#7a7a7a">工具类</a> <a href="tags/工厂模式/" style="font-size:14px;color:#999">工厂模式</a> <a href="tags/布隆过滤器/" style="font-size:14px;color:#999">布隆过滤器</a> <a href="tags/并发/" style="font-size:24px;color:#555">并发</a> <a href="tags/并发安全/" style="font-size:15.82px;color:#8d8d8d">并发安全</a> <a href="tags/建造者模式/" style="font-size:14px;color:#999">建造者模式</a> <a href="tags/总结/" style="font-size:14px;color:#999">总结</a> <a href="tags/指令/" style="font-size:14px;color:#999">指令</a> <a href="tags/数据库连接池/" style="font-size:14px;color:#999">数据库连接池</a> <a href="tags/整体介绍/" style="font-size:14px;color:#999">整体介绍</a> <a href="tags/日志/" style="font-size:14px;color:#999">日志</a> <a href="tags/显示锁/" style="font-size:14px;color:#999">显示锁</a> <a href="tags/本地消息表/" style="font-size:14px;color:#999">本地消息表</a> <a href="tags/架构/" style="font-size:22.18px;color:#616161">架构</a> <a href="tags/模板模式/" style="font-size:14px;color:#999">模板模式</a> <a href="tags/死锁/" style="font-size:14px;color:#999">死锁</a> <a href="tags/永久代/" style="font-size:14px;color:#999">永久代</a> <a href="tags/活锁/" style="font-size:14px;color:#999">活锁</a> <a href="tags/流式计算/" style="font-size:14px;color:#999">流式计算</a> <a href="tags/源码/" style="font-size:23.09px;color:#5b5b5b">源码</a> <a href="tags/热部署/" style="font-size:14px;color:#999">热部署</a> <a href="tags/线程安全/" style="font-size:14px;color:#999">线程安全</a> <a href="tags/线程池/" style="font-size:15.82px;color:#8d8d8d">线程池</a> <a href="tags/线程私有/" style="font-size:14.91px;color:#939393">线程私有</a> <a href="tags/缓存模块/" style="font-size:14px;color:#999">缓存模块</a> <a href="tags/装逼/" style="font-size:14px;color:#999">装逼</a> <a href="tags/装饰器模式/" style="font-size:14px;color:#999">装饰器模式</a> <a href="tags/观察者模式/" style="font-size:14px;color:#999">观察者模式</a> <a href="tags/设计原则/" style="font-size:14px;color:#999">设计原则</a> <a href="tags/设计模式/" style="font-size:21.27px;color:#686868">设计模式</a> <a href="tags/读写锁/" style="font-size:14px;color:#999">读写锁</a> <a href="tags/责任链模式/" style="font-size:14px;color:#999">责任链模式</a> <a href="tags/运行时数据区/" style="font-size:14.91px;color:#939393">运行时数据区</a> <a href="tags/适配器模式/" style="font-size:14px;color:#999">适配器模式</a> <a href="tags/锁优化/" style="font-size:14px;color:#999">锁优化</a> <a href="tags/队列锁/" style="font-size:14px;color:#999">队列锁</a> <a href="tags/阻塞队列/" style="font-size:14px;color:#999">阻塞队列</a> <a href="tags/面试题/" style="font-size:14px;color:#999">面试题</a> <a href="tags/高级/" style="font-size:19.45px;color:#747474">高级</a></div></section></aside><footer id="footer" class="clearfix"><div class="social-wrapper"><a href="atom.xml" class="social fas fa-rss flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="mailto:baiyunpeng42@126.com" class="social fas fa-envelope flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://github.com/baiyunpeng" class="social fab fa-github flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a> <a href="https://music.163.com/#/user/home?id=1973042285" class="social fas fa-headphones-alt flat-btn" target="_blank" rel="external nofollow noopener noreferrer"></a></div><br><div><p>博客内容遵循 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" rel="external nofollow noopener noreferrer" target="_blank">署名-非商业性使用-相同方式共享 4.0 国际 (CC BY-NC-SA 4.0) 协议</a></p></div><div>本站使用 <a href="https://xaoxuu.com/wiki/material-x/" target="_blank" class="codename" rel="external nofollow noopener noreferrer">Material X</a> 作为主题 ， 总访问量为 <span id="busuanzi_value_site_pv"><i class="fas fa-spinner fa-spin fa-fw" aria-hidden="true"></i></span> 次 。</div></footer><script>setLoadingBarProgress(80)</script><script>setLoadingBarProgress(60)</script></div><a class="s-top fas fa-arrow-up fa-fw" href="javascript:void(0)"></a></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script>var GOOGLE_CUSTOM_SEARCH_API_KEY="",GOOGLE_CUSTOM_SEARCH_ENGINE_ID="",ALGOLIA_API_KEY="",ALGOLIA_APP_ID="",ALGOLIA_INDEX_NAME="",AZURE_SERVICE_NAME="",AZURE_INDEX_NAME="",AZURE_QUERY_KEY="",BAIDU_API_ID="",SEARCH_SERVICE="hexo",ROOT="/";ROOT.endsWith("/")||(ROOT+="/")</script><script src="//instant.page/1.2.2" type="module" integrity="sha384-2xV8M5griQmzyiY3CDqh1dn4z3llDVqZDqzjzcY+jCBCk/a5fXJmuZ/40JJAPeoU"></script><script async src="https://cdn.jsdelivr.net/npm/scrollreveal@4.0.5/dist/scrollreveal.min.js"></script><script type="text/javascript">$(function(){const e=$(".reveal");if(0!==e.length){const l=ScrollReveal({distance:0});l.reveal(".reveal")}})</script><script src="https://cdn.jsdelivr.net/npm/node-waves@0.7.6/dist/waves.min.js"></script><script type="text/javascript">$(function(){Waves.attach(".flat-btn",["waves-button"]),Waves.attach(".float-btn",["waves-button","waves-float"]),Waves.attach(".float-btn-light",["waves-button","waves-float","waves-light"]),Waves.attach(".flat-box",["waves-block"]),Waves.attach(".float-box",["waves-block","waves-float"]),Waves.attach(".waves-image"),Waves.init()})</script><script async src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-busuanzi@2.3/js/busuanzi.pure.mini.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery-backstretch/2.0.4/jquery.backstretch.min.js"></script><script type="text/javascript">$(function(){$(".cover").backstretch(["https://img.vim-cn.com/29/91197b04c13f512f734a76d4ac422d89dbe229.jpg"],{duration:"6000",fade:"2500"})})</script><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/app.js"></script><script src="https://cdn.jsdelivr.net/gh/xaoxuu/cdn-material-x@19.9/js/search.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script><script>let COPY_SUCCESS = "复制成功";
  let COPY_FAILURE = "复制失败";
  /*页面载入完成后，创建复制按钮*/
  !function (e, t, a) {
    /* code */
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '  <i class="fa fa-copy"></i><span>复制</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });

      clipboard.on('success', function(e) {
        //您可以加入成功提示
        console.info('Action:', e.action);
        console.info('Text:', e.text);
        console.info('Trigger:', e.trigger);
        success_prompt(COPY_SUCCESS);
        e.clearSelection();
      });
      clipboard.on('error', function(e) {
        //您可以加入失败提示
        console.error('Action:', e.action);
        console.error('Trigger:', e.trigger);
        fail_prompt(COPY_FAILURE);
      });
    }
    initCopyCode();

  }(window, document);

  /**
   * 弹出式提示框，默认1.5秒自动消失
   * @param message 提示信息
   * @param style 提示样式，有alert-success、alert-danger、alert-warning、alert-info
   * @param time 消失时间
   */
  var prompt = function (message, style, time)
  {
      style = (style === undefined) ? 'alert-success' : style;
      time = (time === undefined) ? 1500 : time*1000;
      $('<div>')
          .appendTo('body')
          .addClass('alert ' + style)
          .html(message)
          .show()
          .delay(time)
          .fadeOut();
  };

  // 成功提示
  var success_prompt = function(message, time)
  {
      prompt(message, 'alert-success', time);
  };

  // 失败提示
  var fail_prompt = function(message, time)
  {
      prompt(message, 'alert-danger', time);
  };

  // 提醒
  var warning_prompt = function(message, time)
  {
      prompt(message, 'alert-warning', time);
  };

  // 信息提示
  var info_prompt = function(message, time)
  {
      prompt(message, 'alert-info', time);
  };</script><script src="https://cdn.jsdelivr.net/gh/fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js"></script><script>let LAZY_LOAD_IMAGE = "";
  $(".article-entry").find("fancybox").find("img").each(function () {
      var element = document.createElement("a");
      $(element).attr("data-fancybox", "gallery");
      $(element).attr("href", $(this).attr("src"));
      /* 图片采用懒加载处理时,
       * 一般图片标签内会有个属性名来存放图片的真实地址，比如 data-original,
       * 那么此处将原本的属性名src替换为对应属性名data-original,
       * 修改如下
       */
       if (LAZY_LOAD_IMAGE) {
         $(element).attr("href", $(this).attr("data-original"));
       }
      $(this).wrap(element);
  });</script><script>setLoadingBarProgress(100)</script></body></html><!-- rebuild by neat -->