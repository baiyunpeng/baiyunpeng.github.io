<!-- build time:Fri Aug 16 2019 11:46:13 GMT+0800 (GMT+08:00) --><!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="晓风残月的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><meta name="theme-version" content="1.2.3"><meta name="root" content="/"><link rel="dns-prefetch" href="http://www.baiyp.ren"><meta name="keywords" content="{{ page.keywords }}"><meta name="description" content="java并发工具类-Callable、Future 和FutureTask前言创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在..."><meta name="robots" content="all"><meta name="google" content="all"><meta name="googlebot" content="all"><meta name="verify" content="all"><title>java并发工具类-Callable、Future 和FutureTask | 晓风残月的博客</title><link rel="alternate" href="/rss2.xml" title="晓风残月的博客" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0"><link rel="stylesheet" href="/css/style.css?rev=@@hash"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a475efbbf07ecf405a82aa9bd596d186";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]--><!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]--><body><header class="main-header" style="background-image:url(./img/banner5.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="晓风残月"><img src="img/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>学而时习之,不亦说乎</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span> <i class="fa fa-bars"></i> </span><a class="navbar-brand" href="http://www.baiyp.ren">晓风残月的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i>首页</a></li><li role="presentation" class="text-center"><a href="/categories/java/"><i class="fa"></i>基础</a></li><li role="presentation" class="text-center"><a href="/categories/arch/"><i class="fa"></i>架构</a></li><li role="presentation" class="text-center"><a href="/categories/source/"><i class="fa"></i>源码</a></li><li role="presentation" class="text-center"><a href="/categories/code/"><i class="fa"></i>片段</a></li><li role="presentation" class="text-center"><a href="/archives/"><i class="fa"></i>时间轴</a></li><li role="presentation" class="text-center"><a href="/about.html"><i class="fa"></i>关于我</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="java并发工具类-Callable、Future 和FutureTask">java并发工具类-Callable、Future 和FutureTask</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a class="category-link" href="categories/java/">java</a> <a class="category-link" href="categories/java/并发/">并发</a> <a class="category-link" href="categories/java/并发/工具类/">工具类</a> </span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a class="tag-link" href="tags/java/">java</a> <a class="tag-link" href="tags/工具类/">工具类</a> <a class="tag-link" href="tags/并发/">并发</a> </span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2019/08/05</span> </span><span class="fa-wrap"><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></span><div style="margin-top:10px"><span class="post-time" style="margin-right:0"><span class="post-meta-item-icon" style="margin-right:0"><i class="fa fa-keyboard-o"></i> <span class="post-meta-item-text" style="margin-right:0">字数统计: </span><span class="post-count" style="margin-right:0">2.6k字</span> </span></span><span class="post-time" style="margin-right:0">&nbsp; | &nbsp; <span class="post-meta-item-icon" style="margin-right:0"><i class="fa fa-hourglass-half"></i> <span class="post-meta-item-text" style="margin-right:0">阅读时长: </span><span class="post-count" style="margin-right:0">10分</span></span></span></div></div></div><div class="post-body post-content"><h2 id="java并发工具类-Callable、Future-和FutureTask"><a href="#java并发工具类-Callable、Future-和FutureTask" class="headerlink" title="java并发工具类-Callable、Future 和FutureTask"></a>java并发工具类-Callable、Future 和FutureTask</h2><p><img src="../images/fututetask02.png" alt></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><blockquote><p>创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。</p></blockquote><p>这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。<br>如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。</p><p>而自从<strong>Java 1.5</strong>开始，就提供了<strong>Callable</strong>和<strong>Future</strong>，通过它们可以在任务执行完毕之后得到任务执行结果</p><h3 id="Callable接口"><a href="#Callable接口" class="headerlink" title="Callable接口"></a>Callable接口</h3><p>Callable位于JUC包下，它也是一个接口，在它里面也只声明了一个方法叫做call()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Computes a result, or throws an exception if unable to do so.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> computed result</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception if unable to compute a result</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ Callable接口代表一段可以调用并返回结果的代码。</p><p>​ Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p><p>​ Callable接口使用泛型去定义它的返回类型。</p><p>​ <strong>Executors</strong>类提供了一些有用的方法在线程池中执行Callable内的任务。由于<strong>Callable</strong>任务是并行的（并行就是整体看上去是并行的，其实在某个时间点只有一个线程在执行），我们必须等待它返回的结果。<br>​ <code>java.util.concurrent.Future</code>对象为我们解决了这个问题。在线程池提交<strong>Callable</strong>任务后返回了一个<strong>Future</strong>对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。<strong>Future</strong>提供了<strong>get()</strong>方法让我们可以等待Callable结束并获取它的执行结果。</p><p>那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">&lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">Future&lt;?&gt; submit(Runnable task);</span><br></pre></td></tr></table></figure><p>第一个方法：submit提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future。</p><p>第二个方法：submit提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象。</p><p>第三个方法：submit提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。</p><p>因此我们只要创建好我们的线程对象（实现Callable接口或者Runnable接口），然后通过上面3个方法提交给线程池去执行即可。</p><h3 id="Future接口"><a href="#Future接口" class="headerlink" title="Future接口"></a>Future接口</h3><p>​ Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，<strong>该方法会阻塞直到任务返回结果</strong>。</p><p>​ Future<v>接口是用来获取异步计算结果的，说白了就是对具体的Runnable或者Callable对象任务执行的结果进行获取(get())，取消(cancel())，判断是否完成等操作。我们看看Future接口的源码：</v></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Future接口中声明了5个方法，下面依次解释每个方法的作用</p><table><thead><tr><th><strong>方法</strong></th><th><strong>作用</strong></th></tr></thead><tbody><tr><td>cance(boolean mayInterruptIfRunning)</td><td>试图取消执行的任务，参数为true时直接中断正在执行的任务，否则直到当前任务执行完成，成功取消后返回true，否则返回false</td></tr><tr><td>isCancelled()</td><td>方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。</td></tr><tr><td>isDone()</td><td>方法表示任务是否已经完成，若任务完成，则返回true；</td></tr><tr><td>get()</td><td>方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；</td></tr><tr><td>get(long timeout, TimeUnit unit)</td><td>设定计算结果的返回时间，如果在规定时间内没有返回计算结果则抛出TimeOutException</td></tr></tbody></table><h4 id="Future提供了三种功能"><a href="#Future提供了三种功能" class="headerlink" title="Future提供了三种功能"></a>Future提供了三种功能</h4><ul><li>判断任务是否完成；</li><li>能够中断任务；</li><li>能够获取任务执行结果。</li></ul><p>因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。</p><h3 id="RunnableFuture接口"><a href="#RunnableFuture接口" class="headerlink" title="RunnableFuture接口"></a>RunnableFuture接口</h3><p>RunnableFuture<strong>实现了Runnable和Future</strong>。因此FutureTask可以传递到线程对象Thread或Excutor(线程池)来执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets this Future to the result of its computation</span></span><br><span class="line"><span class="comment">     * unless it has been cancelled.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h3><p>我们先来看一下FutureTask的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>FutureTask除了实现了Future接口外还实现了Runnable接口，因此FutureTask也可以直接提交给Executor执行。 当然也可以调用线程直接执行（FutureTask.run()）。接下来我们根据FutureTask.run()的执行时机来分析其所处的3种状态：</p><ol><li><p>未启动，FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，而且没有执行FutureTask.run()方法前，这个FutureTask也处于未启动状态。</p></li><li><p>已启动，FutureTask.run()被执行的过程中，FutureTask处于已启动状态。</p></li><li><p>已完成，FutureTask.run()方法执行完正常结束，或者被取消或者抛出异常而结束，FutureTask都处于完成状态。</p></li></ol><p><img src="../images/fututetask01.png" alt></p><p>下面我们再来看看FutureTask的方法执行示意图（方法和Future接口基本是一样的，这里就不过多描述了）</p><p><img src="../images/fututetask03.png" alt></p><ul><li><p>当FutureTask处于未启动或已启动状态时，如果此时我们执行FutureTask.get()方法将导致调用线程阻塞；当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。</p></li><li><p>当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会执行。当FutureTask处于已启动状态时，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果任务取消成功，cancel(…)返回true；但如果执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时cancel(…)返回false。当任务已经完成，执行cancel(…)方法将返回false。</p></li></ul><p>最后我们给出FutureTask的两种构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，FutureTask是Future接口的一个唯一实现类。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><p>​ 通过上面的介绍，我们对Callable，Future，RunnableFuture，FutureTask都有了比较清晰的了解了，那么它们到底有什么用呢？我们前面说过通过这样的方式去创建线程的话，最大的好处就是能够返回结果，加入有这样的场景，我们现在需要计算一个数据，而这个数据的计算比较耗时，而我们后面的程序也要用到这个数据结果，那么这个时Callable岂不是最好的选择？我们可以开设一个线程去执行计算，而主线程继续做其他事，而后面需要使用到这个数据时，我们再使用Future获取不就可以了吗？下面我们就来编写一个这样的实例。</p><h4 id="Callable-Future-获取执行结果"><a href="#Callable-Future-获取执行结果" class="headerlink" title="Callable+Future 获取执行结果"></a>Callable+Future 获取执行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line">     <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">     ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">     <span class="comment">//创建Callable对象任务</span></span><br><span class="line">     Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">         System.out.println(<span class="string">"Callable子线程在进行计算"</span>);</span><br><span class="line">         Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">         <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">             sum += i;</span><br><span class="line">         <span class="keyword">return</span> sum;</span><br><span class="line">     &#125;;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//提交任务并获取执行结果</span></span><br><span class="line">     Future&lt;Integer&gt; result = executor.submit(task);</span><br><span class="line">     <span class="comment">//关闭线程池</span></span><br><span class="line">     executor.shutdown();</span><br><span class="line"></span><br><span class="line">     System.out.println(<span class="string">"主线程开始走到这里,耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">     <span class="comment">//get方法会阻塞线程执行</span></span><br><span class="line">     Integer value = result.get();</span><br><span class="line">     System.out.println(<span class="string">"获取值："</span> + value + <span class="string">"，共耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br></pre></td></tr></table></figure><p>运行结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主线程开始走到这里,耗时<span class="number">139</span></span><br><span class="line">Callable子线程在进行计算</span><br><span class="line">获取值：<span class="number">4950</span>，共耗时：<span class="number">3169</span></span><br></pre></td></tr></table></figure><h4 id="Callable-FutureTask获取执行结果"><a href="#Callable-FutureTask获取执行结果" class="headerlink" title="Callable+FutureTask获取执行结果"></a>Callable+FutureTask获取执行结果</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程池</span></span><br><span class="line"> <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line"> ExecutorService executor = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line"> <span class="comment">//创建Callable对象任务</span></span><br><span class="line"> Callable&lt;Integer&gt; task = () -&gt; &#123;</span><br><span class="line">     System.out.println(<span class="string">"Callable子线程在进行计算"</span>);</span><br><span class="line">     Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">     <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++)</span><br><span class="line">         sum += i;</span><br><span class="line">     <span class="keyword">return</span> sum;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//第二种方式，注意这种方式和第一种方式效果是类似的,需要创建FutureTask对象</span></span><br><span class="line"> FutureTask&lt;Integer&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;Integer&gt;(task);</span><br><span class="line"> <span class="comment">//提交任务并获取执行结果</span></span><br><span class="line"> <span class="comment">// Future future = executor.submit(task);</span></span><br><span class="line"> executor.submit(futureTask);</span><br><span class="line"> <span class="comment">//关闭线程池</span></span><br><span class="line"> executor.shutdown();</span><br><span class="line"> System.out.println(<span class="string">"主线程开始走到这里,耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line"> <span class="comment">//get方法会阻塞线程执行</span></span><br><span class="line"> Integer value = futureTask.get();</span><br><span class="line"> System.out.println(<span class="string">"获取值："</span> + value + <span class="string">"，共耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br></pre></td></tr></table></figure><p>输出结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Callable子线程在进行计算</span><br><span class="line">主线程开始走到这里,耗时：<span class="number">89</span></span><br><span class="line">获取值：<span class="number">4950</span>，共耗时：<span class="number">3089</span></span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="实现Runnable接口和实现Callable接口的区别："><a href="#实现Runnable接口和实现Callable接口的区别：" class="headerlink" title="实现Runnable接口和实现Callable接口的区别："></a>实现Runnable接口和实现Callable接口的区别：</h4><ol><li><p>Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的。</p></li><li><p>Callable规定的方法是call(),Runnable规定的方法是run()。</p></li><li><p>Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)。</p></li><li><p>call方法可以抛出异常，run方法不可以。</p></li><li><p>运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。</p></li><li><p>加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。</p></li></ol><h4 id="Callable、Runnable、Future和FutureTask-的区别"><a href="#Callable、Runnable、Future和FutureTask-的区别" class="headerlink" title="Callable、Runnable、Future和FutureTask 的区别"></a>Callable、Runnable、Future和FutureTask 的区别</h4><ol><li><p>Callable、Runnable、Future和FutureTask 做为java 线程池运行的重要载体，有必要深入理解。</p></li><li><p>Callable 和 Runnable 都是执行的任务的接口，区别在于Callable有返回值，而Runnable无返回值。</p></li><li><p>Future 表示异步任务返回结果的接口</p></li><li><p>RunnableFuture 继承了Runnable， Future，表示可以带有返回值的run接口</p></li><li><p>FutureTask是一个实现类，实现了RunnableFuture接口，既能接受Runnable类型的任务，也可以接受Callable类型的任务，这个类的作用主要是 有一个protected void done()方法用来扩展使用，作为一个回调方法</p></li></ol></div><div class="reward" ontouchstart><div class="reward-wrap">赏<div class="reward-box"><span class="reward-type"><img class="alipay" src="./img/alipay.jpg"><b>支付宝打赏</b> </span><span class="reward-type"><img class="wechat" src="./img/wechatpay.png"><b>微信打赏</b></span></div></div><p class="reward-tip">赞赏是不耍流氓的鼓励</p></div><div class="post-footer"><div>转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">Snippet</a></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="git生成并添加SSH-key.html" class="pre-post btn btn-default" title="git生成并添加SSH key"><i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span> <span class="hidden-xs">git生成并添加SSH key</span> </a><a href="java并发工具类-04.html" class="next-post btn btn-default" title="java并发工具类-Semaphore"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">java并发工具类-Semaphore</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><div id="lv-container" data-id="city" data-uid="MTAyMC80NTg2Ny8yMjM3OA"><script type="text/javascript">!function(e,t){var n,c=e.getElementsByTagName(t)[0];"function"!=typeof LivereTower&&(n=e.createElement(t),n.src="https://cdn-city.livere.com/js/embed.dist.js",n.async=!0,c.parentNode.insertBefore(n,c))}(document,"script")</script></div></div></main><aside id="article-toc" role="navigation" class="col-md-4"><div class="widget"><h3 class="title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java并发工具类-Callable、Future-和FutureTask"><span class="toc-text">java并发工具类-Callable、Future 和FutureTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Callable接口"><span class="toc-text">Callable接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future接口"><span class="toc-text">Future接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Future提供了三种功能"><span class="toc-text">Future提供了三种功能</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RunnableFuture接口"><span class="toc-text">RunnableFuture接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FutureTask"><span class="toc-text">FutureTask</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分析"><span class="toc-text">分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用示例"><span class="toc-text">使用示例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable-Future-获取执行结果"><span class="toc-text">Callable+Future 获取执行结果</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable-FutureTask获取执行结果"><span class="toc-text">Callable+FutureTask获取执行结果</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#实现Runnable接口和实现Callable接口的区别："><span class="toc-text">实现Runnable接口和实现Callable接口的区别：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Callable、Runnable、Future和FutureTask-的区别"><span class="toc-text">Callable、Runnable、Future和FutureTask 的区别</span></a></li></ol></li></ol></li></ol></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi">访问量: <strong id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i> </strong>&nbsp; | &nbsp; 访客数: <strong id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></strong></div></div><div class="col-sm-12"><span>Copyright &copy; 2019 </span>| <span>Powered by <a href="//baiyp.ren" class="copyright-links" target="_blank" rel="nofollow">baiyp</a></span></div></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="js/app.js?rev=@@hash"></script></body><!-- rebuild by neat -->