{"meta":{"title":"晓风残月的博客","subtitle":"晓风残月","description":"个人技术的一些积累","author":"晓风残月","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"java多线程-01","slug":"java多线程-01","date":"2019-08-02T23:23:07.000Z","updated":"2019-08-03T01:22:06.205Z","comments":true,"path":"java多线程-01.html","link":"","permalink":"http://yoursite.com/java多线程-01.html","excerpt":"","text":"多线程概述基础概念进程和线程 进程是程序运行资源分配的最小单位 ​ 进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘IO等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。 ​ 进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。 线程是CPU调度的最小单位,必须依赖于进程而存在 ​ 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。 线程无处不在 ​ 任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。 CPU核心数和线程数的关系​ 多核心:也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理 多线程: Simultaneous Multithreading.简称SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。 核心数、线程数:目前主流CPU都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系 CPU时间片轮转机制​ 我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。 ​ 时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。 百度百科对CPU时间片轮转机制原理解释如下: ​ 如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾 ​ 时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。 ​ 为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发 ​ 结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。 ​ 在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KILL掉的,我想也正是因为这种机制的缘故。 澄清并行和并发​ 我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的并行车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。 当谈论并发的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。 ​ 俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。 综合来说： ​ 并发:指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已. ​ 并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行 两者区别:一个是交替执行,一个是同时执行. 高并发编程的意义、好处和注意事项​ 由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。 1. 充分利用CPU的资源​ 从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU,如果还是使用单线程的技术做思路,明显就out了。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。 ​ 就像我们平时坐地铁一样,很多人坐长线地铁的时候都在认真看书,而不是为了坐地铁而坐地铁,到家了再去看书,这样你的时间就相当于有了两倍。这就是为什么有些人时间很充裕,而有些人老是说没时间的一个原因,工作也是这样,有的时候可以并发地去做几件事情,充分利用我们的时间,CPU也是一样,也要充分利用。 2. 加快响应用户的时间​ 比如我们经常用的迅雷下载,都喜欢多开几个线程去下载,谁都不愿意用一个线程去下载,为什么呢?答案很简单,就是多个线程下载快啊。 ​ 我们在做程序开发的时候更应该如此,特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。 3. 可以使你的代码模块化,异步化,简单化​ 例如我们实现电商系统，下订单和给用户发送短信、邮件就可以进行拆分，将给用户发送短信、邮件这两个步骤独立为单独的模块，并交给其他线程去执行。这样既增加了异步的操作，提升了系统性能，又使程序模块化,清晰化和简单化。 多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。 多线程程序需要注意事项1. 线程之间的安全性​ 从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。 2. 线程之间的死锁​ 为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。 假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生 3. 线程太多了会将服务器资源耗尽形成死机当机​ 线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢? ​ 某些系统资源是有限的,如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。 多线程应用开发的注意事项很多,希望大家在日后的工作中可以慢慢体会它的危险所在。 认识Java里的线程Java程序天生就是多线程的​ 一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。 [6] Monitor Ctrl-Break //监控Ctrl-Break中断信号的 [5] Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等 [4] Signal Dispatcher // 分发处理发送给JVM信号的线程 [3] Finalizer // 调用对象finalize方法的线程 [2] Reference Handler//清除Reference的线程 [1] main //main线程，用户程序入口 线程的启动与中止启动启动线程的方式有： 1、X extends Thread;，然后X.start 123456789101112public class ThreadTest extends Thread &#123; @Override public void run() &#123; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); &#125; public static void main(String[] args) &#123; new ThreadTest().start(); &#125;&#125; 2、X implements Runnable；然后交给Thread运行 12345678910111213public class RunableTest implements Runnable &#123; @Override public void run() &#123; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); &#125; public static void main(String[] args) &#123; RunableTest runableTest = new RunableTest(); new Thread(runableTest).start(); &#125;&#125; Thread和Runnable的区别​ Thread才是Java里对线程的唯一抽象，Runnable只是对任务（业务逻辑）的抽象。Thread可以接受任意一个Runnable的实例并执行。 中止线程自然终止要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。 stop​ 暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()。但是这些API是过期的，也就是不建议使用的。不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。 中断​ 安全的中止则是其他线程通过调用某个线程A的interrupt()方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应， ​ 线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。 ​ 如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait等），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。 ​ 不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为， 一般的阻塞方法，如sleep等本身就支持中断的检查， 检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。 注意：处于死锁状态的线程无法被中断 样例代码 1234567891011121314151617181920212223242526public class RunableTest implements Runnable &#123; private int i = 0; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted()) &#123; i++; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (i &gt; 10) &#123; Thread.currentThread().interrupt(); &#125; &#125; &#125; public static void main(String[] args) &#123; RunableTest runableTest = new RunableTest(); new Thread(runableTest).start(); &#125;&#125; 对Java里的线程再多一点点认识深入理解run()和start()​ Thread类是Java里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。 ​ start()方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用，如果重复调用会抛出异常。 ​ 而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。 其他的线程相关方法​ yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行yield( )的线程不一定就会持有锁，我们完全可以在释放锁后再调用yield方法。 所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。 wait()/notify()/notifyAll()：后面会单独讲述 join方法​ 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。(此处为常见面试考点) 看个栗子 12345678910111213141516171819202122232425Thread thread1 = new Thread(() -&gt; &#123; while(!Thread.currentThread().isInterrupted()) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"11111111111\"); &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; while(!Thread.currentThread().isInterrupted()) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"222222222222\"); &#125; &#125;); thread1.start(); //在此处join 其他线程会等待thread1 执行完成后在执行thread2 thread1.join(); thread2.start(); 执行结果 12345678910111213141516171111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111 第二种情况 12345... thread1.start(); thread2.start(); //在此处join 因为下面没有等待启动的线程，所以和不加thread1.join();一样，是交替执行的 thread1.join(); 执行结果 1234567891011121311111111111111111111112222222222221111111111122222222222211111111111222222222222111111111112222222222222222222222221111111111111111111111222222222222 线程的优先级​ 在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。 ​ 设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。 守护线程​ Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。 ​ Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。 线程间的共享和协作线程间的共享synchronized内置锁​ 线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。 ​ Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。 对象锁和类锁：对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。 但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。 方法锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 方法锁 不同的方法可以并行的 */public class RunableTest &#123; public synchronized void test1() &#123; System.out.println(\"test111\"); &#125; public synchronized void test2() &#123; System.out.println(\"test222\"); &#125; public synchronized void test3() &#123; System.out.println(\"test333\"); &#125; public static void main(String[] args) &#123; RunableTest RunableTest = new RunableTest(); new Thread(() -&gt; &#123; while (true) &#123; sleep(1); RunableTest.test1(); &#125; &#125;).start(); new Thread(() -&gt; &#123; while (true) &#123; sleep(1); RunableTest.test2(); &#125; &#125;).start(); new Thread(() -&gt; &#123; while (true) &#123; sleep(1); RunableTest.test3(); &#125; &#125;).start(); &#125; public static void sleep(int sec) &#123; try &#123; Thread.sleep(sec * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 对象锁123456789101112131415161718192021222324252627282930/** * 对象锁 用一个对象锁的话 先获取锁在执行 * 如果是多个对象可以并行的 */ private Object lock = new Object(); public void test1() &#123; synchronized (lock) &#123; sleep(1); System.out.println(\"test111\"); &#125; &#125; public void test2() &#123; synchronized (lock) &#123; sleep(1); System.out.println(\"test222\"); &#125; &#125; public void test3() &#123; synchronized (lock) &#123; sleep(1); System.out.println(\"test333\"); &#125; &#125; 类锁1234567891011121314151617181920212223242526/** *类锁 用一个对象锁的话 先获取锁在执行 */public void test1() &#123; synchronized (RunableTest.class) &#123; sleep(1); System.out.println(\"test111\"); &#125; &#125; public void test2() &#123; synchronized (RunableTest.class) &#123; sleep(1); System.out.println(\"test222\"); &#125; &#125; public void test3() &#123; synchronized (RunableTest.class) &#123; sleep(1); System.out.println(\"test333\"); &#125; &#125;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://yoursite.com/categories/java/多线程/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://yoursite.com/categories/java/多线程/"}]},{"title":"系统加密服务-04","slug":"系统加密服务-04","date":"2019-08-02T23:07:18.000Z","updated":"2019-08-02T23:17:35.799Z","comments":true,"path":"系统加密服务-04.html","link":"","permalink":"http://yoursite.com/系统加密服务-04.html","excerpt":"","text":"系统加密服务-后记开发中遇到的问题 虽然说用起来直接引入js就能解决进行加密但是在使用过程中还是有很多问题的,这里面列出几个 因为使用第三方校验框架，使得jquery监听form表单失效或者数据没有加密 我们通过改写校验框架源码来实现，就是在校验中我们设置$.setSubmit(false)不进行提交，在校验通过后进行加密后再提交，设计的框架有jquery.validate,bootstrapValidate,validform 等 form 表单中的重复的name值以“，”分割 原来是这样来写的，以直没有问题，后来有一个很老的系统使用 request.getParameterValues() 方式来获取数组参数，因为解密后是“,”分割的字符串分不开数组和字符串所以对系统进行了重构js全部以数据的形式接收，因为数据形式数据量太大很多都是不重复的，所以就先生成一个JSON数组，然后检查如果是一个的话就将数据去掉，使用原始的JSON形式，如果有重复的name就保留数组，这样加密后就节省了很大的数据传输量 pyload处理 原来只有参数的解密后来发现对于ajax contentType为GBK的获取步到参数，发现是流的形式接收的，就增加了pyload形式，后来又发现上传文件失效了，原来将文件上传解密了，文件上传失败，就判断contentType不能包含multipart/form-data 空对象处理 因采用了JSON的压缩方式，如果一个参数值为空就不将这个参数传递过去了，因后台没有做任何处理，没有加密前是得到的是空字符串加密后得到的是null，造成了空指针，解决方法是加入了自定义配置默认不将空对象传过去，如果是指定一个配置，就将所以的参数传过去，如果对象为空的也传过去，但这样会造成很大的数据量增加，默认不传递空值的。 其他的各种小问题也很多这里面不列举了 系统响应情况 因为引入了前端加密后端解密系统的响应速度肯定会下降，测试人员测试的是否发现系统明显慢了一些 数据量越大的页面提交也越慢 最慢的页面数据量特别大，提交约2分钟左右，加密的参数达到了恐怖了5万个各种各样的参数和值 有些电脑甚至浏览器直接卡死崩溃但一般都能够接受，正常页面能够再1秒内提交响应 总结 安全问题解决了，积累了经验，特别累，涉及到十几个服务，三四个月以来几乎天天加班，处理各种各样的问题，后两个月几乎天天上线，回滚，测试人员一遍一遍的测试，线上还是问题不断，被骂了不知道多少遍，总算再规定的期限完成了，来检查的时候也是战战兢兢的，生怕出现问题，总算是完美完成，不辜负几个月的辛苦，拿到了安全证书，这几个月也学到很多知识。 感谢各位查看和评阅第一次系列的写一些博客，感觉写的很乱，不能很系统的写出来，有什么问题欢迎指正。","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://yoursite.com/categories/java/加密/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://yoursite.com/categories/java/加密/"}]},{"title":"系统加密服务-03","slug":"系统加密服务-03","date":"2019-08-02T23:06:35.000Z","updated":"2019-08-02T23:21:37.073Z","comments":true,"path":"系统加密服务-03.html","link":"","permalink":"http://yoursite.com/系统加密服务-03.html","excerpt":"","text":"系统加密服务-后台解密涉及的问题 要知道解密是否成功 对于AJAX传过来的PYLOAD 载荷的流的形式的数据解密并重构可重复读取的流 要对后端透明后端不需要改动任何代码 解密通过重写HttpServletRequestWrapper 实现 构建可重复读取的的request流需要 spring-test jar支持使用DelegatingServletInputStream 实现 构建ParameterRequestWrapper 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class ParameterRequestWrapper extends HttpServletRequestWrapper &#123; private static final Logger logger = LoggerFactory.getLogger(ParameterRequestWrapper.class); private Map&lt;String, String[]&gt; parameters = new LinkedHashMap&lt;String, String[]&gt;(); //是否可重复读取流 private boolean isReadInputStream = false; //pyload parameter 主体 private String parameterBody = null; //解密状态 private boolean decryptionState = false; /** * input stream 的buffer * */ public ParameterRequestWrapper(HttpServletRequest request) throws UnsupportedEncodingException &#123; super(request); //request 解密 RequestEnriry requestEnriry = ParameterUtils.decrypt(request); if (null != requestEnriry) &#123; //获取解密后的对象 Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); //流是否被读取了 isReadInputStream = requestEnriry.isReadInputStream(); if (isReadInputStream) &#123; parameterBody = requestEnriry.getParameterBody(); &#125; //解密是否成功 decryptionState = requestEnriry.isPass(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; parameters = parameterMap; &#125; &#125; &#125; @Override public String getParameter(String key) &#123; String[] values = parameters.get(key); return StringUtils.arrayToString(values); &#125; @Override public Map&lt;String, String[]&gt; getParameterMap() &#123; return parameters; &#125; @Override public Enumeration&lt;String&gt; getParameterNames() &#123; return new Vector&lt;String&gt;(parameters.keySet()).elements(); &#125; @Override public String[] getParameterValues(String name) &#123; String[] result = null; Object value = parameters.get(name); if (value == null) &#123; result = null; &#125; else if (value instanceof String[]) &#123; result = (String[]) value; &#125; else if (value instanceof String) &#123; result = new String[]&#123;(String) value&#125;; &#125; else &#123; result = new String[]&#123;value.toString()&#125;; &#125; return result; &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; if (isReadInputStream) &#123; if (null != parameterBody) &#123; final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(parameterBody.getBytes()); //构建可重复读取的流 return new DelegatingServletInputStream(byteArrayInputStream); &#125; &#125; else &#123; return super.getInputStream(); &#125; return null; &#125; public boolean isDecryptionState() &#123; return decryptionState; &#125; public void setDecryptionState(boolean decryptionState) &#123; this.decryptionState = decryptionState; &#125; 构建filter 123456789101112131415161718public class ParametersFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; //强制指定编码，解决解密后乱码问题 request.setCharacterEncoding(\"UTF-8\"); ParameterRequestWrapper parameterRequestWrapper = new ParameterRequestWrapper(request); //获取加密状态 boolean isDecryptionState = parameterRequestWrapper.isDecryptionState(); if (isDecryptionState) &#123; chain.doFilter(parameterRequestWrapper, response); &#125; else &#123; //返回加密失败的状态，可以在页面处理 response.setStatus(911); &#125; &#125;&#125; 在web.xml 设置filter 需要RequestContextListener 支持，在web.xml 中配置 1234567891011121314!-- 参数过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;ParametersFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.xxx.common.security.web.filter.ParametersFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;ParametersFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- request固化器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt; 这样就配置完了 对于普通的parameterMap参数解密 先检查参数名称是否是加密的key 我们可以指定一个不容易重名的例如“$@$.ecryptedData“ 如果加密了 就就行解密 解密完成后通过fastJson将JSON串转换为MAP 检查是否存在我们JS中定义的时间戳 如果不存在 则判断解密失败 代码片段如下参数解密 123456789101112131415161718192021public void decrypt(HttpServletRequest request, RequestEnriry requestEnriry) &#123;//检查是否是form表单提交的 if (check(request)) &#123; Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); //检查是否加密 boolean isEncrypt = isEncrypt(parameterMap); if (isEncrypt) &#123; requestEnriry.setEncrypt(isEncrypt); //获取加密的参数 String encParameter = getEncryptedParameter(parameterMap); //解密数据 String decParameter = decryptData(encParameter, getSecretKey(request)); if (StringUtils.isNotEmpty(decParameter)) &#123; //参数转换 Map&lt;String, String[]&gt; decParameterMap = encParameterConver(decParameter);//将参数封装到实体中 requestEnriry.putParameterMap(decParameterMap);//设置传过来的时间戳 requestEnriry.setTimestamp(getEncryptedTimestamp(decParameterMap)); &#125; &#125; &#125; &#125; 检查参数是否加密 123456789 public boolean isEncrypt(Map parameterMap) &#123;Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty() &amp;&amp; parameterMap.containsKey(\"$@$.ecryptedData\")) &#123; flag = true; &#125; &#125; return flag; &#125; 获取加密的参数 12345678910public String getEncryptedParameter(Map&lt;String, String[]&gt; parameterMap) &#123; String ecryptedParam = null; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; String[] parameterArray = parameterMap.get(\"$@$.ecryptedData\"); if (null != parameterArray &amp;&amp; parameterArray.length &gt; 0) &#123; ecryptedParam = parameterArray[0]; &#125; &#125; return ecryptedParam; &#125; 检查是否需要解密操作 1234567public boolean check(HttpServletRequest request) &#123; Map parameterMap = request.getParameterMap(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; return true; &#125; return false; &#125; 参数转换 12345678910111213141516171819202122public Map&lt;String, String[]&gt; encParameterConver(String decryptionJson) &#123; Map&lt;String, String[]&gt; mappingMap = new LinkedHashMap&lt;String, String[]&gt;(); if (null != mappingMap &amp;&amp; StringUtils.isNotEmpty(decryptionJson)) &#123; Map&lt;String, String[]&gt; parameterMap = null; parameterMap = ParameterUtils.jsonToMap(decryptionJson); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; Set&lt;String&gt; keys = parameterMap.keySet(); for (String key : keys) &#123; if (StringUtils.isNotEmpty(key)) &#123; String[] value = parameterMap.get(key); if (null != value) &#123; value = ParameterUtils.decodeURI(value); &#125; if (null != value) &#123; mappingMap.put(key, value); &#125; &#125; &#125; &#125; &#125; return mappingMap; &#125; 获取时间戳 12345678910public String getEncryptedTimestamp(Map&lt;String, String[]&gt; parameterMap) &#123; String timestamp = null; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; String[] valueArray = parameterMap.get(\"$@$.tmp\"); if (null != valueArray &amp;&amp; valueArray.length &gt; 0) &#123; timestamp = valueArray[0]; &#125; &#125; return timestamp; &#125; 对于AJAX PYLOAD 载荷的参数解密 跟普通的一样解密一样只是有几点区别 pyload需要有contentType contentType 不能包含multipart/form-data 即不支持文件上传 pyload 需要吧解析的参数还原为原始的字符串 可能是JSON字符串或者是URL参数 代码片段如下参数解密 123456789101112131415161718192021222324252627282930public void decrypt(HttpServletRequest request, RequestEnriry requestEnriry) &#123;//检查是否需要解密 if (check(request)) &#123; //获取pyload 参数 String pyloadParameter = getPyloadParameter(request); //设置流读取状态为true requestEnriry.setReadInputStream(true); if (StringUtils.isNotEmpty(pyloadParameter)) &#123; requestEnriry.setParameterBody(pyloadParameter); //将pyload参数解析 Map&lt;String, String[]&gt; parameterMap = ParameterUtils.getUrlParams(pyloadParameter); //检查是否加密 boolean isEncrypt = isEncrypt(parameterMap); if (isEncrypt) &#123; requestEnriry.setEncrypt(isEncrypt); String encParameter = getEncryptedParameter(parameterMap); if (StringUtils.isNotEmpty(encParameter)) &#123; String decParameter = decryptData(encParameter, getSecretKey(request)); requestEnriry.setParameterBody(decParameter); Map&lt;String, String[]&gt; map = ParameterUtils.jsonToMap(decParameter); if (null != map &amp;&amp; !map.isEmpty()) &#123; requestEnriry.setTimestamp(getEncryptedTimestamp(map)); requestEnriry.putParameterMap(map); &#125; &#125; &#125; &#125; &#125; &#125; 检查是否是pyload形式 1234567public boolean check(HttpServletRequest request) &#123; String contentType = getContentType(request); if (StringUtils.isNotEmpty(contentType) &amp;&amp; !contentType.contains(\"multipart/form-data\")) &#123; return true; &#125; return false; &#125; 获取pyload 参数 12345678910111213141516171819202122232425262728public String getPyloadParameter(HttpServletRequest request) &#123; String ecryptedParam = null; InputStream inputStream = null; try &#123; inputStream = request.getInputStream(); &#125; catch (IOException e) &#123; logger.error(\"Error reading the request body…\", e); &#125; if (null != inputStream) &#123; StringBuilder stringBuilder = new StringBuilder(); if (inputStream != null) &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); char[] charBuffer = new char[CHAR_BUFFER_LENGTH]; int bytesRead; while ((bytesRead = bufferedReader.read(charBuffer)) &gt; 0) &#123; stringBuilder.append(charBuffer, BUFFER_START_POSITION, bytesRead); &#125; &#125; catch (IOException e) &#123; logger.error(\"Fail to read input stream\", e); &#125; &#125; else &#123; stringBuilder.append(\"\"); &#125; ecryptedParam = stringBuilder.toString(); &#125; return ecryptedParam; &#125; 其他公共类 RequestEnriry 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class RequestEnriry &#123; private Map&lt;String, String[]&gt; parameterMap = new HashMap&lt;String, String[]&gt;(); private String parameterBody; private boolean isEncrypt = false; private boolean isReadInputStream = false; private String timestamp = null; public RequestEnriry() &#123; &#125; public RequestEnriry(Map&lt;String, String[]&gt; requestParameterMap) &#123; if (null != requestParameterMap &amp;&amp; !requestParameterMap.isEmpty()) &#123; parameterMap.putAll(requestParameterMap); &#125; &#125; public void handle() &#123; parameterMap.remove(SecurityConstant.ECRYPTED_PARAM_NAME); &#125; public boolean isPass() &#123; boolean isPass = false; if (isEncrypt) &#123; if (StringUtils.isNotEmpty(timestamp)) &#123; isPass = true; &#125; &#125; else &#123; isPass = true; &#125; return isPass; &#125; public Map&lt;String, String[]&gt; getParameterMap() &#123; return parameterMap; &#125; public void setParameterMap(Map&lt;String, String[]&gt; parameterMap) &#123; this.parameterMap = parameterMap; &#125; public void putParameterMap(Map&lt;String, String[]&gt; subParameterMap) &#123; parameterMap.putAll(subParameterMap); &#125; public String getParameterBody() &#123; return parameterBody; &#125; public void setParameterBody(String parameterBody) &#123; this.parameterBody = parameterBody; &#125; public boolean isEncrypt() &#123; return isEncrypt; &#125; public void setEncrypt(boolean encrypt) &#123; isEncrypt = encrypt; &#125; public String getTimestamp() &#123; return timestamp; &#125; public void setTimestamp(String timestamp) &#123; this.timestamp = timestamp; &#125; public boolean isReadInputStream() &#123; return isReadInputStream; &#125; public void setReadInputStream(boolean readInputStream) &#123; isReadInputStream = readInputStream; &#125;&#125; 到这一步已经全部完成了，核心思想和代码已经完成","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://yoursite.com/categories/java/加密/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://yoursite.com/categories/java/加密/"}]},{"title":"系统加密服务-02","slug":"系统加密服务-02","date":"2019-08-02T23:05:22.000Z","updated":"2019-08-02T23:21:25.554Z","comments":true,"path":"系统加密服务-02.html","link":"","permalink":"http://yoursite.com/系统加密服务-02.html","excerpt":"","text":"系统加密服务-页面JS加密涉及的问题 因涉及的页面较多不能一个一个改，只能统一引用，最好使用header引入js的形式 能够捕获form表单提交，在提交之前将提交的数据进行加密，并将加密的数据提交，原始数据不提交 form表单序列化 AJAX数据加密 加密方式选择 文件上传对于和上传数据一起的参数数据加密 问题解决 对于第一个问题 写统一的JS进行解决做好兼容性， 对于form表单提交加密 解决方案： 使用jquery监听form表单的submit方案，如果监听到form提交就将form表单对应输入框的元素进行序列化，序列为JSON数组（因为后台Request接收数组，兼容类似于checkBox重复name）将序列化的JSON进行加密，并将加密的数据插入到表单中，并将加密的输入框元素设置为disabled（这样元素就不会提交了）提交表单就只剩下加密的数据了。 123456789101112131415$(function () &#123;//监听form表单提交 $(\"form\").submit(function (data) &#123; //获取提交的URL var url = $(this).attr(\"action\"); //检查是否需要提交 if ($.getSubmit()) &#123; //检查是否需要加密 if ($.isEncrypt(url)) &#123; //数据加密 $(this).formEncryption(); &#125; &#125; &#125;);&#125;); 对于form表单序列化 解决方案：对于表单序列化要排除一些不需要加密的元素例如file,button,image等，对于checkbox和redio可能存在多个相同的name，要使用JSON数据来接收，用于区分后台接受到“,”分割的字符串springMvc 会自动将request参数数组转换为“,”分割的字符串，但有些很老的代码是不支持的，要兼容底层request区分数组和“,”分割的字符串要使用JSON数组来接收，并将序列化的name值进行保存，用于某些情况下将加密后disable后的元素去掉disabled，并将加密设置为jquery插件的形式使用。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253(function ($) &#123;//需要排除的元素 var excludeInputType = [\"file\", \"button\", \"submit\", \"image\", \"reset\"]; $.fn.extend(&#123; //序列化方法 \"serializeJSON\": function () &#123; //表单数据 var formData = &#123;&#125;; //加密的元素数组 var disabledKeys = []; this.find(\"input,select,textarea\").each(function () &#123; if (!$(this).is(\":disabled\")) &#123; var name = $(this).attr(\"name\"); var value = $(this).val(); var valueArray = new Array(value); var type = $(this).attr(\"type\"); var flag = true; for (var i = 0; i &lt; excludeInputType.length; i++) &#123; if (type == excludeInputType[i]) &#123; flag = false; return true; &#125; &#125; disabledKeys.push(name); switch (type) &#123; case \"checkbox\": if (!$(this).is(':checked')) &#123; return true; &#125; break; case \"radio\": if (!$(this).is(':checked')) &#123; return true; &#125; break; &#125; // var v = $.getJsonValue(formData, name); if (v) &#123; v.push(value); valueArray = v; &#125; formData = $.putJson(formData, name, valueArray); &#125; &#125;); $.setDisableKey(disabledKeys); formData = $.arrayParameterSerialize(formData); return formData; &#125; &#125;);&#125;) 对于AJAX数据提交 解决方案：使用 $.ajaxPrefilter 捕获ajax提交，得到提交的数据，并进行解析，加密并将原始数据覆盖为新的数据 12345678910111213141516171819202122232425262728$.ajaxPrefilter(function (options, originalOptions, jqXHR) &#123;//获取ajax数据 var data = options.data; //获取ajaxurl var url = options.url; //是否需要加密 if ($.isEncrypt(url)) &#123; if (data) &#123; var parameter = &#123;&#125;; //检查字符串是否是json字符串 if ($.strIsJSON(data)) &#123; //将json字符串转换为json对象 parameter = JSON.parse(data); &#125; else &#123; //对于普通的数据?xxx=1&amp; 形式的数据进行解析转换为json对象 parameter = $.parseParameter(data); &#125; //添加时间戳 parameter = $.addTmp(parameter); //数据加密 data = $.encryptData(parameter); var dataJson = &#123;&#125;; dataJson = $.putJson(dataJson, $.getEcryptedParameterName(), data); data = $.jsonToParameter(dataJson); //将原始数据覆盖为加密的数据 options.data = data; &#125; &#125; 数据加密 解决方案 使用 des形式加密，可以自己定义加密方式，但要保证前后台都能加密解密。 加密最好加上时间戳 用于后台检查是否解密成功（如果解密后没有这个时间戳字段代表解密失败）还可以用于其他的作用，例如检查加密的字符串超时时间。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(function ($) &#123; var isSubmit_disabled = true; var disabled_keys = []; $.ajaxSetup(&#123; contentType: \"application/x-www-form-urlencoded;charset=utf-8\", complete: function (xhr, textStatus) &#123; if (xhr.status == 911) &#123; layer.msg('当前页面已失效，正在刷新浏览器', &#123;icon: 0, shade: 0.8&#125;, function () &#123; window.location.href = $.getRootPath(); &#125;); return false; &#125; &#125; &#125;); $.ajaxPrefilter(function (options, originalOptions, jqXHR) &#123; var data = options.data; var url = options.url; if ($.isEncrypt(url)) &#123; if (data) &#123; var parameter = &#123;&#125;; if ($.strIsJSON(data)) &#123; parameter = JSON.parse(data); &#125; else &#123; parameter = $.parseParameter(data); &#125; parameter = $.addTmp(parameter); data = $.encryptData(parameter); var dataJson = &#123;&#125;; dataJson = $.putJson(dataJson, $.getEcryptedParameterName(), data); data = $.jsonToParameter(dataJson); options.data = data; &#125; &#125; &#125;); $.fn.extend(&#123; formEncryption: function () &#123; var data = &#123;&#125;; var ecryptedParameterName = $.getEcryptedParameterName(); var url = $(this).attr(\"action\"); if ($.isEncrypt(url)) &#123; var inputArray = this.serializeJSON(); if (!inputArray[ecryptedParameterName]) &#123; $(this).disabledForm(); for (var key in inputArray) &#123; var value = inputArray[key]; data = $.putJson(data, key, value); &#125; data = $.addTmp(data); var encData = $.encryptData(data); if ($.isNotEmpty(encData)) &#123; var encDataInput = $(\"&lt;input type='hidden' name = '\" + ecryptedParameterName + \"' value='\" + encData + \"'/&gt;\"); this.append(encDataInput); &#125; &#125; &#125; &#125;, encryptionSubmit: function () &#123; this.formEncryption(); this.submit(); &#125;, disabledForm: function () &#123; var disableKeys = $.getDisableKey(); var ecryptedParameterName = $.getEcryptedParameterName(); for (var i = 0; i &lt; disableKeys.length; i++) &#123; if (disableKeys[i] != ecryptedParameterName) &#123; $(this).find(\"[name='\" + disableKeys[i] + \"']\").attr(\"disabled\", \"disabled\"); &#125; &#125; &#125;, enableForm: function () &#123; var disableKeys = $.getDisableKey(); var ecryptedParameterName = $.getEcryptedParameterName(); $(this).find(\"[name='\" + ecryptedParameterName + \"']\").remove(); for (var i = 0; i &lt; disableKeys.length; i++) &#123; $(this).find(\"[name='\" + disableKeys[i] + \"']\").attr(\"disabled\", false); &#125; &#125; &#125;); 上下是一个文件 不知道怎么回事 makedown 显示不全一个完整的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 $.extend(&#123; urlDataEncrypt: function (url, extParams) &#123; var secretKey = $.getSecretKey(); var baseUrl = $.parseUrl(url); var params = $.parseUrlParameter(url); params = $.initEncryptParam(params); if ($.isNotEmpty(extParams) &amp;&amp; $.isJson(extParams)) &#123; $.putJson(params, extParams); &#125; var encryptUrl = url; if ($.isEmpty(secretKey)) &#123; encryptUrl = baseUrl + \"?\" + $.jsonToParameter(params); &#125; else &#123; var ecryptedData = $.encryptData(params); params = $.addTmp(params); encryptUrl = baseUrl + \"?\" + $.getEcryptedParameterName() + \"=\" + ecryptedData; &#125; return encryptUrl; &#125;, encryptData: function (data) &#123; var ecryptedData = \"\"; if ($.isJson(data)) &#123; var jsonStr = JSON.stringify(data); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; else &#123; if (!data.match(\"^\\&#123;(.+:.+,*)&#123;1,&#125;\\&#125;$\")) &#123; var params = $.parseParameter(data); var jsonStr = JSON.stringify(params); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; else &#123; var jsonStr = JSON.stringify(jsonData); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; &#125; return ecryptedData; &#125;, initEncryptParam: function (data) &#123; if ($.isEmpty(data)) &#123; data = &#123;&#125;; &#125; else if (!$.isJson(data)) &#123; data = jQuery.parseJSON(data); &#125; data = $.addTmp(data); return data; &#125;, isEncrypt: function (url) &#123; var flag = true; var secretKey = $.getSecretKey(); if ($.isEmpty(secretKey)) &#123; flag = false; &#125; else &#123; var encryptExclude = $.encryptExcludeUrl(); if (encryptExclude &amp;&amp; $.isArray(encryptExclude)) &#123; for (var i = 0; i &lt;= encryptExclude.length; i++) &#123; if (encryptExclude[i] == url) &#123; flag = false; break; &#125; &#125; &#125; &#125; return flag; &#125;, setSubmit: function (obj) &#123; isSubmit_disabled = obj; &#125;, getSubmit: function () &#123; return isSubmit_disabled; &#125;, setDisableKey: function (keys) &#123; if (keys &amp;&amp; keys[0] != $.getEcryptedParameterName()) &#123; disabled_keys = keys; &#125; &#125;, getDisableKey: function () &#123; return disabled_keys; &#125;, &#125;);&#125;)(window.jQuery);","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://yoursite.com/categories/java/加密/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://yoursite.com/categories/java/加密/"}]},{"title":"系统加密服务-01","slug":"系统加密服务-01","date":"2019-08-02T23:03:28.000Z","updated":"2019-08-02T23:21:16.913Z","comments":true,"path":"系统加密服务-01.html","link":"","permalink":"http://yoursite.com/系统加密服务-01.html","excerpt":"","text":"系统加密服务需求背景 我们公司因为要紧急对系统进行安全加密，以前系统都是参数暴漏的，能够直接获取操作链接等数据，为防止系统关键数据被窃取，系统要进行全面加密，时间只有一个月，上级部门要来进行检查，因涉及到多个系统，上万个页面不能一个一个页面进行加密，特需要一套框架来支持。 需要实现的功能 对后端透明 后端不需要该任何代码 对前端透明 前端不需要或者最好不改代码 实现表单放重复提交 实现重放攻击拦截 实现XSS 脚本跨站攻击实现方案 我们系统的讨论了一周时间实现方案如下 通过JS 监听ajax 请求和form表单请求 并对请求的数据进行加密 通过继承HttpServletRequestWrapper 实现参数解析以及XSS防注入 使用拦截器搭配注解实现表单放重复提交 在提交的JS中加入时间戳的方式配合拦截器和注解实现防重放攻击总体实现方案加密方式 前台数据通过JS对form表单以及AJAX数据进行加密 要兼容一些校验框架 加密数据需要加入时间戳用于后台检查是否解密成功以及其他用处 后台得到加密的数据进行解密 通过重写HttpServletRequestWrapper 和OncePerRequestFilter 来实现 如果是AJAX提交可能需要PYLOAD形式通过流的形式进行解析表单防重 通过TOKEN形式来实现，网上很多实现，这里不多说了XXS防跨站脚本攻击 通过将参数中的html代码转义来实现 对应的JS加密和Java解密的资源可以查看下载","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://yoursite.com/categories/java/加密/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://yoursite.com/tags/加密/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://yoursite.com/categories/java/加密/"}]},{"title":"携程Apollo(阿波罗)安装部署以及java整合","slug":"携程Apollo-阿波罗-安装部署以及java整合","date":"2019-08-02T21:48:53.000Z","updated":"2019-08-02T22:39:24.041Z","comments":true,"path":"携程Apollo-阿波罗-安装部署以及java整合.html","link":"","permalink":"http://yoursite.com/携程Apollo-阿波罗-安装部署以及java整合.html","excerpt":"","text":"携程Apollo（阿波罗）安装部署以及java整合服务器部署可以按照apollo wiki 进行部署https://github.com/ctripcorp/apollo/wiki/Quick-Start 安装 Java 环境java 创建数据库Apollo服务端共需要两个数据库：ApolloPortalDB和ApolloConfigDB，我们把数据库、表的创建和样例数据都分别准备了sql文件，只需要导入数据库即可。执行两个sql文件sql/apolloportaldb.sqlsql/apolloconfigdb.sql会创建两个数据库 下载安装包https://github.com/nobodyiam/apollo-build-scripts 服务器部署将快速部署包apollo-quick-start放进服务器解压文件 服务器配置Apollo服务端需要知道如何连接到你前面创建的数据库，所以需要编辑demo.sh，修改ApolloPortalDB和ApolloConfigDB相关的数据库连接串信息。 123456789#apollo config db infoapollo_config_db_url=jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8apollo_config_db_username=用户名apollo_config_db_password=密码（如果没有密码，留空即可）# apollo portal db infoapollo_portal_db_url=jdbc:mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8apollo_portal_db_username=用户名apollo_portal_db_password=密码（如果没有密码，留空即可） 修改服务器端口地址信息 meta server url123config_server_url=http://10.168.16.125:8080admin_server_url=http://10.168.16.125:8090portal_url=http://10.168.16.125:8070 如果部署在linux服务器上需要将地址改为服务器IP地址注意：不要修改demo.sh的其它部分 确保端口未被占用Quick Start脚本会在本地启动3个服务，分别使用8070, 8080, 8090端口，请确保这3个端口当前没有被使用。 例如，在Linux/Mac下，可以通过如下命令检查： lsof -i:8080 执行启动脚本 ./demo.sh start 当看到如下输出后，就说明启动成功了！ 123456789101112==== starting service ====Service logging file is ./service/apollo-service.logStarted [10768]Waiting for config service startup.......Config service started. You may visit http://localhost:8080 for service status now!Waiting for admin service startup....Admin service started==== starting portal ====Portal logging file is ./portal/apollo-portal.logStarted [10846]Waiting for portal startup......Portal started. You can visit http://localhost:8070 now! 使用Apollo配置中心访问 服务器的IP:8070 可以进行访问例如 ：http://10.168.16.125:8070 默认 用户名密码是 apollo admin登陆后如下界面 可以创建自己的项目 添加namespacenamespace 相当于配置文件名称在namespace中添加属性，可以以文本形式添加 可以自己研究琢磨下 java服务整合pom整合官方提供的maven 12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt; 发现拉不下来jar包解决方案下载源代码https://github.com/ctripcorp/apollo.git编译其中的 apollo-client 包并安装到本地引入编译后的jar包即可 12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;0.10.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 现有应用接入在应用接入Apollo之后，这些配置是可以非常方便的迁移到Apollo的，具体步骤如下： 在Apollo为应用新建项目在应用中配置好META-INF/app.properties把原先配置（必须是properties格式）复制一下，然后通过Apollo提供的文本编辑模式全部粘帖到应用的application namespace，发布配置如果原来是其它格式，如yml，请先转成properties格式把原先的配置文件如bootstrap.properties, application.properties从项目中删除 app.properties 内容是创建项目的APPID（应用ID）如前面创建的12345 12# testapp.id=12345 并在resources 下加入apollo-env.properties 各环境的服务器地址 123456local.meta=http://10.168.16.125:8080dev.meta=http://10.168.16.125:8080fat.meta=$&#123;fat_meta&#125;uat.meta=$&#123;uat_meta&#125;lpt.meta=$&#123;lpt_meta&#125;pro.meta=$&#123;pro_meta&#125; 修改环境修改/opt/settings/server.properties（Mac/Linux）或C:\\opt\\settings\\server.properties（Windows）文件，设置env为DEV： 1env=DEV Spring 整合apollo启动配置1&lt;apollo:config/&gt; apollo加载namespace配置1&lt;apollo:config namespaces=&quot;dubbo&quot; order=&quot;1&quot;/&gt; ####官方配置如下Apollo也支持和Spring整合（Spring 3.1.1+），只需要做一些简单的配置就可以了。 Apollo目前既支持比较传统的基于XML的配置，也支持目前比较流行的基于Java（推荐）的配置。 需要注意的是，如果之前有使用org.springframework.beans.factory.config.PropertyPlaceholderConfigurer的，请替换成org.springframework.context.support.PropertySourcesPlaceholderConfigurer。Spring 3.1以后就不建议使用PropertyPlaceholderConfigurer了，要改用PropertySourcesPlaceholderConfigurer。 基于XML的配置注：需要把apollo相关的xml namespace加到配置文件头上，不然会报xml语法错误。 1.注入默认namespace的配置到Spring中 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:apollo=\"http://www.ctrip.com/schema/apollo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.ctrip.com/schema/apollo http://www.ctrip.com/schema/apollo.xsd\"&gt; &lt;!-- 这个是最简单的配置形式，一般应用用这种形式就可以了，用来指示Apollo注入application namespace的配置到Spring环境中 --&gt; &lt;apollo:config/&gt; &lt;bean class=\"com.ctrip.framework.apollo.spring.TestXmlBean\"&gt; &lt;property name=\"timeout\" value=\"$&#123;timeout:100&#125;\"/&gt; &lt;property name=\"batch\" value=\"$&#123;batch:200&#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 2.注入多个namespace的配置到Spring中 123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:apollo=&quot;http://www.ctrip.com/schema/apollo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.ctrip.com/schema/apollo http://www.ctrip.com/schema/apollo.xsd&quot;&gt; &lt;!-- 这个是最简单的配置形式，一般应用用这种形式就可以了，用来指示Apollo注入application namespace的配置到Spring环境中 --&gt; &lt;apollo:config/&gt; &lt;!-- 这个是稍微复杂一些的配置形式，指示Apollo注入FX.apollo和FX.soa namespace的配置到Spring环境中 --&gt; &lt;apollo:config namespaces=&quot;FX.apollo,FX.soa&quot;/&gt; &lt;bean class=&quot;com.ctrip.framework.apollo.spring.TestXmlBean&quot;&gt; &lt;property name=&quot;timeout&quot; value=&quot;$&#123;timeout:100&#125;&quot;/&gt; &lt;property name=&quot;batch&quot; value=&quot;$&#123;batch:200&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt; dubbo服务整合123456789101112 &lt;apollo:config/&gt;&lt;apollo:config namespaces=\"dubbo\" order=\"1\"/&gt; &lt;!-- 公共信息，也可以用dubbo.properties配置 --&gt; &lt;dubbo:application name=\"$&#123;dubbo.application.name&#125;\" /&gt; &lt;!-- 需要强制指定地址，配置文件默认可以不配置 --&gt; &lt;dubbo:registry address=\"$&#123;dubbo.registry.address&#125;\"/&gt; &lt;bean id=\"xxxService\" class=\"com.xxx.cache.service.impl.RedisServiceImpl\"/&gt; &lt;dubbo:service interface=\"com.xxx.xxx.service.RedisService\" ref=\"redisService\" version=\"$&#123;dubbo.version&#125;\"/&gt; dubbo 默认没有不需要配置，但使用apollo后没有自动注入dubbo注册地址，需要手动声明,原因待定 1&lt;dubbo:registry address=&quot;$&#123;dubbo.registry.address&#125;&quot;/&gt;","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"apollo","slug":"java/apollo","permalink":"http://yoursite.com/categories/java/apollo/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"apollo","slug":"apollo","permalink":"http://yoursite.com/tags/apollo/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"apollo","slug":"java/apollo","permalink":"http://yoursite.com/categories/java/apollo/"}]},{"title":"MYBATIS热部署","slug":"MYBATIS热部署","date":"2019-08-02T14:41:56.000Z","updated":"2019-08-02T23:16:43.097Z","comments":true,"path":"MYBATIS热部署.html","link":"","permalink":"http://yoursite.com/MYBATIS热部署.html","excerpt":"","text":"mybatis热部署最近在使用mybatis，由于是刚刚开始用，用的并不顺手，目前是感觉有2个地方非常的不好用： mybatis调试不方便 ​ 由于dao层只有接口，实现只是一个map的xml文件，想加断点都没有地方加，直接导致的后果就是有时候出错了，完全是各种闭眼尝试，抓狂中。。。倒是可以把调试级别改成debug，会把执行的sql，以及参数都输出到控制台，可是一改成debug，那控制台输出的内容，就实在多到让人发指，甚至都会影响到代码的编写及调试，而且输出日志跟打断点调试根本就不是一个级别的。目前仍旧无法解决改问题。 mybatis改sql要不停的重启服务 ​ 这个真心不能忍，map文件在系统重动后，map文件只加载一次，再修改map文件就不会生效了，如果要生效，就需要不停的重启服务。 ​ 后来找到一个办法，就是使用Mybatis-Plus插件。 Mybatis-Plus插件的用法 pom.xml的内容： 123456789101112131415161718 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;lib.dir&#125;/mybatis-plus-1.5.jar&lt;/systemPath&gt; &lt;/dependency&gt; ​ 因为看Mybatis-Plus插件官网的说法，就是添加Mybatis-Plus插件会添加mybatis的依赖包，我已经引过mybatis的包了，不想让他再给我引了。 Mybatis-Plus插件的地址：http://mvnrepository.com/artifact/com.baomidou/mybatis-plus/1.5 2. 然后修改spring的配置文件： 修改前 123&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dynamicDataSource\" /&gt;&lt;property name=\"configLocation\" value=\"classpath:conf/mybatis-config.xml\"&gt;&lt;/property&gt; 123456789101112 修改后 ```xml &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dynamicDataSource&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:conf/mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/huarui/mapping/$&#123;jdbc.dialect&#125;/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.spring.MybatisMapperRefresh&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;constructor-arg name=&quot;mapperLocations&quot; value=&quot;classpath:com/huarui/mapping/$&#123;jdbc.dialect&#125;/*.xml&quot;/&gt; &lt;constructor-arg name=&quot;delaySeconds&quot; value=&quot;5&quot;/&gt; &lt;constructor-arg name=&quot;sleepSeconds&quot; value=&quot;10&quot;/&gt; &lt;constructor-arg name=&quot;enabled&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt; ​ 修改后，改sql就会自动热加载了，其实也不是实时加载，原理是每隔一个时间刷新一下map，我这里设置的是delaySeconds是5秒，sleepSeconds是10秒。 来源: http://www.cnblogs.com/modou/p/6131354.html","categories":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"mybatis","slug":"java/mybatis","permalink":"http://yoursite.com/categories/java/mybatis/"}],"tags":[{"name":"java","slug":"java","permalink":"http://yoursite.com/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://yoursite.com/categories/java/"},{"name":"mybatis","slug":"java/mybatis","permalink":"http://yoursite.com/categories/java/mybatis/"}]}]}