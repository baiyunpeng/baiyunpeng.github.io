{"meta":{"title":"晓风残月的博客","subtitle":"晓风残月","description":"个人技术的一些积累","author":"晓风残月","url":"http://www.baiyp.ren"},"pages":[],"posts":[{"title":"java多线程-02","slug":"java多线程-02","date":"2019-08-03T01:23:46.000Z","updated":"2019-08-03T22:08:44.831Z","comments":true,"path":"java多线程-02.html","link":"","permalink":"http://www.baiyp.ren/java多线程-02.html","excerpt":"","text":"ThreadLocal辨析与Synchonized的比较​ ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程访问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。​ Spring的事务就借助了ThreadLocal类。Spring会从数据库连接池中获得一个connection，然会把connection放进ThreadLocal中，也就和线程绑定了，事务需要提交或者回滚，只要从ThreadLocal中拿到connection进行操作。为何Spring的事务要借助ThreadLocal类？以JDBC为例，正常的事务代码可能如下：12345678910111213dbc = new DataBaseConnection();//第1行Connection con = dbc.getConnection();//第2行con.setAutoCommit(false);// //第3行con.executeUpdate(...);//第4行con.executeUpdate(...);//第5行con.executeUpdate(...);//第6行con.commit();////第7行上述代码，可以分成三个部分:事务准备阶段：第1～3行业务处理阶段：第4～6行事务提交阶段：第7行可以很明显的看到，不管我们开启事务还是执行具体的sql都需要一个具体的数据库连接。​ 现在我们开发应用一般都采用三层结构，如果我们控制事务的代码都放在DAO(DataAccessObject)对象中，在DAO对象的每个方法当中去打开事务和关闭事务，当Service对象在调用DAO时，如果只调用一个DAO，那我们这样实现则效果不错，但往往我们的Service会调用一系列的DAO对数据库进行多次操作，那么，这个时候我们就无法控制事务的边界了，因为实际应用当中，我们的Service调用的DAO的个数是不确定的，可根据需求而变化，而且还可能出现Service调用Service的情况。​ 但是需要注意一个问题，如何让三个DAO使用同一个数据源连接呢？我们就必须为每个DAO传递同一个数据库连接，要么就是在DAO实例化的时候作为构造方法的参数传递，要么在每个DAO的实例方法中作为方法的参数传递。这两种方式无疑对我们的Spring框架或者开发人员来说都不合适。为了让这个数据库连接可以跨阶段传递，又不显示的进行参数传递，就必须使用别的办法。​ Web容器中，每个完整的请求周期会由一个线程来处理。因此，如果我们能将一些参数绑定到线程的话，就可以实现在软件架构中跨层次的参数共享（是隐式的共享）。而JAVA中恰好提供了绑定的方法–使用ThreadLocal。结合使用Spring里的IOC和AOP，就可以很好的解决这一点。只要将一个数据库连接放入ThreadLocalThreadLocalThreadLocal的使用ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：void set(Object value)设置当前线程的线程局部变量的值。public Object get()该方法返回当前线程所对应的线程局部变量。public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。1public final static ThreadLocal&lt;String&gt; RESOURCE = new ThreadLocal&lt;String&gt;();RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。实现解析threadLo1234567891011121314151617public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;​ 上面先取到当前线程，然后调用getMap方法获取对应的ThreadLocalMap，ThreadLocalMap是ThreadLocal的静态内部类，然后Thread类中有一个这样类型成员，所以getMap是直接返回Thread的成员。看下ThreadLocal的内部类ThreadLocalMap源码：​ 可以看到有个Entry内部静态类，它继承了WeakReference，总之它记录了两个信息，一个是ThreadLocal&lt;?&gt;类型，一个是Object类型的值。getEntry方法则是获取某个ThreadLocal对应的值，set方法就是更新或赋值相应的ThreadLocal对应的值。​ 回顾我们的get方法，其实就是拿到每个线程独有的ThreadLocalMap然后再用ThreadLocal的当前实例，拿到Map中的相应的Entry，然后就可以拿到相应的值返回出去。当然，如果Map为空，还会先进行map的创建，初始化等工作。引发的内存泄漏分析预备知识引用Object o = new Object();这个o，我们可以称之为对象引用，而new Object()我们可以称之为在内存中产生了一个对象实例。当写下 o=null时，只是表示o不再指向堆中object的对象实例，不代表这个对象实例不存在了。强引用: 就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。软引用: 是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。弱引用: 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在JDK 1.2之后，提供了WeakReference类来实现弱引用。虚引用: 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在之后，提供了类来实现虚引用内存泄漏的现象1234567891011121314151617181920212223242526272829303132333435363738/** * 类说明：ThreadLocal造成的内存泄漏演示 */public class ThreadLocalOOM &#123; private static final int TASK_LOOP_SIZE = 500; final static ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;()); static class LocalVariable &#123; private byte[] a = new byte[1024*1024*5];/*5M大小的数组*/ &#125; final static ThreadLocal&lt;LocalVariable&gt; localVariable = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; Object o = new Object(); /*5*5=25*/ for (int i = 0; i &lt; TASK_LOOP_SIZE; ++i) &#123; poolExecutor.execute(new Runnable() &#123; public void run() &#123; //localVariable.set(new LocalVariable()); new LocalVariable(); System.out.println(\"use local varaible\"); //localVariable.remove(); &#125; &#125;); Thread.sleep(100); &#125; System.out.println(\"pool execute over\"); &#125;&#125;首先只简单的在每个任务中new出一个数组可以看到内存的实际使用控制在25M左右：因为每个任务中会不断new出一个5M的数组，5*5=25M，这是很合理的。当我们启用了ThreadLocal以后：内存占用最高升至150M，一般情况下稳定在90M左右，那么加入一个ThreadLocal后，内存的占用真的会这么多？于是，我们加入一行代码：再执行，看看内存情况:可以看见最高峰的内存占用也在25M左右，完全和我们不加ThreadLocal表现一样。这就充分说明，确实发生了内存泄漏。分析根据我们前面对ThreadLocal的分析，我们可以知道每个Thread 维护一个 ThreadLocalMap，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object，也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。仔细观察ThreadLocalMap，这个map是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。因此使用了ThreadLocal后，引用链如图所示图中的虚线表示弱引用。​ 这样，当把threadlocal变量置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被gc回收。这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：​ Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，而这块value永远不会被访问到了，所以存在着内存泄露。​ 只有当前thread结束以后，current thread就不会存在栈中，强引用断开，Current Thread、Map value将全部被GC回收。最好的做法是不在需要使用ThreadLocal变量后，都调用它的remove()方法，清除数据。​ 其实考察ThreadLocal的实现，我们可以看见，无论是get()、set()在某些时候，调用了expungeStaleEntry方法用来清除Entry中Key为null的Value，但是这是不及时的，也不是每次都会执行的，所以一些情况下还是会发生内存泄露。只有remove()方法中显式调用了expungeStaleEntry方法。​ 从表面上看内存泄漏的根源在于使用了弱引用，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？下面我们分两种情况讨论：​ key 使用强引用：引用ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal的对象实例不会被回收，导致Entry内存泄漏。​ key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal的对象实例也会被回收。value在下一次ThreadLocalMap调用set，get，remove都有机会被回收。​ 比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障。​ 因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。总结​ JVM利用设置ThreadLocalMap的Key为弱引用，来避免内存泄露。JVM利用调用remove、get、set方法的时候，回收弱引用。当ThreadLocal存储很多Key为null的Entry的时候，而不再去调用remove、get、set方法，那么将导致内存泄漏。使用线程池+ ThreadLocal 时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了value可能造成累积的情况。错误使用ThreadLocal导致线程不安全123456789101112131415161718192021222324252627282930313233343536373839404142434445464748** * 类说明：ThreadLocal的线程不安全演示 */public class ThreadLocalUnsafe implements Runnable &#123; public Number number = new Number(0); public void run() &#123; //每个线程计数加一 number.setNum(number.getNum()+1); //将其存储到ThreadLocal中 value.set(number); SleepTools.ms(2); //输出num值 System.out.println(Thread.currentThread().getName()+\"=\"+value.get().getNum()); &#125; public static ThreadLocal&lt;Number&gt; value = new ThreadLocal&lt;Number&gt;() &#123; &#125;; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new ThreadLocalUnsafe()).start(); &#125; &#125; private static class Number &#123; public Number(int num) &#123; this.num = num; &#125; private int num; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; @Override public String toString() &#123; return \"Number [num=\" + num + \"]\"; &#125; &#125;&#125;运行后的结果为如果我们加入SleepTools.ms(2);会看的更明显​ 为什么每个线程都输出5？难道他们没有独自保存自己的Number副本吗？为什么其他线程还是能够修改这个值？仔细考察ThreadLocal和Thead的代码，我们发现ThreadLocalMap中保存的其实是对象的一个引用，这样的话，当有其他线程对这个引用指向的对象实例做修改时，其实也同时影响了所有的线程持有的对象引用所指向的同一个对象实例。这也就是为什么上面的程序为什么会输出一样的结果：5个线程中保存的是同一Number对象的引用，在线程睡眠的时候，其他线程将num变量进行了修改，而修改的对象Number的实例是同一份，因此它们最终输出的结果是相同的。而上面的程序要正常的工作，应该的用法是让每个线程中的ThreadLocalNumber线程间的协作​ 线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。却存在如下问题：1） 难以确保及时性。2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。等待/通知机制​ 是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。notify()：​ 通知一个在对象上等待的线程,使其从wait方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING状态。notifyAll()：​ 通知所有等待在该对象上的线程wait()​ 调用该方法的线程进入 WAITING状态,只有等待另外线程的通知或被中断才会返回.需要注意,调用wait()方法后,会释放对象的锁wait(long)​ 超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n毫秒,如果没有通知就超时返回wait (long,int)​ 对于超时时间更细粒度的控制,可以达到纳秒等待和通知的标准范式等待方遵循如下原则。1）获取对象的锁。2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。3）条件满足则执行对应的逻辑。123456synchronized (对象)&#123; while(条件不满足)&#123; 对象.wait(); &#125; 对应的处理逻辑 &#125;通知方遵循如下原则。1）获得对象的锁。2）改变条件。3）通知所有等待在对象上的线程1234synchronized (对象)&#123; 改变条件 对象.notifyAll();&#125;​ 在调用wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法、notify()系列方法，进入wait()方法后，当前线程释放锁，在从wait()返回前，线程与其他线程竞争重新获得锁， 执行notify()系列方法的线程退出调用了notifyAll的synchronized代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。notify和notifyAll应该用谁​ 尽可能用notifyall()，谨慎使用notify()，因为notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程，具体表现参见代码。","categories":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://www.baiyp.ren/categories/java/多线程/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://www.baiyp.ren/tags/多线程/"},{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://www.baiyp.ren/tags/ThreadLocal/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://www.baiyp.ren/categories/java/多线程/"}]},{"title":"java多线程-01","slug":"java多线程-01","date":"2019-08-02T23:23:07.000Z","updated":"2019-08-03T22:07:48.167Z","comments":true,"path":"java多线程-01.html","link":"","permalink":"http://www.baiyp.ren/java多线程-01.html","excerpt":"","text":"多线程概述基础概念进程和线程进程是程序运行资源分配的最小单位​ 进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘IO等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。​ 进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。线程是CPU调度的最小单位,必须依赖于进程而存在​ 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程无处不在​ 任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。CPU核心数和线程数的关系​ 多核心:也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理多线程: Simultaneous Multithreading.简称SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。核心数、线程数:目前主流CPU都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系CPU时间片轮转机制​ 我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。​ 时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。百度百科对CPU时间片轮转机制原理解释如下:​ 如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾​ 时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。​ 为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发​ 结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。​ 在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KILL掉的,我想也正是因为这种机制的缘故。澄清并行和并发​ 我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的并行车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。当谈论并发的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。​ 俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。综合来说：​ 并发:指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.​ 并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行两者区别:一个是交替执行,一个是同时执行.高并发编程的意义、好处和注意事项​ 由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。1. 充分利用CPU的资源​ 从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU,如果还是使用单线程的技术做思路,明显就out了。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。​ 就像我们平时坐地铁一样,很多人坐长线地铁的时候都在认真看书,而不是为了坐地铁而坐地铁,到家了再去看书,这样你的时间就相当于有了两倍。这就是为什么有些人时间很充裕,而有些人老是说没时间的一个原因,工作也是这样,有的时候可以并发地去做几件事情,充分利用我们的时间,CPU也是一样,也要充分利用。2. 加快响应用户的时间​ 比如我们经常用的迅雷下载,都喜欢多开几个线程去下载,谁都不愿意用一个线程去下载,为什么呢?答案很简单,就是多个线程下载快啊。​ 我们在做程序开发的时候更应该如此,特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。3. 可以使你的代码模块化,异步化,简单化​ 例如我们实现电商系统，下订单和给用户发送短信、邮件就可以进行拆分，将给用户发送短信、邮件这两个步骤独立为单独的模块，并交给其他线程去执行。这样既增加了异步的操作，提升了系统性能，又使程序模块化,清晰化和简单化。多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。多线程程序需要注意事项1. 线程之间的安全性​ 从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。2. 线程之间的死锁​ 为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生3. 线程太多了会将服务器资源耗尽形成死机当机​ 线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢?​ 某些系统资源是有限的,如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。多线程应用开发的注意事项很多,希望大家在日后的工作中可以慢慢体会它的危险所在。认识Java里的线程Java程序天生就是多线程的​ 一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。[6] Monitor Ctrl-Break //监控Ctrl-Break中断信号的[5] Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等[4] Signal Dispatcher // 分发处理发送给JVM信号的线程[3] Finalizer // 调用对象finalize方法的线程[2] Reference Handler//清除Reference的线程[1] main //main线程，用户程序入口线程的启动与中止启动启动线程的方式有：1、X extends Thread;，然后X.start123456789101112public class ThreadTest extends Thread &#123; @Override public void run() &#123; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); &#125; public static void main(String[] args) &#123; new ThreadTest().start(); &#125;&#125;2、X implements Runnable；然后交给Thread运行12345678910111213public class RunableTest implements Runnable &#123; @Override public void run() &#123; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); &#125; public static void main(String[] args) &#123; RunableTest runableTest = new RunableTest(); new Thread(runableTest).start(); &#125;&#125;Thread和Runnable的区别​ Thread才是Java里对线程的唯一抽象，Runnable只是对任务（业务逻辑）的抽象。Thread可以接受任意一个Runnable的实例并执行。中止线程自然终止要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。stop​ 暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()。但是这些API是过期的，也就是不建议使用的。不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。中断​ 安全的中止则是其他线程通过调用某个线程A的interrupt()方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应，​ 线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。​ 如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait等），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。​ 不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，一般的阻塞方法，如sleep等本身就支持中断的检查，检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。注意：处于死锁状态的线程无法被中断样例代码1234567891011121314151617181920212223242526public class RunableTest implements Runnable &#123; private int i = 0; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted()) &#123; i++; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (i &gt; 10) &#123; Thread.currentThread().interrupt(); &#125; &#125; &#125; public static void main(String[] args) &#123; RunableTest runableTest = new RunableTest(); new Thread(runableTest).start(); &#125;&#125;对Java里的线程再多一点点认识深入理解run()和start()​ Thread类是Java里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。​ start()方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用，如果重复调用会抛出异常。​ 而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。其他的线程相关方法​ yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行yield( )的线程不一定就会持有锁，我们完全可以在释放锁后再调用yield方法。所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。wait()/notify()/notifyAll()：后面会单独讲述join方法​ 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。(此处为常见面试考点)看个栗子12345678910111213141516171819202122232425Thread thread1 = new Thread(() -&gt; &#123; while(!Thread.currentThread().isInterrupted()) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"11111111111\"); &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; while(!Thread.currentThread().isInterrupted()) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"222222222222\"); &#125; &#125;); thread1.start(); //在此处join 其他线程会等待thread1 执行完成后在执行thread2 thread1.join(); thread2.start();执行结果12345678910111213141516171111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111第二种情况12345... thread1.start(); thread2.start(); //在此处join 因为下面没有等待启动的线程，所以和不加thread1.join();一样，是交替执行的 thread1.join();执行结果1234567891011121311111111111111111111112222222222221111111111122222222222211111111111222222222222111111111112222222222222222222222221111111111111111111111222222222222线程的优先级​ 在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。​ 设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。守护线程​ Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。​ Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。线程间的共享和协作线程间的共享synchronized内置锁​ 线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。​ Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。对象锁和类锁：对象锁是用于对象实例方法，或者一个对象实例上的，类锁是用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。方法锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 方法锁 不同的方法可以并行的 */public class RunableTest &#123; public synchronized void test1() &#123; System.out.println(\"test111\"); &#125; public synchronized void test2() &#123; System.out.println(\"test222\"); &#125; public synchronized void test3() &#123; System.out.println(\"test333\"); &#125; public static void main(String[] args) &#123; RunableTest RunableTest = new RunableTest(); new Thread(() -&gt; &#123; while (true) &#123; sleep(1); RunableTest.test1(); &#125; &#125;).start(); new Thread(() -&gt; &#123; while (true) &#123; sleep(1); RunableTest.test2(); &#125; &#125;).start(); new Thread(() -&gt; &#123; while (true) &#123; sleep(1); RunableTest.test3(); &#125; &#125;).start(); &#125; public static void sleep(int sec) &#123; try &#123; Thread.sleep(sec * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125;对象锁123456789101112131415161718192021222324252627282930/** * 对象锁 用一个对象锁的话 先获取锁在执行 * 如果是多个对象可以并行的 */ private Object lock = new Object(); public void test1() &#123; synchronized (lock) &#123; sleep(1); System.out.println(\"test111\"); &#125; &#125; public void test2() &#123; synchronized (lock) &#123; sleep(1); System.out.println(\"test222\"); &#125; &#125; public void test3() &#123; synchronized (lock) &#123; sleep(1); System.out.println(\"test333\"); &#125; &#125;类锁1234567891011121314151617181920212223242526/** *类锁 用一个对象锁的话 先获取锁在执行 */public void test1() &#123; synchronized (RunableTest.class) &#123; sleep(1); System.out.println(\"test111\"); &#125; &#125; public void test2() &#123; synchronized (RunableTest.class) &#123; sleep(1); System.out.println(\"test222\"); &#125; &#125; public void test3() &#123; synchronized (RunableTest.class) &#123; sleep(1); System.out.println(\"test333\"); &#125; &#125;错误的加锁和原因分析12345678910private Integer num = 0; public void test1() &#123; synchronized (num) &#123; sleep(1); num++; System.out.println(\"test111\"+Thread.currentThread().getId()); &#125; &#125;我们反编译代码后12345678public void test1() &#123; synchronized(this.num) &#123; sleep(1); Integer var2 = this.num; Integer var3 = this.num = this.num + 1; System.out.println(\"test111\" + Thread.currentThread().getId()); &#125;&#125;本质上是返回了一个新的Integer对象。也就是每个线程实际加锁的是不同的Integer对象。volatile，最轻量的同步机制​ volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的​ 不加volatile时，子线程无法感知主线程修改了ready的值，从而不会退出循环，而加了volatile后，子线程可以感知主线程修改了ready的值，迅速退出循环。但是volatile不能保证数据在多个线程下同时写时的线程安全volatile最适用的场景：一个线程写，多个线程读。","categories":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://www.baiyp.ren/categories/java/多线程/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"多线程","slug":"多线程","permalink":"http://www.baiyp.ren/tags/多线程/"},{"name":"synchronized","slug":"synchronized","permalink":"http://www.baiyp.ren/tags/synchronized/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"多线程","slug":"java/多线程","permalink":"http://www.baiyp.ren/categories/java/多线程/"}]},{"title":"JsonValidator工具类","slug":"JsonValidator工具类","date":"2018-05-19T23:08:50.000Z","updated":"2019-08-03T23:14:11.343Z","comments":true,"path":"JsonValidator工具类.html","link":"","permalink":"http://www.baiyp.ren/JsonValidator工具类.html","excerpt":"","text":"JsonValidator工具类JsonValidator 是用来校验字符串是否是JSON格式​ 是我用来加前后端段解密时候用到的，前端加密成JSON格式后端需要解密，所以需要对JSON格式做一个校验，网上找到了这个工具类，比较好用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246/** * 用于校验一个字符串是否是合法的JSON格式 */import com.google.common.cache.Cache;import com.google.common.cache.CacheBuilder;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.text.CharacterIterator;import java.text.StringCharacterIterator;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;public class JsonValidator &#123; private static final Logger logger = LoggerFactory.getLogger(JsonValidator.class); private final static Cache&lt;String, JsonValidator&gt; jsonValidatorCache = CacheBuilder.newBuilder() //设置cache的初始大小为10，要合理设置该值 .initialCapacity(10) //设置并发数为5，即同一时间最多只能有5个线程往cache执行写入操作 .concurrencyLevel(10) //构建cache实例 .build(); private CharacterIterator it; private char c; private int col; private JsonValidator() &#123; &#125; public static JsonValidator getJsonValidator() throws ExecutionException &#123; return getJsonValidator(\"JsonValidator\"); &#125; public static JsonValidator getJsonValidator(final String key) throws ExecutionException &#123; return jsonValidatorCache.get(key, new Callable&lt;JsonValidator&gt;() &#123; @Override public JsonValidator call() throws Exception &#123; logger.info(\"[RBRequestParameter] - [getJsonValidator] - key:&#123;&#125; - 创建对象\", key); return new JsonValidator(); &#125; &#125;); &#125; private static boolean error(String type, int col) &#123; System.out.printf(\"type: %s, col: %s%s\", type, col, System.getProperty(\"line.separator\")); return false; &#125; public static void main(String[] args) throws ExecutionException &#123; boolean n = JsonValidator.getJsonValidator().validate(\"[\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\"]\"); System.out.println(n); n = JsonValidator.getJsonValidator().validate(\"[\\\"906102\\\",\\\"906102\\\",\\\"906102\\\",\\\"906102\\\",\\\"906101\\\",\\\"906101\\\",\\\"906101\\\",\\\"906101\\\",\\\"906101\\\",\\\"906101\\\"]\"); System.out.println(n); &#125; /** * 验证一个字符串是否是合法的JSON串 * * @param input 要验证的字符串 * @return true-合法 ，false-非法 */ public boolean validate(String input) &#123; input = input.trim(); boolean ret = valid(input); return ret; &#125; private boolean valid(String input) &#123; if (\"\".equals(input)) return true; boolean ret = true; it = new StringCharacterIterator(input); c = it.first(); col = 1; if (!value()) &#123; ret = error(\"value\", 1); &#125; else &#123; skipWhiteSpace(); if (c != CharacterIterator.DONE) &#123; ret = error(\"end\", col); &#125; &#125; return ret; &#125; private boolean value() &#123; return literal(\"true\") || literal(\"false\") || literal(\"null\") || string() || number() || object() || array(); &#125; private boolean literal(String text) &#123; CharacterIterator ci = new StringCharacterIterator(text); char t = ci.first(); if (c != t) return false; int start = col; boolean ret = true; for (t = ci.next(); t != CharacterIterator.DONE; t = ci.next()) &#123; if (t != nextCharacter()) &#123; ret = false; break; &#125; &#125; nextCharacter(); if (!ret) error(\"literal \" + text, start); return ret; &#125; private boolean array() &#123; return aggregate('[', ']', false); &#125; private boolean object() &#123; return aggregate('&#123;', '&#125;', true); &#125; private boolean aggregate(char entryCharacter, char exitCharacter, boolean prefix) &#123; if (c != entryCharacter) return false; nextCharacter(); skipWhiteSpace(); if (c == exitCharacter) &#123; nextCharacter(); return true; &#125; for (; ; ) &#123; if (prefix) &#123; int start = col; if (!string()) return error(\"string\", start); skipWhiteSpace(); if (c != ':') return error(\"colon\", col); nextCharacter(); skipWhiteSpace(); &#125; if (value()) &#123; skipWhiteSpace(); if (c == ',') &#123; nextCharacter(); &#125; else if (c == exitCharacter) &#123; break; &#125; else &#123; return error(\"comma or \" + exitCharacter, col); &#125; &#125; else &#123; return error(\"value\", col); &#125; skipWhiteSpace(); &#125; nextCharacter(); return true; &#125; private boolean number() &#123; if (!Character.isDigit(c) &amp;&amp; c != '-') return false; int start = col; if (c == '-') nextCharacter(); if (c == '0') &#123; nextCharacter(); &#125; else if (Character.isDigit(c)) &#123; while (Character.isDigit(c)) nextCharacter(); &#125; else &#123; return error(\"number\", start); &#125; if (c == '.') &#123; nextCharacter(); if (Character.isDigit(c)) &#123; while (Character.isDigit(c)) nextCharacter(); &#125; else &#123; return error(\"number\", start); &#125; &#125; if (c == 'e' || c == 'E') &#123; nextCharacter(); if (c == '+' || c == '-') &#123; nextCharacter(); &#125; if (Character.isDigit(c)) &#123; while (Character.isDigit(c)) nextCharacter(); &#125; else &#123; return error(\"number\", start); &#125; &#125; return true; &#125; private boolean string() &#123; if (c != '\"') return false; int start = col; boolean escaped = false; for (nextCharacter(); c != CharacterIterator.DONE; nextCharacter()) &#123; if (!escaped &amp;&amp; c == '\\\\') &#123; escaped = true; &#125; else if (escaped) &#123; if (!escape()) &#123; return false; &#125; escaped = false; &#125; else if (c == '\"') &#123; nextCharacter(); return true; &#125; &#125; return error(\"quoted string\", start); &#125; private boolean escape() &#123; int start = col - 1; if (\" \\\\\\\"/bfnrtu\".indexOf(c) &lt; 0) &#123; return error(\"escape sequence \\\\\\\",\\\\\\\\,\\\\/,\\\\b,\\\\f,\\\\n,\\\\r,\\\\t or \\\\uxxxx \", start); &#125; if (c == 'u') &#123; if (!ishex(nextCharacter()) || !ishex(nextCharacter()) || !ishex(nextCharacter()) || !ishex(nextCharacter())) &#123; return error(\"unicode escape sequence \\\\uxxxx \", start); &#125; &#125; return true; &#125; private boolean ishex(char d) &#123; return \"0123456789abcdefABCDEF\".indexOf(c) &gt;= 0; &#125; private char nextCharacter() &#123; c = it.next(); ++col; return c; &#125; private void skipWhiteSpace() &#123; while (Character.isWhitespace(c)) &#123; nextCharacter(); &#125; &#125;&#125;","categories":[{"name":"片段","slug":"片段","permalink":"http://www.baiyp.ren/categories/片段/"},{"name":"JsonValidator","slug":"片段/JsonValidator","permalink":"http://www.baiyp.ren/categories/片段/JsonValidator/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"json","slug":"json","permalink":"http://www.baiyp.ren/tags/json/"},{"name":"JsonValidator","slug":"JsonValidator","permalink":"http://www.baiyp.ren/tags/JsonValidator/"}],"keywords":[{"name":"片段","slug":"片段","permalink":"http://www.baiyp.ren/categories/片段/"},{"name":"JsonValidator","slug":"片段/JsonValidator","permalink":"http://www.baiyp.ren/categories/片段/JsonValidator/"}]},{"title":"HttpClient工具类","slug":"HttpClient工具类","date":"2018-05-03T23:00:42.000Z","updated":"2019-08-03T23:13:57.068Z","comments":true,"path":"HttpClient工具类.html","link":"","permalink":"http://www.baiyp.ren/HttpClient工具类.html","excerpt":"","text":"HttpClient工具类HttpClient 是用来远程访问页面或者调用Http接口的，可以用来调用接口喝着爬虫都可以​收藏好久的工具类展示以下，用了很长时间，也是从其他地方收集过来的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URISyntaxException;import java.util.ArrayList;import java.util.List;import java.util.Map;import com.alibaba.fastjson.JSON;import org.apache.commons.httpclient.HttpStatus;import org.apache.http.HttpEntity;import org.apache.http.HttpException;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.HttpClient;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.HttpRequestBase;import org.apache.http.client.utils.URLEncodedUtils;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicHeader;import org.apache.http.message.BasicNameValuePair;import org.apache.http.protocol.HTTP;import org.apache.http.util.EntityUtils;import org.springframework.util.Assert;public class HttpClientUtils &#123; private HttpClientUtils()&#123;&#125; /** * 连接超时时间 */ public static final int CONNECTION_TIMEOUT_MS = 5000; /** * 读取数据超时时间 */ public static final int SO_TIMEOUT_MS = 5000; public static final String utf8 = \"UTF-8\"; public static final String application_json = \"application/json\"; public static final String gbk = \"GBK\"; /** * 简单get调用 * * @param url * @param params * @return * @throws ClientProtocolException * @throws IOException * @throws URISyntaxException */ public static String get(String url, Map&lt;String, String&gt; params) throws IOException, URISyntaxException &#123; return get(url, params, utf8); &#125; /** * 简单get调用 * * @param url * @param params * @return * @throws ClientProtocolException * @throws IOException * @throws URISyntaxException */ public static String get(String url, Map&lt;String, String&gt; params, String charset) throws IOException, URISyntaxException &#123; HttpClient client = buildHttpClient(true); HttpGet get = buildHttpGet(url, params, charset); HttpResponse response = client.execute(get); assertStatus(response); HttpEntity entity = response.getEntity(); if (entity != null) &#123; return EntityUtils.toString(entity, charset); &#125; return null; &#125; /** * 简单post调用 * * @param url * @param params * @return * @throws URISyntaxException * @throws ClientProtocolException * @throws IOException */ public static String post(String url, Map&lt;String, String&gt; params) throws URISyntaxException, IOException &#123; return post(url, params, utf8); &#125; public static String postJSON(String url, Map&lt;String, String&gt; params) throws IOException, URISyntaxException &#123; return postJSON(url, params, utf8); &#125; /** * 简单post调用 * * @param url * @param params * @return * @throws URISyntaxException * @throws ClientProtocolException * @throws IOException */ public static String post(String url, Map&lt;String, String&gt; params, String charset) throws URISyntaxException, IOException &#123; HttpClient client = buildHttpClient(true); HttpPost postMethod = buildHttpPost(url, params, charset); HttpResponse response = client.execute(postMethod); assertStatus(response); HttpEntity entity = response.getEntity(); if (entity != null) &#123; return EntityUtils.toString(entity, charset); &#125; return null; &#125; public static String postJSON(String url, Map params, String charset) throws URISyntaxException, IOException &#123; HttpClient client = buildHttpClient(true); HttpPost postMethod = buildHttpJSONPost(url, params, charset); HttpResponse response = client.execute(postMethod); assertStatus(response); HttpEntity entity = response.getEntity(); if (entity != null) &#123; return EntityUtils.toString(entity, charset); &#125; return null; &#125; /** * 创建HttpClient * * @param isMultiThread * @return */ public static HttpClient buildHttpClient(boolean isMultiThread) &#123; CloseableHttpClient client; if (isMultiThread) client = HttpClientBuilder .create().setDefaultRequestConfig(buildRequestConfig()) .setRetryHandler(new DefaultHttpRequestRetryHandler()) .setConnectionManager( new PoolingHttpClientConnectionManager()).build(); else client = HttpClientBuilder.create().build(); return client; &#125; /** * 构建httpPost对象 * * @param url * @return * @throws UnsupportedEncodingException * @throws URISyntaxException */ public static HttpPost buildHttpPost(String url, Map&lt;String, String&gt; params, String charset) throws UnsupportedEncodingException, URISyntaxException &#123; Assert.notNull(url, \"构建HttpPost时,url不能为null\"); HttpPost post = new HttpPost(url); setCommonHttpMethod(post); if (params != null) &#123; List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; formparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); &#125; HttpEntity he = new UrlEncodedFormEntity(formparams, charset); post.setEntity(he); &#125; return post; &#125; public static HttpPost buildHttpJSONPost(String url, Map&lt;String, String&gt; params, String charset) throws UnsupportedEncodingException, URISyntaxException &#123; Assert.notNull(url, \"构建HttpPost时,url不能为null\"); HttpPost post = new HttpPost(url); setJSONHttpMethod(post); if (params != null) &#123; String json = JSON.toJSONString(params); System.out.println(json); StringEntity stringEntity = new StringEntity(json, utf8); stringEntity.setContentEncoding(new BasicHeader(HTTP.CONTENT_TYPE, application_json)); post.setEntity(stringEntity); &#125; return post; &#125; /** * 构建httpGet对象 * * @param url * @return * @throws URISyntaxException */ public static HttpGet buildHttpGet(String url, Map&lt;String, String&gt; params, String chatset) throws URISyntaxException &#123; Assert.notNull(url, \"构建HttpGet时,url不能为null\"); return new HttpGet(buildGetUrl(url, params, chatset)); &#125; /** * build getUrl str * * @param url * @param params * @return */ private static String buildGetUrl(String url, Map&lt;String, String&gt; params, String charset) &#123; StringBuilder uriStr = new StringBuilder(url); if (params != null) &#123; List&lt;NameValuePair&gt; ps = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; ps.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); &#125; uriStr.append(\"?\"); uriStr.append(URLEncodedUtils.format(ps, charset)); &#125; return uriStr.toString(); &#125; /** * 设置HttpMethod通用配置 * * @param httpMethod */ public static void setCommonHttpMethod(HttpRequestBase httpMethod) &#123; httpMethod.setHeader(HTTP.CONTENT_ENCODING, utf8);// setting &#125; /* 设置HttpMethod通用配置 * * @param httpMethod */ public static void setJSONHttpMethod(HttpRequestBase httpMethod) &#123; httpMethod.setHeader(HTTP.CONTENT_ENCODING, utf8);// setting httpMethod.setHeader(HTTP.CONTENT_TYPE, application_json);// setting &#125; /** * 设置成消息体的长度 setting MessageBody length * * @param httpMethod * @param he */ public static void setContentLength(HttpRequestBase httpMethod, HttpEntity he) &#123; if (he == null) &#123; return; &#125; httpMethod.setHeader(HTTP.CONTENT_LEN, String.valueOf(he.getContentLength())); &#125; /** * 构建公用RequestConfig * * @return */ public static RequestConfig buildRequestConfig() &#123; // 设置请求和传输超时时间 return RequestConfig.custom() .setSocketTimeout(SO_TIMEOUT_MS) .setConnectTimeout(CONNECTION_TIMEOUT_MS).build(); &#125; /** * 强验证必须是200状态否则报异常 * * @param res * @throws HttpException */ static void assertStatus(HttpResponse res) throws IOException &#123; Assert.notNull(res, \"http响应对象为null\"); Assert.notNull(res.getStatusLine(), \"http响应对象的状态为null\"); switch (res.getStatusLine().getStatusCode()) &#123; case HttpStatus.SC_OK: break; default: throw new IOException(\"服务器响应状态异常,失败.\"); &#125; &#125; public static void main(String[] args) throws ClientProtocolException, IOException, URISyntaxException &#123; System.out.println(get(\"http://www.baidu.com\", new HashMap&lt;String, String&gt;())); &#125;&#125;","categories":[{"name":"片段","slug":"片段","permalink":"http://www.baiyp.ren/categories/片段/"},{"name":"httpClient","slug":"片段/httpClient","permalink":"http://www.baiyp.ren/categories/片段/httpClient/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"httpClient","slug":"httpClient","permalink":"http://www.baiyp.ren/tags/httpClient/"}],"keywords":[{"name":"片段","slug":"片段","permalink":"http://www.baiyp.ren/categories/片段/"},{"name":"httpClient","slug":"片段/httpClient","permalink":"http://www.baiyp.ren/categories/片段/httpClient/"}]},{"title":"携程Apollo(阿波罗)安装部署以及java整合","slug":"携程Apollo-阿波罗-安装部署以及java整合","date":"2018-04-02T21:48:53.000Z","updated":"2019-08-03T22:16:46.276Z","comments":true,"path":"携程Apollo-阿波罗-安装部署以及java整合.html","link":"","permalink":"http://www.baiyp.ren/携程Apollo-阿波罗-安装部署以及java整合.html","excerpt":"","text":"携程Apollo（阿波罗）安装部署以及java整合服务器部署可以按照apollo wiki 进行部署https://github.com/ctripcorp/apollo/wiki/Quick-Start安装 Java 环境java创建数据库Apollo服务端共需要两个数据库：ApolloPortalDB和ApolloConfigDB，我们把数据库、表的创建和样例数据都分别准备了sql文件，只需要导入数据库即可。执行两个sql文件sql/apolloportaldb.sqlsql/apolloconfigdb.sql会创建两个数据库下载安装包https://github.com/nobodyiam/apollo-build-scripts服务器部署将快速部署包apollo-quick-start放进服务器解压文件服务器配置Apollo服务端需要知道如何连接到你前面创建的数据库，所以需要编辑demo.sh，修改ApolloPortalDB和ApolloConfigDB相关的数据库连接串信息。123456789#apollo config db infoapollo_config_db_url=jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8apollo_config_db_username=用户名apollo_config_db_password=密码（如果没有密码，留空即可）# apollo portal db infoapollo_portal_db_url=jdbc:mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8apollo_portal_db_username=用户名apollo_portal_db_password=密码（如果没有密码，留空即可）修改服务器端口地址信息meta server url123config_server_url=http://10.168.16.125:8080admin_server_url=http://10.168.16.125:8090portal_url=http://10.168.16.125:8070如果部署在linux服务器上需要将地址改为服务器IP地址注意：不要修改demo.sh的其它部分确保端口未被占用Quick Start脚本会在本地启动3个服务，分别使用8070, 8080, 8090端口，请确保这3个端口当前没有被使用。例如，在Linux/Mac下，可以通过如下命令检查：lsof -i:8080执行启动脚本./demo.sh start当看到如下输出后，就说明启动成功了！123456789101112==== starting service ====Service logging file is ./service/apollo-service.logStarted [10768]Waiting for config service startup.......Config service started. You may visit http://localhost:8080 for service status now!Waiting for admin service startup....Admin service started==== starting portal ====Portal logging file is ./portal/apollo-portal.logStarted [10846]Waiting for portal startup......Portal started. You can visit http://localhost:8070 now!使用Apollo配置中心访问 服务器的IP:8070 可以进行访问例如 ：http://10.168.16.125:8070默认 用户名密码是 apollo admin登陆后如下界面可以创建自己的项目添加namespacenamespace 相当于配置文件名称在namespace中添加属性，可以以文本形式添加可以自己研究琢磨下java服务整合pom整合官方提供的maven12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;发现拉不下来jar包解决方案下载源代码https://github.com/ctripcorp/apollo.git编译其中的 apollo-client 包并安装到本地引入编译后的jar包即可12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;0.10.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;现有应用接入在应用接入Apollo之后，这些配置是可以非常方便的迁移到Apollo的，具体步骤如下：在Apollo为应用新建项目在应用中配置好META-INF/app.properties把原先配置（必须是properties格式）复制一下，然后通过Apollo提供的文本编辑模式全部粘帖到应用的application namespace，发布配置如果原来是其它格式，如yml，请先转成properties格式把原先的配置文件如bootstrap.properties, application.properties从项目中删除app.properties 内容是创建项目的APPID（应用ID）如前面创建的1234512# testapp.id=12345并在resources 下加入apollo-env.properties 各环境的服务器地址123456local.meta=http://10.168.16.125:8080dev.meta=http://10.168.16.125:8080fat.meta=$&#123;fat_meta&#125;uat.meta=$&#123;uat_meta&#125;lpt.meta=$&#123;lpt_meta&#125;pro.meta=$&#123;pro_meta&#125;修改环境修改/opt/settings/server.properties（Mac/Linux）或C:\\opt\\settings\\server.properties（Windows）文件，设置env为DEV：1env=DEVSpring 整合apollo启动配置1&lt;apollo:config/&gt;apollo加载namespace配置1&lt;apollo:config namespaces=&quot;dubbo&quot; order=&quot;1&quot;/&gt;####官方配置如下Apollo也支持和Spring整合（Spring 3.1.1+），只需要做一些简单的配置就可以了。Apollo目前既支持比较传统的基于XML的配置，也支持目前比较流行的基于Java（推荐）的配置。需要注意的是，如果之前有使用org.springframework.beans.factory.config.PropertyPlaceholderConfigurer的，请替换成org.springframework.context.support.PropertySourcesPlaceholderConfigurer。Spring 3.1以后就不建议使用PropertyPlaceholderConfigurer了，要改用PropertySourcesPlaceholderConfigurer。基于XML的配置注：需要把apollo相关的xml namespace加到配置文件头上，不然会报xml语法错误。1.注入默认namespace的配置到Spring中12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:apollo=\"http://www.ctrip.com/schema/apollo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.ctrip.com/schema/apollo http://www.ctrip.com/schema/apollo.xsd\"&gt; &lt;!-- 这个是最简单的配置形式，一般应用用这种形式就可以了，用来指示Apollo注入application namespace的配置到Spring环境中 --&gt; &lt;apollo:config/&gt; &lt;bean class=\"com.ctrip.framework.apollo.spring.TestXmlBean\"&gt; &lt;property name=\"timeout\" value=\"$&#123;timeout:100&#125;\"/&gt; &lt;property name=\"batch\" value=\"$&#123;batch:200&#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt;2.注入多个namespace的配置到Spring中123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:apollo=&quot;http://www.ctrip.com/schema/apollo&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.ctrip.com/schema/apollo http://www.ctrip.com/schema/apollo.xsd&quot;&gt; &lt;!-- 这个是最简单的配置形式，一般应用用这种形式就可以了，用来指示Apollo注入application namespace的配置到Spring环境中 --&gt; &lt;apollo:config/&gt; &lt;!-- 这个是稍微复杂一些的配置形式，指示Apollo注入FX.apollo和FX.soa namespace的配置到Spring环境中 --&gt; &lt;apollo:config namespaces=&quot;FX.apollo,FX.soa&quot;/&gt; &lt;bean class=&quot;com.ctrip.framework.apollo.spring.TestXmlBean&quot;&gt; &lt;property name=&quot;timeout&quot; value=&quot;$&#123;timeout:100&#125;&quot;/&gt; &lt;property name=&quot;batch&quot; value=&quot;$&#123;batch:200&#125;&quot;/&gt; &lt;/bean&gt;&lt;/beans&gt;dubbo服务整合123456789101112 &lt;apollo:config/&gt;&lt;apollo:config namespaces=\"dubbo\" order=\"1\"/&gt; &lt;!-- 公共信息，也可以用dubbo.properties配置 --&gt; &lt;dubbo:application name=\"$&#123;dubbo.application.name&#125;\" /&gt; &lt;!-- 需要强制指定地址，配置文件默认可以不配置 --&gt; &lt;dubbo:registry address=\"$&#123;dubbo.registry.address&#125;\"/&gt; &lt;bean id=\"xxxService\" class=\"com.xxx.cache.service.impl.RedisServiceImpl\"/&gt; &lt;dubbo:service interface=\"com.xxx.xxx.service.RedisService\" ref=\"redisService\" version=\"$&#123;dubbo.version&#125;\"/&gt;dubbo 默认没有不需要配置，但使用apollo后没有自动注入dubbo注册地址，需要手动声明,原因待定1&lt;dubbo:registry address=&quot;$&#123;dubbo.registry.address&#125;&quot;/&gt;","categories":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"apollo","slug":"java/apollo","permalink":"http://www.baiyp.ren/categories/java/apollo/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"apollo","slug":"apollo","permalink":"http://www.baiyp.ren/tags/apollo/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"apollo","slug":"java/apollo","permalink":"http://www.baiyp.ren/categories/java/apollo/"}]},{"title":"系统加密服务-04","slug":"系统加密服务-04","date":"2018-03-02T23:07:18.000Z","updated":"2019-08-03T22:17:40.249Z","comments":true,"path":"系统加密服务-04.html","link":"","permalink":"http://www.baiyp.ren/系统加密服务-04.html","excerpt":"","text":"系统加密服务-后记开发中遇到的问题虽然说用起来直接引入js就能解决进行加密但是在使用过程中还是有很多问题的,这里面列出几个因为使用第三方校验框架，使得jquery监听form表单失效或者数据没有加密我们通过改写校验框架源码来实现，就是在校验中我们设置$.setSubmit(false)不进行提交，在校验通过后进行加密后再提交，设计的框架有jquery.validate,bootstrapValidate,validform 等form 表单中的重复的name值以“，”分割原来是这样来写的，以直没有问题，后来有一个很老的系统使用 request.getParameterValues() 方式来获取数组参数，因为解密后是“,”分割的字符串分不开数组和字符串所以对系统进行了重构js全部以数据的形式接收，因为数据形式数据量太大很多都是不重复的，所以就先生成一个JSON数组，然后检查如果是一个的话就将数据去掉，使用原始的JSON形式，如果有重复的name就保留数组，这样加密后就节省了很大的数据传输量pyload处理原来只有参数的解密后来发现对于ajax contentType为GBK的获取步到参数，发现是流的形式接收的，就增加了pyload形式，后来又发现上传文件失效了，原来将文件上传解密了，文件上传失败，就判断contentType不能包含multipart/form-data空对象处理因采用了JSON的压缩方式，如果一个参数值为空就不将这个参数传递过去了，因后台没有做任何处理，没有加密前是得到的是空字符串加密后得到的是null，造成了空指针，解决方法是加入了自定义配置默认不将空对象传过去，如果是指定一个配置，就将所以的参数传过去，如果对象为空的也传过去，但这样会造成很大的数据量增加，默认不传递空值的。其他的各种小问题也很多这里面不列举了系统响应情况因为引入了前端加密后端解密系统的响应速度肯定会下降，测试人员测试的是否发现系统明显慢了一些数据量越大的页面提交也越慢最慢的页面数据量特别大，提交约2分钟左右，加密的参数达到了恐怖了5万个各种各样的参数和值有些电脑甚至浏览器直接卡死崩溃但一般都能够接受，正常页面能够再1秒内提交响应总结安全问题解决了，积累了经验，特别累，涉及到十几个服务，三四个月以来几乎天天加班，处理各种各样的问题，后两个月几乎天天上线，回滚，测试人员一遍一遍的测试，线上还是问题不断，被骂了不知道多少遍，总算再规定的期限完成了，来检查的时候也是战战兢兢的，生怕出现问题，总算是完美完成，不辜负几个月的辛苦，拿到了安全证书，这几个月也学到很多知识。感谢各位查看和评阅第一次系列的写一些博客，感觉写的很乱，不能很系统的写出来，有什么问题欢迎指正。","categories":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://www.baiyp.ren/categories/java/加密/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/tags/加密/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://www.baiyp.ren/categories/java/加密/"}]},{"title":"系统加密服务-03","slug":"系统加密服务-03","date":"2018-03-02T23:06:35.000Z","updated":"2019-08-03T22:17:30.987Z","comments":true,"path":"系统加密服务-03.html","link":"","permalink":"http://www.baiyp.ren/系统加密服务-03.html","excerpt":"","text":"系统加密服务-后台解密涉及的问题要知道解密是否成功对于AJAX传过来的PYLOAD 载荷的流的形式的数据解密并重构可重复读取的流要对后端透明后端不需要改动任何代码解密通过重写HttpServletRequestWrapper 实现构建可重复读取的的request流需要 spring-test jar支持使用DelegatingServletInputStream 实现构建ParameterRequestWrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class ParameterRequestWrapper extends HttpServletRequestWrapper &#123; private static final Logger logger = LoggerFactory.getLogger(ParameterRequestWrapper.class); private Map&lt;String, String[]&gt; parameters = new LinkedHashMap&lt;String, String[]&gt;(); //是否可重复读取流 private boolean isReadInputStream = false; //pyload parameter 主体 private String parameterBody = null; //解密状态 private boolean decryptionState = false; /** * input stream 的buffer * */ public ParameterRequestWrapper(HttpServletRequest request) throws UnsupportedEncodingException &#123; super(request); //request 解密 RequestEnriry requestEnriry = ParameterUtils.decrypt(request); if (null != requestEnriry) &#123; //获取解密后的对象 Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); //流是否被读取了 isReadInputStream = requestEnriry.isReadInputStream(); if (isReadInputStream) &#123; parameterBody = requestEnriry.getParameterBody(); &#125; //解密是否成功 decryptionState = requestEnriry.isPass(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; parameters = parameterMap; &#125; &#125; &#125; @Override public String getParameter(String key) &#123; String[] values = parameters.get(key); return StringUtils.arrayToString(values); &#125; @Override public Map&lt;String, String[]&gt; getParameterMap() &#123; return parameters; &#125; @Override public Enumeration&lt;String&gt; getParameterNames() &#123; return new Vector&lt;String&gt;(parameters.keySet()).elements(); &#125; @Override public String[] getParameterValues(String name) &#123; String[] result = null; Object value = parameters.get(name); if (value == null) &#123; result = null; &#125; else if (value instanceof String[]) &#123; result = (String[]) value; &#125; else if (value instanceof String) &#123; result = new String[]&#123;(String) value&#125;; &#125; else &#123; result = new String[]&#123;value.toString()&#125;; &#125; return result; &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; if (isReadInputStream) &#123; if (null != parameterBody) &#123; final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(parameterBody.getBytes()); //构建可重复读取的流 return new DelegatingServletInputStream(byteArrayInputStream); &#125; &#125; else &#123; return super.getInputStream(); &#125; return null; &#125; public boolean isDecryptionState() &#123; return decryptionState; &#125; public void setDecryptionState(boolean decryptionState) &#123; this.decryptionState = decryptionState; &#125;构建filter123456789101112131415161718public class ParametersFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; //强制指定编码，解决解密后乱码问题 request.setCharacterEncoding(\"UTF-8\"); ParameterRequestWrapper parameterRequestWrapper = new ParameterRequestWrapper(request); //获取加密状态 boolean isDecryptionState = parameterRequestWrapper.isDecryptionState(); if (isDecryptionState) &#123; chain.doFilter(parameterRequestWrapper, response); &#125; else &#123; //返回加密失败的状态，可以在页面处理 response.setStatus(911); &#125; &#125;&#125;在web.xml 设置filter需要RequestContextListener 支持，在web.xml 中配置1234567891011121314!-- 参数过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;ParametersFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.xxx.common.security.web.filter.ParametersFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;ParametersFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- request固化器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt;这样就配置完了对于普通的parameterMap参数解密先检查参数名称是否是加密的key 我们可以指定一个不容易重名的例如“$@$.ecryptedData“如果加密了 就就行解密 解密完成后通过fastJson将JSON串转换为MAP检查是否存在我们JS中定义的时间戳 如果不存在 则判断解密失败代码片段如下参数解密123456789101112131415161718192021public void decrypt(HttpServletRequest request, RequestEnriry requestEnriry) &#123;//检查是否是form表单提交的 if (check(request)) &#123; Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); //检查是否加密 boolean isEncrypt = isEncrypt(parameterMap); if (isEncrypt) &#123; requestEnriry.setEncrypt(isEncrypt); //获取加密的参数 String encParameter = getEncryptedParameter(parameterMap); //解密数据 String decParameter = decryptData(encParameter, getSecretKey(request)); if (StringUtils.isNotEmpty(decParameter)) &#123; //参数转换 Map&lt;String, String[]&gt; decParameterMap = encParameterConver(decParameter);//将参数封装到实体中 requestEnriry.putParameterMap(decParameterMap);//设置传过来的时间戳 requestEnriry.setTimestamp(getEncryptedTimestamp(decParameterMap)); &#125; &#125; &#125; &#125;检查参数是否加密123456789 public boolean isEncrypt(Map parameterMap) &#123;Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty() &amp;&amp; parameterMap.containsKey(\"$@$.ecryptedData\")) &#123; flag = true; &#125; &#125; return flag; &#125;获取加密的参数12345678910public String getEncryptedParameter(Map&lt;String, String[]&gt; parameterMap) &#123; String ecryptedParam = null; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; String[] parameterArray = parameterMap.get(\"$@$.ecryptedData\"); if (null != parameterArray &amp;&amp; parameterArray.length &gt; 0) &#123; ecryptedParam = parameterArray[0]; &#125; &#125; return ecryptedParam; &#125;检查是否需要解密操作1234567public boolean check(HttpServletRequest request) &#123; Map parameterMap = request.getParameterMap(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; return true; &#125; return false; &#125;参数转换12345678910111213141516171819202122public Map&lt;String, String[]&gt; encParameterConver(String decryptionJson) &#123; Map&lt;String, String[]&gt; mappingMap = new LinkedHashMap&lt;String, String[]&gt;(); if (null != mappingMap &amp;&amp; StringUtils.isNotEmpty(decryptionJson)) &#123; Map&lt;String, String[]&gt; parameterMap = null; parameterMap = ParameterUtils.jsonToMap(decryptionJson); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; Set&lt;String&gt; keys = parameterMap.keySet(); for (String key : keys) &#123; if (StringUtils.isNotEmpty(key)) &#123; String[] value = parameterMap.get(key); if (null != value) &#123; value = ParameterUtils.decodeURI(value); &#125; if (null != value) &#123; mappingMap.put(key, value); &#125; &#125; &#125; &#125; &#125; return mappingMap; &#125;获取时间戳12345678910public String getEncryptedTimestamp(Map&lt;String, String[]&gt; parameterMap) &#123; String timestamp = null; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; String[] valueArray = parameterMap.get(\"$@$.tmp\"); if (null != valueArray &amp;&amp; valueArray.length &gt; 0) &#123; timestamp = valueArray[0]; &#125; &#125; return timestamp; &#125;对于AJAX PYLOAD 载荷的参数解密跟普通的一样解密一样只是有几点区别pyload需要有contentTypecontentType 不能包含multipart/form-data 即不支持文件上传pyload 需要吧解析的参数还原为原始的字符串 可能是JSON字符串或者是URL参数代码片段如下参数解密123456789101112131415161718192021222324252627282930public void decrypt(HttpServletRequest request, RequestEnriry requestEnriry) &#123;//检查是否需要解密 if (check(request)) &#123; //获取pyload 参数 String pyloadParameter = getPyloadParameter(request); //设置流读取状态为true requestEnriry.setReadInputStream(true); if (StringUtils.isNotEmpty(pyloadParameter)) &#123; requestEnriry.setParameterBody(pyloadParameter); //将pyload参数解析 Map&lt;String, String[]&gt; parameterMap = ParameterUtils.getUrlParams(pyloadParameter); //检查是否加密 boolean isEncrypt = isEncrypt(parameterMap); if (isEncrypt) &#123; requestEnriry.setEncrypt(isEncrypt); String encParameter = getEncryptedParameter(parameterMap); if (StringUtils.isNotEmpty(encParameter)) &#123; String decParameter = decryptData(encParameter, getSecretKey(request)); requestEnriry.setParameterBody(decParameter); Map&lt;String, String[]&gt; map = ParameterUtils.jsonToMap(decParameter); if (null != map &amp;&amp; !map.isEmpty()) &#123; requestEnriry.setTimestamp(getEncryptedTimestamp(map)); requestEnriry.putParameterMap(map); &#125; &#125; &#125; &#125; &#125; &#125;检查是否是pyload形式1234567public boolean check(HttpServletRequest request) &#123; String contentType = getContentType(request); if (StringUtils.isNotEmpty(contentType) &amp;&amp; !contentType.contains(\"multipart/form-data\")) &#123; return true; &#125; return false; &#125;获取pyload 参数12345678910111213141516171819202122232425262728public String getPyloadParameter(HttpServletRequest request) &#123; String ecryptedParam = null; InputStream inputStream = null; try &#123; inputStream = request.getInputStream(); &#125; catch (IOException e) &#123; logger.error(\"Error reading the request body…\", e); &#125; if (null != inputStream) &#123; StringBuilder stringBuilder = new StringBuilder(); if (inputStream != null) &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); char[] charBuffer = new char[CHAR_BUFFER_LENGTH]; int bytesRead; while ((bytesRead = bufferedReader.read(charBuffer)) &gt; 0) &#123; stringBuilder.append(charBuffer, BUFFER_START_POSITION, bytesRead); &#125; &#125; catch (IOException e) &#123; logger.error(\"Fail to read input stream\", e); &#125; &#125; else &#123; stringBuilder.append(\"\"); &#125; ecryptedParam = stringBuilder.toString(); &#125; return ecryptedParam; &#125;其他公共类 RequestEnriry123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class RequestEnriry &#123; private Map&lt;String, String[]&gt; parameterMap = new HashMap&lt;String, String[]&gt;(); private String parameterBody; private boolean isEncrypt = false; private boolean isReadInputStream = false; private String timestamp = null; public RequestEnriry() &#123; &#125; public RequestEnriry(Map&lt;String, String[]&gt; requestParameterMap) &#123; if (null != requestParameterMap &amp;&amp; !requestParameterMap.isEmpty()) &#123; parameterMap.putAll(requestParameterMap); &#125; &#125; public void handle() &#123; parameterMap.remove(SecurityConstant.ECRYPTED_PARAM_NAME); &#125; public boolean isPass() &#123; boolean isPass = false; if (isEncrypt) &#123; if (StringUtils.isNotEmpty(timestamp)) &#123; isPass = true; &#125; &#125; else &#123; isPass = true; &#125; return isPass; &#125; public Map&lt;String, String[]&gt; getParameterMap() &#123; return parameterMap; &#125; public void setParameterMap(Map&lt;String, String[]&gt; parameterMap) &#123; this.parameterMap = parameterMap; &#125; public void putParameterMap(Map&lt;String, String[]&gt; subParameterMap) &#123; parameterMap.putAll(subParameterMap); &#125; public String getParameterBody() &#123; return parameterBody; &#125; public void setParameterBody(String parameterBody) &#123; this.parameterBody = parameterBody; &#125; public boolean isEncrypt() &#123; return isEncrypt; &#125; public void setEncrypt(boolean encrypt) &#123; isEncrypt = encrypt; &#125; public String getTimestamp() &#123; return timestamp; &#125; public void setTimestamp(String timestamp) &#123; this.timestamp = timestamp; &#125; public boolean isReadInputStream() &#123; return isReadInputStream; &#125; public void setReadInputStream(boolean readInputStream) &#123; isReadInputStream = readInputStream; &#125;&#125;到这一步已经全部完成了，核心思想和代码已经完成","categories":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://www.baiyp.ren/categories/java/加密/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/tags/加密/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://www.baiyp.ren/categories/java/加密/"}]},{"title":"系统加密服务-02","slug":"系统加密服务-02","date":"2018-03-02T23:05:22.000Z","updated":"2019-08-03T22:17:21.317Z","comments":true,"path":"系统加密服务-02.html","link":"","permalink":"http://www.baiyp.ren/系统加密服务-02.html","excerpt":"","text":"系统加密服务-页面JS加密涉及的问题因涉及的页面较多不能一个一个改，只能统一引用，最好使用header引入js的形式能够捕获form表单提交，在提交之前将提交的数据进行加密，并将加密的数据提交，原始数据不提交form表单序列化AJAX数据加密加密方式选择文件上传对于和上传数据一起的参数数据加密问题解决对于第一个问题 写统一的JS进行解决做好兼容性，对于form表单提交加密解决方案： 使用jquery监听form表单的submit方案，如果监听到form提交就将form表单对应输入框的元素进行序列化，序列为JSON数组（因为后台Request接收数组，兼容类似于checkBox重复name）将序列化的JSON进行加密，并将加密的数据插入到表单中，并将加密的输入框元素设置为disabled（这样元素就不会提交了）提交表单就只剩下加密的数据了。123456789101112131415$(function () &#123;//监听form表单提交 $(\"form\").submit(function (data) &#123; //获取提交的URL var url = $(this).attr(\"action\"); //检查是否需要提交 if ($.getSubmit()) &#123; //检查是否需要加密 if ($.isEncrypt(url)) &#123; //数据加密 $(this).formEncryption(); &#125; &#125; &#125;);&#125;);对于form表单序列化解决方案：对于表单序列化要排除一些不需要加密的元素例如file,button,image等，对于checkbox和redio可能存在多个相同的name，要使用JSON数据来接收，用于区分后台接受到“,”分割的字符串springMvc 会自动将request参数数组转换为“,”分割的字符串，但有些很老的代码是不支持的，要兼容底层request区分数组和“,”分割的字符串要使用JSON数组来接收，并将序列化的name值进行保存，用于某些情况下将加密后disable后的元素去掉disabled，并将加密设置为jquery插件的形式使用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253(function ($) &#123;//需要排除的元素 var excludeInputType = [\"file\", \"button\", \"submit\", \"image\", \"reset\"]; $.fn.extend(&#123; //序列化方法 \"serializeJSON\": function () &#123; //表单数据 var formData = &#123;&#125;; //加密的元素数组 var disabledKeys = []; this.find(\"input,select,textarea\").each(function () &#123; if (!$(this).is(\":disabled\")) &#123; var name = $(this).attr(\"name\"); var value = $(this).val(); var valueArray = new Array(value); var type = $(this).attr(\"type\"); var flag = true; for (var i = 0; i &lt; excludeInputType.length; i++) &#123; if (type == excludeInputType[i]) &#123; flag = false; return true; &#125; &#125; disabledKeys.push(name); switch (type) &#123; case \"checkbox\": if (!$(this).is(':checked')) &#123; return true; &#125; break; case \"radio\": if (!$(this).is(':checked')) &#123; return true; &#125; break; &#125; // var v = $.getJsonValue(formData, name); if (v) &#123; v.push(value); valueArray = v; &#125; formData = $.putJson(formData, name, valueArray); &#125; &#125;); $.setDisableKey(disabledKeys); formData = $.arrayParameterSerialize(formData); return formData; &#125; &#125;);&#125;)对于AJAX数据提交解决方案：使用 $.ajaxPrefilter 捕获ajax提交，得到提交的数据，并进行解析，加密并将原始数据覆盖为新的数据12345678910111213141516171819202122232425262728$.ajaxPrefilter(function (options, originalOptions, jqXHR) &#123;//获取ajax数据 var data = options.data; //获取ajaxurl var url = options.url; //是否需要加密 if ($.isEncrypt(url)) &#123; if (data) &#123; var parameter = &#123;&#125;; //检查字符串是否是json字符串 if ($.strIsJSON(data)) &#123; //将json字符串转换为json对象 parameter = JSON.parse(data); &#125; else &#123; //对于普通的数据?xxx=1&amp; 形式的数据进行解析转换为json对象 parameter = $.parseParameter(data); &#125; //添加时间戳 parameter = $.addTmp(parameter); //数据加密 data = $.encryptData(parameter); var dataJson = &#123;&#125;; dataJson = $.putJson(dataJson, $.getEcryptedParameterName(), data); data = $.jsonToParameter(dataJson); //将原始数据覆盖为加密的数据 options.data = data; &#125; &#125;数据加密解决方案 使用 des形式加密，可以自己定义加密方式，但要保证前后台都能加密解密。加密最好加上时间戳 用于后台检查是否解密成功（如果解密后没有这个时间戳字段代表解密失败）还可以用于其他的作用，例如检查加密的字符串超时时间。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(function ($) &#123; var isSubmit_disabled = true; var disabled_keys = []; $.ajaxSetup(&#123; contentType: \"application/x-www-form-urlencoded;charset=utf-8\", complete: function (xhr, textStatus) &#123; if (xhr.status == 911) &#123; layer.msg('当前页面已失效，正在刷新浏览器', &#123;icon: 0, shade: 0.8&#125;, function () &#123; window.location.href = $.getRootPath(); &#125;); return false; &#125; &#125; &#125;); $.ajaxPrefilter(function (options, originalOptions, jqXHR) &#123; var data = options.data; var url = options.url; if ($.isEncrypt(url)) &#123; if (data) &#123; var parameter = &#123;&#125;; if ($.strIsJSON(data)) &#123; parameter = JSON.parse(data); &#125; else &#123; parameter = $.parseParameter(data); &#125; parameter = $.addTmp(parameter); data = $.encryptData(parameter); var dataJson = &#123;&#125;; dataJson = $.putJson(dataJson, $.getEcryptedParameterName(), data); data = $.jsonToParameter(dataJson); options.data = data; &#125; &#125; &#125;); $.fn.extend(&#123; formEncryption: function () &#123; var data = &#123;&#125;; var ecryptedParameterName = $.getEcryptedParameterName(); var url = $(this).attr(\"action\"); if ($.isEncrypt(url)) &#123; var inputArray = this.serializeJSON(); if (!inputArray[ecryptedParameterName]) &#123; $(this).disabledForm(); for (var key in inputArray) &#123; var value = inputArray[key]; data = $.putJson(data, key, value); &#125; data = $.addTmp(data); var encData = $.encryptData(data); if ($.isNotEmpty(encData)) &#123; var encDataInput = $(\"&lt;input type='hidden' name = '\" + ecryptedParameterName + \"' value='\" + encData + \"'/&gt;\"); this.append(encDataInput); &#125; &#125; &#125; &#125;, encryptionSubmit: function () &#123; this.formEncryption(); this.submit(); &#125;, disabledForm: function () &#123; var disableKeys = $.getDisableKey(); var ecryptedParameterName = $.getEcryptedParameterName(); for (var i = 0; i &lt; disableKeys.length; i++) &#123; if (disableKeys[i] != ecryptedParameterName) &#123; $(this).find(\"[name='\" + disableKeys[i] + \"']\").attr(\"disabled\", \"disabled\"); &#125; &#125; &#125;, enableForm: function () &#123; var disableKeys = $.getDisableKey(); var ecryptedParameterName = $.getEcryptedParameterName(); $(this).find(\"[name='\" + ecryptedParameterName + \"']\").remove(); for (var i = 0; i &lt; disableKeys.length; i++) &#123; $(this).find(\"[name='\" + disableKeys[i] + \"']\").attr(\"disabled\", false); &#125; &#125; &#125;);上下是一个文件 不知道怎么回事 makedown 显示不全一个完整的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 $.extend(&#123; urlDataEncrypt: function (url, extParams) &#123; var secretKey = $.getSecretKey(); var baseUrl = $.parseUrl(url); var params = $.parseUrlParameter(url); params = $.initEncryptParam(params); if ($.isNotEmpty(extParams) &amp;&amp; $.isJson(extParams)) &#123; $.putJson(params, extParams); &#125; var encryptUrl = url; if ($.isEmpty(secretKey)) &#123; encryptUrl = baseUrl + \"?\" + $.jsonToParameter(params); &#125; else &#123; var ecryptedData = $.encryptData(params); params = $.addTmp(params); encryptUrl = baseUrl + \"?\" + $.getEcryptedParameterName() + \"=\" + ecryptedData; &#125; return encryptUrl; &#125;, encryptData: function (data) &#123; var ecryptedData = \"\"; if ($.isJson(data)) &#123; var jsonStr = JSON.stringify(data); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; else &#123; if (!data.match(\"^\\&#123;(.+:.+,*)&#123;1,&#125;\\&#125;$\")) &#123; var params = $.parseParameter(data); var jsonStr = JSON.stringify(params); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; else &#123; var jsonStr = JSON.stringify(jsonData); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; &#125; return ecryptedData; &#125;, initEncryptParam: function (data) &#123; if ($.isEmpty(data)) &#123; data = &#123;&#125;; &#125; else if (!$.isJson(data)) &#123; data = jQuery.parseJSON(data); &#125; data = $.addTmp(data); return data; &#125;, isEncrypt: function (url) &#123; var flag = true; var secretKey = $.getSecretKey(); if ($.isEmpty(secretKey)) &#123; flag = false; &#125; else &#123; var encryptExclude = $.encryptExcludeUrl(); if (encryptExclude &amp;&amp; $.isArray(encryptExclude)) &#123; for (var i = 0; i &lt;= encryptExclude.length; i++) &#123; if (encryptExclude[i] == url) &#123; flag = false; break; &#125; &#125; &#125; &#125; return flag; &#125;, setSubmit: function (obj) &#123; isSubmit_disabled = obj; &#125;, getSubmit: function () &#123; return isSubmit_disabled; &#125;, setDisableKey: function (keys) &#123; if (keys &amp;&amp; keys[0] != $.getEcryptedParameterName()) &#123; disabled_keys = keys; &#125; &#125;, getDisableKey: function () &#123; return disabled_keys; &#125;, &#125;);&#125;)(window.jQuery);","categories":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://www.baiyp.ren/categories/java/加密/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/tags/加密/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://www.baiyp.ren/categories/java/加密/"}]},{"title":"系统加密服务-01","slug":"系统加密服务-01","date":"2018-03-02T23:03:28.000Z","updated":"2019-08-03T22:17:10.248Z","comments":true,"path":"系统加密服务-01.html","link":"","permalink":"http://www.baiyp.ren/系统加密服务-01.html","excerpt":"","text":"系统加密服务需求背景我们公司因为要紧急对系统进行安全加密，以前系统都是参数暴漏的，能够直接获取操作链接等数据，为防止系统关键数据被窃取，系统要进行全面加密，时间只有一个月，上级部门要来进行检查，因涉及到多个系统，上万个页面不能一个一个页面进行加密，特需要一套框架来支持。需要实现的功能对后端透明 后端不需要该任何代码对前端透明 前端不需要或者最好不改代码实现表单放重复提交实现重放攻击拦截实现XSS 脚本跨站攻击实现方案我们系统的讨论了一周时间实现方案如下通过JS 监听ajax 请求和form表单请求 并对请求的数据进行加密通过继承HttpServletRequestWrapper 实现参数解析以及XSS防注入使用拦截器搭配注解实现表单放重复提交在提交的JS中加入时间戳的方式配合拦截器和注解实现防重放攻击总体实现方案加密方式前台数据通过JS对form表单以及AJAX数据进行加密要兼容一些校验框架加密数据需要加入时间戳用于后台检查是否解密成功以及其他用处后台得到加密的数据进行解密通过重写HttpServletRequestWrapper 和OncePerRequestFilter 来实现如果是AJAX提交可能需要PYLOAD形式通过流的形式进行解析表单防重通过TOKEN形式来实现，网上很多实现，这里不多说了XXS防跨站脚本攻击通过将参数中的html代码转义来实现对应的JS加密和Java解密的资源可以查看下载","categories":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://www.baiyp.ren/categories/java/加密/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/tags/加密/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"加密","slug":"java/加密","permalink":"http://www.baiyp.ren/categories/java/加密/"}]},{"title":"MYBATIS热部署","slug":"MYBATIS热部署","date":"2017-08-02T14:41:56.000Z","updated":"2019-08-03T22:16:58.643Z","comments":true,"path":"MYBATIS热部署.html","link":"","permalink":"http://www.baiyp.ren/MYBATIS热部署.html","excerpt":"","text":"mybatis热部署最近在使用mybatis，由于是刚刚开始用，用的并不顺手，目前是感觉有2个地方非常的不好用：mybatis调试不方便​ 由于dao层只有接口，实现只是一个map的xml文件，想加断点都没有地方加，直接导致的后果就是有时候出错了，完全是各种闭眼尝试，抓狂中。。。倒是可以把调试级别改成debug，会把执行的sql，以及参数都输出到控制台，可是一改成debug，那控制台输出的内容，就实在多到让人发指，甚至都会影响到代码的编写及调试，而且输出日志跟打断点调试根本就不是一个级别的。目前仍旧无法解决改问题。mybatis改sql要不停的重启服务​ 这个真心不能忍，map文件在系统重动后，map文件只加载一次，再修改map文件就不会生效了，如果要生效，就需要不停的重启服务。​ 后来找到一个办法，就是使用Mybatis-Plus插件。Mybatis-Plus插件的用法pom.xml的内容：123456789101112131415161718 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;lib.dir&#125;/mybatis-plus-1.5.jar&lt;/systemPath&gt; &lt;/dependency&gt;​ 因为看Mybatis-Plus插件官网的说法，就是添加Mybatis-Plus插件会添加mybatis的依赖包，我已经引过mybatis的包了，不想让他再给我引了。Mybatis-Plus插件的地址：http://mvnrepository.com/artifact/com.baomidou/mybatis-plus/1.52. 然后修改spring的配置文件： 修改前 123&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dynamicDataSource\" /&gt;&lt;property name=\"configLocation\" value=\"classpath:conf/mybatis-config.xml\"&gt;&lt;/property&gt;123456789101112 修改后 ```xml &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dynamicDataSource&quot; /&gt; &lt;property name=&quot;configLocation&quot; value=&quot;classpath:conf/mybatis-config.xml&quot;&gt;&lt;/property&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:com/huarui/mapping/$&#123;jdbc.dialect&#125;/*.xml&quot;&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=&quot;com.baomidou.mybatisplus.spring.MybatisMapperRefresh&quot;&gt; &lt;constructor-arg name=&quot;sqlSessionFactory&quot; ref=&quot;sqlSessionFactory&quot;/&gt; &lt;constructor-arg name=&quot;mapperLocations&quot; value=&quot;classpath:com/huarui/mapping/$&#123;jdbc.dialect&#125;/*.xml&quot;/&gt; &lt;constructor-arg name=&quot;delaySeconds&quot; value=&quot;5&quot;/&gt; &lt;constructor-arg name=&quot;sleepSeconds&quot; value=&quot;10&quot;/&gt; &lt;constructor-arg name=&quot;enabled&quot; value=&quot;true&quot;/&gt;&lt;/bean&gt;​ 修改后，改sql就会自动热加载了，其实也不是实时加载，原理是每隔一个时间刷新一下map，我这里设置的是delaySeconds是5秒，sleepSeconds是10秒。 来源: http://www.cnblogs.com/modou/p/6131354.html","categories":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"mybatis","slug":"java/mybatis","permalink":"http://www.baiyp.ren/categories/java/mybatis/"}],"tags":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/tags/java/"},{"name":"mybatis","slug":"mybatis","permalink":"http://www.baiyp.ren/tags/mybatis/"}],"keywords":[{"name":"java","slug":"java","permalink":"http://www.baiyp.ren/categories/java/"},{"name":"mybatis","slug":"java/mybatis","permalink":"http://www.baiyp.ren/categories/java/mybatis/"}]},{"title":"关于我","slug":"about","date":"2016-08-03T22:27:45.000Z","updated":"2019-08-03T22:57:15.935Z","comments":true,"path":"about.html","link":"","permalink":"http://www.baiyp.ren/about.html","excerpt":"","text":"About关于我白云鹏喜欢学习,研究技术,个人有点懒目前在北京工作，有一天突然发现JAVA 好多知识不会感觉饭碗要保不住了，然后边学习边把一些知识总结下以博客的形式展示出来，做个记录。联系我MAIL：baiyunpeng42@126.comGITHUB：baiyunpeng","categories":[],"tags":[{"name":"关于","slug":"关于","permalink":"http://www.baiyp.ren/tags/关于/"}],"keywords":[]}]}