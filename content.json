{"meta":{"title":"晓风残月的博客","subtitle":"晓风残月","description":"个人技术的一些积累","author":"晓风残月","url":"http://www.baiyp.ren"},"pages":[{"title":"所有分类","date":"2019-09-06T01:27:13.007Z","updated":"2019-09-06T01:27:13.007Z","comments":true,"path":"categories/index.html","permalink":"http://www.baiyp.ren/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2019-09-06T01:27:13.009Z","updated":"2019-09-06T01:27:13.009Z","comments":true,"path":"tags/index.html","permalink":"http://www.baiyp.ren/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JVM整体介绍","slug":"JVM整体介绍","date":"2019-09-08T06:10:53.000Z","updated":"2019-09-08T06:40:31.099Z","comments":true,"path":"JVM整体介绍.html","link":"","permalink":"http://www.baiyp.ren/JVM整体介绍.html","excerpt":"","text":"JVM整体介绍JAVA技术体系结构Java虚拟机（Java Virtual Machine 简称 JVM）是运行所有Java程序的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。Java虚拟机是整个Java技术体系最重要的基础。为什么要了解虚拟机首先，Java 虚拟机提供了许多配置参数，用于满足不同应用场景下，对程序性能的需求。学习Java 虚拟机，你可以针对自己的应用，最优化匹配运行参数。其次，Java 虚拟机本身是一种工程产品，在实现过程中自然存在不少局限性。学习 Java 虚拟机，可以更好地规避它在使用中的 Bug，也可以更快地识别出 Java 虚拟机中的错误再次，Java 虚拟机拥有当前最前沿、最成熟的垃圾回收算法实现，以及即时编译器实现。学习Java 虚拟机，我们可以了解背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。最后，Java 虚拟机发展到了今天，已经脱离 Java 语言，形成了一套相对独立的、高性能的执行方案。除了 Java 外，Scala、Clojure、Groovy，以及时下热门的 Kotlin，这些语言都可以运行在 Java 虚拟机之上。学习 Java 虚拟机，便可以了解这些语言的通用机制，甚至于让这些语言共享生态系统。未来的Java技术模块化:OSGI（动态化、模块化），应用层面就是微服务，互联网的发展方向混合语言：多个语言都可以运行在JVM中，google的Kotlin 成为了 Android 的官方语言。Scala(Kafka)多核并行：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)丰富语法：JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource64**位：**虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位，32位的JVM有4G的堆大小限制。更强的垃圾回收器（现在主流CMS、G1）：JDK11 –ZGC（暂停时间不超过10毫秒，且不会随着堆的增加而增加，TB级别的堆回收））：有色指针、加载屏障。JDK12支持并发类卸载，进一步缩短暂停时间 JDK13(计划于2019年9月)将最大堆大小从4TB增加到16TBJVM的整体介绍JVM是如何工作的JVM分成3个主要的子系统类加载器子系统运行时数据区执行引擎类加载器子系统Java的动态类加载功能是通过类加载子系统去处理的。它并不是在编译时候，而是在首次运行时加载引用类时、连接并初始化类文件。加载类通过该组件加载。通过引导类加载器，扩展类加载器，应用类加载器这三个类加载器帮助完成加载。引导类加载器负责从引导类路径去加载类，除了rt.jar之外，没其他别的jar。给予该加载器最高的优先级。扩展类加载器负责加载ext目录（jre\\lib）的类应用加载器负责加载类路径中应用级别的类，path提到的环境变量，等等。以上的类加载器在加载类文件的时候遵循委托层次算法。连接验证-字节码验证器验证生成的字节码是否正确，如果验证失败，我们将收到验证的错误信息。准备-为所有的静态变量分配内存和默认值解析-用方法区的原始引用代替所有符号内存引用。初始化这是类加载的最后一个阶段，此时所有的静态变量都用原始值去赋值，并且将运行静态代码块。运行时数据区运行时数据区域分成5个主要的组件方法区所有类级的数据都存储在这里，包括静态变量。每个JVM只有一个方法区，它是一个共享资源。堆区所有的对象和对应的实例变量以及数组都存储在这里。每个JVM只有一个堆区，由于方法区和堆区为多个线程共享内存，所以存储的数据不是线程安全的。栈区为每个线程，创建一个单独的运行时栈。为每个方法调用，在栈内存创建一个条目，称之为栈帧。所有本地变量都会在栈内存中创建。由于它不是共享的资源，所有是线程安全的。栈帧被分成3子实体本地变量数组-涉及跟方法有关的本地变量和对应的值都存储在这里。操作数栈-如果需要执行中间操作，操作数堆栈作为运行时工作区来执行操作。帧数据-所有和对应方法的标记都存储在里面。在发生异常的情况下，捕捉块信息在这里维护。程序计数器寄存器每个线程都有自己的程序计数器寄存器，持有当前执行指令的地址，一旦当前指令执行被运行，下一个指令将会更新到程序计数器寄存器。执行引擎字节码被分配到执行引擎执行的运行时数据区。执行引擎一块一块的读取字节码并执行。解释器解释器解释字节码很快，但是执行的很慢。解释器的缺点是当一个方法被调用多次，每次都需要一个新的解释。JIT编译器JIT弥补了解释器的缺点。执行引擎将利用解释器转换字节码，但是当他找到重复的编码，它就使用编译器。编译器编译全部的字节码并变成本地代码这些本地码将直接被方法调用重复地使用，这就改善了系统的性能。中间代码生成器-生成中间代码。代码优化器-负责优化上面生成的代码目标代码生成器-负责生成机器码或者本地代码分析器-一个特殊的组件，负责寻找hotspots,即是否方法被调用多次。垃圾收集器收集和清除未被引用的对象，可以通过System.gc()触发垃圾回收，但是不保证一定执行。创建收集对象的JVM垃圾收集。Java Native Interface (JNI)：JNI和本地方法库互动，特供本地库所需的执行引擎。Native Method Libraries: 这是执行引擎所需的本地方法的一个集合","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/categories/JVM/"},{"name":"内存结构","slug":"JVM/内存结构","permalink":"http://www.baiyp.ren/categories/JVM/内存结构/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/tags/JVM/"},{"name":"整体介绍","slug":"整体介绍","permalink":"http://www.baiyp.ren/tags/整体介绍/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/categories/JVM/"},{"name":"内存结构","slug":"JVM/内存结构","permalink":"http://www.baiyp.ren/categories/JVM/内存结构/"}]},{"title":"JVM运行时数据区-线程私有","slug":"JVM运行时数据区-线程私有","date":"2019-09-08T06:10:53.000Z","updated":"2019-09-08T09:16:04.733Z","comments":true,"path":"JVM运行时数据区-线程私有.html","link":"","permalink":"http://www.baiyp.ren/JVM运行时数据区-线程私有.html","excerpt":"","text":"JVM运行时数据区-线程私有什么是运行时数据区JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域！这个是抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）计算机的运行=指令+数据，指令用于执行方法的，数据用于存放数据和对象的。​ Java虚拟机在执行Java程序的过程中会把它管理的内存分为若干个不同的数据区域。这些区域有着各自的用途，一级创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》中规定，jvm所管理的内存大致包括以下几个运行时数据区域。线程私有:程序计数器、虚拟机栈、本地方法栈线程共享：堆、方法区与线程之间的关系：区域是否线程共享是否会内存溢出程序计数器否不会虚拟机栈否会本地方法栈否会堆是会方法区是会程序计数器程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。特 点如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址如果正在执行的是Native 方法，则这个技术器值为空（Undefined）此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域为什么需要程序计数器Java是多线程的，意味着线程切换确保多线程情况下的程序正常执行存储那些内容看一个代码123456public int test() &#123; int a = 100; int b = 200; int c = 300; return (a + b) * c; &#125;这是一段非常简单的计算代码，我们先编译成Class 文件再使用 javap 反汇编工具看下class 文件中数据格式，如下图当执行到方法test()时在当前的线程中会创建相应的程序计数器，在计数器中为存放执行地址 （红框中的）0 2 3…等等。这也说明在我们程序运行过程中计数器中改变的只是值，而不会随着程序的运行需要更大的空间，也就不会发生溢出情况。虚拟机栈什么是虚拟机栈虚拟机栈是用于描述java方法执行的内存模型。​ 每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的“栈内存”指的便是虚拟机栈，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：栈帧栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。栈帧中的元素局部变量表​ 局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。操作数栈​ 操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。操作数是运算符作用于的实体，是表达式中的一个组成部分，它规定了指令中进行数字运算的量 。表达式是操作数与操作符的组合。动态连接​ 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class文文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。返回地址​ 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。​ 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。虚拟机栈的特点虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。虚拟机栈的StackOverflowError若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用。虚拟机栈的OutOfMemoryError​ 不同于StackOverflowError，OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常。本地方法栈​ 本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。如何去服务native方法？native方法使用什么语言实现？怎么组织像栈帧这种为了服务方法的数据结构？虚拟机规范并未给出强制规定，因此不同的虚拟机实可以进行自由实现，我们常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/categories/JVM/"},{"name":"运行时数据区","slug":"JVM/运行时数据区","permalink":"http://www.baiyp.ren/categories/JVM/运行时数据区/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/tags/JVM/"},{"name":"运行时数据区","slug":"运行时数据区","permalink":"http://www.baiyp.ren/tags/运行时数据区/"},{"name":"线程私有","slug":"线程私有","permalink":"http://www.baiyp.ren/tags/线程私有/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/categories/JVM/"},{"name":"运行时数据区","slug":"JVM/运行时数据区","permalink":"http://www.baiyp.ren/categories/JVM/运行时数据区/"}]},{"title":"JVM运行时数据区-线程私有","slug":"JVM运行时数据区-线程共享","date":"2019-09-08T06:10:53.000Z","updated":"2019-09-08T11:57:02.700Z","comments":true,"path":"JVM运行时数据区-线程共享.html","link":"","permalink":"http://www.baiyp.ren/JVM运行时数据区-线程共享.html","excerpt":"","text":"JVM运行时数据区-线程共享方法区(永久代)方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。方法区（method area）只是JVM规范中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而永久代是Hotspot虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西​ 主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。方法区结构classLoader是如何加载class文件和存储文件信息的​ 当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader。那么方法区中的字节码内存块，除了记录一个class自己的class对象引用和一个加载自己的ClassLoader引用之外，还记录了什么信息呢？？方法区关键信息介绍类信息类型的全限定名超类的全限定名直接超接口的全限定名类型标志（该类是类类型还是接口类型）类的访问描述符（public、private、default、abstract、final、static）类型的常量池存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的常量）和对其他类型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为常量池中保存中所有类型使用到的类型、字段、方法的字符引用，所以它也是动态连接的主要对象（在动态链接中起到核心作用）。字段信息（该类声明的所有字段）字段修饰符（public、protect、private、default）字段的类型字段名称方法信息方法信息中包含类的所有方法，每个方法包含以下信息方法修饰符方法返回类型方法名方法参数个数、类型、顺序等方法字节码操作数栈和该方法在栈帧中的局部变量区大小异常表类变量（静态变量）​ 指该类所有对象共享的变量，即使没有任何实例对象时，也可以访问的类变量。它们与类进行绑定。指向类加载器的引用​ 每一个被JVM加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到。指向Class实例的引用​ 类加载的过程中，虚拟机会创建该类型的Class实例，方法区中必须保存对该对象的引用。通过Class.forName(String className)来查找获得该实例的引用，然后创建该类的对象。方法表​ 为了提高访问效率，JVM可能会对每个装载的非抽象类，都创建一个数组，数组的每个元素是实例可能调用的方法的直接引用，包括父类中继承过来的方法。这个表在抽象类或者接口中是没有的，类似C++虚函数表vtbl。常量池Class文件中的常量池​ 在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。​ 常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：类和接口的全限定名字段名称和描述符方法名称和描述符运行时常量池​ Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。​ 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。常量池的好处​ 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。​ 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。双等号==的含义基本数据类型之间应用双等号，比较的是他们的数值。复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。基本类型的包装类和常量池​ java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean。​ 这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float,Double并没有实现常量池技术。堆区堆是需要重点关注的一块区域，因为涉及到内存的分配(new关键字，反射等)与回收(回收算法，收集器等)几乎所有的对象都是在堆中分配。​ 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配。但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得没那么绝对了。​ Java堆是垃圾收集器管理的主要区域，因此很多时候也被称“GC堆”（Garbage Collected Heap）。从内存回收的角度看，现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、F rom Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer ,TLAB）。无论如何划分，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。​ 根据虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，可以是固定大小的，也可以是扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx -Xms 控制）。如果在堆中没有内存完成 实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。特点存储的全部是对象，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。jvm只有一个堆区（heap）被所有线程共享，堆区中不存放基本类型和对象引用，只存放对象本身。堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。缺点是，由于要在运行时动态分配内存，存取速度较慢。直接内存​ 直接内存不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK1.4中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用 进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。总结堆栈方法区的区别存储内容的区别栈：为即时调用的方法开辟空间，存储局部变量值(基本数据类型)，局部变量引用,对象属性的引用。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放；注意：局部变量必须手动初始化。堆：存放引用类型的对象，即new出来的对象、数组值、类的非静态成员变量值(基本数据类型)、非静态成员变量引用。其中非静态成员变量在实例化时开辟空间初始化值。（类中属于全局变量的基本数据类型也存放在堆中）。一个java对象占用的内存空间,除了一个固定大小的空间用于描述这个对象属于哪个类,其它的就用于保存它的字段的值;堆比栈要大。方法区：存放class二进制文件。包含类信息、静态变量，常量池（String字符串和final修饰的常量值等），类的版本号等基本信息。静态成员变量是在方法区的静态域里面，而静态成员方法是在方法区的class二进制信息里面(.class文件和方法区里面的二进制信息不一样，读取.class文件按照虚拟机需要的格式存储在方法区，这种格式包括数据结构方面。）因为是共享的区域，所以如果静态成员变量的值或者常量值(String类型的值能够非修改)被修改了直接就会反应到其它类的对象中。基本类型的地址和值都存在栈中，但是两个相同值的基本类型的地址不同，其中的==比较被重写成员变量存放在堆中，就算是int a[]=new int[10]，也都是存放在堆中，包括a[2]=1.而局部变量存放于栈中定义的区别堆：FIFO队列优先，先进先出。jvm只有一个堆区被所有线程所共享！堆存放在二级缓存中，调用对象的速度相对慢一些，生命周期由虚拟机的垃圾回收机制定。栈：FILO先进后出，暂存数据的地方。每个线程都包含一个栈区！栈存放在一级缓存中，存取速度较快，“栈是限定仅在表头进行插入和删除操作的线性表”。方法区：用来存放方法和static变量。优缺点堆的优点-可以动态的分配内存大小，生命周期不确定。缺点-速度略慢栈的优点-速度快，缺点-存在栈中的数据大小和生命周期必须是明确的，缺少灵活性。直接内存（堆外内存）与堆内存比较直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/categories/JVM/"},{"name":"运行时数据区","slug":"JVM/运行时数据区","permalink":"http://www.baiyp.ren/categories/JVM/运行时数据区/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/tags/JVM/"},{"name":"运行时数据区","slug":"运行时数据区","permalink":"http://www.baiyp.ren/tags/运行时数据区/"},{"name":"线程私有","slug":"线程私有","permalink":"http://www.baiyp.ren/tags/线程私有/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/categories/JVM/"},{"name":"运行时数据区","slug":"JVM/运行时数据区","permalink":"http://www.baiyp.ren/categories/JVM/运行时数据区/"}]},{"title":"JVM永久代与元空间","slug":"JVM永久代与元空间","date":"2019-09-08T06:10:53.000Z","updated":"2019-09-08T09:42:48.400Z","comments":true,"path":"JVM永久代与元空间.html","link":"","permalink":"http://www.baiyp.ren/JVM永久代与元空间.html","excerpt":"","text":"JVM永久代与元空间方法区与永久代方法区和永久代又有着本质的区别。前者是 JVM 的规范，而后者则是 JVM 规范的一种实现，并且只有 HotSpot 才有永久代，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出​ 在Java虚拟机规范中，方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择不在方法区实现垃圾回收与压缩。这个版本的虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。所以不同的JVM厂商，针对自己的JVM可能有不同的方法区实现方式。​ 在HotSpot中，设计者将方法区纳入GC分代收集。HotSpot虚拟机堆内存被分为新生代和老年代，对堆内存进行分代管理，所以HotSpot虚拟机使用者更愿意将方法区称为老年代。​ 方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。​ 我们知道在HotSpot虚拟机中存在三种垃圾回收现象，minor GC、major GC和full GC。对新生代进行垃圾回收叫做minor GC，对老年代进行垃圾回收叫做major GC，同时对新生代、老年代和永久代进行垃圾回收叫做full GC。许多major GC是由minor GC触发的，所以很难将这两种垃圾回收区分开。major GC和full GC通常是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是major GC。大小调节在1.7之前，可以使用如下参数来调节方法区的大小12345//方法区初始大小-XX:PermSize// 方法区最大大小, 超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen-XX:MaxPermSizejdk8中的方法区​ 在jdk8中已经将永久带移除了。也就是说-XX:PermSize这些参数在jdk8中将是无效的。移除了，肯定有人来代替他。就是新出现的元空间(Metaspace)来代替原来的永久带。方法区中主要存放的是一些描述性信息，即元数据。​ 方法区是堆的逻辑组成部分。实际上JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，但是并没完全移除。大小调整在1.8中，使用如下参数来调节方法区的大小12345//元空间初始大小-XX: MetaspaceSize// 元空间最大大小, 超过这个值将会抛出OutOfMemoryError异常：java.lang.OutOfMemoryError: Metadata space-XX: MaxMetaspaceSize永久代​ 永久代中包含了虚拟机中所有可通过反射获取到的数据，比如Class和Method对象。不同的Java虚拟机之间可能会进行类共享，因此永久代又分为只读区和读写区。​ JVM用于描述应用程序中用到的类和方法的元数据也存储在永久代中。JVM运行时会用到多少永久代的空间取决于应用程序用到了多少类。除此之外，Java SE库中的类和方法也都存储在这里。​ 如果JVM发现有的类已经不再需要了，它会去回收（卸载）这些类，将它们的空间释放出来给其它类使用。Full GC会进行持久代的回收。JVM中类的元数据在Java堆中的存储区域。Java类对应的HotSpot虚拟机中的内部表示也存储在这里。类的层级信息，字段，名字。方法的编译信息及字节码。变量常量池和符号解析永久代大小它的上限是MaxPermSize，默认是64MJava堆中的连续区域 : 如果存储在非连续的堆空间中的话，要定位出持久代到新对象的引用非常复杂并且耗时。卡表（card table），是一种记忆集（Remembered Set），它用来记录某个内存代中普通对象指针（oops）的修改。持久代用完后，会抛出OutOfMemoryError “PermGen space”异常。解决方案：应用程序清理引用来触发类卸载；增加MaxPermSize的大小。需要多大的持久代空间取决于类的数量，方法的大小，以及常量池的大小。为什么移除持久代它的大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？HotSpot的内部类型也是Java对象：它可能会在Full GC中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。简化Full GC：每一个回收器有专门的元数据迭代器。可以在GC不进行暂停的情况下并发地释放类数据。使得原来受限于持久代的一些改进未来有可能实现元空间(metaspace)JDK 8的HotSpot JVM现在使用的是本地内存来表示类的元数据，这个区域就叫做元空间。​ 持久代的空间被彻底地删除了，它被一个叫元空间的区域所替代了。持久代删除了之后，很明显，JVM会忽略PermSize和MaxPermSize这两个参数，还有就是你再也看不到java.lang.OutOfMemoryError: PermGen error的异常了。原来类的静态变量和Interned Strings 都被转移到了java堆区，只有class元数据才在元空间。元空间的特点充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。每个加载器有专门的存储空间只进行线性分配不会单独回收某个类省掉了GC扫描及压缩的时间元空间里的对象的位置是固定的如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉元空间的内存分配模型绝大多数的类元数据的空间都从本地内存中分配用来描述类元数据的类也被删除了分元数据分配了多个虚拟内存空间给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些归还内存块，释放内存块列表一旦元空间的数据被清空了，虚拟内存的空间会被回收掉减少碎片的策略元空间内存管理​ 元空间的内存管理由元空间虚拟机来完成。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，类和其元数据的生命周期和其对应的类加载器是相同的。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。​ 准确的来说，每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。​ 元空间虚拟机负责元空间的分配，其采用的形式为组块分配。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个全局的空闲组块列表。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。组块中的块是线性分配（指针碰撞分配形式）。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。​ 运行时常量池在JDK1.6及之前版本的JVM中是方法区的一部分，而在HotSpot虚拟机中方法区放在了”永久代(Permanent Generation)”。所以运行时常量池也是在永久代的，但是JDK1.7及之后版本的JVM已经将字符串常量池从方法区中移了出来，在Java 堆（Heap）中开辟了一块区域存放运行时常量池。​ String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的引用。永久代与元空间JDK8 HotSpot JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）以下是JVM内存模型中方法区的变动1.新生代：Eden+From Survivor+To Survivor2.老年代：OldGen3.永久代（方法区的实现） : PermGen—–&gt;替换为Metaspace(本地内存中)​ 元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：​ 《Java虚拟机规范(JavaSE7)》中也说了方法区是堆的逻辑组成部分。实际上JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代在JDK1.8才被移除移除永久代的影响​ 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，我们就不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM会自动根据类的元数据大小动态增加元空间的容量。注意：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/categories/JVM/"},{"name":"运行时数据区","slug":"JVM/运行时数据区","permalink":"http://www.baiyp.ren/categories/JVM/运行时数据区/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/tags/JVM/"},{"name":"永久代","slug":"永久代","permalink":"http://www.baiyp.ren/tags/永久代/"},{"name":"元空间","slug":"元空间","permalink":"http://www.baiyp.ren/tags/元空间/"}],"keywords":[{"name":"JVM","slug":"JVM","permalink":"http://www.baiyp.ren/categories/JVM/"},{"name":"运行时数据区","slug":"JVM/运行时数据区","permalink":"http://www.baiyp.ren/categories/JVM/运行时数据区/"}]},{"title":"并发面试题总结","slug":"并发面试题总结","date":"2019-09-07T09:12:30.000Z","updated":"2019-09-07T09:56:25.851Z","comments":true,"path":"并发面试题总结.html","link":"","permalink":"http://www.baiyp.ren/并发面试题总结.html","excerpt":"","text":"并发面试题总结谈面试面试主要分为两块：一块是考查工程师对基础知识（包括了技术广度、深度、对技术的热情度等）的掌握程度，因为基础知识决定了一个技术人员发展的上限；另一块是考察工程师的工程能力，比如：做过哪些项目？遇到最难的问题怎样解决的？说说最有成就感的一项任务？工程能力是考察工程师当下能为公司带来的利益。当然还有其它考核方面：抗压性、合作能力。Java只是一门语言，即使是Java工程师也不能局限于Java，要从面向对象语言本身，甚至从整个计算机体系，从工程实际出发看Java。很多知识在一般公司的开发中是用不到的，常有人戏称：“面试造火箭，工作拧螺丝”，但这只是通常情况下公司对程序员的标准——迅速产出，完成任务。所以，工程师为了自己职业的发展不能局限于公司对自己的要求，不能停留在应用层面，要能够很好地掌握基础知识，要多看源码，自己多实践，学成记得产出，比如多为开源社区贡献代码，帮助初学者指路等。其实“面试造火箭，工作拧螺丝”的背后其实是大家都普遍认可基础知识的重要性。常见面试题1.在java中守护线程和用户线程的区别？java中的线程分为两种：守护线程（Daemon）用户线程（User）。任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。两者的区别：唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经结束，Daemon 没有可服务的线程，JVM关闭。扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程2.线程与进程的区别​ 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。​ 一个程序至少有一个进程,一个进程至少有一个线程。3.什么是多线程中的上下文切换多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。4.死锁与活锁的区别，死锁与饥饿的区别？死锁：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。产生死锁的必要条件：互斥条件：所谓互斥就是进程在某一时间内独占资源。请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。活锁：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。饥饿：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。5.synchronized底层实现原理​ synchronized (this)原理：涉及两条指令：monitorenter，monitorexit；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。​ JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。注意，这个问题可能会接着追问，java对象头信息，偏向锁，轻量锁，重量级锁及其他们相互间转化。6.什么是线程组，为什么在Java中不推荐使用？ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。线程组ThreadGroup对象中比较有用的方法是stop、resume、suspend等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。线程组ThreadGroup不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。7.什么是Executors框架？为什么使用Executor框架？Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。调用 new Thread()创建的线程缺乏管理，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。8.在Java中Executor和Executors的区别？Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。Executor 接口对象能执行我们的线程任务。ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。使用ThreadPoolExecutor 可以创建自定义线程池。9.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？原子操作（atomic operation）意为”不可被中断的一个或一系列操作” 。处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。在Java中可以通过锁和循环CAS的方式来实现原子操作。CAS操作——Compare And Set，或是 Compare And Swap，现在几乎所有的CPU指令都支持CAS的原子操作。java.util.concurrent.atomic下提供了大量的原子操作类，比如原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference ，原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray ，原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater10.Java Concurrency API中的Lock接口(Lock interface)是什么？对比synchronized它有什么优势？Lock接口比同步方法和同步块提供了更具扩展性的锁操作。他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。它的优势有：可以使锁更公平，可以使线程在等待锁的时候响应中断，可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间，可以在不同的范围，以不同的顺序获取和释放锁。整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。11.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。JDK7提供了7个阻塞队列。在实现上，主要是利用了Condition和Lock的等待通知模式。12.什么是Callable和Future?Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。可以认为是带有回调的Runnable。Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。13.什么是FutureTask?​ 在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。14.什么是并发容器的实现？何为同步容器：可以简单地理解为通过synchronized来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。15.多线程同步和互斥有几种实现方法，都是什么？线程同步：是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。线程互斥：是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。线程间的同步方法大体可分为两类：用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。16.什么是竞争条件？​ 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。17.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。18.在Java中CycliBarriar和CountdownLatch有什么区别？CyclicBarrier可以重复使用，而CountdownLatch不能重复使用。19.什么是不可变对象，它对写并发应用有什么帮助？不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。不可变对象永远是线程安全的。只有满足如下状态，一个对象才是不可变的：它的状态不能在创建后再被修改；所有域都是final类型；并且， 它被正确创建20.notify()和notifyAll()有什么区别？当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。21.什么是可重入锁（ReentrantLock）？谈谈它的实现。​ 线程可以重复进入任何一个它已经拥有的锁所同步着的代码块，synchronized、ReentrantLock都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每 释放一次锁，进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。22.当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？如果其他方法没有synchronized的话，其他线程是可以进入的。所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。23.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java里面的同步原语synchronized关键字的实现是悲观锁。乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。在Java中j原子变量类就是使用了乐观锁的一种实现方式CAS实现的。乐观锁的实现方式：使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。24.什么是CAS操作，缺点是什么？CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。CAS缺点：ABA问题：​ 比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。循环时间长开销大：​ 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。只能保证一个共享变量的原子操作：​ 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。25.SynchronizedMap和ConcurrentHashMap有什么区别？SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。ConcurrentHashMap使用分段锁来保证在多线程下的性能。26.写时复制容器可以用于什么应用场景？CopyOnWrite并发容器用于对于绝大部分访问都是读，且只是偶尔写的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。透露的思想：读写分离，读和写分开最终一致性使用另外开辟空间的思路，来解决并发冲突27.volatile有什么用？能否用一句话说明下volatile的应用场景？volatile保证内存可见性和禁止指令重排。volatile用于多线程环境下的一写多读，或者无关联的多写。28.为什么代码会重排序？​ 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：在单线程环境下不能改变程序运行的结果；存在数据依赖关系的不允许重排序29.在java中wait和sleep方法的不同？​ 最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。30.一个线程运行时发生异常会怎样？​ 如果异常没有被捕获该线程将会停止执行。hread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。31.为什么wait, notify 和 notifyAll这些方法不在thread类里面？​ JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。32.什么是ThreadLocal变量？​ ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。33.Java中interrupted 和 isInterrupted方法的区别？​ interrupted() 和 isInterrupted()的主要区别是前者会将中断状态清除而后者不会。​ Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。34.为什么wait和notify方法要在同步块中调用？​ 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。35.为什么你应该在循环中检查等待条件?​ 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因36.怎么检测一个线程是否拥有锁？​ 在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。37.你如何在Java中获取线程堆栈？kill -3 [java pid]不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，kill -3 tomcat pid, 输出堆栈到log目录下。Jstack [java pid]这个比较简单，在当前终端显示，也可以重定向到指定文件中。或者使用Java提供的拟机线程系统的管理接口ManagementFactory.getThreadMXBean()。38.Java线程池中submit() 和 execute()方法有什么区别？​ 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口39.你对线程优先级的理解是什么？​ 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。​ java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。40.你如何确保main()方法所在的线程是Java 程序最后结束的线程？​ 可以使用Thread类的join()方法（或者CountDownLatch工具类）来确保所有程序创建的线程在main()方法退出前结束。41.为什么Thread类的sleep()和yield ()方法是静态的？​ Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？​ 可以用join方法实现。42.你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？​ volatile关键字，读写锁，写时复制等等都可以实现。43.用Java实现阻塞队列​ 适用Lock或者synchronize，队列空的时候进行阻塞，有新的入队的时候唤醒阻塞。44.用Java写代码来解决生产者——消费者问题。​ 阻塞队列实现即可，也可以用wait和notify来解决这个问题，或者用Semaphore45.用Java编程一个会导致死锁的程序，你将怎么解决？参照 JAVA中的死锁一章46.Java中如何停止一个线程？使用共享变量的方式​ 在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。使用interrupt方法终止线程​ 如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。所以应该尽量使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态。47.JVM中哪个参数是用来控制线程的栈堆栈大小的-Xss48.如果同步块内的线程抛出异常锁会释放吗？会49.单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？​ 不安全的根本原因是重排序会导致未初始化完成的对象可以被其他线程看见而导致错误。创建安全的单例模式有：延迟占位模式、在声明的时候就new这个类的实例、枚举50.写出3条你遵循的多线程最佳实践给你的线程起个有意义的名字。 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。比如并发编程的黄金原则，尽量无锁化编程等等……..51.合理地配置线程池CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。对于IO型的任务的最佳线程数，有个公式可以计算 Nthreads = NCPU * UCPU * (1 + W/C)52.请概述锁的公平和非公平，JDK内部是如何实现的。公平锁：是指所有试图获得锁的线程按照获取锁的顺序依次获得锁，而非公平锁则是当前的锁状态没有被占用时,当前线程可以直接占用,而不需要等待。在实现上，非公平锁逻辑基本跟公平锁一致，唯一的区别是，当前线程不需要判断同步队列中是否有等待线程。非公平锁：性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。​ 使用场景的话呢，其实还是和他们的属性一一相关，比如：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平锁其实效率并不明显，但是用公平锁可以保证不会有线程被饿死。53.请概述AQS​ 是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock和CountDownLatch就是基于AQS实现的。它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。它是CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。​ AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如tryAcquire、tryReleaseShared等等。​ 这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。​ 在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。同时与Condition相关的等待队列，节点类型也是Node，构成一个单向链表。54.请概述volatilevolatile关键字的作用主要有两点：​ 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。但是volatile不能保证操作的原子，对任意单个volatile变量的读/写具有原子性，但类似于++这种复合操作不具有原子性。。​ 代码底层在执行时为了获取更好的性能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止重排序，当然这也一定程度上降低了代码执行效率。​ 同时在内存语义上，当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存，当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。​ 在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序问题、强制刷新和读取。​ 在具体实现上，volatile关键字修饰的变量会存在一个“lock:”的前缀。它不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。​ 同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"面试题","slug":"并发/面试题","permalink":"http://www.baiyp.ren/categories/并发/面试题/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"面试题","slug":"面试题","permalink":"http://www.baiyp.ren/tags/面试题/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"面试题","slug":"并发/面试题","permalink":"http://www.baiyp.ren/categories/并发/面试题/"}]},{"title":"Synchronized锁优化","slug":"Synchronized锁优化","date":"2019-09-07T01:11:04.000Z","updated":"2019-09-07T10:04:05.963Z","comments":true,"path":"Synchronized锁优化.html","link":"","permalink":"http://www.baiyp.ren/Synchronized锁优化.html","excerpt":"","text":"Synchronized锁优化jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。锁主要存在四中状态，依次是：无锁-&gt; 偏向锁 -&gt; 轻量级锁 -&gt; 重量级锁，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。自旋锁​ 线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。何谓自旋锁？所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋），和CAS类似。自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。适应自旋锁​ JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。​ 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。锁消除​ 为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：12345678public void vectorTest()&#123; Vector&lt;String&gt; vector = new Vector&lt;String&gt;(); for(int i = 0 ; i &lt; 10 ; i++)&#123; vector.add(i + \"\"); &#125; System.out.println(vector); &#125;在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。逃逸分析如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行优化：同步消除synchronization Elimination，如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。锁粗化​ 我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。​ 在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如下面的例子，一个方法由两个加锁,因为num = x + y;耗时较短，对比两次锁短的多，就会锁粗化。1234567891011121314151617181920212223private int x, y; /** * 因为一个方法需要两个加锁解锁耗费资源 * 对于 num = x + y; 耗费时间很短 就会将 * 代码包裹进去组成一个锁 * @return */ public int lockCoarsening() &#123; int num = 0; //对象锁 synchronized (this) &#123; x++; //todo 处理部分业务 &#125; num = x + y; //对象锁 synchronized (this) &#123; y++; //todo 处理部分业务 &#125; return num; &#125;粗化后12345678910111213141516171819private int x, y; /** * 使用一个锁 * * @return */ public int lockCoarsening() &#123; int num = 0; //只进行一次加锁解锁 synchronized (this) &#123; x++; //todo 处理部分业务 num = x + y; y++; //todo 处理部分业务 &#125; return num; &#125;轻量级锁​ 引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。获取锁判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；释放锁轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：取出在获取轻量级锁保存在Displaced Mark Word中的数据；用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；偏向锁引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可获取锁检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；执行同步代码块释放锁偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；重量级锁​ 重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。为什么重量级锁的开销比较大呢​ 原因是当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现，也就是相当于从用户态转化到内核态，而转化状态是需要消耗时间的三种锁的区别锁优点缺点使用场景偏向锁加锁和解锁不需要CAS，没有额外的性能消耗，和执行非同步方法相比，仅存在纳秒级的差距如果线程间存在锁竞争，会带来额外的锁撤销的消耗只有一个线程访问同步块或者同步方法的场景轻量级锁竞争的线程不会阻塞提高响应速度若线程长时间抢不到锁，自旋会消耗CPU性能线程交替执行同步块或者同步方法的场景重量级锁线程竞争不使用自旋，不消耗CPU线程阻塞，响应时间缓慢,在多线程下,频繁的获取释放锁，会带来巨大的性能消耗追求吞吐量，同步块或者同步方法执行时间较长的场景锁升级偏向锁升级轻量级锁：当一个对象持有偏向锁，一旦第二个线程访问这个对象，如果产生竞争，偏向锁升级为轻量级锁。轻量级锁升级重量级锁：一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。wait和notify的原理调用wait方法，首先会获取监视器锁，获得成功以后，会让当前线程进入等待状态进入等待队列并且释放锁。当其他线程调用notify后，会选择从等待队列中唤醒任意一个线程，而执行完notify方法以后，并不会立马唤醒线程，原因是当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁。必须要等到当前的线程执行完按monitorexit指令以后，也就是锁被释放以后，处于等待队列中的线程就可以开始竞争锁了。wait和notify为什么需要在synchronized里面？wait方法的语义有两个，一个是释放当前的对象锁、另一个是使得当前线程进入阻塞队列，而这些操作都和监视器是相关的，所以wait必须要获得一个监视器锁。而对于notify来说也是一样，它是唤醒一个线程，既然要去唤醒，首先得知道它在哪里，所以就必须要找到这个对象获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"Synchronized","slug":"并发/Synchronized","permalink":"http://www.baiyp.ren/categories/并发/Synchronized/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"Synchronized","slug":"Synchronized","permalink":"http://www.baiyp.ren/tags/Synchronized/"},{"name":"锁优化","slug":"锁优化","permalink":"http://www.baiyp.ren/tags/锁优化/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"Synchronized","slug":"并发/Synchronized","permalink":"http://www.baiyp.ren/categories/并发/Synchronized/"}]},{"title":"Synchronized实现原理","slug":"Synchronized实现原理","date":"2019-09-07T01:11:04.000Z","updated":"2019-09-07T04:06:49.008Z","comments":true,"path":"Synchronized实现原理.html","link":"","permalink":"http://www.baiyp.ren/Synchronized实现原理.html","excerpt":"","text":"Synchronized实现原理三种应用方式修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象。特性原子性被 synchronized 修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在 Java 中可以使用 synchronized 来保证方法和代码块内的操作是原子性的。可见性对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。有序性synchronized 本身是无法禁止指令重排和处理器优化的，as-if-serial 语义：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。编译器和处理器无论如何优化，都必须遵守 as-if-serial 语义。synchronized 修饰的代码，同一时间只能被同一线程执行。所以，可以保证其有序性。可重入性​ 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。原理synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性字节码指令​ synchronized同步块使用了monitorenter和monitorexit指令实现同步，这两个指令，本质上都是对一个对象的监视器(monitor)进行获取，这个过程是排他的，也就是说同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。​ 线程执行到monitorenter指令时，会尝试获取对象所对应的monitor所有权，也就是尝试获取对象的锁，而执行monitorexit，就是释放monitor的所有权。内存语义当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量所以锁的释放-获取和volatile的写-读具有相同的内存语义。volatile可以看过轻量级的锁，小结下：A释放锁 ，即 A向后来将拿锁的线程B发送一个消息B拿锁，即B接收了之前释放锁的线程A的一个消息A释放锁、B拿锁，其实就是A向B发送个消息。构成Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：普通同步方法，锁是当前实例对象静态同步方法，锁是当前类的class对象同步方法块，锁是括号里面的对象当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码：12345678public class SynchronizedTest &#123; public void test2() &#123; synchronized (this) &#123; &#125; &#125;&#125;利用javap工具查看生成的class文件信息来分析Synchronize的实现从上面可以看出，同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。同步代码块：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；同步方法：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象下面我们来继续分析，但是在深入之前我们需要了解两个重要的概念：Java对象头，Monitor。Java对象头在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头（Mark Word、Class Metadata Address）、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础。一般而言，synchronized使用的锁对象是存储在Java对象头里。它是轻量级锁和偏向锁的关键。Mark WordMark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit）。Class Metadata Address类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。Array length如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。Monitor我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：Owner：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；EntryQ:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。RcThis:表示blocked或waiting在该monitor record上的所有线程的个数。Nest:用来实现重入锁的计数。HashCode:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。Candidate:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。在hotspot虚拟机中，通过ObjectMonitor类来实现monitor。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"Synchronized","slug":"并发/Synchronized","permalink":"http://www.baiyp.ren/categories/并发/Synchronized/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"Synchronized","slug":"Synchronized","permalink":"http://www.baiyp.ren/tags/Synchronized/"},{"name":"实现原理","slug":"实现原理","permalink":"http://www.baiyp.ren/tags/实现原理/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"Synchronized","slug":"并发/Synchronized","permalink":"http://www.baiyp.ren/categories/并发/Synchronized/"}]},{"title":"MYBATIS源码解析-02数据库连接池","slug":"MYBATIS源码解析-02数据库连接池","date":"2019-09-04T08:58:57.000Z","updated":"2019-09-04T10:04:19.385Z","comments":true,"path":"MYBATIS源码解析-02数据库连接池.html","link":"","permalink":"http://www.baiyp.ren/MYBATIS源码解析-02数据库连接池.html","excerpt":"","text":"MYBATIS数据库连接池什么是数据库连接池​ 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。​ 在使用 Mybatis 的时候，数据库的连接一般都会使用第三方的数据源组件，如 C3P0，DBCP 和 Druid 等，其实 Mybatis 也有自己的数据源实现，可以连接数据库，还有连接池的功能，下面就来看看 Mybatis 自己实现的数据源头和连接池的一个实现原理。类结构Mybatis 数据源的实现主要是在 datasource 包：​ 我们常见的数据库连接池都需要实现javax.sql.DataSource接口mybatis提供了UnpooledDataSource和PooledDataSource的实现， 一个使用连接池，一个不使用连接池此外，对于这两个类，Mybatis 还提供了两个工厂类进行创建对象，是工厂方法模式的一个应用，首先来看下它们的一个类图：我们先看下工厂类DataSourceFactory数据源连接池工厂类接口该类是 JndiDataSourceFactory 和 UnpooledDataSourceFactory 两个工厂类的顶层接口，只定义了两个方法123456789101112131415161718/** * 数据源连接池 接口 * @author Clinton Begin */public interface DataSourceFactory &#123; /** * 设置属性 * @param props */ void setProperties(Properties props); /** * 获取数据源连接池 * @return */ DataSource getDataSource();&#125;UnpooledDataSourceFactoryUnpooledDataSourceFactory 主要用来创建 UnpooledDataSource 对象，它会在构造方法中初始化 UnpooledDataSource 对象，并在 setProperties 方法中完成对 UnpooledDataSource 对象的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * UnpooledDataSource 连接工厂 * * @author Clinton Begin */public class UnpooledDataSourceFactory implements DataSourceFactory &#123; // 数据库驱动前缀 private static final String DRIVER_PROPERTY_PREFIX = \"driver.\"; private static final int DRIVER_PROPERTY_PREFIX_LENGTH = DRIVER_PROPERTY_PREFIX.length(); // 对应的数据源，即 UnpooledDataSource protected DataSource dataSource; //构造方法 public UnpooledDataSourceFactory() &#123; this.dataSource = new UnpooledDataSource(); &#125; /** * 对数据源 UnpooledDataSource 进行配置 * * @param properties */ @Override public void setProperties(Properties properties) &#123; //数据源属性文件 Properties driverProperties = new Properties(); // 创建 DataSource 相应的 MetaObject MetaObject metaDataSource = SystemMetaObject.forObject(dataSource); // 遍历 properties 集合，该集合中存放了数据源需要的信息 for (Object key : properties.keySet()) &#123; String propertyName = (String) key; // 以 \"driver.\" 开头的配置项是对 DataSource 的配置，记录到 driverProperties 中 if (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123; String value = properties.getProperty(propertyName); //设置连接的属性和值 driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value); // 该属性是否有 set 方法 &#125; else if (metaDataSource.hasSetter(propertyName)) &#123; // 获取对应的属性值 String value = (String) properties.get(propertyName); // 根据属性类型进行类型的转换，主要是 Integer, Long, Boolean 三种类型的转换 Object convertedValue = convertValue(metaDataSource, propertyName, value); // 设置DataSource 的相关属性值 metaDataSource.setValue(propertyName, convertedValue); &#125; else &#123; throw new DataSourceException(\"Unknown DataSource property: \" + propertyName); &#125; &#125; // 设置 DataSource.driverProerties 属性值 if (driverProperties.size() &gt; 0) &#123; metaDataSource.setValue(\"driverProperties\", driverProperties); &#125; &#125; // 返回数据源 @Override public DataSource getDataSource() &#123; return dataSource; &#125; // 类型转 private Object convertValue(MetaObject metaDataSource, String propertyName, String value) &#123; Object convertedValue = value; Class&lt;?&gt; targetType = metaDataSource.getSetterType(propertyName); if (targetType == Integer.class || targetType == int.class) &#123; convertedValue = Integer.valueOf(value); &#125; else if (targetType == Long.class || targetType == long.class) &#123; convertedValue = Long.valueOf(value); &#125; else if (targetType == Boolean.class || targetType == boolean.class) &#123; convertedValue = Boolean.valueOf(value); &#125; return convertedValue; &#125;&#125;JndiDataSourceFactory 依赖 JNDI 服务器中获取用户配置的 DataSource，这里可以不看。UnpooledDataSourceFactory工厂类主要的作用是对数据源进行配置。PooledDataSourceFactoryPooledDataSourceFactory 主要用来创建 PooledDataSource 对象，它继承了 UnpooledDataSource 类，设置 DataSource 参数的方法复用UnpooledDataSource 中的 setProperties 方法，只是数据源返回的是 PooledDataSource 对象而已。12345678910111213/** * 连接池工厂 * @author Clinton Begin */public class PooledDataSourceFactory extends UnpooledDataSourceFactory &#123; /** * 创建连接池对象 */ public PooledDataSourceFactory() &#123; this.dataSource = new PooledDataSource(); &#125;&#125;以上这些就是 Mybatis 用来创建数据源的工厂类，下面就来看下数据源的主要实现。UnpooledDataSourceUnpooledDataSource 不使用连接池来创建数据库连接，每次获取数据库连接时都会创建一个新的连接进行返回；初始化过程在static静态块中进行驱动注册123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 未使用连接池的类 * * @author Clinton Begin * @author Eduardo Macarron */public class UnpooledDataSource implements DataSource &#123; // 加载 Driver 类的类加载器 private ClassLoader driverClassLoader; // 数据库连接驱动的相关配置 private Properties driverProperties; // 缓存所有已注册的数据库连接驱动 private static Map&lt;String, Driver&gt; registeredDrivers = new ConcurrentHashMap&lt;&gt;(); //数据源配置相关 private String driver; private String url; private String username; private String password; // 是否自动提交 private Boolean autoCommit; //默认事务隔离级别 private Integer defaultTransactionIsolationLevel; //默认超时时间 private Integer defaultNetworkTimeout; /** * 静态块，在初始化的时候，从 DriverManager 中获取所有的已注册的驱动信息，并缓存到该类的 registeredDrivers集合中 */ static &#123; //获取驱动信息 Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers(); while (drivers.hasMoreElements()) &#123; Driver driver = drivers.nextElement(); //注册进集合中 registeredDrivers.put(driver.getClass().getName(), driver); &#125; &#125; /** * 无参构造 */ public UnpooledDataSource() &#123; &#125; public UnpooledDataSource(String driver, String url, String username, String password) &#123; this.driver = driver; this.url = url; this.username = username; this.password = password; &#125; public UnpooledDataSource(String driver, String url, Properties driverProperties) &#123; this.driver = driver; this.url = url; this.driverProperties = driverProperties; &#125;&#125;获取一个连接这里面没有提供连接销毁的方法，在连接池中有销毁连接的方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106** * 获取一个连接 * * @return 连接对象 * @throws SQLException */@Overridepublic Connection getConnection() throws SQLException &#123; return doGetConnection(username, password);&#125;@Overridepublic Connection getConnection(String username, String password) throws SQLException &#123; return doGetConnection(username, password);&#125;/** * 创建一个数据库连接 * * @param username * @param password * @return * @throws SQLException */private Connection doGetConnection(String username, String password) throws SQLException &#123; Properties props = new Properties(); if (driverProperties != null) &#123; props.putAll(driverProperties); &#125; //设置用户 if (username != null) &#123; props.setProperty(\"user\", username); &#125; //设置密码 if (password != null) &#123; props.setProperty(\"password\", password); &#125; return doGetConnection(props);&#125;/** * 创建一个连接对象 * * @param properties 数据库属性文件 * @return 数据库连接 * @throws SQLException */private Connection doGetConnection(Properties properties) throws SQLException &#123; //初始化驱动信息 initializeDriver(); // 通过 DriverManager 来获取一个数据库连接 Connection connection = DriverManager.getConnection(url, properties); //配置连接信息 configureConnection(connection); return connection;&#125;/** * 初始化驱动信息 * * @throws SQLException */private synchronized void initializeDriver() throws SQLException &#123; // 如果当前的驱动还没有注册，则进行注册 if (!registeredDrivers.containsKey(driver)) &#123; Class&lt;?&gt; driverType; try &#123; //驱动的类加载器不为空 if (driverClassLoader != null) &#123; //获取驱动类型 driverType = Class.forName(driver, true, driverClassLoader); &#125; else &#123; driverType = Resources.classForName(driver); &#125; // DriverManager requires the driver to be loaded via the system ClassLoader. // http://www.kfu.com/~nsayer/Java/dyn-jdbc.html //创建驱动 Driver driverInstance = (Driver) driverType.newInstance(); //向JDBC注册驱动 DriverManager.registerDriver(new DriverProxy(driverInstance)); //向registeredDrivers注册驱动 registeredDrivers.put(driver, driverInstance); &#125; catch (Exception e) &#123; throw new SQLException(\"Error setting driver on UnpooledDataSource. Cause: \" + e); &#125; &#125;&#125;/** * 配置数据库连接信息 * @param conn * @throws SQLException */private void configureConnection(Connection conn) throws SQLException &#123; //设置超时时间 if (defaultNetworkTimeout != null) &#123; conn.setNetworkTimeout(Executors.newSingleThreadExecutor(), defaultNetworkTimeout); &#125; //设置是否自动提交 if (autoCommit != null &amp;&amp; autoCommit != conn.getAutoCommit()) &#123; conn.setAutoCommit(autoCommit); &#125; //设置事务隔离等级 if (defaultTransactionIsolationLevel != null) &#123; conn.setTransactionIsolation(defaultTransactionIsolationLevel); &#125;&#125;​ 以上代码就是 UnpooledDataSource 类的主要实现逻辑，每次获取连接都是从数据库新创建一个连接进行返回，又因为，数据库连接的创建是一个耗时的操作，且数据库连接是非常珍贵的资源，如果每次获取连接都创建一个，则可能会造成系统的瓶颈，拖垮响应速度等，这时就需要数据库连接池了，Mybatis 也提供了自己数据库连接池的实现，就是 PooledDataSource 类。PooledDataSourcePooledDataSource 是一个比较复杂的类，PooledDataSource 新创建数据库连接是使用 UnpooledDataSource 来实现的，且 PooledDataSource 并不会管理 java.sql.Connection 对象，而是管理 PooledConnection 对象，在 PooledConnection 中封装了真正的数据库连接对象和其代理对象；此外，由于它是一个连接池，所以还需要管理连接池的状态，比如有多少连接是空闲的，还可以创建多少连接，此时，就需要一个类来管理连接池的对象，即 PoolState 对象；先来看下 PooledDataSource 的一个 UML 图：PooledConnection它主要是用来管理数据库连接的，它是一个代理类，实现了 InvocationHandler 接口主体方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * mybatis 连接池对象 使用的是 动态代理 * * @author Clinton Begin */class PooledConnection implements InvocationHandler &#123; //关闭方法 private static final String CLOSE = \"close\"; private static final Class&lt;?&gt;[] IFACES = new Class&lt;?&gt;[]&#123;Connection.class&#125;; private final int hashCode; // 记录当前的 PooledConnection 对象所在的 PooledDataSource 对象，该 PooledConnection 对象是从 PooledDataSource 对象中获取的，当调用 close 方法时会将 PooledConnection 放回该 PooledDataSource 中去 private final PooledDataSource dataSource; //真实连接 private final Connection realConnection; // 数据库连接的代理对象 private final Connection proxyConnection; // 从连接池中取出该连接的时间戳 private long checkoutTimestamp; // 该连接创建的时间戳 private long createdTimestamp; // 该连接最后一次被使用的时间戳 private long lastUsedTimestamp; // 用于标识该连接所在的连接池，由URL+username+password 计算出来的hash值 private int connectionTypeCode; // 该连接是否有效 private boolean valid; /** * Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in. * 创建连接 * * @param connection - the connection that is to be presented as a pooled connection * @param dataSource - the dataSource that the connection is from */ public PooledConnection(Connection connection, PooledDataSource dataSource) &#123; this.hashCode = connection.hashCode(); this.realConnection = connection; this.dataSource = dataSource; this.createdTimestamp = System.currentTimeMillis(); this.lastUsedTimestamp = System.currentTimeMillis(); this.valid = true; this.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, this); &#125; /** * Invalidates the connection. * 废弃该连接 设置连接未不可用 */ public void invalidate() &#123; valid = false; &#125; /** * Method to see if the connection is usable. * 检查连接是否可用 连接可用并且能够被ping， * 1.判断 valid 字段 * 2.向数据库中发送检测测试的SQL，查看真正的连接还是否有效 * @return True if the connection is usable */ public boolean isValid() &#123; return valid &amp;&amp; realConnection != null &amp;&amp; dataSource.pingConnection(this); &#125; /** * 检查连接 * @throws SQLException */ private void checkConnection() throws SQLException &#123; if (!valid) &#123; throw new SQLException(\"Error accessing PooledConnection. Connection is invalid.\"); &#125; &#125;&#125;invok代理方法该方法是 proxyConnection 这个连接代理对象的真正代理逻辑，它会对 close 方法进行代理，并且在调用真正的连接之前对连接进行检测。12345678910111213141516171819202122232425262728293031/** * Required for InvocationHandler implementation. * 动态代理的入口方法 * * @param proxy - not used * @param method - the method to be executed * @param args - the parameters to be passed to the method * @see java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[]) */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; String methodName = method.getName(); //如果关闭连接 将当前连接放回连接池 资源复用 if (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123; dataSource.pushConnection(this); return null; &#125; try &#123; //不是Object对象的一些方法例如 toString等方法 if (!Object.class.equals(method.getDeclaringClass())) &#123; // issue #579 toString() should never fail // throw an SQLException instead of a Runtime // 执行之前，需要进行连接的检测 checkConnection(); &#125; // 调用数据库真正的连接进行执行 return method.invoke(realConnection, args); &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125;PoolStatePoolState 类主要是用来管理连接池的状态，比如哪些连接是空闲的，哪些是活动的，还可以创建多少连接等。该类中只是定义了一些属性来进行控制连接池的状态，并没有任何的方法。12345678910111213141516171819202122232425262728293031323334353637/** * 连接池状态 * @author Clinton Begin */public class PoolState &#123; // 该 PoolState 属于哪个 PooledDataSource protected PooledDataSource dataSource; // 来用存放空闲的 pooledConnection 连接 protected final List&lt;PooledConnection&gt; idleConnections = new ArrayList&lt;&gt;(); // 用来存放活跃的 PooledConnection 连接 protected final List&lt;PooledConnection&gt; activeConnections = new ArrayList&lt;&gt;(); // 请求数据库连接的次数 protected long requestCount = 0; // 请求数据库连接的次数 protected long accumulatedRequestTime = 0; // checkoutTime 表示从连接池中获取连接到归还连接的时间 // accumulatedCheckoutTime 记录了所有连接的累计 checkoutTime 时长 protected long accumulatedCheckoutTime = 0; // 连接超时的连接个数 protected long claimedOverdueConnectionCount = 0; // 累计超时时间 protected long accumulatedCheckoutTimeOfOverdueConnections = 0; // 累计等待时间 protected long accumulatedWaitTime = 0; // 等待次数 protected long hadToWaitCount = 0; // 无效的连接数 protected long badConnectionCount = 0; /** * 构造方法 * @param dataSource */ public PoolState(PooledDataSource dataSource) &#123; this.dataSource = dataSource; &#125;&#125;PooledDataSource终于等来了我们的主角，PooledDataSource 它是一个简单的，同步的，线程安全的数据库连接池​ 知道了 UnpooledDataSource 用来创建数据库新的连接，PooledConnection 用来管理连接池中的连接，PoolState 用来管理连接池的状态之后，来看下 PooledDataSource 的一个逻辑，该类中主要有以下几个方法：获取数据库连接的方法 popConnection，把连接放回连接池的方法 pushConnection，检测数据库连接是否有效的方法 pingConnection ，还有 关闭连接池中所有连接的方法 forceCloseAll主体方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * This is a simple, synchronous, thread-safe database connection pool. * &lt;p&gt; * 简单的 带有锁的 线程安全的 数据库连接池 * * @author Clinton Begin */public class PooledDataSource implements DataSource &#123; private static final Log log = LogFactory.getLog(PooledDataSource.class); /** * 数据库连接池状态 */ private final PoolState state = new PoolState(this); // 用来创建真正的数据库连接对象 private final UnpooledDataSource dataSource; // OPTIONAL CONFIGURATION FIELDS // 最大活跃的连接数，默认为 10 protected int poolMaximumActiveConnections = 10; // 最大空闲连接数，默认为 5 protected int poolMaximumIdleConnections = 5; // 最大获取连接的时长 protected int poolMaximumCheckoutTime = 20000; // 在无法获取到连接时，最大等待的时间 protected int poolTimeToWait = 20000; //脸是失败重试次数 protected int poolMaximumLocalBadConnectionTolerance = 3; // 在检测一个连接是否可用时，会向数据库发送一个测试 SQL protected String poolPingQuery = \"NO PING QUERY SET\"; //是否启动连接池ping protected boolean poolPingEnabled; // 当连接超过 poolPingConnectionsNotUsedFor 毫秒未使用时，会发送一次测试 SQL 语句，测试连接是否正常 protected int poolPingConnectionsNotUsedFor; // 标志着当前的连接池，是 url+username+password 的 hash 值 private int expectedConnectionTypeCode; /** * 创建连接池 */ public PooledDataSource() &#123; dataSource = new UnpooledDataSource(); &#125; public PooledDataSource(UnpooledDataSource dataSource) &#123; this.dataSource = dataSource; &#125; /** * 生成 连接的hash 值 * @param url * @param username * @param password * @return */ private int assembleConnectionTypeCode(String url, String username, String password) &#123; return (\"\" + url + username + password).hashCode(); &#125;&#125;获取连接从 连接池中获取连接的方法主要是在 popConnection 中实现的，先来看下它的一个流程图：代码逻辑如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193 /** * 获取连接 * * @return * @throws SQLException */ @Override public Connection getConnection() throws SQLException &#123; return popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection(); &#125; /** * 获取连接 * @param username * @param password * @return * @throws SQLException */ @Override public Connection getConnection(String username, String password) throws SQLException &#123; return popConnection(username, password).getProxyConnection(); &#125;/** * 从连接池中获取连接 * @param username * @param password * @return * @throws SQLException */ private PooledConnection popConnection(String username, String password) throws SQLException &#123; //等待个数 boolean countedWait = false; // PooledConnection 对象 PooledConnection conn = null; //耗时计算 long t = System.currentTimeMillis(); // 无效的连接个数 int localBadConnectionCount = 0; //自旋 while (conn == null) &#123; synchronized (state) &#123; // 检测是否还有空闲的连接 if (!state.idleConnections.isEmpty()) &#123; // Pool has available connection // 连接池中还有空闲的连接，则直接获取连接返回 conn = state.idleConnections.remove(0); if (log.isDebugEnabled()) &#123; log.debug(\"Checked out connection \" + conn.getRealHashCode() + \" from pool.\"); &#125; &#125; else &#123; // 连接池中已经没有空闲连接了 // Pool does not have available connection if (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123; // Can create new connection // 活跃的连接数没有达到最大值，则创建一个新的数据库连接 conn = new PooledConnection(dataSource.getConnection(), this); if (log.isDebugEnabled()) &#123; log.debug(\"Created connection \" + conn.getRealHashCode() + \".\"); &#125; &#125; else &#123; // Cannot create new connection // 如果活跃的连接数已经达到允许的最大值了，则不能创建新的数据库连接 // 获取最先创建的那个活跃的连接 PooledConnection oldestActiveConnection = state.activeConnections.get(0); long longestCheckoutTime = oldestActiveConnection.getCheckoutTime(); // 检测该连接是否超时 if (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123; // 如果该连接超时，则进行相应的统计 // Can claim overdue connection //超时连接个数统计 state.claimedOverdueConnectionCount++; //统计过期的连接超时时间 state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime; //统计超时时间 state.accumulatedCheckoutTime += longestCheckoutTime; // 将超时连接移出 activeConnections 集合 state.activeConnections.remove(oldestActiveConnection); //如果没有设置自动提交 if (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123; try &#123; // 如果超时未提交，则自动回滚 oldestActiveConnection.getRealConnection().rollback(); &#125; catch (SQLException e) &#123; /* Just log a message for debug and continue to execute the following statement like nothing happened. Wrap the bad connection with a new PooledConnection, this will help to not interrupt current executing thread and give current thread a chance to join the next competition for another valid/good database connection. At the end of this loop, bad &#123;@link @conn&#125; will be set as null. */ log.debug(\"Bad connection. Could not roll back\"); &#125; &#125; // 创建新的 PooledConnection 对象，但是真正的数据库连接并没有创建 //刚刚获取的真实连接 新瓶装旧酒 conn = new PooledConnection(oldestActiveConnection.getRealConnection(), this); //设置创建时间 conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp()); //设置最后使用时间 conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp()); // 设置该超时的旧的连接为无效 oldestActiveConnection.invalidate(); if (log.isDebugEnabled()) &#123; log.debug(\"Claimed overdue connection \" + conn.getRealHashCode() + \".\"); &#125; &#125; else &#123; //如果第一个连接还没有超时，说明其他的都没有超时，只能等待了 // Must wait try &#123; //等待个数统计 if (!countedWait) &#123; //等待计数 state.hadToWaitCount++; //下次不进行计数 countedWait = true; &#125; if (log.isDebugEnabled()) &#123; log.debug(\"Waiting as long as \" + poolTimeToWait + \" milliseconds for connection.\"); &#125; long wt = System.currentTimeMillis(); //超时等待 阻塞等待 state.wait(poolTimeToWait); //统计等待的时长 state.accumulatedWaitTime += System.currentTimeMillis() - wt; &#125; catch (InterruptedException e) &#123; //异常退出 break; &#125; &#125; &#125; &#125; // 已经获取到连接，如果连接不为空 if (conn != null) &#123; // ping to server and check the connection is valid or not //连接状态可用 if (conn.isValid()) &#123; // 如果连连接有效，事务未提交则回滚 if (!conn.getRealConnection().getAutoCommit()) &#123; //进行回滚 恢复到最初状态 conn.getRealConnection().rollback(); &#125; //设置连接类型 conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password)); //设置检查超时的时间 conn.setCheckoutTimestamp(System.currentTimeMillis()); //设置最后使用时间 conn.setLastUsedTimestamp(System.currentTimeMillis()); // 把连接加入到活跃集合中去 state.activeConnections.add(conn); //统计请求计数 state.requestCount++; //统计请求时长 state.accumulatedRequestTime += System.currentTimeMillis() - t; &#125; else &#123; //如果验证连接失败 if (log.isDebugEnabled()) &#123; log.debug(\"A bad connection (\" + conn.getRealHashCode() + \") was returned from the pool, getting another connection.\"); &#125; //统计错误连接个数 state.badConnectionCount++; localBadConnectionCount++; //连接置为null 进行GC conn = null; //无效连接个数 &gt; 最大空闲连接数 + 失败尝试次数 //大部分无效连接，可以停止服务了 if (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"PooledDataSource: Could not get a good connection to the database.\"); &#125; //抛异常 因为获取的都是不可用的连接 throw new SQLException(\"PooledDataSource: Could not get a good connection to the database.\"); &#125; &#125; &#125; &#125; &#125; //如果连接还未空 if (conn == null) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"PooledDataSource: Unknown severe error condition. The connection pool returned a null connection.\"); &#125; //抛出异常 throw new SQLException(\"PooledDataSource: Unknown severe error condition. The connection pool returned a null connection.\"); &#125; //返回连接 return conn; &#125;以上就是从连接池获取连接的主要逻辑。关闭连接把连接放入的连接池中以供下次重新使用，把连接放入到连接池中的方法为 pushConnection 方法,它也是 PooledDataSource 类的一个主要方法。代码逻辑如下12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 把不用的连接放入到连接池中 * * @param conn * @throws SQLException */protected void pushConnection(PooledConnection conn) throws SQLException &#123; synchronized (state) &#123; // 首先从活跃的集合中移除掉该连接 state.activeConnections.remove(conn); //验证连接是否有效 if (conn.isValid()) &#123; // 如果空闲连接数没有达到最大值，且 PooledConnection 为该连接池的连接 if (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123; //验证超时时间汇总 state.accumulatedCheckoutTime += conn.getCheckoutTime(); //如果没有自动提交 if (!conn.getRealConnection().getAutoCommit()) &#123; //进行回滚 conn.getRealConnection().rollback(); &#125; //根据真实连接创建一个新的池化的连接 真是链接还用当前的连接 PooledConnection newConn = new PooledConnection(conn.getRealConnection(), this); //添加到空闲连接 state.idleConnections.add(newConn); //设置创建时间 newConn.setCreatedTimestamp(conn.getCreatedTimestamp()); //设置最后使用时间 newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp()); //设置原来的连接为无效 conn.invalidate(); if (log.isDebugEnabled()) &#123; log.debug(\"Returned connection \" + newConn.getRealHashCode() + \" to pool.\"); &#125; //唤醒阻塞等待的线程 state.notifyAll(); &#125; else &#123; // 如果空闲连接数已经达到最大值 //计算超时时间汇总 state.accumulatedCheckoutTime += conn.getCheckoutTime(); //未设置自动提交 if (!conn.getRealConnection().getAutoCommit()) &#123; //回滚 conn.getRealConnection().rollback(); &#125; //关闭真正的数据库连接 conn.getRealConnection().close(); if (log.isDebugEnabled()) &#123; log.debug(\"Closed connection \" + conn.getRealHashCode() + \".\"); &#125; // 设置该连接为无效状态 conn.invalidate(); &#125; &#125; else &#123; //如果连接状态失败 //打印日志 if (log.isDebugEnabled()) &#123; log.debug(\"A bad connection (\" + conn.getRealHashCode() + \") attempted to return to the pool, discarding connection.\"); &#125; //无效连接个数加1 state.badConnectionCount++; &#125; &#125;&#125;以上代码就是把不用的连接放入到连接池中以供下次使用，在上面两个方法中，都调用了 isValid 方法来检测连接是否可用。检查连接该方法除了检测 valid 字段外，还会调用 pingConnection 方法来尝试让数据库执行测试 SQL 语句，从而检测真正的数据库连接对象是否依然正常可用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * Method to check to see if a connection is still usable * 向数据库发送测试 SQL 来检测真正的数据库连接是否可用 * @param conn - the connection to check * @return True if the connection is still usable */protected boolean pingConnection(PooledConnection conn) &#123; // 结果 boolean result = true; try &#123; // 检测真正的数据库连接是否已经关闭 result = !conn.getRealConnection().isClosed(); &#125; catch (SQLException e) &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Connection \" + conn.getRealHashCode() + \" is BAD: \" + e.getMessage()); &#125; result = false; &#125; // 如果真正的数据库连接还没关闭 if (result) &#123; // 是否执行测试 SQL 语句 if (poolPingEnabled) &#123; // 长时间（poolPingConnectionsNotUsedFor 指定的时长）未使用的连接，才需要ping操作来检测连接是否正常 if (poolPingConnectionsNotUsedFor &gt;= 0 &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) &#123; try &#123; if (log.isDebugEnabled()) &#123; log.debug(\"Testing connection \" + conn.getRealHashCode() + \" ...\"); &#125; // 发送测试 SQL 语句执行 Connection realConn = conn.getRealConnection(); try (Statement statement = realConn.createStatement()) &#123; statement.executeQuery(poolPingQuery).close(); &#125; //回滚 if (!realConn.getAutoCommit()) &#123; realConn.rollback(); &#125; result = true; if (log.isDebugEnabled()) &#123; log.debug(\"Connection \" + conn.getRealHashCode() + \" is GOOD!\"); &#125; &#125; catch (Exception e) &#123; log.warn(\"Execution of ping query '\" + poolPingQuery + \"' failed: \" + e.getMessage()); try &#123; //关闭真实连接 conn.getRealConnection().close(); &#125; catch (Exception e2) &#123; //ignore &#125; result = false; if (log.isDebugEnabled()) &#123; log.debug(\"Connection \" + conn.getRealHashCode() + \" is BAD: \" + e.getMessage()); &#125; &#125; &#125; &#125; &#125; return result;&#125;关闭所有连接当修改 PooledDataSource 相应的字段，如 数据库的 URL，用户名或密码等，需要将连接池中连接全部关闭，之后获取连接的时候从重新初始化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Closes all active and idle connections in the pool. * 关闭所有的活动以及空闲连接 */public void forceCloseAll() &#123; synchronized (state) &#123; expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword()); //遍历关闭活动的连接 for (int i = state.activeConnections.size(); i &gt; 0; i--) &#123; try &#123; PooledConnection conn = state.activeConnections.remove(i - 1); // 设置连接为无效状态 conn.invalidate(); //获取真实连接 Connection realConn = conn.getRealConnection(); //是否设置了自动提交 if (!realConn.getAutoCommit()) &#123; //否则进行回滚，保证数据一致性 realConn.rollback(); &#125; //关闭真实连接 realConn.close(); &#125; catch (Exception e) &#123; // ignore &#125; &#125; //遍历关闭空闲的连接 for (int i = state.idleConnections.size(); i &gt; 0; i--) &#123; try &#123; PooledConnection conn = state.idleConnections.remove(i - 1); // 设置为无效状态 conn.invalidate(); //获取真实连接 Connection realConn = conn.getRealConnection(); //如果没有设置自动提交 if (!realConn.getAutoCommit()) &#123; //进行数据回滚 realConn.rollback(); &#125; //关闭真实的链接 realConn.close(); &#125; catch (Exception e) &#123; // ignore &#125; &#125; &#125; if (log.isDebugEnabled()) &#123; log.debug(\"PooledDataSource forcefully closed/removed all connections.\"); &#125;&#125;总结在连接池中提到了 连接池中的最大连接数和最大空闲数，在 获取连接和把连接放入连接池中都有判断，获取连接：首先从连接池中进行获取，如果连接池中已经没有空闲的连接了，则会判断当前的活跃连接数是否已经达到允许的最大值了，如果没有，则还可以创建新的连接，之后把它放到活跃的集合中进行使用，如果当前活跃的已达到最大值，则阻塞。返还连接到连接池，在返还连接的时候，进行判断，如果空闲连接数已达到允许的最大值，则直接关闭真正的数据库连接，否则把该连接放入到空闲集合中以供下次使用。Mybatis 数据源中，主要的代码逻辑还是在连接池类 PooledDataSource 中，对于获取连接的方法 popConnection，返还连接的方法 pushConnection ，需要结合上图来看，才能看得清楚。","categories":[{"name":"MYBATIS","slug":"MYBATIS","permalink":"http://www.baiyp.ren/categories/MYBATIS/"},{"name":"源码","slug":"MYBATIS/源码","permalink":"http://www.baiyp.ren/categories/MYBATIS/源码/"},{"name":"数据库连接池","slug":"MYBATIS/源码/数据库连接池","permalink":"http://www.baiyp.ren/categories/MYBATIS/源码/数据库连接池/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"MYBATIS","slug":"MYBATIS","permalink":"http://www.baiyp.ren/tags/MYBATIS/"},{"name":"数据库连接池","slug":"数据库连接池","permalink":"http://www.baiyp.ren/tags/数据库连接池/"}],"keywords":[{"name":"MYBATIS","slug":"MYBATIS","permalink":"http://www.baiyp.ren/categories/MYBATIS/"},{"name":"源码","slug":"MYBATIS/源码","permalink":"http://www.baiyp.ren/categories/MYBATIS/源码/"},{"name":"数据库连接池","slug":"MYBATIS/源码/数据库连接池","permalink":"http://www.baiyp.ren/categories/MYBATIS/源码/数据库连接池/"}]},{"title":"MYBATIS源码解析-01日志模块","slug":"MYBATIS源码解析-01日志模块","date":"2019-09-04T06:58:57.000Z","updated":"2019-09-04T08:28:04.960Z","comments":true,"path":"MYBATIS源码解析-01日志模块.html","link":"","permalink":"http://www.baiyp.ren/MYBATIS源码解析-01日志模块.html","excerpt":"","text":"MYBATIS日志模块解析前言​ mybatis 没有提供日志的实现类，需要接入第三方的日志组件，但第三方日志组件都有各自的Log级别，且各不相同。而Mybatis统一提供了trace/ debug/ warn/ error四个级别，mybatis使用适配器模式进行日志加载，我们来欣赏下mybatis源码的魅力。日志接口Logmybatis 封装了统一的日志接口，其他日志接口接入需要实现该日志接口。该接口只提供了trace/ debug/ warn/ error四个级别的日志输出1234567891011121314151617181920212223/** * @author Clinton Begin * mybatis log日志接口 */public interface Log &#123; //是否启动debug boolean isDebugEnabled(); //是否启动Trace boolean isTraceEnabled(); //error日志级别 void error(String s, Throwable e); void error(String s); void debug(String s); void trace(String s); void warn(String s);&#125;日志工厂LogFactory在这里定义了日志框架的加载顺序slf4j -&gt; commonsLoging -&gt; Log4J2 -&gt; Log4J -&gt; JdkLog使得日志框架优雅的嵌入到mybatis中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * mybatis log 工厂类 * @author Clinton Begin * @author Eduardo Macarron */public final class LogFactory &#123; /** * Marker to be used by logging implementations that support markers. */ public static final String MARKER = \"MYBATIS\"; /** * 记录正在使用的是那个日志框架的构造方法 */ private static Constructor&lt;? extends Log&gt; logConstructor; /** * 顺序尝试找到一个可用的日志框架 * * :: 双冒号运算符就是java中的方法引用 方法引用的格式是 类名::方法名。 * person -&gt;person.getAge(); 可以替换为 Person::getAge * （）-&gt; new HashMap&lt;&gt;(); 可以替换为 HashMap::new * 双冒号操作符返回的是一个接口的匿名实现 */ static &#123; //尝试使用某一种日志框架 第一个不成功到第二个 一直找到一个合适的 tryImplementation(LogFactory::useSlf4jLogging); tryImplementation(LogFactory::useCommonsLogging); tryImplementation(LogFactory::useLog4J2Logging); tryImplementation(LogFactory::useLog4JLogging); tryImplementation(LogFactory::useJdkLogging); tryImplementation(LogFactory::useNoLogging); &#125; private LogFactory() &#123; // disable construction &#125; /** * 返回具体实现的实现类 * @param aClass * @return */ public static Log getLog(Class&lt;?&gt; aClass) &#123; return getLog(aClass.getName()); &#125; /** * 返回具体实现的接口 * @param logger 具体需要日志的 类 * @return */ public static Log getLog(String logger) &#123; try &#123; //使用当前可用的构造方法进行创建对象 return logConstructor.newInstance(logger); &#125; catch (Throwable t) &#123; throw new LogException(\"Error creating logger for logger \" + logger + \". Cause: \" + t, t); &#125; &#125; public static synchronized void useCustomLogging(Class&lt;? extends Log&gt; clazz) &#123; setImplementation(clazz); &#125; public static synchronized void useSlf4jLogging() &#123; setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl.class); &#125; public static synchronized void useCommonsLogging() &#123; setImplementation(org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.class); &#125; public static synchronized void useLog4JLogging() &#123; setImplementation(org.apache.ibatis.logging.log4j.Log4jImpl.class); &#125; public static synchronized void useLog4J2Logging() &#123; setImplementation(org.apache.ibatis.logging.log4j2.Log4j2Impl.class); &#125; public static synchronized void useJdkLogging() &#123; setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class); &#125; public static synchronized void useStdOutLogging() &#123; setImplementation(org.apache.ibatis.logging.stdout.StdOutImpl.class); &#125; public static synchronized void useNoLogging() &#123; setImplementation(org.apache.ibatis.logging.nologging.NoLoggingImpl.class); &#125; /** * 咋一看好像是多线程 * 其实不然，只用用了下Runnable接口的钩子方法 * 不用再自定义接口内部类实现了，用现成的Runnable接口 * @param runnable */ private static void tryImplementation(Runnable runnable) &#123; //如果构造方法为空就调用匿名内部类 if (logConstructor == null) &#123; try &#123; //调用具体接口的方法 runnable.run(); &#125; catch (Throwable t) &#123; // ignore &#125; &#125; &#125; /** * 设置日志实现类 * @param implClass */ private static void setImplementation(Class&lt;? extends Log&gt; implClass) &#123; try &#123; //获取具体实现类的构造方法 Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class); //创建一个实现类 并打印日志 Log log = candidate.newInstance(LogFactory.class.getName()); if (log.isDebugEnabled()) &#123; log.debug(\"Logging initialized using '\" + implClass + \"' adapter.\"); &#125; //设置否则方法为当前可用构造方法 logConstructor = candidate; &#125; catch (Throwable t) &#123; throw new LogException(\"Error setting Log implementation. Cause: \" + t, t); &#125; &#125;&#125;到这里是整个日志的加载顺序，尝试找到一个可用的构造方法，找到后返回该日志框架的实例。这里面用到了Runable接口的钩子方法，也可以叫做接口回调，并没有使用多线程编程。日志系统转换这里采用了很多日志框架，使用了适配器模式进行日志的转换，装饰着模式可以查看我的设计模式一节这里我们就拿比较负责的sl4j来查看源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576/** * 适配器模式 Sl4j 实现类 * 实现Log 接口 * @author Clinton Begin * @author Eduardo Macarron */public class Slf4jImpl implements Log &#123; /** * 当前类的实现类 */ private Log log; /** * 构造方法 初始化 log * * @param clazz 需要打印日志的类 */ public Slf4jImpl(String clazz) &#123; //logger的方式创建日志类 Logger logger = LoggerFactory.getLogger(clazz); //如果返回的是 LocationAwareLogger 对象 if (logger instanceof LocationAwareLogger) &#123; try &#123; // check for slf4j &gt;= 1.6 method signature //检查sl4j 版本是否&gt;=1.6 logger.getClass().getMethod(\"log\", Marker.class, String.class, int.class, String.class, Object[].class, Throwable.class); //使用 Slf4jLocationAwareLoggerImpl 实例 log = new Slf4jLocationAwareLoggerImpl((LocationAwareLogger) logger); return; &#125; catch (SecurityException | NoSuchMethodException e) &#123; // fail-back to Slf4jLoggerImpl &#125; &#125; // Logger is not LocationAwareLogger or slf4j version &lt; 1.6 //sl4j 版本小于1.6 使用Slf4jLoggerImpl log = new Slf4jLoggerImpl(logger); &#125; @Override public boolean isDebugEnabled() &#123; return log.isDebugEnabled(); &#125; @Override public boolean isTraceEnabled() &#123; return log.isTraceEnabled(); &#125; @Override public void error(String s, Throwable e) &#123; log.error(s, e); &#125; @Override public void error(String s) &#123; log.error(s); &#125; @Override public void debug(String s) &#123; log.debug(s); &#125; @Override public void trace(String s) &#123; log.trace(s); &#125; @Override public void warn(String s) &#123; log.warn(s); &#125;&#125;这里注意下Slf4j版本控制，如果Slf4j版本&gt;=1.6 使用 Slf4jLocationAwareLoggerImpl 否则使用Slf4jLoggerImpl我们再拿Slf4jLoggerImpl看一下1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * @author Eduardo Macarron */class Slf4jLoggerImpl implements Log &#123; private final Logger log; public Slf4jLoggerImpl(Logger logger) &#123; log = logger; &#125; @Override public boolean isDebugEnabled() &#123; return log.isDebugEnabled(); &#125; @Override public boolean isTraceEnabled() &#123; return log.isTraceEnabled(); &#125; @Override public void error(String s, Throwable e) &#123; log.error(s, e); &#125; @Override public void error(String s) &#123; log.error(s); &#125; @Override public void debug(String s) &#123; log.debug(s); &#125; @Override public void trace(String s) &#123; log.trace(s); &#125; @Override public void warn(String s) &#123; log.warn(s); &#125;&#125;到这里就是mybatis日志框架的优雅封装实现，通过依次尝试加载，使用适配器模式进行日志接口的统一JDBC日志增强JDBC模板类BaseJdbcLoggerBaseJdbcLogger初始化了日志框架Log，SET_METHODS和jdbc执行方法列表EXECUTE_METHODS123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178/** * Base class for proxies to do logging. * 基类 JDBC操作日志 * * @author Clinton Begin * @author Eduardo Macarron */public abstract class BaseJdbcLogger &#123; protected static final Set&lt;String&gt; SET_METHODS; protected static final Set&lt;String&gt; EXECUTE_METHODS = new HashSet&lt;&gt;(); private final Map&lt;Object, Object&gt; columnMap = new HashMap&lt;&gt;(); private final List&lt;Object&gt; columnNames = new ArrayList&lt;&gt;(); private final List&lt;Object&gt; columnValues = new ArrayList&lt;&gt;(); protected final Log statementLog; protected final int queryStack; /* * Default constructor * 默认构造方法，将日志接口以及查询 */ public BaseJdbcLogger(Log log, int queryStack) &#123; this.statementLog = log; if (queryStack == 0) &#123; this.queryStack = 1; &#125; else &#123; this.queryStack = queryStack; &#125; &#125; static &#123; //将Set方法设置进SET_METHODS SET_METHODS = Arrays.stream(PreparedStatement.class.getDeclaredMethods()) .filter(method -&gt; method.getName().startsWith(\"set\")) .filter(method -&gt; method.getParameterCount() &gt; 1) .map(Method::getName) .collect(Collectors.toSet()); //添加执行方法 EXECUTE_METHODS.add(\"execute\"); EXECUTE_METHODS.add(\"executeUpdate\"); EXECUTE_METHODS.add(\"executeQuery\"); EXECUTE_METHODS.add(\"addBatch\"); &#125; /** * 设置参数 * @param key * @param value */ protected void setColumn(Object key, Object value) &#123; columnMap.put(key, value); columnNames.add(key); columnValues.add(value); &#125; protected Object getColumn(Object key) &#123; return columnMap.get(key); &#125; /** * 获取参数值 * @return */ protected String getParameterValueString() &#123; List&lt;Object&gt; typeList = new ArrayList&lt;&gt;(columnValues.size()); for (Object value : columnValues) &#123; if (value == null) &#123; typeList.add(\"null\"); &#125; else &#123; typeList.add(objectValueString(value) + \"(\" + value.getClass().getSimpleName() + \")\"); &#125; &#125; final String parameters = typeList.toString(); return parameters.substring(1, parameters.length() - 1); &#125; /** * 将Object转换为String * @param value * @return */ protected String objectValueString(Object value) &#123; if (value instanceof Array) &#123; try &#123; return ArrayUtil.toString(((Array) value).getArray()); &#125; catch (SQLException e) &#123; return value.toString(); &#125; &#125; return value.toString(); &#125; /** * 获取参数名称列表 * @return */ protected String getColumnString() &#123; return columnNames.toString(); &#125; /** * 清空参数map */ protected void clearColumnInfo() &#123; columnMap.clear(); columnNames.clear(); columnValues.clear(); &#125; /** * 清除换行符以及制表符 * @param original * @return */ protected String removeBreakingWhitespace(String original) &#123; StringTokenizer whitespaceStripper = new StringTokenizer(original); StringBuilder builder = new StringBuilder(); while (whitespaceStripper.hasMoreTokens()) &#123; builder.append(whitespaceStripper.nextToken()); builder.append(\" \"); &#125; return builder.toString(); &#125; /** * 是否启用debug * @return */ protected boolean isDebugEnabled() &#123; return statementLog.isDebugEnabled(); &#125; /** * 是否启用Trace * @return */ protected boolean isTraceEnabled() &#123; return statementLog.isTraceEnabled(); &#125; /** * 日志打印 * @param text * @param input */ protected void debug(String text, boolean input) &#123; if (statementLog.isDebugEnabled()) &#123; statementLog.debug(prefix(input) + text); &#125; &#125; protected void trace(String text, boolean input) &#123; if (statementLog.isTraceEnabled()) &#123; statementLog.trace(prefix(input) + text); &#125; &#125; /** * 获取输出的前缀 * @param isInput * @return */ private String prefix(boolean isInput) &#123; char[] buffer = new char[queryStack * 2 + 2]; Arrays.fill(buffer, '='); buffer[queryStack * 2 + 1] = ' '; if (isInput) &#123; buffer[queryStack * 2] = '&gt;'; &#125; else &#123; buffer[0] = '&lt;'; &#125; return new String(buffer); &#125;&#125;Connection日志增强Connection日志增加是基于动态代理实现的，具有很高的参考价值，他创建预处理等对象的时候并返回预处理对象的代理方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102/** * Connection proxy to add logging. * 基于动态代理的日志增强 * * @author Clinton Begin * @author Eduardo Macarron * */public final class ConnectionLogger extends BaseJdbcLogger implements InvocationHandler &#123; /** * 数据库连接 */ private final Connection connection; /** * 构造方法 * @param conn 连接 * @param statementLog 日志接口 * @param queryStack */ private ConnectionLogger(Connection conn, Log statementLog, int queryStack) &#123; super(statementLog, queryStack); this.connection = conn; &#125; /** * 动态代理的核心处理类 * @param proxy * @param method * @param params * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] params) throws Throwable &#123; try &#123; if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, params); &#125; //如果是预处理方法 打印debug信息 if (\"prepareStatement\".equals(method.getName())) &#123; if (isDebugEnabled()) &#123; debug(\" Preparing: \" + removeBreakingWhitespace((String) params[0]), true); &#125; //调用prepareStatement方法 PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params); //链式创建预处理代理对象 stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack); //并返回预处理代理对象 return stmt; //如果是调用存储过程 &#125; else if (\"prepareCall\".equals(method.getName())) &#123; //打印日志 if (isDebugEnabled()) &#123; debug(\" Preparing: \" + removeBreakingWhitespace((String) params[0]), true); &#125; //调用prepareCall 方法 PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params); //链式创建预处理代理对象 stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack); //并返回预处理代理对象 return stmt; //如果创建createStatement 方法 &#125; else if (\"createStatement\".equals(method.getName())) &#123; //调用 createStatement 方法 Statement stmt = (Statement) method.invoke(connection, params); //链式创建预处理代理对象 stmt = StatementLogger.newInstance(stmt, statementLog, queryStack); //并返回预处理代理对象 return stmt; &#125; else &#123; //其他方法直接调用 return method.invoke(connection, params); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; /** * Creates a logging version of a connection. * 创建 连接的代理对象 * @param conn - the original connection * @return - the connection with logging */ public static Connection newInstance(Connection conn, Log statementLog, int queryStack) &#123; InvocationHandler handler = new ConnectionLogger(conn, statementLog, queryStack); ClassLoader cl = Connection.class.getClassLoader(); return (Connection) Proxy.newProxyInstance(cl, new Class[]&#123;Connection.class&#125;, handler); &#125; /** * return the wrapped connection. * 获取连接 * @return the connection */ public Connection getConnection() &#123; return connection; &#125;&#125;PreparedStatementLogger预处理日志增强预处理日志增强，对其中一些方法进行增强，对于查询以及获取结果集，返回结果集的日志动态代理增强。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119/** * PreparedStatement proxy to add logging. * 基于动态代理的预处理日志增强 * * @author Clinton Begin * @author Eduardo Macarron */public final class PreparedStatementLogger extends BaseJdbcLogger implements InvocationHandler &#123; /** * 原始的预处理对象 */ private final PreparedStatement statement; /** * 私有的构造方法 * * @param stmt 预处理对象 * @param statementLog 日志接口 * @param queryStack */ private PreparedStatementLogger(PreparedStatement stmt, Log statementLog, int queryStack) &#123; super(statementLog, queryStack); this.statement = stmt; &#125; /** * 动态代理和核心方法 * * @param proxy * @param method * @param params * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] params) throws Throwable &#123; try &#123; //如果是Object对象直接调用 if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, params); &#125; //如果包含定义的可执行方法 则打印日志 以及值列表 if (EXECUTE_METHODS.contains(method.getName())) &#123; if (isDebugEnabled()) &#123; debug(\"Parameters: \" + getParameterValueString(), true); &#125; //清空 参数 clearColumnInfo(); //如果是查询方法 if (\"executeQuery\".equals(method.getName())) &#123; //调用 executeQuery 方法 并返回结果集 ResultSet rs = (ResultSet) method.invoke(statement, params); //返回结果集的 动态代理日志增强 return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack); &#125; else &#123; //其他方法直接调用不进行日志增强 return method.invoke(statement, params); &#125; //如果方法在SET_METHODS列表中 &#125; else if (SET_METHODS.contains(method.getName())) &#123; //如果是 setNull 的方法 则设置为null if (\"setNull\".equals(method.getName())) &#123; setColumn(params[0], null); &#125; else &#123; //其他设置具体参数的值 setColumn(params[0], params[1]); &#125; //调用set方法 return method.invoke(statement, params); //如果是getResultSet方法 &#125; else if (\"getResultSet\".equals(method.getName())) &#123; //调用具体的getResultSet方法 ResultSet rs = (ResultSet) method.invoke(statement, params); //返回结果集日志曾倩 return rs == null ? null : ResultSetLogger.newInstance(rs, statementLog, queryStack); //如果是获取更新条数 &#125; else if (\"getUpdateCount\".equals(method.getName())) &#123; //调用具体方法获取条数 int updateCount = (Integer) method.invoke(statement, params); //如果是不等于-1 打印结果日志 if (updateCount != -1) &#123; debug(\" Updates: \" + updateCount, false); &#125; //返回更新条数 return updateCount; &#125; else &#123; //不进行增加的方法 return method.invoke(statement, params); &#125; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; /** * Creates a logging version of a PreparedStatement. * * 创建动态代理的实例 * @param stmt - the statement * @param statementLog - the statement log * @param queryStack - the query stack * @return - the proxy */ public static PreparedStatement newInstance(PreparedStatement stmt, Log statementLog, int queryStack) &#123; InvocationHandler handler = new PreparedStatementLogger(stmt, statementLog, queryStack); ClassLoader cl = PreparedStatement.class.getClassLoader(); return (PreparedStatement) Proxy.newProxyInstance(cl, new Class[]&#123;PreparedStatement.class, CallableStatement.class&#125;, handler); &#125; /** * Return the wrapped prepared statement. * * @return the PreparedStatement */ public PreparedStatement getPreparedStatement() &#123; return statement; &#125;&#125;StatementLogger日志增加和PreparedStatementLogger这个类基本上一样，大家可以看一下。ResultSetLogger结果集日志增强结果集打印没有什么可说的了，基本上就是判断是否是blob类型，特殊处理，其他情况进行字符串拼接这里使用了JDK1.8的StringJoiner 进行字符串拼接，可以简单的方式进行包含有分隔符的字符串拼接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155/** * ResultSet proxy to add logging. * 结果集处理日志动态代理 * @author Clinton Begin * @author Eduardo Macarron * */public final class ResultSetLogger extends BaseJdbcLogger implements InvocationHandler &#123; /** * Bolb 字段类型列表 */ private static final Set&lt;Integer&gt; BLOB_TYPES = new HashSet&lt;&gt;(); private boolean first = true; private int rows; //结果集原始对象 private final ResultSet rs; //blob参数 private final Set&lt;Integer&gt; blobColumns = new HashSet&lt;&gt;(); static &#123; //设置blob数据类型 BLOB_TYPES.add(Types.BINARY); BLOB_TYPES.add(Types.BLOB); BLOB_TYPES.add(Types.CLOB); BLOB_TYPES.add(Types.LONGNVARCHAR); BLOB_TYPES.add(Types.LONGVARBINARY); BLOB_TYPES.add(Types.LONGVARCHAR); BLOB_TYPES.add(Types.NCLOB); BLOB_TYPES.add(Types.VARBINARY); &#125; /** * 私有构造方法 * @param rs 结果集 * @param statementLog 日志接口 * @param queryStack */ private ResultSetLogger(ResultSet rs, Log statementLog, int queryStack) &#123; super(statementLog, queryStack); this.rs = rs; &#125; /** * 动态代理的核心方法 * @param proxy * @param method * @param params * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] params) throws Throwable &#123; try &#123; //方法是Object类型 直接调用 if (Object.class.equals(method.getDeclaringClass())) &#123; return method.invoke(this, params); &#125; //调用原始的方法 Object o = method.invoke(rs, params); //如果调用next方法 if (\"next\".equals(method.getName())) &#123; //如果有下一行 if ((Boolean) o) &#123; //行数++ rows++; //日志打印 if (isTraceEnabled()) &#123; //获取元数据 ResultSetMetaData rsmd = rs.getMetaData(); //获取列数 final int columnCount = rsmd.getColumnCount(); //如果是第一行 用来判断是否是第一行 if (first) &#123; //设置第一行不显示 first = false; //打印列标题 printColumnHeaders(rsmd, columnCount); &#125; //打印参数结果集数据 printColumnValues(columnCount); &#125; &#125; else &#123; debug(\" Total: \" + rows, false); &#125; &#125; clearColumnInfo(); return o; &#125; catch (Throwable t) &#123; throw ExceptionUtil.unwrapThrowable(t); &#125; &#125; /** * 打印结果集日志 * @param rsmd 结果集元数据 * @param columnCount 列行数 * @throws SQLException */ private void printColumnHeaders(ResultSetMetaData rsmd, int columnCount) throws SQLException &#123; StringJoiner row = new StringJoiner(\", \", \" Columns: \", \"\"); for (int i = 1; i &lt;= columnCount; i++) &#123; if (BLOB_TYPES.contains(rsmd.getColumnType(i))) &#123; blobColumns.add(i); &#125; row.add(rsmd.getColumnLabel(i)); &#125; trace(row.toString(), false); &#125; /** * 打印结果集数据 * @param columnCount */ private void printColumnValues(int columnCount) &#123; //StringJoiner 进行字符串拼接 StringJoiner row = new StringJoiner(\", \", \" Row: \", \"\"); for (int i = 1; i &lt;= columnCount; i++) &#123; try &#123; //如果包是blob类型 添加BLOB 标识 if (blobColumns.contains(i)) &#123; row.add(\"&lt;&lt;BLOB&gt;&gt;\"); &#125; else &#123; //将值添加到字符串中 row.add(rs.getString(i)); &#125; &#125; catch (SQLException e) &#123; // generally can't call getString() on a BLOB column row.add(\"&lt;&lt;Cannot Display&gt;&gt;\"); &#125; &#125; trace(row.toString(), false); &#125; /** * Creates a logging version of a ResultSet. * 创建结果集代理类 * @param rs - the ResultSet to proxy * @return - the ResultSet with logging */ public static ResultSet newInstance(ResultSet rs, Log statementLog, int queryStack) &#123; InvocationHandler handler = new ResultSetLogger(rs, statementLog, queryStack); ClassLoader cl = ResultSet.class.getClassLoader(); return (ResultSet) Proxy.newProxyInstance(cl, new Class[]&#123;ResultSet.class&#125;, handler); &#125; /** * Get the wrapped result set. * * @return the resultSet */ public ResultSet getRs() &#123; return rs; &#125;&#125;总结​ mybatis 日志模块使用适配器模式进行不同类型的日志框架的统一，使用动态代理对连接执行sql，结果集进行日志的增强，使其无缝的与mybatis结合起来，你们的日志是怎么打印的呢？","categories":[{"name":"MYBATIS","slug":"MYBATIS","permalink":"http://www.baiyp.ren/categories/MYBATIS/"},{"name":"源码","slug":"MYBATIS/源码","permalink":"http://www.baiyp.ren/categories/MYBATIS/源码/"},{"name":"日志","slug":"MYBATIS/源码/日志","permalink":"http://www.baiyp.ren/categories/MYBATIS/源码/日志/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"MYBATIS","slug":"MYBATIS","permalink":"http://www.baiyp.ren/tags/MYBATIS/"},{"name":"日志","slug":"日志","permalink":"http://www.baiyp.ren/tags/日志/"}],"keywords":[{"name":"MYBATIS","slug":"MYBATIS","permalink":"http://www.baiyp.ren/categories/MYBATIS/"},{"name":"源码","slug":"MYBATIS/源码","permalink":"http://www.baiyp.ren/categories/MYBATIS/源码/"},{"name":"日志","slug":"MYBATIS/源码/日志","permalink":"http://www.baiyp.ren/categories/MYBATIS/源码/日志/"}]},{"title":"volatile实现原理","slug":"volatile实现原理","date":"2019-09-03T01:11:04.000Z","updated":"2019-09-07T09:10:09.807Z","comments":true,"path":"volatile实现原理.html","link":"","permalink":"http://www.baiyp.ren/volatile实现原理.html","excerpt":"","text":"volatile实现原理简介​ volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。特性可以把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步原子性即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。​ 原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：基本类型的读取和赋值操作，且赋值必须是数字赋值给变量，变量之间的相互赋值不是原子性操作。所有引用reference的赋值操作java.concurrent.Atomic.* 包中所有类的一切操作可见性指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。​ 在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。有序性即程序执行的顺序按照代码的先后顺序执行。​ java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。​ 在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。volatile变量的特性保证可见性，不保证原子性当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；这个写会操作会导致其他线程中的缓存无效。禁止指令重排重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：重排序操作不会对存在数据依赖关系的操作进行重排序。比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运​ 行时这两个操作不会被重排序。重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发​ 生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。​ 重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。原理volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；它会强制将对缓存的修改操作立即写入主存；如果是写操作，它会导致其他CPU中对应的缓存行无效。内存语义当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。​ 当主线程对stop进行修改后且子线程尚未对stop进行读时，主线程已经把stop的值刷新到了主内存。其示意图如下：​ 当子线程进行读取时，会把本地内存置为无效直接去主内存中读取。（这里的主线程和子线程可以了解为两个普通线程没有父子关系）其示意图如下：volatile内存语义的实现​ 为了实现volatile的内存语义，JMM会分别限制这两种类型的重排序。下图是JMM针对编译器指定的volatile重排序规则表。当第二个操作为volatile写操作时,不管第一个操作是什么(普通读写或者volatile读写),都不能进行重排序。这个规则确保volatile写之前的所有操作都不会被重排序到volatile写之后;当第一个操作为volatile读操作时,不管第二个操作是什么,都不能进行重排序。这个规则确保volatile读之后的所有操作都不会被重排序到volatile读之前;当第一个操作是volatile写操作时,第二个操作是volatile读操作,不能进行重排序。为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。下面是基于保守策略的 JMM 内存屏障插入策略：在每个 volatile 写操作的前面插入一个 StoreStore 屏障（禁止前面的写与volatile写重排序）。在每个 volatile 写操作的后面插入一个 StoreLoad 屏障（禁止volatile写与后面可能有的读和写重排序）。在每个 volatile 读操作的后面插入一个 LoadLoad 屏障（禁止volatile读与后面的读操作重排序）。在每个 volatile 读操作的后面插入一个 LoadStore 屏障（禁止volatile读与后面的写操作重排序）。其中重点说下StoreLaod屏障，它是确保可见性的关键，因为它会将屏障之前的写缓冲区中的数据全部刷新到主内存中。上述内存屏障插入策略非常保守，但它可以保证在任意处理平台，任意的程序中都能得到正确的volatile语义。下面是保守策略（为什么说保守呢，因为有些在实际的场景是可省略的）下，volatile 写操作 插入内存屏障后生成的指令序列示意图：​ 其中StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作对任意处理器可见（把它刷新到主内存）。另外volatile写后面有StoreLoad屏障，此屏障的作用是避免volatile写与后面可能有的读或写操作进行重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）为了保证能正确实现volatile的内存语义，JMM采取了保守策略：在每个volatile写的后面插入一个StoreLoad屏障。因为volatile写-读内存语义的常见模式是：一个写线程写volatile变量，多个度线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里也可看出JMM在实现上的一个特点：首先确保正确性，然后再去追求效率（其实我们工作中编码也是一样）。下面是在保守策略下，volatile读插入内存屏障后生产的指令序列示意图：上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况忽略不必要的屏障。在JMM基础中就有提到过各个处理器对各个屏障的支持度，其中x86处理器仅会对写-读操作做重排序。单例模式的双重锁为什么要加volatile1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125;需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第8行会出现问题。singleton = new Singleton();可以分解为3行伪代码memory = allocate() //分配内存ctorInstanc(memory) //初始化对象singleton= memory //设置instance指向刚分配的地址上面的代码在编译运行时，可能会出现重排序从1-2-3排序为1-3-2。在多线程的情况下会出现以下问题。线程A在执行第5行代码时，B线程进来，而此时A执行了1和3，没有执行2，此时B线程判断instance不为null，直接返回一个未初始化的对象。synchronizevolatile是线程同步的轻量级实现，所以volatile的性能要比synchronize好；volatile只能用于修饰变量，synchronize可以用于修饰方法、代码块。随着jdk技术的发展，synchronize在执行效率上会得到较大提升，所以synchronize在项目过程中还是较为常见的；多线程访问volatile不会发生阻塞；而synchronize会发生阻塞；volatile能保证变量在私有内存和主内存间的同步，但不能保证变量的原子性；synchronize可以保证变量原子性；volatile是变量在多线程之间的可见性；synchronize是多线程之间访问资源的同步性；对于volatile修饰的变量，可以解决变量读时可见性问题，无法保证原子性。对于多线程访问同一个实例变量还是需要加锁同步。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"volatile","slug":"并发/volatile","permalink":"http://www.baiyp.ren/categories/并发/volatile/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"实现原理","slug":"实现原理","permalink":"http://www.baiyp.ren/tags/实现原理/"},{"name":"volatile","slug":"volatile","permalink":"http://www.baiyp.ren/tags/volatile/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"volatile","slug":"并发/volatile","permalink":"http://www.baiyp.ren/categories/并发/volatile/"}]},{"title":"final实现原理","slug":"final实现原理","date":"2019-09-01T01:11:04.000Z","updated":"2019-09-07T04:48:19.073Z","comments":true,"path":"final实现原理.html","link":"","permalink":"http://www.baiyp.ren/final实现原理.html","excerpt":"","text":"final实现原理简介​ final关键字，实际的含义就一句话，不可改变。什么是不可改变？就是初始化完成之后就不能再做任何的修改，修饰成员变量的时候，成员变量变成一个常数；修饰方法的时候，方法不允许被重写；修饰类的时候，类不允许被继承；修饰参数列表的时候，入参的对象也是不可以改变。这个就是不可变，无论是引用新的对象，重写还是继承，都是改变的方法，而final就是把这个变更的路给堵死用法final修饰变量final成员变量表示常量，只能被赋值一次，赋值后值不再改变（final要求地址值不能改变）当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式。一种是在变量声明的时候初始化。第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。final修饰方法使用final方法的原因有两个。第一个原因是把方法锁定，以防任何继承类修改它的含义，不能被重写；第二个原因是效率，final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。注：类的private方法会隐式地被指定为final方法final修饰类当用final修饰一个类时，表明这个类不能被继承。final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。final关键字的好处final关键字提高了性能。JVM和Java应用都会缓存final变量。final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。使用final关键字，JVM会对方法、变量及类进行优化。注意事项final关键字可以用于成员变量、本地变量、方法以及类。final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。你不能够对final变量再次赋值。本地变量必须在声明时赋值。在匿名类中所有变量都必须是final变量。final方法不能被重写。final类不能被继承。final关键字不同于finally关键字，后者用于异常处理。final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。接口中声明的所有变量本身是final的。final和abstract这两个关键字是反相关的，final类就不可能是abstract的。final方法在编译阶段绑定，称为静态绑定(static binding)。没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。按照Java代码惯例，final变量就是常量，而且通常常量名要大写。对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。原理内存语义写内存语义可以确保在对象的引用为任意线程可见之前，final 域已经被初始化过了。读内存语义可以确保如果对象的引用不为 null，则说明 final 域已经被初始化过了。总之，final 域的内存语义提供了初始化安全保证。写内存语义：在构造函数内对一个 final 域的写入，与随后将对象引用赋值给引用变量，这两个操作不能重排序。读内存语义：初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作不能重排序。Final域是普通类型对于final域，编译器和处理器要遵守两个重排序规则在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。（先写入final变量，后调用该对象引用）原因：编译器会在final域的写之后，插入一个StoreStore屏障初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。（先读对象的引用，后读final变量）​ 编译器会在读final域操作的前面插入一个LoadLoad屏障1234567891011121314151617181920212223242526272829303132333435363738public class FinalExample &#123; // 普通变量 int i; // final 变量 final int j; static FinalExample obj; /** * 构造方法 */ public void FinalExample() &#123; // 写普通域 i = 1; // 写 final 域 j = 2; &#125; /** * 写方法A执行 */ public static void writer() &#123; obj = new FinalExample(); &#125; /** * 读线程B执行 */ public static void reader() &#123; // 读对象引用 FinalExample object = obj; // 读普通域 a=1或者a=0或者直接报错i没有初始化 int a = object.i; /// 读 final域 int b = object.j; b = 2; &#125;&#125;第一种情况写普通域的操作被编译器重排序到了构造函数之外而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。写 final 域的重排序规则可以确保：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。第二种情况读对象的普通域的操作被处理器重排序到读对象引用之前而读 final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。读 final 域的重排序规则可以确保：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。final 域是引用类型对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。12345678910111213141516171819202122232425262728293031323334353637383940/** * final域是引用类型 */public class FinalReferenceExample &#123; // final 是引用类型 final int[] intArray; static FinalReferenceExample obj; /** * 构造方法 */ public FinalReferenceExample() &#123; intArray = new int[1]; // 1 intArray[0] = 1; // 2 &#125; /** * 写线程 A 执行 */ public static void writerOne() &#123; obj = new FinalReferenceExample(); // 3 &#125; /** * 写线程 B 执行 */ public static void writerTwo() &#123; obj.intArray[0] = 2; // 4 &#125; /** * 读线程 C 执行 */ public static void reader() &#123; if (obj != null) &#123; // 5 // temp1=1或者temp1=2，不可能等于0 int temp1 = obj.intArray[0]; // 6 &#125; &#125;&#125;假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTwo() 方法，执行完后线程 C 执行 reader () 方法。在上图中1 是对 final 域的写入；2 是对这个 final 域引用的对象的成员域的写入；3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。final、finally、 finalize区别final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final的变量是不可以修改的，而final的方法也是不可以重写的（override）。finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"final","slug":"并发/final","permalink":"http://www.baiyp.ren/categories/并发/final/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"实现原理","slug":"实现原理","permalink":"http://www.baiyp.ren/tags/实现原理/"},{"name":"final","slug":"final","permalink":"http://www.baiyp.ren/tags/final/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"final","slug":"并发/final","permalink":"http://www.baiyp.ren/categories/并发/final/"}]},{"title":"JAVA设计模式08-建造者模式","slug":"JAVA设计模式08","date":"2019-08-31T01:42:30.000Z","updated":"2019-09-08T11:51:00.731Z","comments":true,"path":"JAVA设计模式08.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式08.html","excerpt":"","text":"JAVA设计模式-建造者模式（Builder Pattern）什么是建造者模式​ 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的​ 创建者模式又叫建造者模式，是将一个复杂的对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。角色Product（产品角色）： 一个具体的产品对象。Builder（抽象建造者）：创建一个Product对象的各个部件指定的抽象接口。ConcreteBuilder（具体建造者）：实现抽象接口，构建和装配各个部件。Director（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。优缺点优点客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”缺点产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。适用场景隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果多个部件都可以装配到一个对象中，但产生的运行结果不相同产品类非常复杂或者产品类因为调用顺序不同而产生不同作用初始化一个对象时，参数过多，或者很多参数具有默认值Builder模式不适合创建差异性很大的产品类产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；注意事项和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。主要作用在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。用户只需要给出指定复杂对象的类型和内容；建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)解决的问题方便用户创建复杂的对象（不需要知道实现过程）代码复用性 &amp; 封装性（将对象构建过程和细节进行封装 &amp; 复用）实现产品类需要进行构建的原始的产品类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 需要进行构建的产品类 */public class Product &#123; /** * 产品名称 */ private String name; /** * 单价 */ private float price; /** * 数量 */ private int num; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getPrice() &#123; return price; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; @Override public String toString() &#123; return \"Product&#123;\" + \"name='\" + name + '\\'' + \", price=\" + price + \", num=\" + num + '&#125;'; &#125;&#125;Builder 接口Builder 可以是接口也可以是抽象类，定义需要实现的构建模板12345678910111213141516/** * 建造者接口 */public interface Builder &#123; //构建产品名称 public void buildName(); //构建单价 public void buildPrice(); //构建数量 public void buildNum(); //获取构建的对象 public Product build();&#125;具体建造者（ConcreteBuilder）构建苹果手机1234567891011121314151617181920212223242526/** * 构建苹果手机 */public class MobileBuilder implements Builder &#123; private Product product = new Product(); @Override public void buildName() &#123; product.setName(\"iphone手机\"); &#125; @Override public void buildPrice() &#123; product.setPrice(8000); &#125; @Override public void buildNum() &#123; product.setNum(1000); &#125; @Override public Product build() &#123; return product; &#125;&#125;构建手表1234567891011121314151617181920212223242526/** * 构建手表 */public class WatchBuilder implements Builder &#123; private Product product = new Product(); @Override public void buildName() &#123; product.setName(\"手表\"); &#125; @Override public void buildPrice() &#123; product.setPrice(10000); &#125; @Override public void buildNum() &#123; product.setNum(10); &#125; @Override public Product build() &#123; return product; &#125;&#125;指挥者(Director)12345678910111213141516171819202122/** * 指挥者 */public class Director &#123; //建造者接口 private Builder builder = null; //构造方法 public Director(Builder builder)&#123; this.builder = builder; &#125; /** * 构建具体的对象 * @return 构建出来的对象 */ public Product getProduct()&#123; builder.buildName(); builder.buildPrice(); builder.buildNum(); return builder.build(); &#125;&#125;客户端使用12345678910111213141516171819202122/** * 建造者测试 */public class BuildTest &#123; public static void main(String[] args) &#123; //打印手机 printBuild(new MobileBuilder()); //打印手表 printBuild(new WatchBuilder()); &#125; /** * 打印建造后的对象数据 * @param builder */ public static void printBuild(Builder builder)&#123; Director director = new Director(builder); Product product = director.getProduct(); System.out.println(product.toString()); &#125;&#125;输出12Product&#123;name='iphone手机', price=8000.0, num=1000&#125;Product&#123;name='手表', price=10000.0, num=10&#125;通过链式调用优化(非常推荐)链式写法是在原型写法的基础上做优化，有些时候Builder的创建部分有默认值，或者不需要的情况下，而产生不同的Product，通过以上方式，就需要修改Director类和Builder类，再或者根据不同的创建顺序，生成不同的结果，也需要修改Director类。Director似乎显得很不稳定和多余。可以通过Builder自身的调用逻辑来生成Product，即链式调用实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 链式的建造者 */public class StreamProductBuilder &#123; /** * 产品名称 */ private String name; /** * 单价 */ private float price; /** * 数量 */ private int num; public StreamProductBuilder() &#123; &#125; public StreamProductBuilder(String name, float price, int num) &#123; this.name = name; this.price = price; this.num = num; &#125; /** * 静态类 Builder */ public static final class Builder &#123; /** * 产品名称 */ private String name; /** * 单价 */ private float price; /** * 数量 */ private int num; //空的构造方法 public Builder()&#123;&#125; /** * 进行建造 * @param name * @return */ public Builder name(String name) &#123; this.name = name; return this; &#125; public Builder price(float prie) &#123; this.price = price; return this; &#125; public Builder num(int num) &#123; this.num = num; return this; &#125; /** * 返回建造的对象 * @return */ public StreamProductBuilder build() &#123; return new StreamProductBuilder(name, price, num); &#125; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public float getPrice() &#123; return price; &#125; public void setPrice(float price) &#123; this.price = price; &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125;&#125;客户端使用1234567public class BuildTest &#123; public static void main(String[] args) &#123; StreamProductBuilder builder = new StreamProductBuilder.Builder().name(\"iphone手机\").price(8000).num(100).build(); System.out.println(builder.getName()); &#125;&#125;上面的示例代码只是传入三个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性，代码更加简洁。相比于普通JavaBean的好处​ 在建造者模式中,提供一个辅助的静态建造器Builder(静态内部类),可以在里面set实体类的属性,与JavaBean不同的是,建造者是先set,在通过build实例化实体类,这样既可以提高代码的阅读性,也可以防止对象没有实例化,就被调用;不会造成不一致性,同时解决了Javabean模式的线程安全问题建造者模式与抽象工厂模式的比较与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车总结​ Director角色并非多余，能把复杂的Product创建过程对外隐藏，使Builder部件和创建过程分离，各方易于扩展，降低了耦合度。当需要对一个对象设置很多属性，此时就能方便的使用链式调用来提高编码速度和代码可读性。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"建造者模式","slug":"设计模式/建造者模式","permalink":"http://www.baiyp.ren/categories/设计模式/建造者模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"建造者模式","slug":"建造者模式","permalink":"http://www.baiyp.ren/tags/建造者模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"建造者模式","slug":"设计模式/建造者模式","permalink":"http://www.baiyp.ren/categories/设计模式/建造者模式/"}]},{"title":"JAVA设计模式07-代理模式","slug":"JAVA设计模式07","date":"2019-08-30T01:42:30.000Z","updated":"2019-09-05T09:23:26.677Z","comments":true,"path":"JAVA设计模式07.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式07.html","excerpt":"","text":"JAVA设计模式-代理模式（Proxy Pattern）什么是代理模式​ 在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。​ 代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，后面将学习这些不同的代理形式。​ 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。​ 代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。为什么要用代理模式中介隔离作用：在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。开闭原则，增加功能：代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。角色Subject（抽象主题角色）： 它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。Proxy（代理主题角色）： 它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。RealSubject（真实主题角色）： 它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。优缺点优点职责清晰。高扩展性。智能化。缺点由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。实现代理模式需要额外的工作，有些代理模式的实现非常复杂。适用场景远程代理。虚拟代理。Copy-on-Write 代理。保护（Protect or Access）代理。Cache代理。防火墙（Firewall）代理。同步化（Synchronization）代理。智能引用（Smart Reference）代理。注意事项和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。静态代理其实代理的一般模式就是静态代理的实现模式：首先创建一个接口（JDK代理都是面向接口的），然后创建具体实现类来实现这个接口，在创建一个代理类同样实现这个接口，不同之处在于，具体实现类的方法中需要将接口中定义的方法的业务逻辑功能实现，而代理类中的方法只要调用具体类中的对应方法即可，这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可，将具体的实现类隐藏在底层。实现公用接口代理类和真实类的公用接口123public interface Subject &#123; void request();&#125;真实类的请求实现公有的接口123456public class RealSubject implements Subject&#123; @Override public void request() &#123; System.out.println(\"真实请求\"); &#125;&#125;创建代理类代理请求，引入了真实类对象，对方法进行了增强。123456789101112131415public class Proxy implements Subject&#123; //真实请求接口 private Subject realSubject; @Override public void request() &#123; if (realSubject == null) &#123; realSubject = new RealSubject(); &#125; System.out.println(\"前置增强\"); //转发真实请求 realSubject.request(); System.out.println(\"后置增强\"); &#125;&#125;测试123456public class ProxyDemo &#123; public static void main(String[] args)&#123; Proxy proxy = new Proxy(); proxy.request(); &#125;&#125;静态代理总结优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。动态代理在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。编写动态处理器动态代理需要实现InvocationHandler接口123456789101112131415161718192021222324252627282930313233343536373839404142/** * 动态代理类只能代理接口（不支持抽象类），代理类都需要实现InvocationHandler类，实现invoke方法。 * 该invoke方法就是调用被代理接口的所有方法时需要调用的，该invoke方法返回的值是被代理接口的一个实现类 */public class DynamicProxyHandler implements InvocationHandler &#123; // 目标对象 private Object targetObject; /** * 绑定关系，也就是关联到哪个接口（与具体的实现类绑定）的哪些方法将被调用时，执行invoke方法。 * @param targetObject * @return */ public Object newProxyInstance(Object targetObject)&#123; this.targetObject=targetObject; //该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 //第一个参数指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器 //第二个参数要实现和目标对象一样的接口，所以只需要拿到目标对象的实现接口 //第三个参数表明这些被拦截的方法在被拦截时需要执行哪个InvocationHandler的invoke方法 //根据传入的目标返回一个代理对象 return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(),this); &#125; /** * 关联的这个实现类的方法被调用时将被执行 * InvocationHandler接口的方法 * @param proxy 代理对象 * @param method 原对象被调用的方法 * @param args 表示方法的参数* * @return * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"前置增强\"); //调用目标方法 Object result = method.invoke(targetObject, args); System.out.println(\"后置增强\"); return result; &#125;&#125;测试12345678public class DynamicProxyDemo &#123; public static void main(String[] args)&#123; DynamicProxyHandler dynamicProxyHandler=new DynamicProxyHandler(); UserManager userManager=(UserManager)dynamicProxyHandler.newProxyInstance(new UserManagerImpl()); UserManager userManager=new UserManagerImpl(); userManager.addUser(\"1111\", \"张三\"); &#125;&#125;动态代理总结​ 虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。CGLIB动态代理JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。创建CGLIB代理类12345678910111213141516171819202122232425262728293031public class CglibProxy implements MethodInterceptor &#123; // 目标对象 private Object targetObject; public Object getInstance(final Object target) &#123; this.target = target; //CGLIB enhancer增强类对象 Enhancer enhancer = new Enhancer(); //设置代理类 enhancer.setSuperclass(this.targetObject.getClass()); //定义代理逻辑对象为当前对象 ，对象要继承MethodInterceptor。并实现逻辑方法intercept enhancer.setCallback(this); return enhancer.create(); &#125; /** * 代理逻辑方法 * @param proxy 代理对象 * @param method 方法 * @param args 方法参数 * @param methodProxy 方法代理 * @return * @throws Throwable */ public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable &#123; System.out.println(\"前置增强\"); //真的是代理对象，不像JDk代理，还是真实对象 Object result = methodProxy.invokeSuper(proxy, args); System.out.println(\"后置增强\"); return result; &#125;&#125;这里用了CGLIB的加强者Enhancer,通过设置超类的方法setSuperclass，然后通过setCallback方法设置哪个类为它的代理类。其中，参数为this就意味着是当前对象，那就要求用this这个对象实现接口Methodlnterceptor的方法intercept，然后返回代理对象。那么此时当前类的intercept方法就是其代理逻辑方法，其参数内容见代码注解，我们在反射真实对象方法前后进行了打印，CGLIB是通过如下代码完成的。1Object result=methodProxy.invokeSuper(proxy,args);测试123456789public class CglibProxyDemo &#123; public static void main(String arg[]) &#123; CglibProxy cglib = new CglibProxy(); Dog dog = (Dog) cglib.getInstance(Dog.class); //调用代理对象的isAnimal()方法 dog.isAnimal(); &#125;&#125;CGLIB代理总结​ CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"代理模式","slug":"设计模式/代理模式","permalink":"http://www.baiyp.ren/categories/设计模式/代理模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"代理模式","slug":"代理模式","permalink":"http://www.baiyp.ren/tags/代理模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"代理模式","slug":"设计模式/代理模式","permalink":"http://www.baiyp.ren/categories/设计模式/代理模式/"}]},{"title":"JAVA字节码指令","slug":"JAVA字节码指令","date":"2019-08-29T06:20:57.000Z","updated":"2019-08-29T07:21:09.418Z","comments":true,"path":"JAVA字节码指令.html","link":"","permalink":"http://www.baiyp.ren/JAVA字节码指令.html","excerpt":"","text":"JAVA字节码指令​ Java程序是运行在Java虚拟机上的，而这里的“虚拟”是对什么东西进行虚拟呢？答案当然就是对“实体”机进行虚拟啦，虚拟机可以看做是对实体机进行了进一步的封装和抽象，隐藏了不同实体机之间的差别，从而达成“Write Once,Run AnyWhere”的目标。既然虚拟机是对实体机的虚拟，所以我认为虚拟机和实体机在结构和功能上必然存在某种程度上的对应与关联。因此我们在学习时应该注意发掘和类比两者之间的关系。​ 本着这样的思想，我们进行Java字节码指令的学习。JAVA字节码在JAVA虚拟机中的地位相当于实体机的机器码，一切在Java虚拟机上运行的程序都要被解释或编译成字节码，一切在实体机上运行的程序最后也都要编译成机器码。Java字节码指令可以对字节码进行操作，在实体机中对机器码进行操作的是汇编语言。所以Java字节码指令对应汇编语言，Java字节码指令集对应汇编指令集。字节码简介Java汇编指令就是Java虚拟机能够听得懂、可执行的指令，也可以说是Java代码的最小执行单元。​ Java字节码指令由一个字节长度的，代表某种特定操作含义的数字（操作码）以及其后的零至多个代表此操作所需参数（操作数）。此外字节码指令是面向操作数栈的，这里操作数栈在功能上对应实体机的寄存器但是结构上有所区别。java字节码指令集常用指令集指令码操作码（助记符）操作数描述（栈指操作数栈）0x01aconst_nullnull值入栈。0x02iconst_m1-1(int)值入栈。0x03iconst_00(int)值入栈。0x04iconst_11(int)值入栈。0x05iconst_22(int)值入栈。0x06iconst_33(int)值入栈。0x07iconst_44(int)值入栈。0x08iconst_55(int)值入栈。0x09lconst_00(long)值入栈。0x0alconst_11(long)值入栈。0x0bfconst_00(float)值入栈。0x0cfconst_11(float)值入栈。0x0dfconst_22(float)值入栈。0x0edconst_00(double)值入栈。0x0fdconst_11(double)值入栈。0x10bipushvaluebytevaluebyte值带符号扩展成int值入栈。0x11sipushvaluebyte1，valuebyte2(valuebyte1 &lt;&lt; 8) | valuebyte2 值带符号扩展成int值入栈。0x12ldcindexbyte1常量池中的常量值（int, float, string reference, object reference）入栈。0x13ldc_windexbyte1，indexbyte2常量池中常量（int, float, string reference, object reference）入栈。0x14ldc2_windexbyte1，indexbyte2常量池+A1:D24中常量（long, double）入栈。局部变量值转载到栈中指令指令码操作码（助记符）操作数描述（栈指操作数栈）0x19(wide)aloadindexbyte从局部变量indexbyte中装载引用类型值入栈。0x2aaload_0从局部变量0中装载引用类型值入栈。0x2baload_1从局部变量1中装载引用类型值入栈。0x2caload_2从局部变量2中装载引用类型值入栈。0x2daload_3从局部变量3中装载引用类型值入栈。0x15(wide)iloadindexbyte从局部变量indexbyte中装载int类型值入栈。0x1aiload_0从局部变量0中装载int类型值入栈。0x1biload_1从局部变量1中装载int类型值入栈。0x1ciload_2从局部变量2中装载int类型值入栈。0x1diload_3从局部变量3中装载int类型值入栈。0x16(wide)lloadindexbyte从局部变量indexbyte中装载long类型值入栈。0x1elload_0从局部变量0中装载int类型值入栈。0x1flload_1从局部变量1中装载int类型值入栈。0x20lload_2从局部变量2中装载int类型值入栈。0x21lload_3从局部变量3中装载int类型值入栈。0x17(wide)floadindexbyte从局部变量indexbyte中装载float类型值入栈。0x22fload_0从局部变量0中装载float类型值入栈。0x23fload_1从局部变量1中装载float类型值入栈。0x24fload_2从局部变量2中装载float类型值入栈。0x25fload_3从局部变量3中装载float类型值入栈。0x18(wide)dloadindexbyte从局部变量indexbyte中装载double类型值入栈。0x26dload_0从局部变量0中装载double类型值入栈。0x27dload_1从局部变量1中装载double类型值入栈。0x28dload_2从局部变量2中装载double类型值入栈。0x29dload_3从局部变量3中装载double类型值入栈。0x32aaload从引用类型数组中装载指定项的值。0x2eiaload从int类型数组中装载指定项的值。0x2flaload从long类型数组中装载指定项的值。0x30faload从float类型数组中装载指定项的值。0x31daload从double类型数组中装载指定项的值。0x33baload从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。0x34caload从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。0x35saload从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。wide指令指令码操作码（助记符）操作数描述（栈指操作数栈）0xc4wide使用附加字节扩展局部变量索引（iinc指令特殊）。将栈顶值保存到局部变量中指令指令码操作码（助记符）操作数描述（栈指操作数栈）0x3a(wide)astoreindexbyte将栈顶引用类型值保存到局部变量indexbyte中。0x4bastroe_0将栈顶引用类型值保存到局部变量0中。0x4castore_1将栈顶引用类型值保存到局部变量1中。0x4dastore_2将栈顶引用类型值保存到局部变量2中。0x4eastore_3将栈顶引用类型值保存到局部变量3中。0x36(wide)istoreindexbyte将栈顶int类型值保存到局部变量indexbyte中。0x3bistore_0将栈顶int类型值保存到局部变量0中。0x3cistore_1将栈顶int类型值保存到局部变量1中。0x3distore_2将栈顶int类型值保存到局部变量2中。0x3eistore_3将栈顶int类型值保存到局部变量3中。0x37(wide)lstoreindexbyte将栈顶long类型值保存到局部变量indexbyte中。0x3flstore_0将栈顶long类型值保存到局部变量0中。0x40lstore_1将栈顶long类型值保存到局部变量1中。0x41lstore_2将栈顶long类型值保存到局部变量2中。0x42lstroe_3将栈顶long类型值保存到局部变量3中。0x38(wide)fstoreindexbyte将栈顶float类型值保存到局部变量indexbyte中。0x43fstore_0将栈顶float类型值保存到局部变量0中。0x44fstore_1将栈顶float类型值保存到局部变量1中。0x45fstore_2将栈顶float类型值保存到局部变量2中。0x46fstore_3将栈顶float类型值保存到局部变量3中。0x39(wide)dstoreindexbyte将栈顶double类型值保存到局部变量indexbyte中。0x47dstore_0将栈顶double类型值保存到局部变量0中。0x48dstore_1将栈顶double类型值保存到局部变量1中。0x49dstore_2将栈顶double类型值保存到局部变量2中。0x4adstore_3将栈顶double类型值保存到局部变量3中。0x53aastore将栈顶引用类型值保存到指定引用类型数组的指定项。0x4fiastore将栈顶int类型值保存到指定int类型数组的指定项。0x50lastore将栈顶long类型值保存到指定long类型数组的指定项。0x51fastore将栈顶float类型值保存到指定float类型数组的指定项。0x52dastore将栈顶double类型值保存到指定double类型数组的指定项。0x54bastroe将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。0x55castore将栈顶char类型值保存到指定char类型数组的指定项。0x56sastore将栈顶short类型值保存到指定short类型数组的指定项。通用（无类型）栈操作指令指令码操作码（助记符）操作数描述（栈指操作数栈）0x00nop空操作。0x57pop从栈顶弹出一个字长的数据。0x58pop2从栈顶弹出两个字长的数据。0x59dup复制栈顶一个字长的数据，将复制后的数据压栈。0x5adup_x1复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。0x5bdup_x2复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。0x5cdup2复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。0x5ddup2_x1复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。0x5edup2_x2复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。0x5fswap交换栈顶两个字长的数据的位置。Java指令中没有提供以两个字长为单位的交换指令。类型转换指令指令码操作码（助记符）操作数描述（栈指操作数栈）0x86i2f将栈顶int类型值转换为float类型值。0x85i2l将栈顶int类型值转换为long类型值。0x87i2d将栈顶int类型值转换为double类型值。0x8bf2i将栈顶float类型值转换为int类型值。0x8cf2l将栈顶float类型值转换为long类型值。0x8df2d将栈顶float类型值转换为double类型值。0x88l2i将栈顶long类型值转换为int类型值。0x89l2f将栈顶long类型值转换为float类型值。0x8al2d将栈顶long类型值转换double类型值。0x8ed2i将栈顶double类型值转换为int类型值。0x90d2f将栈顶double类型值转换为float类型值。0x8fd2l将栈顶double类型值转换为long类型值。0x91i2b将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。0x92i2c将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。0x93i2s将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。整数运算指令码操作码（助记符）操作数描述（栈指操作数栈）0x60iadd将栈顶两int类型数相加，结果入栈。0x64isub将栈顶两int类型数相减，结果入栈。0x68imul将栈顶两int类型数相乘，结果入栈。0x6cidiv将栈顶两int类型数相除，结果入栈。0x70irem将栈顶两int类型数取模，结果入栈。0x74ineg将栈顶int类型值取负，结果入栈。0x61ladd将栈顶两long类型数相加，结果入栈。0x65lsub将栈顶两long类型数相减，结果入栈。0x69lmul将栈顶两long类型数相乘，结果入栈。0x6dldiv将栈顶两long类型数相除，结果入栈。0x71lrem将栈顶两long类型数取模，结果入栈。0x75lneg将栈顶long类型值取负，结果入栈。0x84(wide)iincindexbyte，constbyte将整数值constbyte加到indexbyte指定的int类型的局部变量中。浮点运算指令码操作码（助记符）操作数描述（栈指操作数栈）0x62fadd将栈顶两float类型数相加，结果入栈。0x66fsub将栈顶两float类型数相减，结果入栈。0x6afmul将栈顶两float类型数相乘，结果入栈。0x6efdiv将栈顶两float类型数相除，结果入栈。0x72frem将栈顶两float类型数取模，结果入栈。0x76fneg将栈顶float类型值取反，结果入栈。0x63dadd将栈顶两double类型数相加，结果入栈。0x67dsub将栈顶两double类型数相减，结果入栈。0x6bdmul将栈顶两double类型数相乘，结果入栈。0x6fddiv将栈顶两double类型数相除，结果入栈。0x73drem将栈顶两double类型数取模，结果入栈。0x77dneg将栈顶double类型值取负，结果入栈。逻辑运算——移位运算指令码操作码（助记符）操作数描述（栈指操作数栈）0x78ishl左移int类型值。0x79lshl左移long类型值。0x7aishr算术右移int类型值。0x7blshr算术右移long类型值。0x7ciushr逻辑右移int类型值。0x7dlushr逻辑右移long类型值。逻辑运算——按位布尔运算指令码操作码（助记符）操作数描述（栈指操作数栈）0x73iand对int类型按位与运算。0x7fland对long类型的按位与运算。0x80ior对int类型的按位或运算。0x81lor对long类型的按位或运算。0x82ixor对int类型的按位异或运算。0x83lxor对long类型的按位异或运算。控制流指令——条件跳转指令指令码操作码（助记符）操作数描述（栈指操作数栈）0x99ifeqbranchbyte1，branchbyte2若栈顶int类型值为0则跳转。0x9aifnebranchbyte1，branchbyte2若栈顶int类型值不为0则跳转。0x9bifltbranchbyte1，branchbyte2若栈顶int类型值小于0则跳转。0x9eiflebranchbyte1，branchbyte2若栈顶int类型值小于等于0则跳转。0x9difgtbranchbyte1，branchbyte2若栈顶int类型值大于0则跳转。0x9cifgebranchbyte1，branchbyte2若栈顶int类型值大于等于0则跳转。0x9fif_icmpeqbranchbyte1，branchbyte2若栈顶两int类型值相等则跳转。0xa0if_icmpnebranchbyte1，branchbyte2若栈顶两int类型值不相等则跳转。0xa1if_icmpltbranchbyte1，branchbyte2若栈顶两int类型值前小于后则跳转。0xa4if_icmplebranchbyte1，branchbyte2若栈顶两int类型值前小于等于后则跳转。0xa3if_icmpgtbranchbyte1，branchbyte2若栈顶两int类型值前大于后则跳转。0xa2if_icmpgebranchbyte1，branchbyte2若栈顶两int类型值前大于等于后则跳转。0xc6ifnullbranchbyte1，branchbyte2若栈顶引用值为null则跳转。0xc7ifnonnullbranchbyte1，branchbyte2若栈顶引用值不为null则跳转。0xa5if_acmpeqbranchbyte1，branchbyte2若栈顶两引用类型值相等则跳转。0xa6if_acmpnebranchbyte1，branchbyte2若栈顶两引用类型值不相等则跳转。控制流指令——比较指令0x94lcmp比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。0x95fcmpl比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。0x96fcmpg比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。0x97dcmpl比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。0x98dcmpg比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。控制流指令——无条件跳转指令指令码操作码（助记符）操作数描述（栈指操作数栈）0xa7gotobranchbyte1，branchbyte2无条件跳转到指定位置。0xc8goto_wbranchbyte1，branchbyte2，branchbyte3，branchbyte4无条件跳转到指定位置（宽索引）。控制流指令——表跳转指令指令码操作码（助记符）操作数描述（栈指操作数栈）0xaatableswitch&lt;0-3bytepad&gt;,defaultbyte1,defaultbyte2,defaultbyte3,defaultbyte4,lowbyte1,lowbyte2,lowbyte3,lowbyte4,highbyte1,highbyte2,highbyte3,highbyte4,jump offsets…通过索引访问跳转表，并跳转。0xablookupswitch&lt;0-3bytepad&gt;,defaultbyte1,defaultbyte2,defaultbyte3,defaultbyte4,npairs1,npairs2,npairs3,npairs4,match offsets通过键值访问跳转表，并跳转。控制流指令——异常和finally指令码操作码（助记符）操作数描述（栈指操作数栈）0xbfathrow抛出异常。0xa8jsrbranchbyte1,branchbyte2跳转到子例程序。0xc9jsr_wbranchbyte1,branchbyte2,branchbyte3,branchbyte4跳转到子例程序（宽索引）。0xa9(wide)retindexbyte返回子例程序。对象操作指令指令码操作码（助记符）操作数描述（栈指操作数栈）0xbbnewindexbyte1,indexbyte2创建新的对象实例。0xc0checkcastindexbyte1,indexbyte2类型强转。0xc1instanceofindexbyte1,indexbyte2判断类型。0xb4getfieldindexbyte1,indexbyte2获取对象字段的值。0xb5putfieldindexbyte1,indexbyte2给对象字段赋值。0xb2getstaticindexbyte1,indexbyte2获取静态字段的值。0xb3putstaticindexbyte1,indexbyte2给静态字段赋值。数组操作指令指令码操作码（助记符）操作数描述（栈指操作数栈）0xbcnewarrayatype创建type类型的数组。0xbdanewarrayindexbyte1,indexbyte2创建引用类型的数组。0xbearraylength获取一维数组的长度。0xc5multianewarrayindexbyte1,indexbyte2,dimension创建dimension维度的数组。方法调用指令指令码操作码（助记符）操作数描述（栈指操作数栈）0xb7invokespecialindexbyte1,indexbyte2编译时方法绑定调用方法。0xb6invokevirtualindexbyte1,indexbyte2运行时方法绑定调用方法。0xb8invokestaticindexbyte1,indexbyte2调用静态方法。0xb9invokeinterfaceindexbyte1,indexbyte2,count,0调用接口方法。方法返回指令指令码操作码（助记符）操作数描述（栈指操作数栈）0xacireturn返回int类型值。0xadlreturn返回long类型值。0xaefreturn返回float类型值。0xafdreturn返回double类型值。0xb0areturn返回引用类型值。0xb1returnvoid函数返回。线程同步指令指令码操作码（助记符）操作数描述（栈指操作数栈）0xc2monitorenter进入并获得对象监视器。0xc3monitorexit释放并退出对象监视器。","categories":[{"name":"jvm","slug":"jvm","permalink":"http://www.baiyp.ren/categories/jvm/"},{"name":"指令","slug":"jvm/指令","permalink":"http://www.baiyp.ren/categories/jvm/指令/"}],"tags":[{"name":"jvm","slug":"jvm","permalink":"http://www.baiyp.ren/tags/jvm/"},{"name":"指令","slug":"指令","permalink":"http://www.baiyp.ren/tags/指令/"}],"keywords":[{"name":"jvm","slug":"jvm","permalink":"http://www.baiyp.ren/categories/jvm/"},{"name":"指令","slug":"jvm/指令","permalink":"http://www.baiyp.ren/categories/jvm/指令/"}]},{"title":"JAVA设计模式的六大原则","slug":"JAVA设计模式的六大原则","date":"2019-08-29T01:42:30.000Z","updated":"2019-08-30T03:18:19.015Z","comments":true,"path":"JAVA设计模式的六大原则.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式的六大原则.html","excerpt":"","text":"JAVA设计模式的六大原则开闭原则（Open Close Principle）开闭原则，对于扩展是开放的，对于修改是关闭。​ 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。​ 可以通过“抽象约束、封装变化”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。​ 开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。开闭原则的好处是：由于对于软件原来的模块不需要修改，因此不担心软件的稳定性。对软件进行扩展，加入新的功能，这样，这个软件就可以通过不断地增加新模块满足不断变化的新需求。和其他原则的关系开闭原则具有理想主义的色彩，它是面向对象设计的终极目标​ 因此，针对开闭原则的实现方法，一直都有面向对象设计的大师费尽心机，研究开闭原则的实现方式。后面要提到的里氏替换原则（LSP）、依赖倒转原则（DIP）、接口隔离原则（ISP）以及抽象类（Abstract Class）、接口(Interface)等等，都可以看作是开闭原则的实现方法。单一职责原则（Single Responsibility Principle）就一个类而言，应该仅有一个引起它变化的原因（一个类只负责一项职责）为什么要使用单一职责原则：​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计。优点：可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；提高类的可读性，提高系统的可维护性；变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。里氏代换原则（Liskov Substitution Principle）子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。子类中可以增加自己特有的方法。当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。​ 里氏代换原则是对“开闭”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。​ 简单的理解为一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类都替换成它的子类，程序的行为没有变化。但是反过来的代换却不成立，一个软件实体如果使用的是一个子类的话，那么它不能适用于其父类。例如：​ 在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅却不能继承鸟。在面向对象设计时，子类拥有父类所有非private的行为和属性，鸟会飞，但企鹅不会飞，所以企鹅不能继承鸟类。里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。依赖倒转原则（Dependence Inversion Principle）高层模块不应该依赖低层模块，两者都应该依赖其抽象抽象不应该依赖细节细节应该依赖抽象也可以说高层模块，低层模块，细节都应该依赖抽象​ 依赖倒转其实就是谁也不要依靠谁，除了约定的接口，大家都可以灵活自如。依赖倒转可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。如果设计的各个部件或类相互依赖，这样就是耦合度高，难以维护和扩展，这也就体现不出面向对象的好处了。​ 赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。​ 依赖倒置原则的中心思想是面向接口编程，传递依赖关系有三种方式，以上的说的是是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。DIP的好处： 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。在实际编程中，我们一般需要做到如下3点：低层模块尽量都要有抽象类或接口，或者两者都有。变量的声明类型尽量是抽象类或接口。使用继承时遵循里氏替换原则。接口隔离原则（Interface Segregation Principle）客户端不应该依赖它不需要的接口类间的依赖关系应该建立在最小的接口上​ 接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。​ 说到这里，很多人会觉的接口隔离原则跟单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。采用接口隔离原则对接口进行约束时，要注意以下几点：接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。好处:​ 现在我们知道，接口隔离原则的要点，就是要细化我们的接口。那么这样做具体有什么好处呢？主要有四个好处，分别是：避免接口污染；提高灵活性；提供定制服务；实现高内聚。迪米特法则（Law Of Demeter）一个对象应该对其他对象保持最少的了解​ 迪米特法则的意义在于降低类之间的耦合。由于每个对象尽量减少对其他对象的了解，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。​ 迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。​ 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。模式中的外观模式和中介模式就是迪米特法则的实现","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"设计原则","slug":"设计模式/设计原则","permalink":"http://www.baiyp.ren/categories/设计模式/设计原则/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"设计原则","slug":"设计原则","permalink":"http://www.baiyp.ren/tags/设计原则/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"设计原则","slug":"设计模式/设计原则","permalink":"http://www.baiyp.ren/categories/设计模式/设计原则/"}]},{"title":"JAVA设计模式06-模板模式","slug":"JAVA设计模式06","date":"2019-08-29T01:42:30.000Z","updated":"2019-09-05T10:28:05.539Z","comments":true,"path":"JAVA设计模式06.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式06.html","excerpt":"","text":"JAVA设计模式-模板模式（Template Pattern）什么是模板模式​ 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。​ 使用了JAVA的继承机制，在抽象类中定义一个模板方法，该方法引用了若干个抽象方法（由子类实现）或具体方法（子类可以覆盖重写）；​ 其实就是JAVA的继承以及抽象方法、重写覆盖的使用；​ 注意：为防止恶意操作，一般模板方法都加上 final 关键词角色AbstractClass（抽象模板）：定义了一个模板方法和若干抽象方法和具体方法，ConcreteClass（具体模板）：继承抽象模板类并实现抽象方法优缺点优点封装不变部分，扩展可变部分。提取公共代码，便于维护。行为由父类控制，子类实现。缺点每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。适用场景多个子类有公有的方法,而且逻辑基本相同时.重要,复杂的算法,可以把核心算法设计为模板方法,周边的相关细节功能由各个子类实现.重构时,模板方法模式是一个经常使用的模式,把相同的代码抽取到父类中,庵后通过函数约束其行为。实现我们将创建一个定义操作的 Game 抽象类，其中，模板方法设置为 final，这样它就不会被重写。Cricket 和 Football 是扩展了 Game 的实体类，它们重写了抽象类的方法。TemplatePatternDemo*，我们的演示类使用 *Game 来演示模板模式的用法。创建一个抽象类它的模板方法被设置为 final。123456789101112131415161718public abstract class Game &#123; abstract void initialize(); abstract void startPlay(); abstract void endPlay(); //模板 public final void play()&#123; //初始化游戏 initialize(); //开始游戏 startPlay(); //结束游戏 endPlay(); &#125;&#125;创建扩展的子类Cricket 类1234567891011121314151617public class Cricket extends Game &#123; @Override void endPlay() &#123; System.out.println(\"Cricket Game Finished!\"); &#125; @Override void initialize() &#123; System.out.println(\"Cricket Game Initialized! Start playing.\"); &#125; @Override void startPlay() &#123; System.out.println(\"Cricket Game Started. Enjoy the game!\"); &#125;&#125;Football 类1234567891011121314151617public class Football extends Game &#123; @Override void endPlay() &#123; System.out.println(\"Football Game Finished!\"); &#125; @Override void initialize() &#123; System.out.println(\"Football Game Initialized! Start playing.\"); &#125; @Override void startPlay() &#123; System.out.println(\"Football Game Started. Enjoy the game!\"); &#125;&#125;测试12345678910public class TemplatePatternDemo &#123; public static void main(String[] args) &#123; Game game = new Cricket(); game.play(); System.out.println(); game = new Football(); game.play(); &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"模板模式","slug":"设计模式/模板模式","permalink":"http://www.baiyp.ren/categories/设计模式/模板模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"模板模式","slug":"模板模式","permalink":"http://www.baiyp.ren/tags/模板模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"模板模式","slug":"设计模式/模板模式","permalink":"http://www.baiyp.ren/categories/设计模式/模板模式/"}]},{"title":"JAVA中的伪共享与缓存行","slug":"JAVA中的伪共享","date":"2019-08-28T07:33:17.000Z","updated":"2019-09-07T09:07:49.684Z","comments":true,"path":"JAVA中的伪共享.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的伪共享.html","excerpt":"","text":"JAVA中的伪共享Java中的伪共享​ 解决伪共享最直接的方法就是填充（padding），例如下面的VolatileLong，一个long占8个字节，Java的对象头占用8个字节（32位系统）或者12字节（64位系统，默认开启对象头压缩，不开启占16字节）。一个缓存行64字节，那么我们可以填充6个long（6 * 8 = 48 个字节）。​ 现在，我们学习JVM对象的内存模型。所有的Java对象都有8字节的对象头，前四个字节用来保存对象的哈希码和锁的状态，前3个字节用来存储哈希码，最后一个字节用来存储锁状态，一旦对象上锁，这4个字节都会被拿出对象外，并用指针进行链接。剩下4个字节用来存储对象所属类的引用。对于数组来讲，还有一个保存数组大小的变量，为4字节。每一个对象的大小都会对齐到8字节的倍数，不够8字节部分需要填充。为了保证效率，Java编译器在编译Java对象的时候，通过字段类型对Java对象的字段进行排序，如下表所示。顺序类型字节数量1double8字节2long8字节3int4字节4float4字节5short2字节6char2字节7boolean1字节8byte1字节9对象引用4字节或者8字节10子类字段重新排序​ 因此，我们可以在任何字段之间通过填充长整型的变量把热点变量隔离在不同的缓存行中，通过减少伪同步，在多核心CPU中能够极大的提高效率。最简单的方式123456789/** * 缓存行填充父类 */public class DataPadding &#123; //填充 6个long类型字段 8*4 = 48 个字节 private long p1, p2, p3, p4, p5, p6; //需要操作的数据 private long data;&#125;因为JDK1.7以后就自动优化代码会删除无用的代码，在JDK1.7以后的版本这些不生效了。继承的方式1234567/** * 缓存行填充父类 */public class DataPadding &#123; //填充 6个long类型字段 8*4 = 48 个字节 private long p1, p2, p3, p4, p5, p6;&#125;继承缓存填充类123456789101112131415161718192021222324/** * 继承DataPadding */public class VolatileData extends DataPadding &#123; // 占用 8个字节 +48 + 对象头 = 64字节 private long data = 0; public VolatileData() &#123; &#125; public VolatileData(long defValue) &#123; this.data = defValue; &#125; public long accumulationAdd() &#123; //因为单线程操作不需要加锁 data++; return data; &#125; public long getValue() &#123; return data; &#125;&#125;这样在JDK1.8中是可以使用的@Contended注解12345@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.FIELD, ElementType.TYPE&#125;)public @interface Contended &#123; String value() default \"\";&#125;​ Contended注解可以用于类型上和属性上，加上这个注解之后虚拟机会自动进行填充，从而避免伪共享。这个注解在Java8 ConcurrentHashMap、ForkJoinPool和Thread等类中都有应用。我们来看一下Java8中ConcurrentHashMap中如何运用Contended这个注解来解决伪共享问题。以下说的ConcurrentHashMap都是Java8版本。注意：在Java8中提供了@sun.misc.Contended来避免伪共享时，在运行时需要设置JVM启动参数-XX:-RestrictContended否则可能不生效。缓存行填充的威力123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 缓存行测试 */public class CacheLineTest &#123; /** * 是否启用缓存行填充 */ private final boolean isDataPadding = false; /** * 正常定义的变量 */ private volatile long x = 0; private volatile long y = 0; private volatile long z = 0; /** * 通过缓存行填充的变量 */ private volatile VolatileData volatileDataX = new VolatileData(0); private volatile VolatileData volatileDataY = new VolatileData(0); private volatile VolatileData volatileDataZ = new VolatileData(0); /** * 循环次数 */ private final long size = 100000000; /** * 进行累加操作 */ public void accumulationX() &#123; //计算耗时 long currentTime = System.currentTimeMillis(); long value = 0; //循环累加 for (int i = 0; i &lt; size; i++) &#123; //使用缓存行填充的方式 if (isDataPadding) &#123; value = volatileDataX.accumulationAdd(); &#125; else &#123; //不使用缓存行填充的方式 因为时单线程操作不需要加锁 value = (++x); &#125; &#125; //打印 System.out.println(value); //打印耗时 System.out.println(\"耗时：\" + (System.currentTimeMillis() - currentTime)); &#125; /** * 进行累加操作 */ public void accumulationY() &#123; long currentTime = System.currentTimeMillis(); long value = 0; for (int i = 0; i &lt; size; i++) &#123; if (isDataPadding) &#123; value = volatileDataY.accumulationAdd(); &#125; else &#123; value = ++y; &#125; &#125; System.out.println(value); System.out.println(\"耗时：\" + (System.currentTimeMillis() - currentTime)); &#125; /** * 进行累加操作 */ public void accumulationZ() &#123; long currentTime = System.currentTimeMillis(); long value = 0; for (int i = 0; i &lt; size; i++) &#123; if (isDataPadding) &#123; value = volatileDataZ.accumulationAdd(); &#125; else &#123; value = ++z; &#125; &#125; System.out.println(value); System.out.println(\"耗时：\" + (System.currentTimeMillis() - currentTime)); &#125; public static void main(String[] args) &#123; //创建对象 CacheLineTest cacheRowTest = new CacheLineTest(); //创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(3); //启动三个线程个调用他们各自的方法 executorService.execute(() -&gt; cacheRowTest.accumulationX()); executorService.execute(() -&gt; cacheRowTest.accumulationY()); executorService.execute(() -&gt; cacheRowTest.accumulationZ()); executorService.shutdown(); &#125;&#125;不使用缓存行填充测试1234/** * 是否启用缓存行填充 */ private final boolean isDataPadding = false;输出123456100000000耗时：7960100000000耗时：7984100000000耗时：7989使用缓存行填充测试1234/** * 是否启用缓存行填充 */ private final boolean isDataPadding = true;输出123456100000000耗时：176100000000耗时：178100000000耗时：182同样的结构他们之间差了 将近 50倍的速度差距总结​ 当多个线程同时对共享的缓存行进行写操作的时候，因为缓存系统自身的缓存一致性原则，会引发伪共享问题，解决的常用办法是将共享变量根据缓存行大小进行补充对齐，使其加载到缓存时能够独享缓存行，避免与其他共享变量存储在同一个缓存行。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"伪共享","slug":"并发/伪共享","permalink":"http://www.baiyp.ren/categories/并发/伪共享/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"伪共享","slug":"伪共享","permalink":"http://www.baiyp.ren/tags/伪共享/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"伪共享","slug":"并发/伪共享","permalink":"http://www.baiyp.ren/categories/并发/伪共享/"}]},{"title":"伪共享与缓存行","slug":"伪共享与缓存行","date":"2019-08-28T07:33:17.000Z","updated":"2019-09-07T09:07:49.686Z","comments":true,"path":"伪共享与缓存行.html","link":"","permalink":"http://www.baiyp.ren/伪共享与缓存行.html","excerpt":"","text":"伪共享与缓存行CPU缓存架构CPU 是计算机的心脏，所有运算和程序最终都要由它来执行。主内存（RAM）是数据存放的地方，CPU 和主内存之间有好几级缓存，因为即使直接访问主内存也是非常慢的。CPU的速度要远远大于内存的速度，为了解决这个问题，CPU引入了三级缓存：L1，L2和L3三个级别，L1最靠近CPU，L2次之，L3离CPU最远，L3之后才是主存。速度是L1&gt;L2&gt;L3&gt;主存。越靠近CPU的容量越小。CPU获取数据会依次从三级缓存中查找。当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取，由此可见一级缓存是整个CPU缓存架构中最为重要的部分。下表是一些缓存未命中的消耗数据：从CPU到大约需要的CPU周期大约需要的时间主存约60-80nsQPI总线约20nsL3 cache约40-45cycles约15nsL2 cache约10cycles约3nsL1 cache约3-4cycles约1ns寄存器1cycleMESI协议缓存行状态CPU的缓存是以缓存行(cache line)为单位的，MESI协议描述了多核处理器中一个缓存行的状态。在MESI协议中，每个缓存行有4个状态，分别是：M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；I（无效，Invalid）：缓存行失效, 不能使用。缓存行的E状态如下图：此时只有core1访问缓存行，它的缓存行的状态为E，表示core1独占。缓存行的S状态如下图：此时core1和core2都会访问缓存行，他们的缓存行状态为S，表示缓存行处于共享状态。缓存行的M和I状态如下图：此时core1修改了缓存行，因此core1的缓存行状态为M，代表已经修改，而core2的缓存行状态为I，代表已经失效，需要从主存中读取。缓存行状态转换​ 在MESI协议中，每个Cache的Cache控制器不仅知道自己的读写操作，而且也监听(snoop)其它Cache的读写操作。每个Cache line所处的状态根据本核和其它核的读写操作在4个状态间进行迁移。MESI协议状态迁移图如下：初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。缓存行​ CPU缓存是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节，并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。下图是一个CPU缓存行的示意图：上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。什么是伪共享​ 计算机系统中为了解决主内存与CPU运行速度的差距，在CPU与主内存之间添加了一级或者多级高速缓冲存储器（Cache），这个Cache一般是集成到CPU内部的，所以也叫 CPU Cache，如下图是两级cache结构：Cache内部是按行存储的，其中每一行称为一个cache行，cache行是Cache与主内存进行数据交换的单位，cache行的大小一般为2的幂次数字节。​ 当CPU访问某一个变量时候，首先会去看CPU Cache内是否有该变量，如果有则直接从中获取，否者就去主内存里面获取该变量，然后把该变量所在内存区域的一个Cache行大小的内存拷贝到Cache（cache行是Cache与主内存进行数据交换的单位）。由于存放到Cache行的的是内存块而不是单个变量，所以可能会把多个变量存放到了一个cache行。当多个线程同时修改一个缓存行里面的多个变量时候，由于同时只能有一个线程操作缓存行，所以相比每个变量放到一个缓存行性能会有所下降，这就是伪共享。​ 如上图变量x,y同时被放到了CPU的一级和二级缓存，当线程1使用CPU1对变量x进行更新时候，首先会修改cpu1的一级缓存变量x所在缓存行，这时候缓存一致性协议会导致cpu2中变量x对应的缓存行失效，那么线程2写入变量x的时候就只能去二级缓存去查找，这就破坏了一级缓存，而一级缓存比二级缓存更快。更坏的情况下如果cpu只有一级缓存，那么会导致频繁的直接访问主内存。为何会出现伪共享​ 伪共享的产生是因为多个变量被放入了一个缓存行，并且多个线程同时去写入缓存行中不同变量。那么为何多个变量会被放入一个缓存行那。其实是因为Cache与内存交换数据的单位就是Cache，当CPU要访问的变量没有在Cache命中时候，根据程序运行的局部性原理会把该变量在内存中大小为Cache行的内存放如缓存行。1234long a;long b;long c;long d;​ 如上代码，声明了四个long变量，假设cache行的大小为32个字节，那么当cpu访问变量a时候发现该变量没有在cache命中，那么就会去主内存把变量a以及内存地址附近的b,c,d放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中，当创建数组时候，数组里面的多个元素就会被放入到同一个缓存行。那么单线程下多个变量放入缓存行对性能有影响？其实正常情况下单线程访问时候由于数组元素被放入到了一个或者多个cache行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"伪共享","slug":"并发/伪共享","permalink":"http://www.baiyp.ren/categories/并发/伪共享/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"伪共享","slug":"伪共享","permalink":"http://www.baiyp.ren/tags/伪共享/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"伪共享","slug":"并发/伪共享","permalink":"http://www.baiyp.ren/categories/并发/伪共享/"}]},{"title":"JAVA设计模式05-装饰器模式","slug":"JAVA设计模式05","date":"2019-08-27T01:42:30.000Z","updated":"2019-09-05T10:28:13.423Z","comments":true,"path":"JAVA设计模式05.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式05.html","excerpt":"","text":"JAVA设计模式-装饰器模式（Decorator Pattern）装饰器模式(Decorator Pattern)，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更灵活。 —-《大话设计模式》什么是装饰器模式​ 允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。​ 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。角色Component（抽象构件）：给出一个抽象接口，装饰器模式中公共方法的类，在装饰器模式结构图的顶层，以规范准备接收附加责任的对象。ConcreteComponent（具体构件）：是要动态扩展的对象，转换器模式中具体的被装饰的类，它继承自Component。Decorator（装饰器）：持有一个构件(Component)对象的实例，它是装饰器模式中的核心对象，所有具体装饰器对象的父类，完成装饰器的部分职能。可以只对被装饰的对象进行一些简单的包裹，也可包含对Component中方法的实现。ConcreteDecorator（具体装饰）：完成具体的装饰功能。装饰功能的实现是通过调用被装饰对象对应的方法，加上装饰对象自身的方法。这是装饰器模式动机中的添加额外功能的关键。优缺点优点装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”或者除掉一个“装饰”，继承关系是静态的，它在系统运行前就决定了；通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合；装饰者类可以在被装饰者的行为前面或后面加上自己的行为，甚至取代被装饰者的行为，达到特定的目的；装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型缺点多层装饰比较复杂。由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。适用场景运行时，你需要动态地为对象增加额外职责时；当你需要一个能够代替子类的类，借助它提供额外方法时。在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；处理那些可以撤销的职责；当不能采用生成子类的方式进行扩充时。装饰器模式与适配器模式的比较共同点：都拥有一个目标对象。装饰器通过包装一个装饰对象来扩展其功能，而又不改变其接口，这实际上是基于对象的适配器模式的一种变种。不同点：适配器模式需要实现另外一个接口，而装饰器模式必须实现该对象的接口。适配器模式主要是为了接口的转换，而装饰者模式关注的是通过组合来动态的为被装饰者注入新的功能或行为(即所谓的责任)。实现假设我去买咖啡，首先服务员给我冲了一杯原味咖啡，我希望服务员给我加些牛奶和白糖混合入原味咖啡中。使用装饰器模式就可以解决这个问题。咖啡接口定义了获取花费和配料的接口。12345678910111213141516/** * 咖啡接口 */public interface Coffee &#123; /** * 获取价格 * @return */ public float getPrice(); /** * 获取咖啡 * @return */ public String getCoffee();&#125;原味咖啡实现Coffe接口，花费1元，配料中，只有咖啡1234567891011121314/** * 原味咖啡类 */public class OriginalCoffee implements Coffee &#123; @Override public float getPrice() &#123; return 1; &#125; @Override public String getCoffee() &#123; return \"原味咖啡\"; &#125;&#125;装饰器类咖啡对象的装饰器类，同样实现Coffee接口，定义一个Coffe对象的引用，在构造器中进行初始化。并且将getPrice（）和getCoffee()方法转发给被装饰对象。123456789101112131415161718192021222324252627282930313233343536/** * 咖啡的\"装饰器\"，可以给咖啡添加各种\"配料\" * 该类是一个抽象类需要具体子类来实现 */public class DecoratorAbstractCoffee implements Coffee &#123; /** * 具体咖啡的接口 */ protected final Coffee coffee; /** * 构造方法，初始化咖啡对象的引用 * @param coffee */ public DecoratorAbstractCoffee(Coffee coffee) &#123; this.coffee = coffee; &#125; /** * 获取价格，装饰器父类中直接转发\"请求\"至引用对象 * @return */ @Override public float getPrice() &#123; return coffee.getPrice(); &#125; /** * 获取咖啡，装饰器父类中直接转发\"请求\"至引用对象 * @return */ @Override public String getCoffee() &#123; return coffee.getCoffee(); &#125;&#125;具体的装饰器类添加牛奶具体的装饰器类，负责往咖啡中“添加”牛奶，注意看getPrice（）方法和getCoffee()方法，可以在转发请求之前或者之后，增加功能。如果是代理模式，这里的结构就有所不同，通常代理模式根据运行时的条件来判断是否转发请求。1234567891011121314151617181920212223242526272829303132/** * 混合牛奶到蜂蜜中 */public class CreamCoffee extends DecoratorAbstractCoffee &#123; private float price = (float) 0.5; /** * 调用父类的构造方法 * @param coffee */ public CreamCoffee(Coffee coffee) &#123; super(coffee); &#125; /** * 增加配料需要加钱 * @return */ @Override public float getPrice() &#123; return coffee.getPrice()+price; &#125; /** * 对咖啡进行加工 * @return */ @Override public String getCoffee() &#123; return coffee.getCoffee()+\"；添加牛奶\"; &#125;&#125;添加糖另一个具体装饰器类，用来给咖啡加蜂蜜，一样的逻辑。1234567891011121314151617class HoneyCoffee extends DecoratorAbstractCoffee &#123; private float price = (float) 1.4; public HoneyCoffee(Coffee coffee) &#123; super(coffee); &#125; @Override public float getPrice() &#123; return coffee.getPrice()+price; &#125; @Override public String getCoffee() &#123; return coffee.getCoffee()+\"；添加蜂蜜\"; &#125;&#125;客户端使用12345678910public class DecoratorMain &#123; public static void main(String[] args) &#123; //是不是很像 javaIO中的 stream流 Coffee coffee = new CreamCoffee(new HoneyCoffee(new OriginalCoffee())); System.out.println(coffee.getCoffee()); System.out.println(coffee.getPrice()); &#125;&#125;总结​ 装饰器模式是代替增加子类的一种解决方案，体现了聚合/合成复用原则的思想，尽量使用组合的方式来扩展功能，这样就把基本功能和扩展功能解耦了，使得代码可复用，可维护，灵活。关键点在于装饰器模式可以动态地为对象增加扩展功能。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"装饰器模式","slug":"设计模式/装饰器模式","permalink":"http://www.baiyp.ren/categories/设计模式/装饰器模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"装饰器模式","slug":"装饰器模式","permalink":"http://www.baiyp.ren/tags/装饰器模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"装饰器模式","slug":"设计模式/装饰器模式","permalink":"http://www.baiyp.ren/categories/设计模式/装饰器模式/"}]},{"title":"JAVA中的线程安全","slug":"JAVA中的线程安全","date":"2019-08-26T07:33:17.000Z","updated":"2019-09-07T09:07:49.682Z","comments":true,"path":"JAVA中的线程安全.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的线程安全.html","excerpt":"","text":"JAVA中的线程安全什么是线程安全​ 指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行程序时出现意外结果。线程不安全：是指不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。线程安全的解决方案栈封闭（局部变量）​ 栈限制是线程封闭的一种特例，只能通过局部变量才可以访问对象，局部使对象限制在执行线程中，存在于执行线程栈，其他线程无法访问这个栈，从而确保线程安全。（每一个线程都有一个工作内存，工作内存中班包括有栈，局部的基本类型变量是处于栈中，引用类型的引用处于栈中，而引用指向的对象处于堆中）。123456789public class Test &#123; public int add(int x, int y) &#123; //x,y 传递进来，因为x，y都是基本数据类型作为变量副本传递过来 //z变量被封闭在了方法内部 int z = x + y; return z; &#125;&#125;无状态（No State）如果一个类的同一个实例被多个线程共享并不会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为无状态对象；反之，如果一个类的同一个实例被多个线程共享，会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为有状态对象无状态对象不包含任何实例变量，且不包含任何静态变量或者其包含的静态变量都是只读的（常量）​ 即使一个类不包含任何实例变量或者静态变量，执行该类方法的多个线程也仍然可能存在共享状态；因为类方法中可能存在的实例对象中包含有静态变量或实例变量。此时就需要在方法中加锁来保障​ 当多个线程访问相同的实例或静态变量时，必须以某种方式来协调对此变量的访问。最简单的方法就是避免使用实例或静态变量。对于没有实例变量的类，它的方法只使用局部变量和方法参数以下示例显示了java.lang.Math类的其中一部分:123456789public static int subtractExact(int x, int y) &#123; int r = x - y; // HD 2-12 Overflow iff the arguments have different signs and // the sign of the result is different than the sign of x if (((x ^ y) &amp; (x ^ r)) &lt; 0) &#123; throw new ArithmeticException(\"integer overflow\"); &#125; return r;&#125;volatile​ 使用volatile可以保证变量的可见性与有序性，但是volatile不能保证线程的安全性，适合于一写多读的场景。加锁与CAS​ 通过加内置锁 synchronize或者 显示锁Lock可以解决线程同步问题，但是线程比较多的情况下会产生上下文切花问题，对于变量的同步可以使用CAS原子操作。安全的发布TheadLocal使用ThreadLocal 来进行线程的隔离，因为TheadLocal都保存这线程对象的副本，所以可以避免线程安全问题。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"线程安全","slug":"并发/线程安全","permalink":"http://www.baiyp.ren/categories/并发/线程安全/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"并发安全","slug":"并发安全","permalink":"http://www.baiyp.ren/tags/并发安全/"},{"name":"线程安全","slug":"线程安全","permalink":"http://www.baiyp.ren/tags/线程安全/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"线程安全","slug":"并发/线程安全","permalink":"http://www.baiyp.ren/categories/并发/线程安全/"}]},{"title":"JAVA线程池实现03-其余方法","slug":"JAVA线程池实现03","date":"2019-08-25T02:55:59.000Z","updated":"2019-09-07T09:07:49.673Z","comments":true,"path":"JAVA线程池实现03.html","link":"","permalink":"http://www.baiyp.ren/JAVA线程池实现03.html","excerpt":"","text":"JAVA线程池实现03-其余方法shutdown安全停止任务注意该方法不会马上停止线程池，会先将线程池置于shutdown状态然后发起中断请求，等待任务自己结束，线程内部要实现中断请求的响应处理，否则就不会终止。12345678910111213141516171819202122//安全的中断任务 public void shutdown() &#123; //获取重入锁 final ReentrantLock mainLock = this.mainLock; //加锁 mainLock.lock(); try &#123; //检查权限 checkShutdownAccess(); //更改运行状态 advanceRunState(SHUTDOWN); //中断任务 interruptIdleWorkers(); //模板方法，不继承实现则是一个空方法 onShutdown(); &#125; finally &#123; //解锁 mainLock.unlock(); &#125; //尝试中断任务 tryTerminate(); &#125;检查权限 checkShutdownAccess这主要的目的是为了在系统层面对线程池进行保护，防止其发生意外。比如中断系统进程等，获取了安全管理器之后接下来再对其进行权限检查。12345678910111213141516171819202122 //检查线程池个任务权限private void checkShutdownAccess() &#123; //获取安全管理器 SecurityManager security = System.getSecurityManager(); if (security != null) &#123; //检查任务权限 security.checkPermission(shutdownPerm); //获取重入锁 final ReentrantLock mainLock = this.mainLock; //加锁 mainLock.lock(); try &#123; //检查个任务的权限 for (ThreadPoolExecutor.Worker w : workers) &#123; security.checkAccess(w.thread); &#125; &#125; finally &#123; //解锁 mainLock.unlock(); &#125; &#125;&#125;更改运行状态 advanceRunState更改线程池的状态123456789//设置运行状态 private void advanceRunState(int targetState) &#123; for (; ; ) &#123; int c = ctl.get(); //非运行状态 当前状态&gt; targetState 或者 设置运行状态为 targetState状态成功 if (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))) break; &#125; &#125;中断工作任务 interruptIdleWorkers中断任务，但是只是发起中断请求，不会强制中断任务。1234567891011121314151617181920212223242526272829303132333435363738/** * 中断任务 */ private void interruptIdleWorkers() &#123; interruptIdleWorkers(false); &#125; /** * 中断任务 * @param onlyOne 是否只中断一次 */ private void interruptIdleWorkers(boolean onlyOne) &#123; //获取重入锁 final ReentrantLock mainLock = this.mainLock; //加锁 mainLock.lock(); try &#123; for (Worker w : workers) &#123; Thread t = w.thread; //任务未中断 并且尝试获取锁成功 if (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123; try &#123; //发起中断请求 t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; finally &#123; //解锁 w.unlock(); &#125; &#125; if (onlyOne) break; &#125; &#125; finally &#123; //解锁 mainLock.unlock(); &#125; &#125;尝试终止任务尝试终止任务如果有正在运行的任务或者任务队列不为空且运行状态是SHUTDOWN就返回，不进行前置终止。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 尝试终止任务 */final void tryTerminate() &#123; //自旋 for (;;) &#123; //获取运行状态 int c = ctl.get(); /** * isRunning 线程正在运行 * runStateAtLeast 线程池已经中断 * 或者 线程池停止并且任务队列不为空 返回 * 不进行强制终止 * */ //正在运行或者 if (isRunning(c) || runStateAtLeast(c, TIDYING) || (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) &#123; return; &#125; //当前工作线程不为0 if (workerCountOf(c) != 0) &#123; // Eligible to terminate //发起中断请求 只终止一次 interruptIdleWorkers(ONLY_ONE); //返回 return; &#125; //获取重入锁 final ReentrantLock mainLock = this.mainLock; //加锁 mainLock.lock(); try &#123; //设置运行状态为真理状态 if (ctl.compareAndSet(c, ctlOf(TIDYING, 0))) &#123; try &#123; //空方法，用于终止线程后的自定义任务 terminated(); &#125; finally &#123; //设置线程池为终止状态 ctl.set(ctlOf(TERMINATED, 0)); //通知所有线程 termination.signalAll(); &#125; return; &#125; &#125; finally &#123; //解锁 mainLock.unlock(); &#125; // else retry on failed CAS &#125;&#125;shutdownNow马上终止线程该方法是马上中断线程池，如果有未完成的任务先发起中断请求，然后将线程池中的任务删除，并将删除的数据放进一个临时的队列并且返回。1234567891011121314151617181920212223242526/** * 马上终止线程 * @return 未完成的任务列表 */public List&lt;Runnable&gt; shutdownNow() &#123; List&lt;Runnable&gt; tasks; //获取重入锁 final ReentrantLock mainLock = this.mainLock; //加锁 mainLock.lock(); try &#123; //检查权限 checkShutdownAccess(); //设置状态为终止 advanceRunState(STOP); //发起中断请求 interruptWorkers(); //将线程池任务队列清空，并返回未完成的任务 tasks = drainQueue(); &#125; finally &#123; mainLock.unlock(); &#125; //尝试终止任务 tryTerminate(); return tasks;&#125;drainQueue 清空队列清理队列并且返回未完成任务的列表123456789101112131415161718192021/** * 清空队列，并返回清除的数据 * @return */private List&lt;Runnable&gt; drainQueue() &#123; BlockingQueue&lt;Runnable&gt; q = workQueue; ArrayList&lt;Runnable&gt; taskList = new ArrayList&lt;Runnable&gt;(); //批量获取任务 q.drainTo(taskList); //为防止还有剩余数据，做一次查询 if (!q.isEmpty()) &#123; for (Runnable r : q.toArray(new Runnable[0])) &#123; //删除队列中的元素 if (q.remove(r)) &#123; //添加到队列 taskList.add(r); &#125; &#125; &#125; return taskList;&#125;shutdown与shutdownNow到这里我们发现shutdown和 shutdownNow很像，但是有差别，shutdownNow就强制在调用后会清空任务列表，强制终止任务，但是shutdown不会，shutdown会等待任务完成然后才会进行终止。isShutdown 线程池是否关闭123public boolean isShutdown() &#123; return ! isRunning(ctl.get()); &#125;isTerminating 线程池是否正在终止1234public boolean isTerminating() &#123; int c = ctl.get(); return ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED); &#125;线程池是否终止123public boolean isTerminated() &#123; return runStateAtLeast(ctl.get(), TERMINATED); &#125;","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"线程池","slug":"源码/线程池","permalink":"http://www.baiyp.ren/categories/源码/线程池/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"线程池","slug":"线程池","permalink":"http://www.baiyp.ren/tags/线程池/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://www.baiyp.ren/tags/ThreadPoolExecutor/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"线程池","slug":"源码/线程池","permalink":"http://www.baiyp.ren/categories/源码/线程池/"}]},{"title":"JAVA设计模式04-适配器模式","slug":"JAVA设计模式04","date":"2019-08-25T01:42:30.000Z","updated":"2019-09-05T10:28:22.242Z","comments":true,"path":"JAVA设计模式04.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式04.html","excerpt":"","text":"JAVA设计模式-适配器模式（Adapter Pattern）什么是适配器模式​ 将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。​ 在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。​ 根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。​ 缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。在JDK类库的事件处理包java.awt.event中广泛使用了缺省适配器模式，如WindowAdapter、KeyAdapter、MouseAdapter等。适配器模式实现的方式有三种：类适配器，对象适配器，接口适配器。角色Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。优缺点优点可以让任何两个没有关联的类一起运行。提高了类的复用。增加了类的透明度。灵活性好。缺点过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。适用场景想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。我们有一个类，想将其设计为可重用的类（可已经被多处访问了），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。想要使用接口中的某个或者某些方法，但是接口中有太多不是自己需要的方法了，接口在实现时必须实现其中的所有方法，这个时候就要使用抽象类来实现接口，并不对所有方法进行实现（进置空），然后我们再继承这个抽象类来重写想要的方法。这个抽象类就是适配器类适配器Adapter 类继承Adaptee （被适配类），同时实现Target 接口（因为 Java 不支持多继承，所以只能通过接口的方法来实现多继承），在 Client 类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。实现创建被适配的类12345public class Adaptee &#123; public void adapteeRequest() &#123; System.out.println(\"被适配者的方法\"); &#125;&#125;定义一个目标接口123public interface Target &#123; void request();&#125;创建适配器类实现 Target 接口，同时继承了 Adaptee 类，然后在实现的 request()方法中调用父类的 adapteeRequest()12345678public class Adapter extends Adaptee implements Target&#123; @Override public void request() &#123; //...一些操作... super.adapteeRequest(); //...一些操作... &#125;&#125;对象适配器对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 Adapter 类即可将转变为对象适配器1234567891011public class Adapter implements Target&#123; // 适配者是对象适配器的一个属性 private Adaptee adaptee = new Adaptee(); @Override public void request() &#123; //... adaptee.adapteeRequest(); //... &#125;&#125;注意这里的 Adapter 是将 Adaptee 作为一个成员属性，而不是继承它接口适配器当不需要全部实现接口提供的方法时，可先设计一个抽象类实现接口，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求，它适用于一个接口不想使用其所有的方法的情况。手机品牌接口12345678public interface MobilePhoneBrand &#123; String xiaomi(); String huawei(); String apple(); String vivo(); String oppo(); String samsung();&#125;创建抽象类12345678910111213141516171819202122public abstract class MobilePhoneDefault implements MobilePhoneBrand&#123; public String xiaomi()&#123; return null; &#125; public String huawei()&#123; return null; &#125; public String apple()&#123; return null; &#125; public String vivo()&#123; return null; &#125; public String oppo()&#123; return null; &#125; public String samsung()&#123; return null; &#125;&#125;创建具体实现类中国手机品牌12345678910111213141516171819public class ChinaMobilePhone extends MobilePhoneDefault &#123; public String xiaomi()&#123; return \"小米\"; &#125; public String huawei()&#123; return \"华为\"; &#125; public String vivo()&#123; return \"VIVO\"; &#125; public String oppo()&#123; return \"OPPO\"; &#125;&#125;美国手机品牌12345public class USAMobilePhone extends MobilePhoneDefault &#123; public String apple()&#123; return \"苹果\"; &#125;&#125;韩国手机品牌12345public class KoreaMobilePhone extends MobilePhoneDefault &#123; public String samsung()&#123; return \"三星\"; &#125;&#125;","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"适配器模式","slug":"设计模式/适配器模式","permalink":"http://www.baiyp.ren/categories/设计模式/适配器模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"适配器模式","slug":"适配器模式","permalink":"http://www.baiyp.ren/tags/适配器模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"适配器模式","slug":"设计模式/适配器模式","permalink":"http://www.baiyp.ren/categories/设计模式/适配器模式/"}]},{"title":"JAVA中的死锁","slug":"JAVA中的死锁","date":"2019-08-24T07:33:17.000Z","updated":"2019-09-07T09:07:49.680Z","comments":true,"path":"JAVA中的死锁.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的死锁.html","excerpt":"","text":"JAVA中的死锁什么是死锁​ 在多线程环境中，多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为死锁​ 在Java中使用多线程，就会有可能导致死锁问题。死锁会让程序一直卡住，不再程序往下执行。我们只能通过中止并重启的方式来让程序重新执行。造成死锁的原因当前线程拥有其他线程需要的资源当前线程等待其他线程已拥有的资源都不放弃自己拥有的资源死锁的必要条件互斥​ 进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。不可剥夺​ 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。请求与保持​ 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。循环等待​ 是指进程发生死锁后，必然存在一个进程–资源之间的环形链，通俗讲就是你等我的资源，我等你的资源，大家一直等。死锁的分类静态顺序型死锁线程之间形成相互等待资源的环时，就会形成顺序死锁lock-ordering deadlock，多个线程试图以不同的顺序来获取相同的锁时，容易形成顺序死锁，如果所有线程以固定的顺序来获取锁，就不会出现顺序死锁问题​ 经典案例是LeftRightDeadlock，两个方法，分别是leftRigth、rightLeft。如果一个线程调用leftRight，另一个线程调用rightLeft，且两个线程是交替执行的，就会发生死锁。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class LeftRightDeadLock &#123; //左边锁 private static Object left = new Object(); //右边锁 private static Object right = new Object(); /** * 现持有左边的锁，然后获取右边的锁 */ public static void leftRigth() &#123; synchronized (left) &#123; System.out.println(\"leftRigth: left lock，threadId:\" + Thread.currentThread().getId()); //休眠增加死锁产生的概率 sleep(100); synchronized (right) &#123; System.out.println(\"leftRigth: right lock，threadId:\" + Thread.currentThread().getId()); &#125; &#125; &#125; /** * 现持有右边的锁，然后获取左边的锁 */ public static void rightLeft() &#123; synchronized (right) &#123; System.out.println(\"rightLeft: right lock，threadId:\" + Thread.currentThread().getId()); //休眠增加死锁产生的概率 sleep(100); synchronized (left) &#123; System.out.println(\"rightLeft: left lock，threadId:\" + Thread.currentThread().getId()); &#125; &#125; &#125; /** * 休眠 * * @param time */ private static void sleep(long time) &#123; try &#123; Thread.sleep(time); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; //创建一个线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); executorService.execute(() -&gt; leftRigth()); executorService.execute(() -&gt; rightLeft()); executorService.shutdown(); &#125;&#125;输出12leftRigth: left lock，threadId:12rightLeft: right lock，threadId:13我们发现，12号线程锁住了左边要向右边获取锁，13号锁住了右边，要向左边获取锁，因为两边都不释放自己的锁，互不相让，就产生了死锁。解决方案固定加锁的顺序(针对锁顺序死锁)只要交换下锁的顺序，让线程来了之后先获取同一把锁，获取不到就等待，等待上一个线程释放锁再获取锁。1234567891011121314151617public static void leftRigth() &#123; synchronized (left) &#123; ... synchronized (right) &#123; ... &#125; &#125; &#125; public static void rightLeft() &#123; synchronized (left) &#123; ... synchronized (right) &#123; ... &#125; &#125; &#125;动态锁顺序型死锁由于方法入参由外部传递而来，方法内部虽然对两个参数按照固定顺序进行加锁，但是由于外部传递时顺序的不可控，而产生锁顺序造成的死锁，即动态锁顺序死锁。​ 上例告诉我们，交替的获取锁会导致死锁，且锁是固定的。有时候并锁的执行顺序并不那么清晰，参数导致不同的执行顺序。经典案例是银行账户转账，from账户向to账户转账，在转账之前先获取两个账户的锁，然后开始转账，如果这是to账户向from账户转账，角色互换，也会导致锁顺序死锁。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * 动态顺序型死锁 * 转账业务 */public class TransferMoneyDeadlock &#123; public static void transfer(Account from, Account to, int amount) &#123; //先锁住转账的账户 synchronized (from) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + from.name + \"】账户锁成功\"); //休眠增加死锁产生的概率 sleep(100); //在锁住目标账户 synchronized (to) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + to.name + \"】账户锁成功\"); if (from.balance &lt; amount) &#123; System.out.println(\"余额不足\"); return; &#125; else &#123; from.debit(amount); to.credit(amount); System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】从【\" + from.name + \"】账户转账到【\" + to.name + \"】账户【\" + amount + \"】元钱成功\"); &#125; &#125; &#125; &#125; private static class Account &#123; String name; int balance; public Account(String name, int balance) &#123; this.name = name; this.balance = balance; &#125; void debit(int amount) &#123; this.balance = balance - amount; &#125; void credit(int amount) &#123; this.balance = balance + amount; &#125; &#125; /** * 休眠 * * @param time */ private static void sleep(long time) &#123; try &#123; Thread.sleep(time); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; //创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); //创建账户A Account A = new Account(\"A\", 100); //创建账户B Account B = new Account(\"B\", 200); //A -&gt; B 的转账 executorService.execute(() -&gt; transfer(A, B, 5)); //B -&gt; A 的转账 executorService.execute(() -&gt; transfer(B, A, 10)); executorService.shutdown(); &#125;&#125;输出12线程【12】获取【A】账户锁成功线程【13】获取【B】账户锁成功然后就没有然后了，产生了死锁，我们发现 因为对象的调用关系，产生了互相锁住资源的问题。解决方案​ 根据传入对象的hashCode硬性确定加锁顺序，消除可变性，避免死锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145package com.test.thread.deadlock;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 动态顺序型死锁解决方案 */public class TransferMoneyDeadlock &#123; /** * 监视器，第三把锁，为了方式HASH冲突 */ private static Object lock = new Object(); /** * 我们经过上一次得失败，明白了不能依赖参数名称简单的确定锁的顺序，因为参数是 * 具有动态性的，所以，我们改变一下思路，直接根据传入对象的hashCode()大小来 * 对锁定顺序进行排序(这里要明白的是如何排序不是关键，有序才是关键)。 * * @param from * @param to * @param amount */ public static void transfer(Account from, Account to, int amount) &#123; /** * 这里需要说明一下为什么不使用HashCode()因为HashCode方法可以被重写， * 所以，我们无法简单的使用父类或者当前类提供的简单的hashCode()方法， * 所以，我们就使用系统提供的identityHashCode()方法，该方法保证无论 * 你是否重写了hashCode方法，都会在虚拟机层面上调用一个名为JVM_IHashCode * 的方法来根据对象的存储地址来获取该对象的hashCode(),HashCode如果不重写 * 的话，其实也是通过这个虚拟机层面上的方法，JVM_IHashCode()方法实现的 * 这个方法是用C++实现的。 */ int fromHash = System.identityHashCode(from); int toHash = System.identityHashCode(to); if (fromHash &gt; toHash) &#123; //先锁住转账的账户 synchronized (from) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + from.name + \"】账户锁成功\"); //休眠增加死锁产生的概率 sleep(100); //在锁住目标账户 synchronized (to) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + to.name + \"】账户锁成功\"); if (from.balance &lt; amount) &#123; System.out.println(\"余额不足\"); return; &#125; else &#123; from.debit(amount); to.credit(amount); System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】从【\" + from.name + \"】账户转账到【\" + to.name + \"】账户【\" + amount + \"】元钱成功\"); &#125; &#125; &#125; &#125; else if (fromHash &lt; toHash) &#123; //先锁住转账的账户 synchronized (to) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + from.name + \"】账户锁成功\"); //休眠增加死锁产生的概率 sleep(100); //在锁住目标账户 synchronized (from) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + to.name + \"】账户锁成功\"); if (from.balance &lt; amount) &#123; System.out.println(\"余额不足\"); return; &#125; else &#123; from.debit(amount); to.credit(amount); System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】从【\" + from.name + \"】账户转账到【\" + to.name + \"】账户【\" + amount + \"】元钱成功\"); &#125; &#125; &#125; &#125; else &#123; //如果传入对象的Hash值相同，那就加让加第三层锁 synchronized (lock) &#123; //先锁住转账的账户 synchronized (from) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + from.name + \"】账户锁成功\"); //休眠增加死锁产生的概率 sleep(100); //在锁住目标账户 synchronized (to) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + to.name + \"】账户锁成功\"); if (from.balance &lt; amount) &#123; System.out.println(\"余额不足\"); return; &#125; else &#123; from.debit(amount); to.credit(amount); System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】从【\" + from.name + \"】账户转账到【\" + to.name + \"】账户【\" + amount + \"】元钱成功\"); &#125; &#125; &#125; &#125; &#125; &#125; private static class Account &#123; String name; int balance; public Account(String name, int balance) &#123; this.name = name; this.balance = balance; &#125; void debit(int amount) &#123; this.balance = balance - amount; &#125; void credit(int amount) &#123; this.balance = balance + amount; &#125; &#125; /** * 休眠 * * @param time */ private static void sleep(long time) &#123; try &#123; Thread.sleep(time); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; //创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); //创建账户A Account A = new Account(\"A\", 100); //创建账户B Account B = new Account(\"B\", 200); //A -&gt; B 的转账 executorService.execute(() -&gt; transfer(A, B, 5)); //B -&gt; A 的转账 executorService.execute(() -&gt; transfer(B, A, 10)); executorService.shutdown(); &#125;&#125;输出123456线程【12】获取【A】账户锁成功线程【12】获取【B】账户锁成功线程【12】从【A】账户转账到【B】账户【5】元钱成功线程【13】获取【B】账户锁成功线程【13】获取【A】账户锁成功线程【13】从【B】账户转账到【A】账户【10】元钱成功协作对象间的死锁在协作对象之间可能存在多个锁获取的情况，但是这些获取多个锁的操作并不像在LeftRightDeadLock或transferMoney中那么明显，这两个锁并不一定必须在同一个方法中被获取。如果在持有锁时调用某个外部方法，那么这就需要警惕死锁问题，因为在这个外部方法中可能会获取其他锁，或者阻塞时间过长，导致其他线程无法及时获取当前被持有的锁。​ 上述两例中，在同一个方法中获取两个锁。实际上，锁并不一定在同一方法中被获取。经典案例，如出租车调度系统。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182/** * 协作对象间的死锁 */public class CoordinateDeadlock &#123; /** * Taxi 类 */ static class Taxi &#123; private String location; private String destination; private Dispatcher dispatcher; public Taxi(Dispatcher dispatcher, String destination) &#123; this.dispatcher = dispatcher; this.destination = destination; &#125; public synchronized String getLocation() &#123; return this.location; &#125; /** * 该方法先获取Taxi的this对象锁后，然后调用Dispatcher类的方法时，又需要获取 * Dispatcher类的this方法。 * * @param location */ public synchronized void setLocation(String location) &#123; this.location = location; System.out.println(Thread.currentThread().getName() + \" taxi set location:\" + location); if (this.location.equals(destination)) &#123; dispatcher.notifyAvailable(this); &#125; &#125; &#125; /** * 调度类 */ static class Dispatcher &#123; private Set&lt;Taxi&gt; taxis; private Set&lt;Taxi&gt; availableTaxis; public Dispatcher() &#123; taxis = new HashSet&lt;Taxi&gt;(); availableTaxis = new HashSet&lt;Taxi&gt;(); &#125; public synchronized void notifyAvailable(Taxi taxi) &#123; System.out.println(Thread.currentThread().getName() + \" notifyAvailable.\"); availableTaxis.add(taxi); &#125; /** * 打印当前位置：有死锁风险 * 持有当前锁的时候，同时调用Taxi的getLocation这个外部方法；而这个外部方法也是需要加锁的 * reportLocation的锁的顺序与Taxi的setLocation锁的顺序完全相反 */ public synchronized void reportLocation() &#123; System.out.println(Thread.currentThread().getName() + \" report location.\"); for (Taxi t : taxis) &#123; t.getLocation(); &#125; &#125; public void addTaxi(Taxi taxi) &#123; taxis.add(taxi); &#125; &#125; public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); final Dispatcher dispatcher = new Dispatcher(); final Taxi taxi = new Taxi(dispatcher, \"软件园\"); dispatcher.addTaxi(taxi); //先获取dispatcher锁，然后是taxi的锁 executorService.execute(() -&gt; dispatcher.reportLocation()); //先获取taxi锁，然后是dispatcher的锁 executorService.execute(() -&gt; taxi.setLocation(\"软件园\")); executorService.shutdown(); &#125;&#125;解决方案使用开放调用，开放调用指调用该方法不需要持有锁。​ 开放调用，是指在调用某个方法时不需要持有锁。开放调用可以避免死锁，这种代码更容易编写。上述调度算法完全可以修改为开发调用，修改同步代码块的范围，使其仅用于保护那些涉及共享状态的操作，避免在同步代码块中执行方法调用。修改Dispatcher的reportLocation方法：setLocation方法1234567891011121314/** * 开放调用，不持有锁期间进行外部方法调用 * * @param location */ public void setLocation(String location) &#123; synchronized (this) &#123; this.location = location; &#125; System.out.println(Thread.currentThread().getName() + \" taxi set location:\" + location); if (this.location.equals(destination)) &#123; dispatcher.notifyAvailable(this); &#125; &#125;reportLocation 方法12345678910111213/** * 同步块只包含对共享状态的操作代码 */ public synchronized void reportLocation() &#123; System.out.println(Thread.currentThread().getName() + \" report location.\"); Set&lt;Taxi&gt; taxisCopy; synchronized (this) &#123; taxisCopy = new HashSet&lt;Taxi&gt;(taxis); &#125; for (Taxi t : taxisCopy) &#123; t.getLocation(); &#125; &#125;死锁问题排查​ 拿动态顺序型死锁举例，其他的都一样12345678public static void main(String[] args) &#123; ExecutorService executorService = Executors.newFixedThreadPool(10); Account A = new Account(\"A\", 100); Account B = new Account(\"B\", 200); executorService.execute(() -&gt; transfer(A, B, 5)); executorService.execute(() -&gt; transfer(B, A, 10)); executorService.shutdown(); &#125;死锁的现象系统越来越卡，没有任何报错信息，随机性比较高排查死锁使用 jps + jstack在 window或linux中使用jps + jstack命令找到可能发生死锁的类对应的PID我们对应的类是TransferMoneyDeadlock PID是 13964使用jstack -l PID执行 jstack -l 13964 命令我们观察BLOCKED 就表示阻塞状态pool-1-thread-2 等待锁 &lt;0x00000000d673baa8&gt;并且已经获取了锁 &lt;0x00000000d673baf0&gt;pool-1-thread-1 等待锁 &lt;0x00000000d673baf0&gt; 并且已经获取了锁&lt;0x00000000d673baa8&gt;我们发现他们互相持有各自的锁，并且想获取对方的锁，这就是明显的死锁。使用jconsole使用命令打开jconsole打开jconsole界面工具选择我们需要检测的类选择检查死锁点击检查死锁","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"死锁","slug":"并发/死锁","permalink":"http://www.baiyp.ren/categories/并发/死锁/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"并发安全","slug":"并发安全","permalink":"http://www.baiyp.ren/tags/并发安全/"},{"name":"死锁","slug":"死锁","permalink":"http://www.baiyp.ren/tags/死锁/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"死锁","slug":"并发/死锁","permalink":"http://www.baiyp.ren/categories/并发/死锁/"}]},{"title":"JAVA中的活锁","slug":"JAVA中的活锁","date":"2019-08-22T09:33:17.000Z","updated":"2019-09-05T09:20:43.072Z","comments":true,"path":"JAVA中的活锁.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的活锁.html","excerpt":"","text":"JAVA中的活锁什么是活锁​ 两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。​ 百度定义：活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。造成死锁的原因​ 当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁。活锁的解决​ 每个线程休眠随机数，错开拿锁的时间。活锁重现还拿我们死锁中转账的业务，也可以使用显示锁来解决123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108/** * 活锁 * 转账业务 */public class TransferMoneyDeadlock &#123; public static void transfer(Account from, Account to, int amount) &#123; //自旋 一直尝试到转账成功 while (true) &#123; //先锁住转账的账户 if (from.tryLock()) &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + from.name + \"】账户锁成功\"); //休眠增加死锁产生的概率 sleep(100); try &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】获取【\" + to.name + \"】账户锁成功\"); if (from.balance &lt; amount) &#123; System.out.println(\"余额不足\"); //退出 return; &#125; else &#123; if (to.tryLock()) &#123; //休眠增加死锁产生的概率 sleep(100); try &#123; from.debit(amount); to.credit(amount); System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】从【\" + from.name + \"】账户转账到【\" + to.name + \"】账户【\" + amount + \"】元钱成功\"); //转账成功退出自旋 return; &#125; finally &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】释放TO锁【\" + to.name + \"】成功\"); to.unLock(); &#125; &#125; &#125; &#125; finally &#123; System.out.println(\"线程【\" + Thread.currentThread().getId() + \"】释放FROM锁【\" + from.name + \"】锁成功\"); from.unLock(); &#125; &#125; //休眠随机数字，避开同时同时拿锁释放锁 // sleep(new Random().nextInt(10)); &#125; &#125; private static class Account &#123; //显示锁 private Lock lock = new ReentrantLock(); String name; int balance; public Account(String name, int balance) &#123; this.name = name; this.balance = balance; &#125; void debit(int amount) &#123; this.balance = balance - amount; &#125; void credit(int amount) &#123; this.balance = balance + amount; &#125; //尝试获取锁 boolean tryLock() &#123; return lock.tryLock(); &#125; //尝试释放锁 void unLock() &#123; lock.unlock(); &#125; &#125; /** * 休眠 * * @param time */ private static void sleep(long time) &#123; try &#123; Thread.sleep(time); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; //创建线程池 ExecutorService executorService = Executors.newFixedThreadPool(10); //创建账户A Account A = new Account(\"A\", 100); //创建账户B Account B = new Account(\"B\", 200); //A -&gt; B 的转账 executorService.execute(() -&gt; transfer(A, B, 5)); //B -&gt; A 的转账 executorService.execute(() -&gt; transfer(B, A, 10)); executorService.shutdown(); &#125;&#125;输出123456789线程【13】获取【A】账户锁成功线程【13】释放FROM锁【B】锁成功线程【13】获取【B】账户锁成功线程【12】获取【B】账户锁成功线程【12】释放FROM锁【A】锁成功线程【12】获取【A】账户锁成功线程【13】获取【A】账户锁成功线程【13】释放FROM锁【B】锁成功....我们发现 转账没有成功一直在尝试拿锁释放锁，没有做具体的事情，但是也没有阻塞，这就是活锁避开活锁很简单休眠一个随机数字,把这行代码解开即可12//休眠随机数字，避开同时同时拿锁释放锁 sleep(new Random().nextInt(10));12345678910111213线程【12】获取【A】账户锁成功线程【13】获取【B】账户锁成功线程【13】获取【A】账户锁成功线程【13】释放FROM锁【B】锁成功线程【12】获取【B】账户锁成功线程【12】从【A】账户转账到【B】账户【5】元钱成功线程【12】释放TO锁【B】成功线程【12】释放FROM锁【A】锁成功线程【13】获取【B】账户锁成功线程【13】获取【A】账户锁成功线程【13】从【B】账户转账到【A】账户【10】元钱成功线程【13】释放TO锁【A】成功线程【13】释放FROM锁【B】锁成功虽然还有部分尝试拿锁，因为我们休眠了100ms ，但是我们的代码是成功的。总结​ 在开发中应该想办法避免死锁，可以尝试使用显示锁，但是显示锁要小心活锁的产生，一直在尝试拿锁释放锁，不做任何事情。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"并发安全","slug":"并发/并发安全","permalink":"http://www.baiyp.ren/categories/并发/并发安全/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"并发安全","slug":"并发安全","permalink":"http://www.baiyp.ren/tags/并发安全/"},{"name":"活锁","slug":"活锁","permalink":"http://www.baiyp.ren/tags/活锁/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"并发安全","slug":"并发/并发安全","permalink":"http://www.baiyp.ren/categories/并发/并发安全/"}]},{"title":"JAVA线程池实现02-提交任务","slug":"JAVA线程池实现02","date":"2019-08-21T02:55:59.000Z","updated":"2019-09-07T09:07:49.670Z","comments":true,"path":"JAVA线程池实现02.html","link":"","permalink":"http://www.baiyp.ren/JAVA线程池实现02.html","excerpt":"","text":"JAVA线程池实现02-提交任务submit提交任务12345678910111213141516171819202122232425/** * 提交一个带有返回值的任务 * @param task 任务 * @param result 结果 * @param &lt;T&gt; 泛型 * @return Future */public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); //调用execute进行执行 execute(ftask); return ftask;&#125;/** * 创建一个FutureTask * @param runnable 运行的任务 * @param value 返回结果 * @param &lt;T&gt; 泛型 * @return FutureTask */protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);&#125;流程步骤如下调用submit方法，传入Runnable或者Callable对象判断传入的对象是否为null，为null则抛出异常，不为null继续流程将传入的对象转换为RunnableFuture对象执行execute方法，传入RunnableFuture对象返回RunnableFuture对象execute 执行线程1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * 在未来执行任务 * 任务将新建或者现有的线程池中执行 * 如果线程池关闭或者线程池满了将执行拒绝策略 * @param command */ public void execute(Runnable command) &#123; if (command == null) throw new NullPointerException(); int c = ctl.get(); /** * 1、运行线程数少于核心线程数，则调用addWorker启动一个新的线程 * 需要检查否应该添加线程 */ if (workerCountOf(c) &lt; corePoolSize) &#123; //添加线程 if (addWorker(command, true)) &#123; return; &#125; c = ctl.get(); &#125; /** * 运行线程数量大于核心线程数量时，上面的if分支针对大于corePoolSize，并且缓存队列加入任务操作成功的情况。 * 运行中并且将任务加入缓冲队列成功，正常来说这样已经完成了处理逻辑。 * 但是为了保险起见，增加了状态出现异常的确认判断，如果状态出现异常会继续remove操作，如果执行true，则按照拒绝处理策略驳回任务； */ //线程运行状态，并且添加进队列成功 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; int recheck = ctl.get(); //线程未运行并且删除成功 if (! isRunning(recheck) &amp;&amp; remove(command)) //拒绝任务 reject(command); //线程正在运行中 else if (workerCountOf(recheck) == 0) //添加任务 addWorker(null, false); &#125; /** * 这里针对运行线程数量超过了corePoolSize，并且缓存队列也已经放满的情况。 * 注意第二个参数是false，可以在下面addWorker方法看到，就是针对线程池最大线程数量maximumPoolSize的判断。 */ else if (!addWorker(command, false)) //拒绝任务 reject(command); &#125;其实从上面代码注释中可以看出就三个判断，核心线程数是否已满队列是否已满线程池是否已满调用execute方法，传入Runable对象判断传入的对象是否为null，为null则抛出异常，不为null继续流程获取当前线程池的状态和线程个数变量判断当前线程数是否小于核心线程数，是走流程5，否则走流程6添加线程数，添加成功则结束，失败则重新获取当前线程池的状态和线程个数变量,判断线程池是否处于RUNNING状态，是则添加任务到阻塞队列，否则走流程10，添加任务成功则继续流程7重新获取当前线程池的状态和线程个数变量重新检查线程池状态，不是运行状态则移除之前添加的任务，有一个false走流程9，都为true则走流程11检查线程池线程数量是否为0，否则结束流程，是调用addWorker(null, false)，然后结束调用!addWorker(command, false)，为true走流程11，false则结束调用拒绝策略reject(command)，结束addWorker 增加工作线程123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105/** * 添加工作线程 * @param firstTask 任务 * @param core 是否是核心线程 * @return */private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: //自旋 for (;;) &#123; int c = ctl.get(); //获取运行状态 int rs = runStateOf(c); // 检查当前线程池状态是否是SHUTDOWN、STOP、TIDYING或者TERMINATED // 且！（当前状态为SHUTDOWN、且传入的任务为null，且队列不为null） // 条件都成立则返回false if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) &#123; return false; &#125; //有一个自旋 for (;;) &#123; //获取工作线程数 int wc = workerCountOf(c); /** * 工作线程数 &gt;= 队列容量 返回fasle * 如果是核心线程 工作线程数&gt;=核心线程数 返回false * 如果不是核心线程 工作线程数&gt;=最大线程数 返回false */ if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123; return false; &#125; //CAS增加c，成功则跳出retry if (compareAndIncrementWorkerCount(c)) &#123; break retry; &#125; c = ctl.get(); // Re-read ctl //CAS失败执行下面方法，查看当前线程数是否变化，变化则继续retry循环，没变化则继续内部循环 if (runStateOf(c) != rs) &#123; continue retry; &#125; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; //CAS成功 //工作线程状态 boolean workerStarted = false; //工作线程添加状态 boolean workerAdded = false; Worker w = null; try &#123; //创建一个工作线程 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; //获取重入锁 final ReentrantLock mainLock = this.mainLock; //加锁 mainLock.lock(); try &#123; //重新检查线程池状态 //避免ThreadFactory退出故障或者在锁获取前线程池被关闭 int rs = runStateOf(ctl.get()); //再次检查线程池状态 ？？？ if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; //检查thread的状态 if (t.isAlive()) &#123; // precheck that t is startable throw new IllegalThreadStateException(); &#125; //任务列表添加任务 workers.add(w); //获取任务列表大小 int s = workers.size(); //最大线程数 计数 if (s &gt; largestPoolSize) &#123; largestPoolSize = s; &#125; //线程添加成功 workerAdded = true; &#125; &#125; finally &#123; //解锁 mainLock.unlock(); &#125; //判断worker是否添加成功，成功则启动线程，然后将workerStarted设置为true if (workerAdded) &#123; t.start(); //启动状态成功 workerStarted = true; &#125; &#125; &#125; finally &#123; //判断线程有没有启动成功，没有则调用addWorkerFailed方法 if (! workerStarted) &#123; addWorkerFailed(w); &#125; &#125; //返回任务启动状态 return workerStarted;&#125;这里可以将addWorker分为两部分，第一部分增加线程池个数，第二部分是将任务添加到workder里面并执行。第一部分主要是两个循环，外层循环主要是判断线程池状态1234rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())展开！运算后等价于1234s &gt;= SHUTDOWN &amp;&amp; (rs != SHUTDOWN || firstTask != null || workQueue.isEmpty())也就是说下面几种情况下会返回false：当前线程池状态为STOP，TIDYING，TERMINATED当前线程池状态为SHUTDOWN并且已经有了第一个任务当前线程池状态为SHUTDOWN并且任务队列为空内层循环作用是使用cas增加线程个数，如果线程个数超限则返回false，否者进行cas，cas成功则退出双循环，否者cas失败了，要看当前线程池的状态是否变化了，如果变了，则重新进入外层循环重新获取线程池状态，否者进入内层循环继续进行cas尝试。到了第二部分说明CAS成功了，也就是说线程个数加一了，但是现在任务还没开始执行，这里使用全局的独占锁来控制workers里面添加任务，其实也可以使用并发安全的set，但是性能没有独占锁好（这个从注释中知道的）。这里需要注意的是要在获取锁后重新检查线程池的状态，这是因为其他线程可可能在本方法获取锁前改变了线程池的状态，比如调用了shutdown方法。添加成功则启动任务执行。所以这里也将流程图分为两部分来描述第一部分流程图第二部分流程图这里面有一个核心的工作类 WorkerAQS的Worker工作任务这个类继承了抽象队列同步器 是标准的AQS线程安全的类。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131/** * 工作任务对象 * 继承了AQS 抽象队列同步器 以及 Runnable 接口 */ private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** * Thread this worker is running in. Null if factory fails. */ //正在运行的线程，工厂创建线程失败则为null final Thread thread; /** * Initial task to run. Possibly null. */ //运行的初始任务，可能为null Runnable firstTask; /** * Per-thread task counter */ //完成任务的计数器 volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * * @param firstTask the first task (null if none) */ //构造方法 Worker(Runnable firstTask) &#123; //设置状态为未运行 setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; //使用线程工厂创建线程 this.thread = getThreadFactory().newThread(this); &#125; /** * Delegates main run loop to outer runWorker */ //实现Runnable的run方法 @Override public void run() &#123; //运行任务方法 runWorker(this); &#125; // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. /*是否是独占的 * @return 0 未锁 1 已锁定 */ protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; /** * 尝试获取占用权 * @param unused * @return */ protected boolean tryAcquire(int unused) &#123; //CAS 设置锁定状态 if (compareAndSetState(0, 1)) &#123; //设置持有者是当前线程 setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; /** * 尝试释放锁 * @param unused * @return */ protected boolean tryRelease(int unused) &#123; //设置是持有者为null setExclusiveOwnerThread(null); //设置锁定状态为 未锁定 setState(0); return true; &#125; /** * 加锁 */ public void lock() &#123; acquire(1); &#125; /** * 尝试获取锁 * @return */ public boolean tryLock() &#123; return tryAcquire(1); &#125; //释放锁 public void unlock() &#123; release(1); &#125; /** * 释放 * @return */ public boolean isLocked() &#123; return isHeldExclusively(); &#125; /** * 中断启动 */ void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125;这个类很值得学习，里面最核心的方法是 runWorker 方法runWorker方法运行任务的主体，通过循环从阻塞队列中拿任务，进行执行12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061/** * 运行任务 * @param w 任务 */final void runWorker(Worker w) &#123; //获取当前线程 Thread wt = Thread.currentThread(); //获取任务 task Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts //是否突然完成任务(异常，或者其他情况) boolean completedAbruptly = true; try &#123; //循环获取任务 while (task != null || (task = getTask()) != null) &#123; //加锁 w.lock(); // 当线程池是处于STOP状态或者TIDYING、TERMINATED状态时，设置当前线程处于中断状态 // 如果不是，当前线程就处于RUNNING或者SHUTDOWN状态，确保当前线程不处于中断状态 // 重新检查当前线程池的状态是否大于等于STOP状态 if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) &#123; wt.interrupt(); &#125; try &#123; //线程执行前执行一些任务，在ThreadPoolExecutor是空实现 beforeExecute(wt, task); Throwable thrown = null; try &#123; //运行任务 task.run(); &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; //完成任务后执行一些任务，在ThreadPoolExecutor是空实现 afterExecute(task, thrown); &#125; &#125; finally &#123; //完成任务task置为空，交给GC处理 task = null; //完成任务计数器+1 w.completedTasks++; //解锁 w.unlock(); &#125; &#125; /** * 正常完成任务为false * 否则completedAbruptly 为true */ completedAbruptly = false; &#125; finally &#123; //整个线程结束时调用，线程退出操作。统计整个线程池完成的任务个数之类的工作 processWorkerExit(w, completedAbruptly); &#125;&#125;这里面有两个核心方法getTask：从队列中获取任务processWorkerExit：处任务并退出我们先从getTask开始getTask 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354 /** * 获取待执行的任务 * * @return */private Runnable getTask() &#123; //最后一次poll()是否超时 boolean timedOut = false; //自旋 for (; ; ) &#123; int c = ctl.get(); //获取运行状态 int rs = runStateOf(c); //线程不在运行状态并且队列为空 if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; //使用CAS进行工作任务数-1 decrementWorkerCount(); return null; &#125; //获取当前工作任务数 int wc = workerCountOf(c); /** * 是否进行任务淘汰 如果 allowCoreThreadTimeOut为true 就一直淘汰下去 */ boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; //（当前线程数是否大于最大线程数或者） //且（线程数大于1或者任务队列为空） //这里有个问题(timed &amp;&amp; timedOut)timedOut = false，好像(timed &amp;&amp; timedOut)一直都是false吧 if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; //CAS方式进行工作线程-1 if (compareAndDecrementWorkerCount(c)) &#123; return null; &#125; continue; &#125; try &#123; /** * 如果需要淘汰淘汰从工作先队列中在指定keepAliveTime时间内获取一个工作线程否则返回null * 否则工作线程池为空就一直等待 */ Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) &#123; return r; &#125; //如果获取超时设置超时时间为true timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125;接下来我们分析下processWorkerExit方法processWorkerExit 方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 处理完成后续的线程统计工作 * 删除完成工作的线程 * @param w 工作线程 * @param completedAbruptly 是否突然完成（异常情况） */ private void processWorkerExit(Worker w, boolean completedAbruptly) &#123; //如果突然完成，工作线程数统计未统计 if (completedAbruptly) &#123; // If abrupt, then workerCount wasn't adjusted //重新对工作线程数-1 decrementWorkerCount(); &#125; //获取锁 final ReentrantLock mainLock = this.mainLock; //加锁 mainLock.lock(); try &#123; //完成任务数统计 completedTaskCount += w.completedTasks; //从工作任务队列删除队列 workers.remove(w); &#125; finally &#123; //解锁 mainLock.unlock(); &#125; //尝试终止线程池 tryTerminate(); int c = ctl.get(); //正在运行或者停止 if (runStateLessThan(c, STOP)) &#123; //没有突然完成 if (!completedAbruptly) &#123; // 计算最小工作线程，如果allowCoreThreadTimeOut为true 就是 0 否则就是核心线程数 int min = allowCoreThreadTimeOut ? 0 : corePoolSize; //如果最小线程为0并且工作任务队列不为空则设置最小线程数为1 if (min == 0 &amp;&amp; !workQueue.isEmpty()) &#123; min = 1; &#125; //如果工作线程数&gt;=最小线程数返回 if (workerCountOf(c) &gt;= min) return; // replacement not needed &#125; addWorker(null, false); &#125; &#125;到这里为止,submit 和 execute已经分析完成了。","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"线程池","slug":"源码/线程池","permalink":"http://www.baiyp.ren/categories/源码/线程池/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"线程池","slug":"线程池","permalink":"http://www.baiyp.ren/tags/线程池/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://www.baiyp.ren/tags/ThreadPoolExecutor/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"线程池","slug":"源码/线程池","permalink":"http://www.baiyp.ren/categories/源码/线程池/"}]},{"title":"JAVA设计模式03-观察者模式","slug":"JAVA设计模式03","date":"2019-08-21T01:42:30.000Z","updated":"2019-09-05T10:28:29.078Z","comments":true,"path":"JAVA设计模式03.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式03.html","excerpt":"","text":"JAVA设计模式-观察者模式（Observer Pattern）什么是观察者模式​ 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。​ 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。观察者角色抽象被观察者角色：定义了动态增加、删除以及通知观察者对象的方法，职责就是管理和通知观察者。持有观察者对象的集合。具体被观察者角色：一般继承抽象被观察者，实现自己本身的业务逻辑，当状态发生改变时发起通知。抽象观察者角色：提供一个接口，定义了观察者收到通知时更新自己的方法。具体观察者角色：实现抽象观察者接口，处理不同具体观察者的不同业务逻辑。优缺点优点观察者和被观察者是抽象耦合的。建立一套触发机制。对象之间的保持高度的协作。当被观察者发生变化时，所有被观察者都会通知到，然后做出相应的动作。缺点如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。如果观察者太多，被观察者通知观察者消耗的时间很多，影响系统的性能。当观察者集合中的某一观察者错误时就会导致系统卡壳，因此一般会采用异步方式。适用场景一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。一个对象必须通知其他对象，而并不知道这些对象是谁。需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。实现灰太狼具有被观察者属性，喜洋洋这些羊咩咩一直都在观察者灰太狼，所以羊咩咩们是观察者。OK，角色确定了，看看具体是怎么实现的…抽象被观察者12345678910111213141516171819202122232425262728293031323334353637public abstract class Subject &#123; /** * 观察者对象的集合 */ private List&lt;Observer&gt; observerList = new ArrayList&lt;&gt;(); /** * 登记观察者 * * @param observer */ public void attach(Observer observer) &#123; observerList.add(observer); System.out.println(\"增加了观察者：\" + observer.getName()); &#125; /** * 删除观察者 * * @param observer */ public void dettach(Observer observer) &#123; observerList.remove(observer); System.out.println(\"删除了观察者：\" + observer.getName()); &#125; /** * 通知所有观察者 */ public void notifyObserver() &#123; for (Observer observer : observerList) &#123; observer.update(\"灰太狼要搞事情了\"); &#125; &#125;&#125;创建被观察者对象灰太狼是具体被观察者，继承抽象被观察者12345678public class Wolf extends Subject &#123; public void invade()&#123; System.out.println(\"灰太狼：我要搞事情了\"); // 通知所有观察者 notifyObserver(); &#125;&#125;抽象观察者123456789101112public interface Observer &#123; String getName(); /** * 通知更新方法 * * @param msg */ public void update(String msg);&#125;创建观察者对象喜羊羊是具体观察者12345678910111213141516public class PleasantSheep implements Observer&#123; @Override public String getName() &#123; return \"喜羊羊\"; &#125; /** * 具体业务逻辑 */ @Override public void update(String msg) &#123; System.out.println(\"喜羊羊收到通知：\" + msg); &#125;&#125;测试接下来看客户端如何把观察者模式跑起来1234567891011121314public class Client &#123; public static void main(String[] args) &#123; // 灰太狼--被观察者 Wolf wolf = new Wolf(); // 喜羊羊--观察者 Observer pleasantSheep = new PleasantSheep(); // 登记观察者 wolf.attach(pleasantSheep); // 灰太狼入侵 wolf.invade(); &#125;&#125;输出12345增加了观察者：喜羊羊灰太狼：我要搞事情了喜羊羊收到通知：灰太狼要搞事情了总结在Java中已经提供了Observable类以及一个Observer接口，也就是说Java已经实现了观察者模式的定义","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"观察者模式","slug":"设计模式/观察者模式","permalink":"http://www.baiyp.ren/categories/设计模式/观察者模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"观察者模式","slug":"观察者模式","permalink":"http://www.baiyp.ren/tags/观察者模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"观察者模式","slug":"设计模式/观察者模式","permalink":"http://www.baiyp.ren/categories/设计模式/观察者模式/"}]},{"title":"JAVA线程池实现01-简介","slug":"JAVA线程池实现01","date":"2019-08-20T06:55:59.000Z","updated":"2019-09-07T09:07:49.668Z","comments":true,"path":"JAVA线程池实现01.html","link":"","permalink":"http://www.baiyp.ren/JAVA线程池实现01.html","excerpt":"","text":"JAVA线程池实现01-简介什么是线程池​ 线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件），则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。为什么使用线程池操作系统创建线程、切换线程状态、终结线程都要进行CPU调度——这是一个耗费时间和系统资源的事情。​ 大多数实际场景中是这样的：处理某一次请求的时间是非常短暂的，但是请求数量是巨大的。这种技术背景下，如果我们为每一个请求都单独创建一个线程，那么物理机的所有资源基本上都被操作系统创建线程、切换线程状态、销毁线程这些操作所占用，用于业务请求处理的资源反而减少了。所以最理想的处理方式是，将处理请求的线程数量控制在一个范围，既保证后续的请求不会等待太长时间，又保证物理机将足够的资源用于请求处理本身。另外，一些操作系统是有最大线程数量限制的。当运行的线程数量逼近这个值的时候，操作系统会变得不稳定。这也是我们要限制线程数量的原因。线程池的优点降低资源消耗：通过重复利用已创建的线程降低线程创建和销毁带来的消耗。提高响应速度：当任务到达时，任务可以不需要等待线程创建就能立即执行。提高线程的可管理性：使用线程池可以统一进行线程分配、调度和监控。线程统一管理：线程池具有创建线程和销毁线程的能力，线程集中在一起比起分散开来，更加便于管理### 继承关系线程池都继承自Exceutor接口Executor接口Executor接口只有一个方法execute,传入线程任务参数123public interface Executor &#123; void execute(Runnable command);&#125;ExecutorService接口ExecutorService接口继承Executor接口，并增加了submit、shutdown、invokeAll等等一系列方法。1234567891011121314151617181920212223242526272829303132333435public interface ExecutorService extends Executor &#123; void shutdown(); List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125;AbstractExecutorService抽象类bstractExecutorService抽象类实现ExecutorService接口，并且提供了一些方法的默认实现，例如submit方法、invokeAny方法、invokeAll方法。像execute方法、线程池的关闭方法（shutdown、shutdownNow等等）就没有提供默认的实现。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class AbstractExecutorService implements ExecutorService &#123; protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value); &#125; protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable); &#125; public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask; &#125; public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask; &#125; public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask; &#125; private &lt;T&gt; T doInvokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, boolean timed, long nanos) throws InterruptedException, ExecutionException, TimeoutException &#123;...&#125; public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException &#123;... &#125; public &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException &#123;...&#125; public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException &#123;...&#125; public &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException &#123;...&#125;&#125;线程池的分类和作用newCachedThreadPool创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟）当线程池中，没有可用线程，会重新创建一个线程newFixedThreadPool创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。线程池中的线程处于一定的量，可以很好的控制线程的并发量线程可以重复被使用，在显示关闭之前，都将一直存在超出一定量的线程被提交时候需在队列中等待newSingleThreadExecutor创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行newScheduleThreadPool创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。线程池中具有指定数量的线程，即便是空线程也将保留可定时或者延迟执行线程活动newSingleThreadScheduledExecutor创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行可定时或者延迟执行线程活动ThreadPoolExecutor源码分析为什么要讲ThreadPoolExector类​ Exector是ThreadPoolExector的祖父类接口，ThreadPoolExector的直接父类接口是ExectorService，而我们所讲的第三点，其中的不同线程池的分类其实都是Exector中的方法，而在ThreadPoollExector中得到了实现，所以我们要构建的不同种类的线程池主要还是依赖这个类完成，接下来我们就聚焦ThreadPoolExector来看其具体的实现方法。线程池的执行流程成员变量分析123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 //记录线程池状态和线程数量（总共32位，前三位表示线程池状态，后29位表示线程数量） private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));//线程数量统计位数29 Integer.SIZE=32 private static final int COUNT_BITS = Integer.SIZE - 3;//容量 000 11111111111111111111111111111 private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1; //运行中 111 00000000000000000000000000000 private static final int RUNNING = -1 &lt;&lt; COUNT_BITS; //关闭 000 00000000000000000000000000000 private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //停止 001 00000000000000000000000000000 private static final int STOP = 1 &lt;&lt; COUNT_BITS; //整理 010 00000000000000000000000000000 private static final int TIDYING = 2 &lt;&lt; COUNT_BITS; //终止 011 00000000000000000000000000000 private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS; //获取运行状态（获取前3位） private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125; //获取线程个数（获取后29位） private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125; private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; // 存放任务的阻塞队列泛型是Runnable private final BlockingQueue&lt;Runnable&gt; workQueue; //可重入锁 private final ReentrantLock mainLock = new ReentrantLock(); //获取锁的一个条件 private final Condition termination = mainLock.newCondition(); //存放任务Worker 的集合 private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;(); //线程池正在运行的数量 private int largestPoolSize; //已完成任务的计数器 private long completedTaskCount; //线程工厂，可以手工传入 自己构建线程 private volatile ThreadFactory threadFactory; //拒接策略 private volatile RejectedExecutionHandler handler; //默认拒绝策略为AbortPolicy private static final RejectedExecutionHandler defaultHandler = new ThreadPoolExecutor.AbortPolicy(); //空闲线程等待超时时间 private volatile long keepAliveTime; /** * 是否允许核心线程超时 * 默认为 false * true 核心线程等待超时后 也将会销毁 */ private volatile boolean allowCoreThreadTimeOut; /** * 核心池大小 不允许超时 * 除非allowCoreThreadTimeOut为true 这种情况下可为0 */ private volatile int corePoolSize; //最大线程池大小 最大不超过 CAPACITY private volatile int maximumPoolSize;我们也可以看出我们在线程池介绍中谈到的关于coreSize和maxiumSize等参数，这些int值对线程池的中的线程池数量进行了限制，还有一些关于锁ReentrantLock的类，这是一个可重入锁，它的主要目的是锁住其操作，因为线程的操作要保证其原子性，防止冲突发生，所以在其源码中很多都对其进行了上锁操作。还有一个很重要的值的全局的变量state:线城池的状态12345678910//表示正在运行中 private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;//表示关闭 private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//表示停止 private static final int STOP = 1 &lt;&lt; COUNT_BITS;//表示整理 private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//表示结束 private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;这些状态值是线程池目前所处环境的状态的体现，它采用int数字来表现，记住这些值很重要，因为后面有很多方法调用线程池的运行状态，有很多对其值进行判断。构造方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596/** * 创建线程池 * @param corePoolSize 核心线程池大小 * @param maximumPoolSize 最大线程池大小 * @param keepAliveTime 空闲等待时间 * @param unit 时间单位 * @param workQueue 传入的阻塞队列 */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue) &#123; //调用重载的构造方法 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); &#125; /** * 创建线程池 * @param corePoolSize 核心线程池大小 * @param maximumPoolSize 最大线程池大小 * @param keepAliveTime 空闲等待时间 * @param unit 时间单位 * @param workQueue 传入的阻塞队列 * @param threadFactory 线程工厂 */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory) &#123; ///调用重载的构造方法 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler); &#125; /** * 创建线程池 * @param corePoolSize 核心线程池大小 * @param maximumPoolSize 最大线程池大小 * @param keepAliveTime 空闲等待时间 * @param unit 时间单位 * @param workQueue 传入的阻塞队列 * @param handler 拒绝策略 */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, RejectedExecutionHandler handler) &#123; ///调用重载的构造方法 this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), handler); &#125; /** * 创建线程池 * @param corePoolSize 核心线程池大小 * @param maximumPoolSize 最大线程池大小 * @param keepAliveTime 空闲等待时间 * @param unit 时间单位 * @param workQueue 传入的阻塞队列 * @param threadFactory 线程工厂 * @param handler 拒绝策略 */ public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; //条件校验，不满足抛出异常 if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); // 阻塞队列，线程工厂，拒绝策略不允许为空 if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); //java安全模式 this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125;可以看出ThreadPoolExector一共有四个构造函数，但是最后调用的都是最后一个，我们可以只看最后一个，它主要有核心池大小、最大池大小、存活时间、时间单位、阻塞队列、线程工厂这几个参数，其中又对其进行了值范围的检查，如果参数违法就抛出异常，然后构造进去。关于这几个参数，随着后面我们对其方法的讲解，会理解越来越深刻的。","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"线程池","slug":"源码/线程池","permalink":"http://www.baiyp.ren/categories/源码/线程池/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"线程池","slug":"线程池","permalink":"http://www.baiyp.ren/tags/线程池/"},{"name":"ThreadPoolExecutor","slug":"ThreadPoolExecutor","permalink":"http://www.baiyp.ren/tags/ThreadPoolExecutor/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"线程池","slug":"源码/线程池","permalink":"http://www.baiyp.ren/categories/源码/线程池/"}]},{"title":"布隆过滤器","slug":"布隆过滤器","date":"2019-08-20T06:23:36.000Z","updated":"2019-09-07T09:07:49.678Z","comments":true,"path":"布隆过滤器.html","link":"","permalink":"http://www.baiyp.ren/布隆过滤器.html","excerpt":"","text":"布隆过滤器什么是布隆过滤器布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。​ 布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。​ 当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。打个比方，当它说不认识你时，肯定就不认识；当它说见过你时，可能根本就没见过面，不过因为你的脸跟它认识的人中某脸比较相似 (某些熟脸的系数组合)，所以误判以前见过你。套在上面的使用场景中，布隆过滤器能准确过滤掉那些已经看过的内容，那些没有看过的新内容，它也会过滤掉极小一部分 (误判)，但是绝大多数新内容它都能准确识别。这样就可以完全保证推荐给用户的内容都是无重复的。布隆过滤器的原理​ 其本质就是一个只包含0和1的数组。具体操作当一个元素被加入到集合里面后，该元素通过K个Hash函数运算得到K个hash后的值，然后将K个值映射到这个位数组对应的位置，把对应位置的值设置为1。查询是否存在时，我们就看对应的映射点位置如果全是1，他就很可能存在（跟hash函数的个数和hash函数的设计有关），如果有一个位置是0，那这个元素就一定不存在。首先需要初始化一个二进制的数组，长度设为 L，同时初始值全为 0 。当写入一个 A1=1000 的数据时，需要进行 H 次 hash 函数的运算（这里为 2 次）；与 HashMap 有点类似，通过算出的 HashCode 与 L 取模后定位到 0、2 处，将该处的值设为 1。A2=2000 也是同理计算后将 4、7 位置设为 1。当有一个 B1=1000 需要判断是否存在时，也是做两次 Hash 运算，定位到 0、2 处，此时他们的值都为 1 ，所以认为 B1=1000 存在于集合中。当有一个 B2=3000 时，也是同理。第一次 Hash 定位到 index=4 时，数组中的值为 1，所以再进行第二次 Hash 运算，结果定位到 index=5 的值为 0，所以认为 B2=3000 不存在于集合中。整个的写入、查询的流程就是这样，汇总起来就是：对写入的数据做 H 次 hash 运算定位到数组中的位置，同时将数据改为 1 。当有数据查询时也是同样的方式定位到数组中。一旦其中的有一位为 0 则认为数据肯定不存在于集合，否则数据可能存在于集合中。布隆过滤器的特点只要返回数据不存在，则肯定不存在。返回数据存在，但只能是大概率存在。同时不能清除其中的数据。在有限的数组长度中存放大量的数据，即便是再完美的 Hash 算法也会有冲突，所以有可能两个完全不同的 A、B 两个数据最后定位到的位置是一模一样的。删除数据也是同理，当我把 B 的数据删除时，其实也相当于是把 A 的数据删掉了，这样也会造成后续的误报。基于以上的 Hash 冲突的前提，所以 Bloom Filter 有一定的误报率，这个误报率和 Hash 算法的次数 H，以及数组长度 L 都是有关的。应用场景缓存穿透​ 我们经常会把一部分数据放在Redis等缓存，比如产品详情。这样有查询请求进来，我们可以根据产品Id直接去缓存中取数据，而不用读取数据库，这是提升性能最简单，最普遍，也是最有效的做法。一般的查询请求流程是这样的：先查缓存，有缓存的话直接返回，如果缓存中没有，再去数据库查询，然后再把数据库取出来的数据放入缓存，一切看起来很美好。但是如果现在有大量请求进来，而且都在请求一个不存在的产品Id，会发生什么？既然产品Id都不存在，那么肯定没有缓存，没有缓存，那么大量的请求都怼到数据库，数据库的压力一下子就上来了，还有可能把数据库打死。​ 使用布隆过滤器的特点，只要返回数据不存在，则肯定不存在，返回数据存在，但只能是大概率存在，这种特点可以大批量的无效请求过滤掉，能够穿透缓存的知识漏网之鱼，无关紧要。检查单词拼写​ 检查一个单词拼写是否正确，因为有海量的单词数量，每天可能有新的单词，使用布隆过滤器，可以将单词映射到很小的内存中，可以经过简单的几次hash运行就可以进行校验，只要返回数据不存在，则肯定不存在，返回数据存在，但只能是大概率存在，虽然可能有误报，但是对系统的提升是革命性的。Guava的布隆过滤器这就又要提起我们的Guava了，它是Google开源的Java包，提供了很多常用的功能。Guava中，布隆过滤器的实现主要涉及到2个类，BloomFilter和BloomFilterStrategies，首先来看一下BloomFilter的成员变量。需要注意的是不同Guava版本的BloomFilter实现不同。布隆过滤器解析成员变量分析12345678910/** guava实现的以CAS方式设置每个bit位的bit数组 */ private final LockFreeBitArray bits; /** hash函数的个数 */ private final int numHashFunctions; /** guava中将对象转换为byte的通道 */ private final Funnel&lt;? super T&gt; funnel; /** * 将byte转换为n个bit的策略，也是bloomfilter hash映射的具体实现 */ private final Strategy strategy;这是它的4个成员变量:LockFreeBitArray是定义在BloomFilterStrategies中的内部类，封装了布隆过滤器底层bit数组的操作。numHashFunctions表示哈希函数的个数。Funnel，它和PrimitiveSink配套使用，能将任意类型的对象转化成Java基本数据类型，默认用java.nio.ByteBuffer实现，最终均转化为byte数组。Strategy是定义在BloomFilter类内部的接口，代码如下，主要有2个方法，put和mightContain。12345678interface Strategy extends java.io.Serializable &#123; /** 设置元素 */ &lt;T&gt; boolean put(T object, Funnel&lt;? super T&gt; funnel, int numHashFunctions, BitArray bits); /** 判断元素是否存在*/ &lt;T&gt; boolean mightContain( T object, Funnel&lt;? super T&gt; funnel, int numHashFunctions, BitArray bits); .....&#125;创建布隆过滤器，BloomFilter并没有公有的构造函数，只有一个私有构造函数，而对外它提供了5个重载的create方法，在缺省情况下误判率设定为3%，采用BloomFilterStrategies.MURMUR128_MITZ_64的实现。BloomFilterStrategies.MURMUR128_MITZ_64是Strategy的两个实现之一，Guava以枚举的方式提供这两个实现，这也是《Effective Java》书中推荐的提供对象的方法之一。1234enum BloomFilterStrategies implements BloomFilter.Strategy &#123; MURMUR128_MITZ_32() &#123;//....&#125; MURMUR128_MITZ_64() &#123;//....&#125;&#125;​ 二者对应了32位哈希映射函数，和64位哈希映射函数，后者使用了murmur3 hash生成的所有128位，具有更大的空间，不过原理是相通的，我们选择相对简单的MURMUR128_MITZ_32来分析。先来看一下它的put方法，它用两个hash函数来模拟多个hash函数的情况，这是布隆过滤器的一种优化。put方法1234567891011121314151617181920212223public &lt;T&gt; boolean put( T object, Funnel&lt;? super T&gt; funnel, int numHashFunctions, BitArray bits) &#123; long bitSize = bits.bitSize(); // 先利用murmur3 hash对输入的funnel计算得到128位的哈希值，funnel现将object转换为byte数组， // 然后在使用哈希函数转换为long long hash64 = Hashing.murmur3_128().hashObject(object, funnel).asLong(); // 根据hash值的高低位算出hash1和hash2 int hash1 = (int) hash64; int hash2 = (int) (hash64 &gt;&gt;&gt; 32); boolean bitsChanged = false; // 循环体内采用了2个函数模拟其他函数的思想,相当于每次累加hash2 for (int i = 1; i &lt;= numHashFunctions; i++) &#123; int combinedHash = hash1 + (i * hash2); // 如果是负数就变为正数 if (combinedHash &lt; 0) &#123; combinedHash = ~combinedHash; &#125; // 通过基于bitSize取模的方式获取bit数组中的索引，然后调用set函数设置。 bitsChanged |= bits.set(combinedHash % bitSize); &#125; return bitsChanged;&#125;在put方法中，先是将索引位置上的二进制置为1，然后用bitsChanged记录插入结果，如果返回true表明没有重复插入成功，而mightContain方法则是将索引位置上的数值取出，并判断是否为0，只要其中出现一个0，那么立即判断为不存在。mightContain方法1234567891011121314151617181920public &lt;T&gt; boolean mightContain( T object, Funnel&lt;? super T&gt; funnel, int numHashFunctions, BitArray bits) &#123; long bitSize = bits.bitSize(); long hash64 = Hashing.murmur3_128().hashObject(object, funnel).asLong(); int hash1 = (int) hash64; int hash2 = (int) (hash64 &gt;&gt;&gt; 32); for (int i = 1; i &lt;= numHashFunctions; i++) &#123; int combinedHash = hash1 + (i * hash2); // Flip all the bits if it's negative (guaranteed positive number) if (combinedHash &lt; 0) &#123; combinedHash = ~combinedHash; &#125; // 和put的区别就在这里，从set转换为get，来判断是否存在 if (!bits.get(combinedHash % bitSize)) &#123; return false; &#125; &#125; return true;&#125;Guava为了提供效率，自己实现了LockFreeBitArray来提供bit数组的无锁设置和读取。我们只来看一下它的put函数。12345678910111213141516171819202122boolean set(long bitIndex) &#123; if (get(bitIndex)) &#123; return false; &#125; int longIndex = (int) (bitIndex &gt;&gt;&gt; LONG_ADDRESSABLE_BITS); long mask = 1L &lt;&lt; bitIndex; // only cares about low 6 bits of bitIndex long oldValue; long newValue; // 经典的CAS自旋重试机制 do &#123; oldValue = data.get(longIndex); newValue = oldValue | mask; if (oldValue == newValue) &#123; return false; &#125; &#125; while (!data.compareAndSet(longIndex, oldValue, newValue)); bitCount.increment(); return true;&#125;Guava布隆过滤器使用引入坐标12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;28.0-jre&lt;/version&gt;&lt;/dependency&gt;代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class GuavaBloomFilter &#123; /** * 设置布隆过滤器大小 */ private static final int size = 100000; /** * 构建一个BloomFilter * 第一个参数Funnel类型的参数 * 第二个参数 期望处理的数据量 * 第三个参数 误判率 可不加，默认 0.03D */ private static final BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), size); public static void main(String[] args) &#123; //成功计数 float success = 0; //失败计数 float fial = 0; Set&lt;String&gt; stringSet = new HashSet&lt;String&gt;(); for (int i = 0; i &lt; size; i++) &#123; //生成随机字符串 String randomStr = RandomStringUtils.randomNumeric(10); //加入到set中 stringSet.add(randomStr); //加入到布隆过滤器 bloomFilter.put(randomStr); &#125; for (int i = 0; i &lt; size; i++) &#123; //生成随机字符串 String randomStr = RandomStringUtils.randomNumeric(10); //布隆过滤器校验存在 if (bloomFilter.mightContain(randomStr)) &#123; //set中存在 if (stringSet.contains(randomStr)) &#123; //成功计数 success++; &#125; else &#123; //失败计数 fial++; &#125; //布隆过滤器校验不存在 &#125; else &#123; // set中存在 if (stringSet.contains(randomStr)) &#123; //失败计数 fial++; &#125; else &#123; //成功计数 success++; &#125; &#125; &#125; System.out.println(\"判断成功数：\"+success + \"，判断失败数:\" + fial + \"，误判率:\" + fial / 100000); &#125;输出1判断成功数：97084.0，判断失败数:2916.0，误判率:0.02916可以通过增加误判率的参数来调整误判率1234567/** * 构建一个BloomFilter * 第一个参数Funnel类型的参数 * 第二个参数 期望处理的数据量 * 第三个参数 误判率 可不加，默认 0.03D */private static final BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), size,0.00001);输出1判断成功数：100000.0，判断失败数:0.0，误判率:0.0","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"布隆过滤器","slug":"架构/布隆过滤器","permalink":"http://www.baiyp.ren/categories/架构/布隆过滤器/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"布隆过滤器","slug":"布隆过滤器","permalink":"http://www.baiyp.ren/tags/布隆过滤器/"},{"name":"BloomFilter","slug":"BloomFilter","permalink":"http://www.baiyp.ren/tags/BloomFilter/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"布隆过滤器","slug":"架构/布隆过滤器","permalink":"http://www.baiyp.ren/categories/架构/布隆过滤器/"}]},{"title":"JAVA阻塞队列实现","slug":"JAVA阻塞队列实现","date":"2019-08-19T06:55:59.000Z","updated":"2019-09-07T09:07:49.676Z","comments":true,"path":"JAVA阻塞队列实现.html","link":"","permalink":"http://www.baiyp.ren/JAVA阻塞队列实现.html","excerpt":"","text":"JAVA阻塞队列实现什么是阻塞队列​ 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。队列的特点是：先进先出（FIFO）BlockingQueue的方法阻塞队列提供了四种处理方法:方法\\处理方式抛出异常返回特殊值一直阻塞超时退出插入add(e)offer(e)put(e)offer(e, time, unit)移除remove()poll()take()poll(time, unit)检查remove()peek()不可用不可用抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。Java里的阻塞队列ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列，遵循FIFO原则。LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列，遵循FIFO原则，默认和最大长度为Integer.MAX_VALUE。PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。DelayQueue：一个使用优先级队列实现的支持延时无界阻塞队列。SynchronousQueue：一个不存储元素的阻塞队列。LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。有界：有初始化最大长度，达到最大程度继续添加要莫阻塞，要莫抛出异常无界：没有初始化最大长度，能够一直添加，不会阻塞或抛出异常，一直到OOM。因为阻塞队列实现都差不多，我们就拿ArrayBlockingQueue来看下实现ArrayBlockingQueue结构阻塞队列的实现都差不多，我们就拿ArrayBlockingQueue 来举例1234567891011121314151617 //底层数据结构 private final E[] items;//用来为下一个take/poll/remove的索引（出队） private int takeIndex;//用来为下一个put/offer/add的索引（入队） private int putIndex;//队列中元素的个数 private int count;//定义的可重入锁 final ReentrantLock lock; //非空的条件 private final Condition notEmpty; //非满的条件 private final Condition notFull;构造方法123456789101112131415161718192021222324252627282930 /** * 创造一个队列，指定队列容量，默认模式为非公平模式 * @param capacity &lt;1会抛异常 */ public ArrayBlockingQueue(int capacity) &#123; this(capacity, false); &#125;/** * ArrayBlockingQueue 的构造方法 * * @param capacity 初始化大小 默认Integer * @param fair 是否使用公平锁 */ public ArrayBlockingQueue(int capacity, boolean fair) &#123; //指定大小&lt;=0 抛出异常 if (capacity &lt;= 0) &#123; throw new IllegalArgumentException(); &#125; //初始化数组的大小 this.items = new Object[capacity]; //创建可重入锁 lock = new ReentrantLock(fair); //创建非空条件 notEmpty = lock.newCondition(); //创建非满条件 notFull = lock.newCondition(); &#125;入队offer不阻塞添加在队尾插入一个元素， 如果队列没满，立即返回true； 如果队列满了，立即返回false1234567891011121314151617181920212223242526 /** * 在队尾插入一个元素， * 如果队列没满，立即返回true； * 如果队列满了，立即返回false * 注意：该方法通常优于add(),因为add()失败直接抛异常 */public boolean offer(E e) &#123; //检查非空 checkNotNull(e); final ReentrantLock lock = this.lock; //加锁 lock.lock(); try &#123; //队列满了 if (count == items.length) &#123; return false; //队列没有满 &#125; else &#123; //入队 enqueue(e); return true; &#125; &#125; finally &#123; lock.unlock(); &#125;&#125;offer等待超时阻塞添加12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 在队尾插入一个元素,如果数组已满，则进入等待，直到出现以下三种情况： * 1、被唤醒 * 2、等待时间超时 * 3、当前线程被中断 * @param e 需要添加的元素 * @param timeout 超时时间 * @param unit 时间单位 * @return * @throws InterruptedException */public boolean offer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; //检查非空 checkNotNull(e); //计算等待时间 long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; //可中断锁加锁 lock.lockInterruptibly(); try &#123; //队列满 while (count == items.length) &#123; //如果超时返回fasle if (nanos &lt;= 0) return false; /* * 进行等待： * 在这个过程中可能发生三件事： * 1、被唤醒--&gt;继续当前这个for(;;)循环 * 2、超时--&gt;继续当前这个for(;;)循环 * 3、被中断--&gt;之后直接执行catch部分的代码 */ nanos = notFull.awaitNanos(nanos); &#125; //入队 enqueue(e); return true; &#125; finally &#123; //解锁 lock.unlock(); &#125;&#125;put阻塞添加在队尾插入一个元素，如果队列满了，一直阻塞，直到数组不满了或者线程被中断12345678910111213141516171819202122/** * 在队尾插入一个元素 * 如果队列满了，一直阻塞，直到数组不满了或者线程被中断 */public void put(E e) throws InterruptedException &#123; //检查非空 checkNotNull(e); final ReentrantLock lock = this.lock; //可中断锁-加锁 lock.lockInterruptibly(); try &#123; //队列满了 阻塞 while (count == items.length) &#123; notFull.await(); &#125; //入队 enqueue(e); &#125; finally &#123; //解锁 lock.unlock(); &#125;&#125;这里使用的lock.lockInterruptibly() ,当前线程如果调用了Thread.interrupt()方法，那么lockInterruptible()判断的Thread.interrupted()聚会成立，就会抛出异常，其实就是线程中断，该方法就抛出异常。enqueue入队操作1234567891011121314151617181920/** * 入队操作 * * @param x 需要入队的袁旭 */ private void enqueue(E x) &#123; // assert lock.getHoldCount() == 1; // assert items[putIndex] == null; final Object[] items = this.items; //putIndex 默认为队列数据的长度 items[putIndex] = x; //队列满了重置为0 从头开始 if (++putIndex == items.length) &#123; putIndex = 0; &#125; //统计数字+1 count++; //非空的条件阻塞的线程唤醒 notEmpty.signal(); &#125;队列没满items[putIndex] = data;达到数组长度重置putIndex，达到环形队列目的出队poll非阻塞出队如果没有元素，直接返回null；如果有元素，将队头元素置null，但是要注意队头是随时变化的，并非一直是items[0]。1234567891011121314/** * 出队 * @return */ public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; //队列为空返回努力了,否则出队操作 return (count == 0) ? null : dequeue(); &#125; finally &#123; lock.unlock(); &#125; &#125;poll 等待超时阻塞出队从对头删除一个元素，如果数组不空，出队；如果数组已空且已经超时，返回null；如果数组已空且时间未超时，则进入等待，直到出现以下三种情况：被唤醒等待时间超时当前线程被中断1234567891011121314151617181920212223242526272829303132333435/** * 等待超时出队 * @param timeout 超时时间 * @param unit 单位 * @return 出队的元素 * @throws InterruptedException */ public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; //计算等待时间 long nanos = unit.toNanos(timeout); final ReentrantLock lock = this.lock; //可中断锁 lock.lockInterruptibly(); try &#123; //队列为空 while (count == 0) &#123; //等待时间到了还未没有元素返回null if (nanos &lt;= 0) &#123; return null; &#125; /* * 进行等待： * 在这个过程中可能发生三件事： * 1、被唤醒--&gt;继续当前这个for(;;)循环 * 2、超时--&gt;继续当前这个for(;;)循环 * 3、被中断--&gt;之后直接执行catch部分的代码 */ nanos = notEmpty.awaitNanos(nanos); &#125; //出队 return dequeue(); &#125; finally &#123; lock.unlock(); &#125; &#125;take阻塞移除12345678910111213141516171819202122/** * 阻塞移除操作 * @return 返回移除的元素 * @throws InterruptedException */ public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; //可中断锁 lock.lockInterruptibly(); try &#123; //如果元素为空就阻塞 while (count == 0) &#123; //非空阻塞 notEmpty.await(); &#125; //出队操作 return dequeue(); &#125; finally &#123; //解锁 lock.unlock(); &#125; &#125;dequeue出队操作1234567891011121314151617181920212223242526/** * 出队操作 * @return 返回出队的元素 */private E dequeue() &#123; // assert lock.getHoldCount() == 1; // assert items[takeIndex] != null; final Object[] items = this.items; //获取第takeIndex个元素 E x = (E) items[takeIndex]; //删除元素，让GC进行回收 items[takeIndex] = null; //takeIndex+1 如果移除到最后一个元素 重置为0 从头开始 if (++takeIndex == items.length) &#123; takeIndex = 0; &#125; //统计长度-1 count--; if (itrs != null) &#123; //元素 itrs.elementDequeued(); &#125; //队列不满了唤醒非满线程 notFull.signal(); return x;&#125;使用场景延时队列 DelayQueue在我们的业务中通常会有一些需求是这样的淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。饿了吗订餐通知:下单成功后60s之后给用户发送短信通知。缓存系统，如果key到期了取出来删除那么这类业务我们可以总结出一个特点:需要延迟工作。由此的情况，就是我们的DelayQueue应用需求的产生。看一个简单的例子123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class DelayedTask implements Delayed &#123; public DelayedTask(int delayedTime, TimeUnit unit, String message) &#123; this.delayedTime = delayedTime; //计算到期时间 this.expireTime = System.currentTimeMillis() + (delayedTime &gt; 0 ? unit.toMillis(delayedTime) : 0); this.message = message; &#125; //延时时长 private int delayedTime; /** * 到期时间 */ private long expireTime; /** * 消息 */ private String message; /** * 获取队列需要演示获取水煎 * @param unit * @return */ @Override public long getDelay(TimeUnit unit) &#123; return expireTime - System.currentTimeMillis(); &#125; /** * 对比，将延时比较小的放在前面 * @param other * @return */ @Override public int compareTo(Delayed other) &#123; long d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS)); return (d == 0) ? 0 : ((d &lt; 0) ? -1 : 1); &#125; @Override public String toString() &#123; return \"出队，延时:\"+delayedTime+\",消息：\"+message; &#125; public static void main(String[] args) throws InterruptedException &#123; Random random = new Random(); ExecutorService executorService = Executors.newCachedThreadPool(); DelayQueue&lt;DelayedTask&gt; delayedTasks = new DelayQueue&lt;DelayedTask&gt;(); //生产者 executorService.submit(() -&gt; &#123; while (true) &#123; //生成随机消息 String randomStr = RandomStringUtils.randomNumeric(10); //生成随机数 int randomTime = random.nextInt(10); DelayedTask task = new DelayedTask(randomTime, TimeUnit.SECONDS, randomStr); //入队 delayedTasks.add(task); System.out.println(\"入队，消息：\" + randomStr + \"延时：\" + randomTime + \"秒\"); Thread.sleep(1000); &#125; &#125;); //消费者 executorService.submit(() -&gt; &#123; while (true) &#123; DelayedTask task = delayedTasks.take(); System.out.println(task); &#125; &#125;); //显示时间进度 executorService.submit(() -&gt; &#123; float time = 0F; while (true) &#123; System.out.println(time+\"秒\"); Thread.sleep(500); time += 0.5; &#125; &#125;); executorService.shutdown(); &#125;&#125;输出12345678910111213141516171819202122232425262728293031320.0秒入队，消息：8675326967延时：5秒0.5秒入队，消息：8861554454延时：0秒出队，延时:0,消息：88615544541.0秒1.5秒入队，消息：9123579697延时：1秒2.0秒2.5秒出队，延时:1,消息：9123579697入队，消息：5909478713延时：6秒3.0秒3.5秒入队，消息：6287328130延时：0秒出队，延时:0,消息：62873281304.0秒4.5秒出队，延时:5,消息：8675326967入队，消息：4056656965延时：7秒5.0秒5.5秒入队，消息：8250385270延时：9秒6.0秒6.5秒入队，消息：1949026689延时：1秒7.0秒7.5秒出队，延时:1,消息：1949026689入队，消息：2952840210延时：9秒8.0秒8.5秒总结ArrayBlockingQueue是有界的阻塞队列，不接受null底层数据接口是数组，下标putIndex/takeIndex，构成一个环形FIFO队列所有的增删改查数组公用了一把锁ReentrantLock，入队和出队数组下标和count变更都是靠这把锁来维护安全的。阻塞的场景：1获取lock锁，2进入和取出还要满足condition 满了或者空了都等待出队和加入唤醒，ArrayBlockingQueue我们主要是put和take真正用到的阻塞方法（条件不满足）。成员cout /putIndex、takeIndex是共享的,所以一些查询方法size、peek、toString、方法也是加上锁保证线程安全，但没有了并发损失了性能。remove(Object obj) 返回了第一个equals的Object三种入队对比offer(E e)：如果队列没满，立即返回true； 如果队列满了，立即返回false–&gt;不阻塞put(E e)：如果队列满了，一直阻塞，直到数组不满了或者线程被中断–&gt;阻塞offer(E e, long timeout, TimeUnit unit)：在队尾插入一个元素,，如果数组已满，则进入等待，直到出现以下三种情况：–&gt;阻塞被唤醒等待时间超时当前线程被中断三种出对对比poll()：如果没有元素，直接返回null；如果有元素，出队take()：如果队列空了，一直阻塞，直到数组不为空或者线程被中断–&gt;阻塞poll(long timeout, TimeUnit unit)：如果数组不空，出队；如果数组已空且已经超时，返回null；如果数组已空且时间未超时，则进入等待，直到出现以下三种情况：被唤醒等待时间超时当前线程被中断等待通知模式这里面要理解等待/通知模式阻塞队列使用了等待/通知的设计模式标准范式等待方123456789101112 //等待方public void wait() &#123; lock.lock(); try &#123; while (条件) &#123; condition.await(); &#125; //todo 业务代码 &#125; finally &#123; lock.unlock(); &#125;&#125;通知方1234public void notify() &#123; //todo 改变数据 condition.signal();&#125;等待超时模式标准范式12345678910111213141516public Integer wait(long time, TimeUnit timeUnit) &#123; //获取到期时间 long duration = timeUnit.toMillis(time); lock.lock(); try &#123; while (duration &gt; 0) &#123; duration += System.currentTimeMillis(); condition.await(time, timeUnit); duration -= System.currentTimeMillis(); &#125; //todo 业务代码 return null; &#125; finally &#123; lock.unlock(); &#125; &#125;","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"阻塞队列","slug":"源码/阻塞队列","permalink":"http://www.baiyp.ren/categories/源码/阻塞队列/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"阻塞队列","slug":"阻塞队列","permalink":"http://www.baiyp.ren/tags/阻塞队列/"},{"name":"ArrayBlockingQueue","slug":"ArrayBlockingQueue","permalink":"http://www.baiyp.ren/tags/ArrayBlockingQueue/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"阻塞队列","slug":"源码/阻塞队列","permalink":"http://www.baiyp.ren/categories/源码/阻塞队列/"}]},{"title":"JAVA中的分布式事务08-分布式事务总结","slug":"JAVA中的分布式事务08","date":"2019-08-18T02:05:25.000Z","updated":"2019-09-07T09:07:49.666Z","comments":true,"path":"JAVA中的分布式事务08.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的分布式事务08.html","excerpt":"","text":"JAVA中的分布式事务08-分布式事务总结各方案使用场景​ 介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景。2PC/3PC依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。TCC适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。本地消息表/MQ事务都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。Saga事务由于Saga事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。Saga相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga事务较适用于补偿动作容易处理的场景。分布式事务的分类刚性事务刚性事务是指再解决事务中需要锁表的操作,相对来说性能低2PC，3PC柔性事务是指再解决事务中不需要锁表的操作，因为不需要锁表，导致会发生临时不一致。TCC，本地消息表，MQ事务，Saga分布式事务方案设计​ 实际运用理论时进行架构设计时，许多人容易犯“手里有了锤子，看什么都觉得像钉子”的错误，设计方案时考虑的问题场景过多，各种重试，各种补偿机制引入系统，导致设计出来的系统过于复杂，落地遥遥无期。世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— 阿里中间件技术专家沈询​ 有些问题，看起来很重要，但实际上我们可以通过合理的设计或者将问题分解来规避。设计分布式事务系统也不是需要考虑所有异常情况，不必过度设计各种回滚，补偿机制。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。​ 如果系统要实现回滚流程的话，有可能系统复杂度将大大提升，且很容易出现Bug，估计出现Bug的概率会比需要事务回滚的概率大很多。在设计系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，可以考虑当出现这个概率很小的问题，能否采用人工解决的方式，这也是大家在解决疑难问题时需要多多思考的地方。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.baiyp.ren/tags/分布式事务/"},{"name":"总结","slug":"总结","permalink":"http://www.baiyp.ren/tags/总结/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}]},{"title":"JAVA设计模式02-工厂模式","slug":"JAVA设计模式02","date":"2019-08-18T01:42:30.000Z","updated":"2019-09-05T10:28:37.072Z","comments":true,"path":"JAVA设计模式02.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式02.html","excerpt":"","text":"JAVA设计模式-工厂模式（Factory Pattern）什么是工厂模式​ 我们在创建对象时不会对客户端直接暴露创建逻辑，而是 通过使用一个共同的接口根据不同的条件来指向具体想要创建的对象。为什么要使用工厂模式解耦 ：把对象的创建和使用的过程分开降低代码重复： 如果创建某个对象的过程都很复杂，需要一定的代码量，而且很多地方都要用到，那么就会有很多的重复代码。降低维护成本 ：由于创建过程都由工厂统一管理，所以发生业务逻辑变化，不需要找到所有需要创建某个对象的地方去逐个修正，只需要在工厂里修改即可，降低维护成本。优点使用工厂模式的优点在于一个调用者想创建一个对象，只要知道其名称（也就是不同的标签）就可以在工厂获取具体的对象扩展性强，如果想增加一个产品（也就是具体的对象），只要扩展工厂类就可以（也就是增加不同的标签，增加不同标签所对应的对象）。屏蔽产品的具体实现，调用者只关心产品的接口、无需关心内部实现。适用场景需要创建的对象较少。客户端不关心对象的创建过程。分类简单工厂（Simple Factory）模式，又称静态工厂方法模式（Static Factory Method Pattern）。工厂方法（Factory Method）模式，又称多态性工厂（Polymorphic Factory）模式或虚拟构造子（Virtual Constructor）模式；抽象工厂（Abstract Factory）模式，又称工具箱（Kit 或Toolkit）模式。简单工厂（Simple Factory）​ 专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。它又称为静态工厂方法模式。它的实质是由一个工厂类根据传入的参数，动态决定应该创建哪一个产品类（这些产品类继承自一个父类或接口）的实例。简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。在这个模式中，工厂类是整个模式的关键所在。它包含必要的判断逻辑，能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。用户在使用时可以直接根据工厂类去创建所需的实例，而无需了解这些对象是如何创建以及如何组织的。有利于整个软件体系结构的优化。角色分配工厂(Factory)角色 :简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类可以被外界直接调用，创建所需的产品对象。抽象产品(Product)角色 :简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。具体产品(Concrete Product)角色:简单工厂模式的创建目标，所有创建的对象都是充当这个角色的某个具体类的实例。优点​ 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的责任，而仅仅”消费”产品。简单工厂模式通过这种做法实现了对责任的分割。简单工厂模式能够根据外界给定的信息，决定究竟应该创建哪个具体类的对象。通过它，外界可以从直接创建具体产品对象的尴尬局面中摆脱出来。外界与具体类隔离开来，偶合性低。明确区分了各自的职责和权力，有利于整个软件体系结构的优化。缺点​ 当产品有复杂的多层等级结构时，工厂类只有自己，以不变应万变，就是模式的缺点。因为工厂类集中了所有产品创建逻辑，一旦不能正常工作，整个系统都要受到影响。系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，有可能造成工厂逻辑过于复杂,违背了”开放–封闭”原则(OCP).另外，简单工厂模式通常使用静态工厂方法，这使得无法由子类继承，造成工厂角色无法形成基于继承的等级结构。适用范围工厂类负责创建的对象比较少，客户只知道传入了工厂类的参数，对于始何创建对象（逻辑）不关心。实现创建Shape接口123public interface Shape &#123; void draw();&#125;创建实现该接口的具体图形类圆形123456789public class Circle implements Shape &#123; public Circle() &#123; System.out.println(\"Circle\"); &#125; @Override public void draw() &#123; System.out.println(\"Draw Circle\"); &#125;&#125;长方形123456789public class Rectangle implements Shape &#123; public Rectangle() &#123; System.out.println(\"Rectangle\"); &#125; @Override public void draw() &#123; System.out.println(\"Draw Rectangle\"); &#125;&#125;正方形12345678910public class Square implements Shape &#123; public Square() &#123; System.out.println(\"Square\"); &#125; @Override public void draw() &#123; System.out.println(\"Draw Square\"); &#125;&#125;创建工厂类1234567891011121314151617public class ShapeFactory &#123; // 使用 getShape 方法获取形状类型的对象 public static Shape getShape(String shapeType) &#123; if (shapeType == null) &#123; return null; &#125; if (shapeType.equalsIgnoreCase(\"CIRCLE\")) &#123; return new Circle(); &#125; else if (shapeType.equalsIgnoreCase(\"RECTANGLE\")) &#123; return new Rectangle(); &#125; else if (shapeType.equalsIgnoreCase(\"SQUARE\")) &#123; return new Square(); &#125; return null; &#125;&#125;这样的实现有个问题，如果我们新增产品类的话，就需要修改工厂类中的getShape（）方法，这很明显不符合 开放-封闭原则 。工厂方法（Factory Method）工厂方法模式应该是在工厂模式家族中是用的最多模式，一般项目中存在最多的就是这个模式。工厂方法模式是简单工厂的仅一步深化， 在工厂方法模式中，我们不再提供一个统一的工厂类来创建所有的对象，而是针对不同的对象提供不同的工厂。也就是说 每个对象都有一个与之对应的工厂 。角色分配抽象工厂(Abstract Factory)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。具体工厂(Concrete Factory)角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。抽象产品(AbstractProduct)角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。具体产品(Concrete Product)角色 ：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应适用场景一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无需关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。实现上面简单工厂例子中的图形接口以及相关图像实现类不变。我们只需要增加一个工厂接口以及实现这个接口的工厂类即可。增加一个工厂接口123public interface Factory &#123; public Shape getShape();&#125;增加相关工厂类圆形工厂类123456789public class CircleFactory implements Factory &#123; @Override public Shape getShape() &#123; // TODO Auto-generated method stub return new Circle(); &#125;&#125;长方形工厂类123456789public class RectangleFactory implements Factory&#123; @Override public Shape getShape() &#123; // TODO Auto-generated method stub return new Rectangle(); &#125;&#125;圆形工厂类123456789public class SquareFactory implements Factory&#123; @Override public Shape getShape() &#123; // TODO Auto-generated method stub return new Square(); &#125;&#125;这样每个工厂负责一种类型，再增加其他的类型只需要添加一个工厂类以及具体的图形类即可，符合了开放-封闭原则抽象工厂（Abstract Factory）在工厂方法模式中，其实我们有一个潜在意识的意识。那就是我们生产的都是同一类产品。抽象工厂模式是工厂方法的仅一步深化，在这个模式中的工厂类不单单可以创建一种产品，而是可以创建一组产品。抽象工厂应该是比较最难理解的一个工厂模式了。角色分配抽象工厂（AbstractFactory）角色 ：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。具体工厂类（ConreteFactory）角色 ：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建某一种产品对象。抽象产品（Abstract Product）角色 ：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。具体产品（Concrete Product）角色 ：抽象工厂模式所创建的任何产品对象都是某一个具体产品类的实例。在抽象工厂中创建的产品属于同一产品族，这不同于工厂模式中的工厂只创建单一产品，我后面也会详解介绍到。适用场景和工厂方法一样客户端不需要知道它所创建的对象的类。需要一组对象共同完成某种功能时，并且可能存在多组对象完成不同功能的情况。（同属于同一个产品族的产品）系统结构稳定，不会频繁的增加对象。（因为一旦增加就需要修改原有代码，不符合开闭原则）抽象工厂和工厂方法的区别​ 抽象工厂是生产一整套有产品的（至少要生产两个产品)，这些产品必须相互是有关系或有依赖的，而工厂方法中的工厂是生产单一产品的工厂。实现不知道大家玩过穿越火线或者吃鸡这类游戏了吗，游戏中存在各种枪。我们假设现在存在AK、M4A1两类枪，每一种枪对应一种子弹。我们现在这样考虑生产AK的工厂可以顺便生产AK使用的子弹，生产M4A1的工厂可以顺便生产M4A1使用的子弹。（AK工厂生产AK系列产品包括子弹啊，AK枪的类型啊这些，M4A1工厂同理）创建相关接口枪123public interface Gun &#123; public void shooting();&#125;子弹123public interface Bullet &#123; public void load();&#125;创建接口对应实现类AK类123456789public class AK implements Gun&#123; @Override public void shooting() &#123; System.out.println(\"shooting with AK\"); &#125;&#125;M4A1类123456789public class M4A1 implements Gun &#123; @Override public void shooting() &#123; System.out.println(\"shooting with M4A1\"); &#125;&#125;AK子弹类12345678public class AK_Bullet implements Bullet &#123; @Override public void load() &#123; System.out.println(\"Load bullets with AK\"); &#125;&#125;M4A1子弹类123456789public class M4A1_Bullet implements Bullet &#123; @Override public void load() &#123; System.out.println(\"Load bullets with M4A1\"); &#125;&#125;创建工厂接口1234public interface Factory &#123; public Gun produceGun(); public Bullet produceBullet();&#125;创建具体工厂生产AK和AK子弹的工厂12345678910111213public class AK_Factory implements Factory&#123; @Override public Gun produceGun() &#123; return new AK(); &#125; @Override public Bullet produceBullet() &#123; return new AK_Bullet(); &#125;&#125;生产M4A1和M4A1子弹的工厂12345678910111213public class M4A1_Factory implements Factory&#123; @Override public Gun produceGun() &#123; return new M4A1(); &#125; @Override public Bullet produceBullet() &#123; return new M4A1_Bullet(); &#125;&#125;总结其实，无论是简单工厂模式、工厂模式还是抽象工厂模式，它们本质上都是将不变的业务部分提取出来，将可变的业务部分留作接口，以达到最大程度上的复用。究竟用哪种设计模式更适合，这要根据具体的业务需求来决定。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"工厂模式","slug":"设计模式/工厂模式","permalink":"http://www.baiyp.ren/categories/设计模式/工厂模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"工厂模式","slug":"工厂模式","permalink":"http://www.baiyp.ren/tags/工厂模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"工厂模式","slug":"设计模式/工厂模式","permalink":"http://www.baiyp.ren/categories/设计模式/工厂模式/"}]},{"title":"ThreadLocal源码解析02","slug":"ThreadLocal源码解析02","date":"2019-08-17T02:49:37.000Z","updated":"2019-09-07T09:07:49.650Z","comments":true,"path":"ThreadLocal源码解析02.html","link":"","permalink":"http://www.baiyp.ren/ThreadLocal源码解析02.html","excerpt":"","text":"ThreadLocal源码解析02上一节我们详细解析了set方法，现在我们来解析get方法ThreadLocal.get 方法ThreadLocal.get 方法相对来说简单我们先来看下get的流程图下面我们解析代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//获取ThreadLocal 中的值 public T get() &#123; //获取当前线程 Thread t = Thread.currentThread(); //同set方法类似获取对应线程中的ThreadLocalMap实例 ThreadLocal.ThreadLocalMap map = getMap(t); if (map != null) &#123; //从Map中根据ThreadLocal获取entry ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(this); //如果Entry 不为空 则返回 if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T) e.value; return result; &#125; &#125; //为空返回初始化值 return setInitialValue(); &#125; /** * 初始化设值的方法，可以被子类覆盖。 */ protected T initialValue() &#123; return null; &#125; /** * 设置初始化的方法 * @return */ private T setInitialValue() &#123; //获取初始化值，默认为null(如果没有子类进行覆盖) T value = initialValue(); Thread t = Thread.currentThread(); //同set方法类似获取对应线程中的ThreadLocalMap实例 ThreadLocalMap map = getMap(t); //不为空不用再初始化，直接调用set操作设值 if (map != null) map.set(this, value); else &#123; //第一次初始化，createMap在上面介绍set()的时候有介绍过。 createMap(t, value); &#125; //返回初始化后的值 return value; &#125;我们发现首先从当前线程中获取ThreadLocalMap 然后从map中根据ThreadLocal获取entry，entry不为空则返回value，否则调用setInitialValue设置初始值并返回。我们深入到 map.getEntry(this);方法ThreadLocalMap.getEntry 方法123456789101112131415161718/** * 根据 ThreadLocal 获取获取entry * @param key 当前的threadLocal * @return */ private ThreadLocal.ThreadLocalMap.Entry getEntry(ThreadLocal&lt;?&gt; key) &#123; //计算 table 中需要映射的下标 int i = key.threadLocalHashCode &amp; (table.length - 1); //从table中获取entry ThreadLocal.ThreadLocalMap.Entry e = table[i]; //如果entry 不为空且entry中的key和传入的key匹配则返回entry if (e != null &amp;&amp; e.get() == key) return e; else &#123; //发生了hash冲突，当前的entry为空或者key和传入的key不一致 return getEntryAfterMiss(key, i, e); &#125; &#125;getEntryAfterMiss123456789101112131415161718192021222324/** * 通过直接计算出来的key找不到对于的value的时候适用这个方法. */ private ThreadLocal.ThreadLocalMap.Entry getEntryAfterMiss(ThreadLocal&lt;?&gt; key, int i, ThreadLocal.ThreadLocalMap.Entry e) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; while (e != null) &#123; ThreadLocal&lt;?&gt; k = e.get(); //如果当前的key和传入的key匹配则返回 if (k == key) return e; if (k == null) //清除无效的entry expungeStaleEntry(i); else &#123; //基于线性探测法向后扫描 i = nextIndex(i, len); &#125; e = tab[i]; &#125; //找不到返回null return null; &#125;到这里 get方法以及完结了。ThreadLocal.remove 方法1234567891011121314151617181920212223242526272829public void remove() &#123; //同set方法类似获取对应线程中的ThreadLocalMap实例 ThreadLocal.ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) &#123; //调用ThreadLocalMap的remove方法进行清除entry m.remove(this); &#125; &#125; /** * 根据ThreadLocal 删除entry * @param key 当前的ThreadLocal */ private void remove(ThreadLocal&lt;?&gt; key) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; //计算 table 中需要映射的下标 int i = key.threadLocalHashCode &amp; (len - 1); //进行线性探测，查找正确的key for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; if (e.get() == key) &#123; //调用weakrefrence的clear()清除引用 e.clear(); //连续段清除 expungeStaleEntry(i); return; &#125; &#125; &#125;​ remove()在有上面了解后可以说极为简单了，就是找到对应的table[],调用weakrefrence的clear()清除引用，然后再调用expungeStaleEntry()进行清除。ThreadLocal 防止hash冲突的到这里整个threadLocal 基本介绍完成了，但是还少一块，如何处理hash冲突的生成映射下标1int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1);这一段代码和 求模的效果类似，根据hash生成一个0-(INITIAL_CAPACITY-1)之间的数我们发现计算冲突与threadLocalHashCode 和 INITIAL_CAPACITY有关INITIAL_CAPACITY值的设置例如 ：10 0001 0111 110100 0000 0000 1111 &amp; (INITIAL_CAPACITY-1) 即 1500 0000 0000 1101 13所以这种算法只对后半段的数据敏感 如果是其他值 后面可能包含0 例如 0011 这样只有两位参与了运算，重复率就增加了，如果下面的值全是1 就更加平均了，什么时候全是1呢 就是 2的N次幂-1例如2^4=16=10000B16-1=15= 01111B所以只有当INITIAL_CAPACITY值时2的n次幂的时候才对hash的数据敏感，因为是与运算，只利用了hahs二进制的后半段。threadLocalHashCode 值的设置我们看下threadLocalHashCode 的声明123456private final int threadLocalHashCode = nextHashCode(); //返回下一个hashCode private static int nextHashCode() &#123; //通过CAS的方式进行获取并且相加 return nextHashCode.getAndAdd(HASH_INCREMENT);&#125;这里面有一个神奇的数字 HASH_INCREMENT他的声明是1private static final int HASH_INCREMENT = 0x61c88647;神奇的数字既然ThreadLocal用map就避免不了冲突的产生这里碰撞其实有两种类型只有一个ThreadLocal实例的时候(上面推荐的做法)，当向thread-local变量中设置多个值的时产生的碰撞，碰撞解决是通过开放定址法， 且是线性探测(linear-probe)多个ThreadLocal实例的时候，最极端的是每个线程都new一个ThreadLocal实例，此时利用特殊的哈希码0x61c88647大大降低碰撞的几率， 同时利用开放定址法处理碰撞注意 0x61c88647的利用主要是为了多个ThreadLocal实例的情况下用的注意实例变量threadLocalHashCode, 每当创建ThreadLocal实例时这个值都会累加 0x61c88647,为了让哈希码能均匀的分布在2的N次方的数组里, 即 Entry[] table的大小必须是2的N次方我们看下table的定义1234567/** * The table, resized as necessary. * 该表根据需要调整大小。 * table.length MUST always be a power of two. * table.length必须始终是2的幂。 */private Entry[] table;key.threadLocalHashCode &amp; (len-1)这么用是什么意思? 我们上面定义了table数组的长度是16 =2^4​ ThreadLocalMap 中Entry[] table的大小必须是2的N次方呀(len = 2^N)，那 len-1 的二进制表示就是低位连续的N个1， 那 key.threadLocalHashCode &amp; (len-1) 的值就是 threadLocalHashCode 的低N位, 这样就能均匀的产生均匀的分布? 我们做个实验。1234567891011121314151617181920212223//神奇的数字private static final int HASH_INCREMENT = 0x61c88647;//模拟table大小 16 2^4private static final int tableSize = 1 &lt;&lt; 4;public static void main(String[] args) &#123; getHashIndex(1000);&#125;public static void getHashIndex(int num) &#123; Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;(); int nextHashCode = HASH_INCREMENT; for (int i = 0; i &lt; num; i++) &#123; //每次进行*2 计算 nextHashCode += HASH_INCREMENT; //计算映射的小标 int index = nextHashCode &amp; (tableSize - 1); //用Map进行统计 Integer count = map.computeIfAbsent(index, x -&gt; 0); map.put(index, ++count); &#125; System.out.println(map);&#125;输出1&#123;0=62, 1=63, 2=62, 3=63, 4=62, 5=63, 6=62, 7=62, 8=63, 9=62, 10=63, 11=62, 12=63, 13=62, 14=63, 15=63&#125;我们发现数据分布的惊人的平均，比我们写的随机数更平均。总结Hash冲突怎么解决​ 和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。内存泄露问题​ threadlocal里面使用了一个存在弱引用的map,当释放掉threadlocal的强引用以后,map里面的value却没有被回收.而这块value永远不会被访问到了. 所以存在着内存泄露. 最好的做法是将调用threadlocal的remove方法.​ 因为ThreadLocal本身又清理机制，调用，get,set,remove等方法时会触发自动清理机制，清理掉key为空的主句，但是不是实时的，会有延后，在没有调用get,set,remove方法时，过期的entry时内存泄漏状态，推荐不适用了调用remove方法。hash散列算法​ 在实际使用中，不同的输入可能会散列成相同的输出，这时也就产生了冲突。通过上文提到的 HASH_INCREMENT 再借助一定的算法，就可以将哈希码能均匀的分布在 2 的 N 次方的数组里，保证了散列表的离散度，从而降低了冲突几率，使用nextHashCode &amp; (tableSize - 1);这种方式进行下标映射性能更高，使用用HASH_INCREMENT 0x61c88647 这个神奇的数字让数据分布的更平均。","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"ThreadLocal","slug":"源码/ThreadLocal","permalink":"http://www.baiyp.ren/categories/源码/ThreadLocal/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://www.baiyp.ren/tags/ThreadLocal/"},{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"ThreadLocal","slug":"源码/ThreadLocal","permalink":"http://www.baiyp.ren/categories/源码/ThreadLocal/"}]},{"title":"ThreadLocal源码解析01","slug":"ThreadLocal源码解析01","date":"2019-08-16T11:49:37.000Z","updated":"2019-09-07T09:07:49.648Z","comments":true,"path":"ThreadLocal源码解析01.html","link":"","permalink":"http://www.baiyp.ren/ThreadLocal源码解析01.html","excerpt":"","text":"ThreadLocal源码解析01先看下set的流程图ThreadLocal 简介​ ThreadLocal 在面试中经常提到，关于ThreadLocal使用不当造成OOM以及在特殊场景下，通过ThreadLocal可以轻松实现一些看起来复杂的功能，都说明值得花时间研究其原理。​ ThreadLocal 不是 Thread，是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，每个线程存储的是主线程变量的副本，子线程操作的是对副本进行操作，不影响其他子线程的中的数据，所以一般说，ThreadLocal不保证线程的安全，只保证线程的隔离。​ 举个例子，如果ThreadLocal保存保存的是一个静态变量，副本都是静态变量自己，这样就又会出现线程安全问题。ThreadLocal 注意事项ThreadLocal类封装了getMap()、set()、get()、remove()4个核心方法通过getMap()获取每个子线程Thread持有自己的ThreadLocalMap实例, 因此它们是不存在并发竞争的。可以理解为每个线程有自己的变量副本。ThreadLocalMap中Entry[]数组存储数据，初始化长度16，后续每次都是2倍扩容。主线程中定义了几个变量，Entry[]中就有几个key。Entry的key是对ThreadLocal的弱引用，当抛弃掉ThreadLocal对象时，垃圾收集器会忽略这个key的引用而清理掉ThreadLocal对象， 防止了内存泄漏。源码解读看源码要有入口我们先从初始化开始ThreadLocal 初始化方式123456789/** * 定义一个ThreadLocal */ private static ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;Integer&gt;(); public static void main(String[] args) &#123; //设置变量的值 threadLocal.set(1); &#125;我们发现ThreadLocal的set方法是设置值的，他为什么能是变量的副本呢我们进入set方法ThreadLocal.set 方法123456789101112//设置此线程局部变量的当前线程副本public void set(T value) &#123; //获取当前线程 Thread t = Thread.currentThread(); //根据当前线程获取ThreadLocalMap ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else //如果map为空就创建一个显得Map参数是当前线程和我们需要设置的值 createMap(t, value); &#125;我看看set方法 很简单，获取当前线程，根据当前线程获取ThreadLocalMap，有的话就set没有就创建我们可以这样理解 ThreadLocalMap 和当前线程有关，我们进去看下ThreadLocal.getMap方法1234//从当前线程获取 ThreadLocalMapThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;好吧到这里 确定了ThreadLocalMap 实在当前线程中存储了，这也解释了为什么是变量的副本，调用ThreadLocal的set方法实际上是将值放进当前的线程中了，每个线程中的值是不一样的。我们需要进入Thread内部看源码了12//再Thread 中定义的ThreadLocalMapThreadLocal.ThreadLocalMap threadLocals = null;我们发现ThreadLocalMap 实在Thread类中定义的到这里ThreadLocal.getMap方法解析完了，我们需要看createMap方法了。ThreadLocal.createMap方法set 方法是获取线程内部的ThreadLocalMap，初始化肯定为空，就需要调用createMap了123456789//创建ThreadLocalMap void createMap(Thread t, T firstValue) &#123; /** * this 就是ThreadLocal 本身 * * firstValue 就是我们需要保存的值 */ t.threadLocals = new ThreadLocalMap(this, firstValue); &#125;我看看这段代码，很有意思，ThreadLocalMap的key是threadLocal本身，value则是我们需要设置的值，这里就出现一个问题，key是相同的，如果一个ThreadLocal有多个值肯定会被覆盖，所以可以确定，ThreadLocalMap是用来处理一个线程中存在多个ThreadLocal的问题，value肯定有更细化的对象存储，我们进去看看ThreadLocalMap的构造方法。ThreadLocalMap的构造方法12345678910111213141516171819202122232425/** *构建一个最初包含（firstkey，firstvalue）的新的 ThreadLocalMap。 *因为Thread中的 ThreadLocalMaps是懒加载构造的，所以我们只创建 * * @param firstKey ThreadLocal 本身 * @param firstValue 需要存放的第一个值 */ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123; //创建一个Entry数组的表，初始化大小为INITIAL_CAPACITY table = new ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY]; //通过与运算将threadLocalHashCode映射到一个数组下标 //他比取模或者求余速度快性能高 int i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - 1); //将取模后的值映射到对应的Entry数组中的某个位置 table[i] = new ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue); //因为第一次调用设置size为1 size = 1; //计算下次需要扩容的值 setThreshold(INITIAL_CAPACITY);&#125;//setThreshold方法是计算扩容下次扩容的阈值的private void setThreshold(int len) &#123; threshold = len * 2 / 3;&#125;我们来看下EntryThreadLocalMap.Entry123456789//ThreadLocal作为key进行软引用static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123; //与ThreadLocal相绑定的值 Object value; Entry(ThreadLocal&lt;?&gt; k, Object v) &#123; super(k); value = v; &#125;&#125;这里使用了WeakReference 软引用WeakReference： 当一个对象仅仅被weak reference（软引用）指向, 而没有任何其他strong reference（强引用）指向的时候, 如果这时GC运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。也就是如果当前线程的ThreadLocal 被销毁后，因为当前线程引用了ThreadLocalMap，所以当前线程和entry还是强引用，因为ThreadLocal在entry是软引用，所以垃圾回收key(ThreadLocal)会被销毁，entry中的value没有被销毁，但是没有key造成无法访问，这就造成了内存泄漏，ThreadLocal为了防止内存泄漏我们会在后面详细的说。整体结构我们回顾上面介绍的内容我们看下ThreadLocal整体结构的图解ThreadLocalMap.set方法我们上面介绍了getMap和createMap方法，我们来看看map.set方法线性探测算法​ ThreadLocalMap使用线性探测法来解决哈希冲突，线性探测法的地址增量di = 1, 2, … , m-1，其中，i为探测次数。该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。先看一下线性探测相关的代码，从中也可以看出来table实际是一个环：12345678910111213/**java * 获取环形数组的下一个索引 */ private static int nextIndex(int i, int len) &#123; return ((i + 1 &lt; len) ? i + 1 : 0); &#125; /** * 获取环形数组的上一个索引 */ private static int prevIndex(int i, int len) &#123; return ((i - 1 &gt;= 0) ? i - 1 : len - 1); &#125;ThreadLocalMap的set()1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556/** * 将Value设置进对应的ThreadLocal 的key 中 * * @param key * @param value */private void set(ThreadLocal&lt;?&gt; key, Object value) &#123; // We don't use a fast path as with get() because it is at // least as common to use set() to create new entries as // it is to replace existing ones, in which case, a fast // path would fail more often than not. /** * 不使用 get的快速路径 set一般是替换方式 * 快速路径一般会失败 */ ThreadLocal.ThreadLocalMap.Entry[] tab = table; //获取table的长度 int len = tab.length; //计算需要映射的table下标 int i = key.threadLocalHashCode &amp; (len - 1); /** * 根据获取到的索引进行循环，如果当前索引上的table[i]不为空，在没有return的情况下， * 就使用nextIndex()获取下一个（上面提到到线性探测法）。 */ for (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != null; e = tab[i = nextIndex(i, len)]) &#123; //获取当前的ThreadLocal ThreadLocal&lt;?&gt; k = e.get(); //如果entry中的ThreadLocal(k) 和 传进来的 ThreadLocal(key)是同一个 if (k == key) &#123; //将 e.value替换为新的value e.value = value; return; &#125; /** * table[i]上的key为空，说明被回收了（上面的弱引用中提到过）。 * 这个时候说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry */ if (k == null) &#123; //对key为空的entry进行重新赋值替换 replaceStaleEntry(key, value, i); return; &#125; &#125; //找到为空的插入位置，插入值，在为空的位置插入需要对size进行加1操作 tab[i] = new ThreadLocal.ThreadLocalMap.Entry(key, value); int sz = ++size; /** * cleanSomeSlots用于清除那些e.get()==null，也就是table[index] != null &amp;&amp; table[index].get()==null * 之前提到过，这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。 * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行rehash() */ if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold) rehash();&#125;​ 大致分析上面都已经标注出来了，需要注意的是Entry对象是继承是WeakReference也就是一个弱引用是会被回收的，所以对应 的key值可能是为null的。存放对象之后是需要判断数组中存储对象的个数是否超过了设定的临界值threshold的大小，如果超过了需要扩容，并且还要重新计算扩容后所有对象的位置。扩容的方法是rehash()replaceStaleEntry 替换无效的key1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 替换无效entry */ private void replaceStaleEntry(ThreadLocal&lt;?&gt; key, Object value, int staleSlot) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; ThreadLocal.ThreadLocalMap.Entry e; /** * 根据传入的无效entry的位置（staleSlot）,向前扫描 * 一段连续的entry(这里的连续是指一段相邻的entry并且table[i] != null), * 直到找到一个无效entry，或者扫描完也没找到 */ int slotToExpunge = staleSlot;//之后用于清理的起点 for (int i = prevIndex(staleSlot, len); (e = tab[i]) != null; i = prevIndex(i, len)) if (e.get() == null) slotToExpunge = i; /** * 向后扫描一段连续的entry */ for (int i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); /** * 如果找到了key，将其与传入的无效entry替换，也就是与table[staleSlot]进行替换 */ if (k == key) &#123; e.value = value; tab[i] = tab[staleSlot]; tab[staleSlot] = e; //如果向前查找没有找到无效entry，则更新slotToExpunge为当前值i if (slotToExpunge == staleSlot) slotToExpunge = i; cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); return; &#125; /** * 如果向前查找没有找到无效entry，并且当前向后扫描的entry无效，则更新slotToExpunge为当前值i */ if (k == null &amp;&amp; slotToExpunge == staleSlot) slotToExpunge = i; &#125; /** * 如果没有找到key,也就是说key之前不存在table中 * 就直接最开始的无效entry——tab[staleSlot]上直接新增即可 */ tab[staleSlot].value = null; tab[staleSlot] = new ThreadLocal.ThreadLocalMap.Entry(key, value); /** * slotToExpunge != staleSlot,说明存在其他的无效entry需要进行清理。 */ if (slotToExpunge != staleSlot) cleanSomeSlots(expungeStaleEntry(slotToExpunge), len); &#125;expungeStaleEntry 连续段清除123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 连续段清除 * 根据传入的staleSlot,清理对应的无效entry——table[staleSlot], * 并且根据当前传入的staleSlot,向后扫描一段连续的entry(这里的连续是指一段相邻的entry并且table[i] != null), * 对可能存在hash冲突的entry进行rehash，并且清理遇到的无效entry. * * @param staleSlot key为null,需要无效entry所在的table中的索引 * @return 返回下一个为空的solt的索引。 */ private int expungeStaleEntry(int staleSlot) &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; // 清理无效entry，置空 tab[staleSlot].value = null; tab[staleSlot] = null; //size减1，置空后table的被使用量减1 size--; ThreadLocal.ThreadLocalMap.Entry e; int i; /** * 从staleSlot开始向后扫描一段连续的entry */ for (i = nextIndex(staleSlot, len); (e = tab[i]) != null; i = nextIndex(i, len)) &#123; ThreadLocal&lt;?&gt; k = e.get(); //如果遇到key为null,表示无效entry，进行清理. if (k == null) &#123; e.value = null; tab[i] = null; size--; &#125; else &#123; //如果key不为null,计算索引 int h = k.threadLocalHashCode &amp; (len - 1); /** * 计算出来的索引——h，与其现在所在位置的索引——i不一致，置空当前的table[i] * 从h开始向后线性探测到第一个空的slot，把当前的entry挪过去。 */ if (h != i) &#123; tab[i] = null; while (tab[h] != null) h = nextIndex(h, len); tab[h] = e; &#125; &#125; &#125; //下一个为空的solt的索引。 return i; &#125;cleanSomeSlots 清理脏数据1234567891011121314151617181920212223242526272829/** * 启发式的扫描清除，扫描次数由传入的参数n决定 * * @param i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null） * * @param n 控制扫描次数，正常情况下为 log2(n) ， * 如果找到了无效entry，会将n重置为table的长度len,进行段清除。 * * map.set()点用的时候传入的是元素个数，replaceStaleEntry()调用的时候传入的是table的长度len * * @return true if any stale entries have been removed. */ private boolean cleanSomeSlots(int i, int n) &#123; boolean removed = false; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; do &#123; i = nextIndex(i, len); ThreadLocal.ThreadLocalMap.Entry e = tab[i]; if (e != null &amp;&amp; e.get() == null) &#123; //重置n为len n = len; removed = true; //依然调用expungeStaleEntry来进行无效entry的清除 i = expungeStaleEntry(i); &#125; &#125; while ( (n &gt;&gt;&gt;= 1) != 0);//无符号的右移动，可以用于控制扫描次数在log2(n) return removed; &#125;n的用途​ 主要用于扫描控制（scan control），从while中是通过n来进行条件判断的说明n就是用来控制扫描趟数（循环次数）的。在扫描过程中，如果没有遇到脏entry就整个扫描过程持续log2(n)次，log2(n)的得来是因为n &gt;&gt;&gt;= 1，每次n右移一位相当于n除以2。如果在扫描过程中遇到脏entry的话就会令n为当前hash表的长度（n=len），再扫描log2(n)趟，注意此时n增加无非就是多增加了循环次数从而通过nextIndex往后搜索的范围扩大，示意图如下rehash 重新整理rehash 方法分两步1、先是删除过期的对象：expungeStaleEntries()；2、如果存储对象个数大于临界值的3/4，扩容12345678910111213141516/** * 刷新ThreadLocal */private void rehash() &#123; //全清理过期的数据 expungeStaleEntries(); /** * threshold = 2/3 * len * 所以threshold - threshold / 4 = 1en/2 * 这里主要是因为上面做了一次全清理所以size减小，需要进行判断。 * 判断的时候把阈值调低了。 */ if (size &gt;= threshold - threshold / 4) //扩容 resize();&#125;expungeStaleEntries 全清理无效的entry123456789101112131415/** * 全清理，清理所有无效entry */ private void expungeStaleEntries() &#123; ThreadLocal.ThreadLocalMap.Entry[] tab = table; int len = tab.length; //遍历整个table for (int j = 0; j &lt; len; j++) &#123; ThreadLocal.ThreadLocalMap.Entry e = tab[j]; // Entry存在且key不存在 就是 threadLoca已被GC回收 if (e != null &amp;&amp; e.get() == null) //使用连续段清理 expungeStaleEntry(j); &#125; &#125;​ 删除数组中过时的Entry对象。有些小伙伴可能会有些疑问什么是过时的Entry？为什么会过时？其实这个在前面说过，Entry是弱引用会被回收。这个方法中判断的删除条件是，Entry对象不为空并且key值为空。可见expungStaleEntry(j) 方法就是删除指定索引的Entry对象。resize扩容方法123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * 扩容，扩大为原来的2倍（这样保证了长度为2的冥） */private void resize() &#123; //将table 赋值为old table ThreadLocal.ThreadLocalMap.Entry[] oldTab = table; int oldLen = oldTab.length; //扩容是原来的二倍 int newLen = oldLen * 2; //创建一个新的table ThreadLocal.ThreadLocalMap.Entry[] newTab = new ThreadLocal.ThreadLocalMap.Entry[newLen]; int count = 0; //遍历old table for (int j = 0; j &lt; oldLen; ++j) &#123; //获取当前遍历到的entry ThreadLocal.ThreadLocalMap.Entry e = oldTab[j]; //如果存在entry if (e != null) &#123; //获取key ThreadLocal&lt;?&gt; k = e.get(); //虽然做过一次清理，但在扩容的时候可能会又存在key==null的情况。 if (k == null) &#123; //将value置为空，让GC进行回收 e.value = null; // Help the GC &#125; else &#123; //重新计算下标 int h = k.threadLocalHashCode &amp; (newLen - 1); //同样适用线性探测来设置值，如果发生hahs冲突找到向后找到最近的一个空位 while (newTab[h] != null) &#123; h = nextIndex(h, newLen); &#125; //将entry 放进计算出的table对应的下标数组中 newTab[h] = e; count++; &#125; &#125; &#125; //重新设置下次扩容的阈值 setThreshold(newLen); //赋值threadLocal 的size size = count; //将新的table赋值为 table对象 table = newTab;&#125;​ 先是创建一个是原来容量两倍的Entry[]数组，在遍历原来的数组，将key值为空的Entry对象的value置为空方便GC回收，key不为空的Entry对象先根据key的hashcode计算需要存放的位置存入新的数组中，存储结束后别忘了更新临界值。到这里整个set方法的过程也完结了下一篇介绍其他的方法以及threadlocal的总结","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"ThreadLocal","slug":"源码/ThreadLocal","permalink":"http://www.baiyp.ren/categories/源码/ThreadLocal/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://www.baiyp.ren/tags/ThreadLocal/"},{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"ThreadLocal","slug":"源码/ThreadLocal","permalink":"http://www.baiyp.ren/categories/源码/ThreadLocal/"}]},{"title":"JAVA中的分布式事务07-Saga事务(最终一致性)","slug":"JAVA中的分布式事务07","date":"2019-08-16T02:05:25.000Z","updated":"2019-09-07T09:07:49.664Z","comments":true,"path":"JAVA中的分布式事务07.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的分布式事务07.html","excerpt":"","text":"JAVA中的分布式事务07-Saga事务(最终一致性)方案简介​ Saga事务源于1987年普林斯顿大学的Hecto和Kenneth发表的如何处理long lived transaction（长活事务）论文，Saga事务核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。处理流程Saga事务基本协议每个Saga事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。每个Ti 都有对应的幂等补偿动作Ci，补偿动作用于撤销Ti造成的结果。可以看到，和TCC相比，Saga没有“预留”动作，它的Ti就是直接提交到库。下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分Saga的执行顺序有两种：事务正常执行完成T1, T2, T3, …, Tn，例如：扣减库存(T1)，创建订单(T2)，支付(T3)，依次有序完成整个事务。事务回滚T1, T2, …, Tj, Cj,…, C2, C1，其中0 &lt; j &lt; n，例如：扣减库存(T1)，创建订单(T2)，支付(T3，支付失败)，支付回滚(C3)，订单回滚(C2)，恢复库存(C1)。Saga的两种恢复策略向前恢复(forward recovery)对应于上面第一种执行顺序，适用于必须要成功的场景，发生失败进行重试，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的子事务(sub-transaction)。该情况下不需要Ci。向后恢复(backward recovery)对应于上面提到的第二种执行顺序，其中j是发生错误的子事务(sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个Saga的执行结果撤销。Saga事务常见的有两种不同的实现方式命令协调(Order Orchestrator)中央协调器负责集中处理事件的决策和业务逻辑排序。​ 中央协调器（Orchestrator，简称OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。以电商订单的例子为例：1、事务发起方的主业务逻辑请求OSO服务开启订单事务2、OSO向库存服务请求扣减库存，库存服务回复处理结果。3、OSO向订单服务请求创建订单，订单服务回复创建结果。4、OSO向支付服务请求支付，支付服务回复处理结果。5、主业务逻辑接收并处理OSO事务处理结果回复。​ 中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。事件编排 (Event Choreography)没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动。​ 在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。以电商订单的例子为例：1、事务发起方的主业务逻辑发布开始订单事件2、库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件2、订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件4、支付服务监听订单已创建事件，进行支付，并发布订单已支付事件5、主业务逻辑监听订单已支付事件并处理。方案总结命令协调设计的优点和缺点优点1、服务之间关系简单，避免服务之间的循环依赖关系，因为Saga协调器会调用Saga参与者，但参与者不会调用协调器2、程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。3、易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试缺点1、中央协调器容易处理逻辑容易过于复杂，导致难以维护。2、存在协调器单点故障风险。事件/编排设计的优点和缺点优点1、避免中央协调器单点故障风险。2、当涉及的步骤较少服务开发简单，容易实现。缺点1、服务之间存在循环依赖的风险。2、当涉及的步骤较多，服务间关系混乱，难以追踪调测。值得补充的是，由于Saga模型中没有Prepare阶段，因此事务间不能保证隔离性，当多个Saga事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.baiyp.ren/tags/分布式事务/"},{"name":"Saga","slug":"Saga","permalink":"http://www.baiyp.ren/tags/Saga/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}]},{"title":"JAVA动态代理源码分析","slug":"JAVA动态代理源码分析","date":"2019-08-15T02:28:05.000Z","updated":"2019-09-07T09:07:49.645Z","comments":true,"path":"JAVA动态代理源码分析.html","link":"","permalink":"http://www.baiyp.ren/JAVA动态代理源码分析.html","excerpt":"","text":"JAVA动态代理源码分析动态代理简介​ Proxy模式是常用的设计模式，其特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。用户可以更加结构图，自己编码完成Proxy模式。这种实现称为静态代理。​ Java提供了java.lang.reflect.Proxy类与InvocationHandler接口，配合反射，可以实现动态代理。静态代理的代理类与代理操作，都是事先编码，运行过程种无法修改代理结构。动态代理的代理与代理操作，都是在运行过程中，动态生成，可以在运行过程中，修改代理结构，符合面向对象的开闭原则。​ 最最最主要的原因就是，在不改变目标对象方法的情况下对方法进行增强，比如，我们希望对方法的调用增加日志记录，或者对方法的调用进行拦截，等等…​ 动态代理用于将在不需要修改原代码的情况下进行代码的增加，spring中的AOP，事务，都是使用动态代理来实现的，我们天天都在使用动态代理只是自己不知道而已。动态代理三大要素需要定义一个接口java动态代理类只能代理接口（不支持抽象类），如果没有接口就要使用cjlib需要一个实现类继承这个接口编写一个增强类实现 InvocationHandler接口代理类都需要实现InvocationHandler接口的invoke方法一个栗子先定义一个接口定义一个海外代购的接口123456/** * 海外代购 */public interface Buying &#123; public String buy();&#125;编写一个实现类实现类实现接口1234567public class BuyingImpl implements Buying &#123; @Override public String buy() &#123; System.out.println(\"开始逻辑处理\"); return \"买了个锤子\"; &#125;&#125;编写一个增将类编写一个增强类，主要要包裹一个需要需要增强的对象也就是我们的BuyingImpl，并实现InvocationHandler接口，在invoke方法中写增强实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 海外代购增强类 * 注意实现 InvocationHandler * 动态代理类只能代理接口（不支持抽象类），代理类都需要实现InvocationHandler类，实现invoke方法。 * 该invoke方法就是调用被代理接口的所有方法时需要调用的 。 */public class BuingHandler implements InvocationHandler &#123; /** * 包裹一个需要增强的目标对象 */ private Object targetObject; public BuingHandler(Object targetObject)&#123; this.targetObject = targetObject; &#125; /** * 获取代理类 * * @return */ public Object getProxy() &#123; /** * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例 * 第一个参数指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器 * 第二个参数要实现和目标对象一样的接口，所以只需要拿到目标对象的实现接口 * 第三个参数表明这些被拦截的方法在被拦截时需要执行哪个InvocationHandler的invoke方法 * 根据传入的目标返回一个代理对象 */ return Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this); &#125; /** * 关联的这个实现类的方法被调用时将被执行 * InvocationHandler接口的方法 * * @param proxy 表示代理对象 * @param method 示原对象被调用的方法 * @param args 表示方法的参数 * @return 返回的是对象的一个接口 * @throws Throwable */ @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(\"前置增强\"); //反射调用原始的需要增强的方法 Object value = method.invoke(targetObject, args); System.out.println(\"后置增强\"); return value; &#125;&#125;这里面要注意 method 是我们需要增强的方法，args 是我们需要增强的参数数组编写Main方法123456789public static void main(String[] args) &#123; //创建BuingHandler 类 BuingHandler buingHandler = new BuingHandler(new BuyingImpl()); //获取代理对象 Buying buying = (Buying) buingHandler.getProxy(); //调用具体接口 String value = buying.buy(); System.out.println(value); &#125;输出1234前置增强开始逻辑处理后置增强买了个锤子我们就这样实现了动态代理，我们没有修改原有代码的情况下做了增强我们实现了 其那只以及后置增强我们运行下看下接口对象我们看到实际对象是$Proxy0，我们发现动态代理给我们换了一个对象，我们要研究下他是怎么实现的源码实现读源码首先找到入口，没有不得入口就像无头的苍蝇，苍蝇还不叮无缝的蛋呢下面内容有点多，也有点绕，请跟着思路来一点点解析1、首先找到入口我们创建代理对象调用的是12Proxy.newProxyInstance(targetObject.getClass().getClassLoader(), targetObject.getClass().getInterfaces(), this);所以我们先从Proxy.newProxyInstance开始入手2、newProxyInstance方法进入newProxyInstance方法内部1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException &#123; //增强实现不能为空，为空就抛出异常 Objects.requireNonNull(h); //对接口数组进行clone final Class&lt;?&gt;[] intfs = interfaces.clone(); //进项权限检查 final SecurityManager sm = System.getSecurityManager(); if (sm != null) &#123; checkProxyAccess(Reflection.getCallerClass(), loader, intfs); &#125; /* * Look up or generate the designated proxy class. * ********核心代码入口*********** * 查找或者是生成一个特定的代理类对象 */ Class&lt;?&gt; cl = getProxyClass0(loader, intfs); /* * Invoke its constructor with the designated invocation handler. * 使用指定的调用处理程序调用其构造函数 */ try &#123; if (sm != null) &#123; checkNewProxyPermission(Reflection.getCallerClass(), cl); &#125; // 从代理类对象中查找参数为InvocationHandler的构造器 final Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams); final InvocationHandler ih = h; // 检测构造器是否是Public修饰，如果不是则强行转换为可以访问的。 if (!Modifier.isPublic(cl.getModifiers())) &#123; AccessController.doPrivileged(new PrivilegedAction&lt;Void&gt;() &#123; public Void run() &#123; cons.setAccessible(true); return null; &#125; &#125;); &#125; //通过反射，将h作为参数，实例化代理类，返回代理类实例。 return cons.newInstance(new Object[]&#123;h&#125;); &#125; catch (IllegalAccessException | InstantiationException e) &#123; throw new InternalError(e.toString(), e); &#125; catch (InvocationTargetException e) &#123; Throwable t = e.getCause(); if (t instanceof RuntimeException) &#123; throw (RuntimeException) t; &#125; else &#123; throw new InternalError(t.toString(), t); &#125; &#125; catch (NoSuchMethodException e) &#123; throw new InternalError(e.toString(), e); &#125; &#125;上面代码的核心方法是1Class&lt;?&gt; cl = getProxyClass0(loader, intfs);找到了核心方法继续深入3、getProxyClass0方法入口生成一个代理对象的方法1234567891011121314151617181920/** * 生成一个代理对象 * Generate a proxy class. Must call the checkProxyAccess method * to perform permission checks before calling this. */ private static Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123; //接口数量不能大于65535 否则报错 具体为什么 不太清楚 if (interfaces.length &gt; 65535) &#123; throw new IllegalArgumentException(\"interface limit exceeded\"); &#125; //根据类加载器生成代理字节码文件 // If the proxy class defined by the given loader implementing //如果接口存在缓存中们就从缓存中获取 // the given interfaces exists, this will simply return the cached copy; //否则，它将通过proxyClassFactory创建代理类 // otherwise, it will create the proxy class via the ProxyClassFactory return proxyClassCache.get(loader, interfaces); &#125;这一段代码是从缓存中获取代理对象，核心的代码还在里面 proxyClassCache.get(loader, interfaces);因为 proxyClassCache 是一个WeakCache 的类，所以我们先来学习下WeakCache4、WeakCache类WeakCache 方法声明在这个方法中，是直接从一个叫proxyClassCache缓存中读取的，来看一下这个缓存的声明：123456/** * a cache of proxy classes * 缓存代理的class字节码文件，如果没有则使用ProxyClassFactory创建 */ private static final WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt; proxyClassCache = new WeakCache&lt;&gt;(new KeyFactory(), new ProxyClassFactory());里涉及到三个类：WeakCache,KeyFactory,ProxyClassFactory，其中后面两个类都是Proxy类的静态内部类，从类名可以大概猜测到，keyFactory是用来生产key的，ProxyClassFactory是用来生产代理类对象的，这个稍后会提到。WeakCache类的大概结构12345678910111213141516171819202122final class WeakCache&lt;K, P, V&gt; &#123; private final ReferenceQueue&lt;K&gt; refQueue = new ReferenceQueue&lt;&gt;(); // the key type is Object for supporting null key // key的类型为Object，支持null key,这里的null key并不是真的可以使用null最为key,而是一个new Objdec()对象实例。ConcurrentHashMap,不允许键或值null，而HashMap可以。ConcurrentHashMap是线程安全的，HashMap不是。 private final ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map = new ConcurrentHashMap&lt;&gt;(); private final ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = new ConcurrentHashMap&lt;&gt;(); private final BiFunction&lt;K, P, ?&gt; subKeyFactory; private final BiFunction&lt;K, P, V&gt; valueFactory; // 构造方法 public WeakCache(BiFunction&lt;K, P, ?&gt; subKeyFactory, BiFunction&lt;K, P, V&gt; valueFactory) &#123; this.subKeyFactory = Objects.requireNonNull(subKeyFactory); this.valueFactory = Objects.requireNonNull(valueFactory); &#125; //核心入口方法 我们接下来介绍这个类 public V get(K key, P parameter) &#123; &#125; ...上面的源代码中写明，代理对象的核心方法是get , 我们结合上下文 发现 key是loader 类加载器，parameter是接口数组interfaces5、proxyClassCache.get这个对象是从缓存中获取字节码对象，key是接口，value是对象的字节码文件，如果给定的接口存在则返回字节码文件，如果不存在则调用proxyClassFactory创建代理类进行创建123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384/** * return proxyClassCache.get(loader, interfaces); * &lt;p&gt; * 获取代理对象的核心方法 * * @param key 类加载器 loader * @param parameter 接口的数组 interfaces * @return */ public V get(K key, P parameter) &#123; //接口数组不能为空，否则抛出异常 Objects.requireNonNull(parameter); // 删除过时的条目 expungeStaleEntries(); // 生成缓存key对象实例，如果key = null，cacheKey = new Object(); Object cacheKey = WeakCache.CacheKey.valueOf(key, refQueue); // lazily install the 2nd level valuesMap for the particular cacheKey // 从缓存map中读取指定cacheKey的缓存数据valuesMap ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey); if (valuesMap == null) &#123; //如果valuesMap为null,则新增 // putIfAbsent方法解释：如果值存在则返回值，并且不对原来的值做任何更改，如果不存在则新增，并返回null //map.putIfAbsent 是map中新增的一个方法 存在则返回，不存在put然后在返回 ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = new ConcurrentHashMap&lt;&gt;()); //赋值 if (oldValuesMap != null) &#123; valuesMap = oldValuesMap; &#125; &#125; // create subKey and retrieve the possible Supplier&lt;V&gt; stored by that // subKey from valuesMap //获取subKey，这里用到了上面提到的Proxy的静态内部类 KeyFactory:subKeyFactory.apply(ket,parameter) Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter)); // 从valuesMap中获取supplier Supplier&lt;V&gt; supplier = valuesMap.get(subKey); WeakCache.Factory factory = null; while (true) &#123; if (supplier != null) &#123; // supplier might be a Factory or a CacheValue&lt;V&gt; instance // 4、从工厂中获取代理类对象 V value = supplier.get(); if (value != null) &#123; //5、返回 return value; &#125; &#125; // else no supplier in cache // or a supplier that returned null (could be a cleared CacheValue // or a Factory that wasn't successful in installing the CacheValue) // lazily construct a Factory //1、实例化工厂 if (factory == null) &#123; factory = new WeakCache.Factory(key, parameter, subKey, valuesMap); &#125; if (supplier == null) &#123; //2、将supplier保存到valuesMap中 supplier = valuesMap.putIfAbsent(subKey, factory); if (supplier == null) &#123; // successfully installed Factory // 3、赋值 supplier = factory; &#125; // else retry with winning supplier &#125; else &#123; //如果subKey和supplier都匹配则则将supplier替换为新生成的factory if (valuesMap.replace(subKey, supplier, factory)) &#123; // successfully replaced // cleared CacheEntry / unsuccessful Factory // with our Factory //替换成功赋值 supplier = factory; &#125; else &#123; // retry with current supplier //使用当前的supplier进行重试 supplier = valuesMap.get(subKey); &#125; &#125; &#125; &#125;因为程序中Proxy.newProxyInstance是第一次执行，所以while循环开始的时候，supplier，valuesMap都是null。在这个前提下，我为代码的执行顺序做了一个编号，从1-5执行。可以看到第5步，也就是源代码的第47行将结果返回，那么，代理类对象就是在第4步，也就是第43行生成的。而且也可以从第3步，也就是第65行发现supplier就是factory。那么接下来，就分析一下Factory.get方法。6、Factory.get方法Factory类是WeakCache的内部类。这个类中除去构造方法外，就是get方法了，下面是这个代码的实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475 /** * Factory 实现类Supplier 接口 */ private final class Factory implements Supplier&lt;V&gt; &#123;//类加载器 loader private final K key; 接口的数组 interfaces private final P parameter; //这里的subkey 就是上面的 KeyFactory 可以会看 WeakCache 方法声明 private final Object subKey; //提供者的MAP key是KeyFactory ，value 是 Factory 本身 private final ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap; //构造方法 Factory(K key, P parameter, Object subKey, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123; this.key = key; this.parameter = parameter; this.subKey = subKey; this.valuesMap = valuesMap; &#125; @Override public synchronized V get() &#123; // serialize access // re-check //检查 如果 supplier不是自己 返回 Supplier&lt;V&gt; supplier = valuesMap.get(subKey); if (supplier != this) &#123; // something changed while we were waiting: // might be that we were replaced by a CacheValue // or were removed because of failure -&gt; // return null to signal WeakCache.get() to retry // the loop return null; &#125; // else still us (supplier == this) // create new value //定义一个新的对象 V value = null; try &#123; /** * valueFactory就是WeakCache的valueFactory属性，因为Factory是WeakCache的内部类，所以可以直接访问WeakCache的valueFactory属性 * 我们可以回去看看第四第五 proxyClassCache.get 以及 WeakCache 的简单结构 注意valueFactory 发现就是 ProxyClassFactory * 就在这一步生成了 代理对象 */ value = Objects.requireNonNull(valueFactory.apply(key, parameter)); &#125; finally &#123; if (value == null) &#123; // remove us on failure valuesMap.remove(subKey, this); &#125; &#125; // the only path to reach here is with non-null value //校验对象不为空 assert value != null; // wrap value with CacheValue (WeakReference) WeakCache.CacheValue&lt;V&gt; cacheValue = new WeakCache.CacheValue&lt;&gt;(value); // put into reverseMap //缓存代理对象 reverseMap.put(cacheValue, Boolean.TRUE); // try replacing us with CacheValue (this should always succeed) //并将valuesMap替换为最新生成的对象 if (!valuesMap.replace(subKey, this, cacheValue)) &#123; throw new AssertionError(\"Should not reach here\"); &#125; // successfully replaced us with new CacheValue -&gt; return the value // wrapped by it //返回对象 return value; &#125; &#125;我们核心注意的是1value = Objects.requireNonNull(valueFactory.apply(key, parameter));这里的valueFactory就是Proxy的静态内部类ProxyClassFactory，上面也提到过，那么就接着分析ProxyClassFactory的apply方法吧。7、ProxyClassFactory.apply方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128/** * 一个利用给定的类加载器和接口类数组生成，定义并返回代理类对象的工厂方法 * A factory function that generates, defines and returns the proxy class given * the ClassLoader and array of interfaces. */private static final class ProxyClassFactory implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;&#123; // prefix for all proxy class names //所有代理类对象的前缀 这个就回答了为什么代理类都带有$Proxy private static final String proxyClassNamePrefix = \"$Proxy\"; // next number to use for generation of unique proxy class names //用于生成唯一代理类名称的下一个数字 private static final AtomicLong nextUniqueNumber = new AtomicLong(); /** * 开始我们的核心方法apply * @param loader 类加载器 * @param interfaces 接口数组 * @return */ @Override public Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123; Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = new IdentityHashMap&lt;&gt;(interfaces.length); //接口校验循环 for (Class&lt;?&gt; intf : interfaces) &#123; /* * Verify that the class loader resolves the name of this * interface to the same Class object. */ Class&lt;?&gt; interfaceClass = null; try &#123; //加载接口类，获得接口类的类对象，第二个参数为false表示不进行实例化 interfaceClass = Class.forName(intf.getName(), false, loader); &#125; catch (ClassNotFoundException e) &#123; &#125; //进行校验 if (interfaceClass != intf) &#123; throw new IllegalArgumentException( intf + \" is not visible from class loader\"); &#125; /* * Verify that the Class object actually represents an * interface. * 验证是否是接口 不是接口报错 */ if (!interfaceClass.isInterface()) &#123; throw new IllegalArgumentException( interfaceClass.getName() + \" is not an interface\"); &#125; /* * Verify that this interface is not a duplicate. * 验证此接口不是重复的，重复的就报错 */ if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) &#123; throw new IllegalArgumentException( \"repeated interface: \" + interfaceClass.getName()); &#125; &#125; //代理类的包名 String proxyPkg = null; // package to define proxy class in //访问权限 int accessFlags = Modifier.PUBLIC | Modifier.FINAL; /* * Record the package of a non-public proxy interface so that the * proxy class will be defined in the same package. Verify that * all non-public proxy interfaces are in the same package. */ for (Class&lt;?&gt; intf : interfaces) &#123; int flags = intf.getModifiers(); //如果接口是public就跳过 我们的接口基本上不会走这里 if (!Modifier.isPublic(flags)) &#123; accessFlags = Modifier.FINAL; String name = intf.getName(); int n = name.lastIndexOf('.'); String pkg = ((n == -1) ? \"\" : name.substring(0, n + 1)); if (proxyPkg == null) &#123; proxyPkg = pkg; &#125; else if (!pkg.equals(proxyPkg)) &#123; throw new IllegalArgumentException( \"non-public interfaces from different packages\"); &#125; &#125; &#125; if (proxyPkg == null) &#123; // if no non-public proxy interfaces, use com.sun.proxy package //如果没有public的接口 就是用 com.sun.proxy 的包前缀 //类似于com.sun.proxy.$Proxy0 proxyPkg = ReflectUtil.PROXY_PACKAGE + \".\"; &#125; /* * Choose a name for the proxy class to generate. * 生成代理类的类名 */ //生成代理类的序号 long num = nextUniqueNumber.getAndIncrement(); //生成代理类的完全限定名 String proxyName = proxyPkg + proxyClassNamePrefix + num; /* * Generate the specified proxy class. * 生成代理类class文件 * 这个是生成的核心方法 */ byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags); try &#123; //返回代理类对象 return defineClass0(loader, proxyName, proxyClassFile, 0, proxyClassFile.length); &#125; catch (ClassFormatError e) &#123; /* * A ClassFormatError here means that (barring bugs in the * proxy class generation code) there was some other * invalid aspect of the arguments supplied to the proxy * class creation (such as virtual machine limitations * exceeded). */ throw new IllegalArgumentException(e.toString()); &#125; &#125;&#125;在代码的第111行，生成了代理类的class文件，并且在115行返回了我们需要的代理类对象。那么怎么找到这个生成的代理类class文件呢？到这里 我们就跟完了动态代理的核心流程，我们解释了为什么 代理类都带有$Proxy，以及后面的序号是怎么来的。生成代码的核心代码是12byte[] proxyClassFile = ProxyGenerator.generateProxyClass( proxyName, interfaces, accessFlags);ProxyGenerator是根据代理名称接口生成代理类的核心代码，我们就不跟进去了，以后有时间再进去，里面都是字节码操作的知识了，也是在sun.misc包下，一般是不开源的，如果需要可以去下载sun包的源码，1.8之后就不开源了。查看生成的代理类我们上面最终跟到了ProxyGenerator类，ProxyGenerator是生成字节码文件的核心代码，我们想看下生成的字节码怎么办呢，我们自己去生成并且输出出来。看代码1234567//生成代理字节码数组文件 传入一个接口数组byte[] proxyClassFile = ProxyGenerator.generateProxyClass(\"com.sun.proxy\", new Class[]&#123;Buying.class&#125;, 1);//将字节数组转换成class文件并输出到本地 FileOutputStream fos = new FileOutputStream(new File(\"d:/com.sun.proxy.class\")); fos.write(proxyClassFile); fos.flush(); fos.close();我们反编译以下 com.sun.proxy.class12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485//继承了Proxy类，实现了Buying接口public class proxy extends Proxy implements Buying &#123; private static Method m1; private static Method m2; private static Method m3; private static Method m0; //构造方法，直接调用了父类，也就是Proxy的构造方法，参数paramInvocationHandler就是我们的BuingHandler实例化对象handler public proxy(InvocationHandler paramInvocationHandler) &#123; super(paramInvocationHandler); &#125; /** * 实现equals 方法 * @param var1 * @return */ public final boolean equals(Object var1) &#123; try &#123; return (Boolean)super.h.invoke(this, m1, new Object[]&#123;var1&#125;); &#125; catch (RuntimeException | Error var3) &#123; throw var3; &#125; catch (Throwable var4) &#123; throw new UndeclaredThrowableException(var4); &#125; &#125; /** * 实现toString方法 * @return */ public final String toString() &#123; try &#123; return (String)super.h.invoke(this, m2, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; //实现了Buying 接口的 buy public final String buy() &#123; try &#123; /** * 这里的h就是我们的BuingHandler 实例 * 调用 父类 Proxy 里面我们传入的 BuingHandler 对象 */ return (String)super.h.invoke(this, m3, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; /** * 实现了hashCode方法 * @return */ public final int hashCode() &#123; try &#123; return (Integer)super.h.invoke(this, m0, (Object[])null); &#125; catch (RuntimeException | Error var2) &#123; throw var2; &#125; catch (Throwable var3) &#123; throw new UndeclaredThrowableException(var3); &#125; &#125; //静态代码块，做初始化操作 static &#123; try &#123; //通过反射，获取Object对象方法对象的equals 方法 m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\")); //通过反射，获取Object对象方法对象的toString 方法 m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\"); //通过反射，获取Buying对象方法对象的buy 方法 m3 = Class.forName(\"com.test.proxy.Buying\").getMethod(\"buy\"); //通过反射，获取Object对象方法对象的hashCode 方法 m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\"); &#125; catch (NoSuchMethodException var2) &#123; throw new NoSuchMethodError(var2.getMessage()); &#125; catch (ClassNotFoundException var3) &#123; throw new NoClassDefFoundError(var3.getMessage()); &#125; &#125;&#125;代理类实例化的代码是：cons.newInstance(new Object[]{h})。这里是通过反射调用代理类对象的构造方法，传入了参数h（我们的BuingHandler实例化对象handler）。​ 这个构造方法，就是上述反编译代码里的构造方法，而上述反编译代码里的构造方法调用了Proxy类的构造方法，来看一下Proxy类的构造方法：1234567protected InvocationHandler h;protected Proxy(InvocationHandler h) &#123; Objects.requireNonNull(h); this.h = h;&#125;​ 这里将我们传入的handler直接赋值给了InvocationHandler h。上述反编译代码中的super.h 就是我们传入的handler。所以proxy.buy();方法在执行的时候会去调用BuingHandler类的invoke方法。好了到这里我们的源码解析已经完了。","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"动态代理","slug":"源码/动态代理","permalink":"http://www.baiyp.ren/categories/源码/动态代理/"}],"tags":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"动态代理","slug":"动态代理","permalink":"http://www.baiyp.ren/tags/动态代理/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"动态代理","slug":"源码/动态代理","permalink":"http://www.baiyp.ren/categories/源码/动态代理/"}]},{"title":"java中AQS-03源代码实现","slug":"java中的AQS-03","date":"2019-08-11T09:47:16.000Z","updated":"2019-09-07T09:07:49.640Z","comments":true,"path":"java中的AQS-03.html","link":"","permalink":"http://www.baiyp.ren/java中的AQS-03.html","excerpt":"","text":"java中AQS的源代码实现AQS的源代码实现主要通过独占式同步状态的获取和释放、共享式同步状态的获取和释放来看下AQS是如何实现的。独占式同步状态的获取和释放独占式同步状态调用的方法是acquire，代码如下：12345public final void acquire(long arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125;​ 上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：首先调用子类实现的tryAcquire方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造独占式同步节点（同一时刻只能有一个线程成功获取同步状态）并通过addWaiter方法将该节点加入到同步队列的尾部，最后调用acquireQueued方法，使得该节点以自旋的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。下面来首先来看下节点构造和加入同步队列是如何实现的。代码如下：12345678910111213141516171819202122232425262728293031323334353637private Node addWaiter(Node mode) &#123; // 当前线程构造成Node节点 Node node = new Node(Thread.currentThread(), mode); // Try the fast path of enq; backup to full enq on failure // 尝试快速在尾节点后新增节点 提升算法效率 先将尾节点指向pred Node pred = tail; if (pred != null) &#123; //尾节点不为空 当前线程节点的前驱节点指向尾节点 node.prev = pred; //并发处理 尾节点有可能已经不是之前的节点 所以需要CAS更新 if (compareAndSetTail(pred, node)) &#123; //CAS更新成功 当前线程为尾节点 原先尾节点的后续节点就是当前节点 pred.next = node; return node; &#125; &#125; //第一个入队的节点或者是尾节点后续节点新增失败时进入enq enq(node); return node; &#125;private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize //尾节点为空 第一次入队 设置头尾节点一致 同步队列的初始化 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //所有的线程节点在构造完成第一个节点后 依次加入到同步队列中 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125;​ 节点进入同步队列之后，就进入了一个自旋的过程，每个线程节点都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中并会阻塞节点的线程，代码如下：12345678910111213141516171819202122232425final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取当前线程节点的前驱节点 final Node p = node.predecessor(); //前驱节点为头节点且成功获取同步状态 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //设置当前节点为头节点 setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; //是否阻塞 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125;再来看看shouldParkAfterFailedAcquire和parkAndCheckInterrupt是怎么来阻塞当前线程的，代码如下：123456789101112131415161718192021222324252627282930313233private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; //前驱节点的状态决定后续节点的行为 int ws = pred.waitStatus; if (ws == Node.SIGNAL) /*前驱节点为-1 后续节点可以被阻塞 * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123; /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /*前驱节点是初始或者共享状态就设置为-1 使后续节点阻塞 * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false; &#125;private final boolean parkAndCheckInterrupt() &#123; //阻塞线程 LockSupport.park(this); return Thread.interrupted(); &#125;节点自旋的过程大致示意图如下，其实就是对图二、图三的补充。整个独占式获取同步状态的流程图大致如下：​ 当同步状态获取成功之后，当前线程从acquire方法返回，对于锁这种并发组件而言，就意味着当前线程获取了锁。有获取同步状态的方法，就存在其对应的释放方法，该方法为release，现在来看下这个方法的实现，代码如下：12345678910111213141516171819202122232425262728293031323334353637public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123;//同步状态释放成功 Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) //直接释放头节点 unparkSuccessor(h); return true; &#125; return false; &#125;private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /*寻找符合条件的后续节点 * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) //唤醒后续节点 LockSupport.unpark(s.thread); &#125;​ 独占式释放是非常简单而且明确的。总结下独占式同步状态的获取和释放：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用tryRelease方法释放同步状态，然后唤醒头节点的后继节点。共享式同步状态的获取和释放共享式同步状态调用的方法是acquireShared，代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public final void acquireShared(int arg) &#123; //获取同步状态的返回值大于等于0时表示可以获取同步状态 //小于0时表示可以获取不到同步状态 需要进入队列等待 if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125;private void doAcquireShared(int arg) &#123; //和独占式一样的入队操作 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; //自旋 for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; //前驱结点为头节点且成功获取同步状态 可退出自旋 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125;private void setHeadAndPropagate(Node node, int propagate) &#123; Node h = head; // Record old head for check below //退出自旋的节点变成首节点 setHead(node); /* * Try to signal next queued node if: * Propagation was indicated by caller, * or was recorded (as h.waitStatus either before * or after setHead) by a previous operation * (note: this uses sign-check of waitStatus because * PROPAGATE status may transition to SIGNAL.) * and * The next node is waiting in shared mode, * or we don't know, because it appears null * * The conservatism in both of these checks may cause * unnecessary wake-ups, but only when there are multiple * racing acquires/releases, so most need signals now or soon * anyway. */ if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; if (s == null || s.isShared()) doReleaseShared(); &#125; &#125;与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared方法可以释放同步状态，代码如下：1234567891011121314151617181920212223242526272829public final boolean releaseShared(int arg) &#123; //释放同步状态 if (tryReleaseShared(arg)) &#123; //唤醒后续等待的节点 doReleaseShared(); return true; &#125; return false; &#125;private void doReleaseShared() &#123; //自旋 for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases //唤醒后续节点 unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125;unparkSuccessor方法和独占式是一样的。","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"并发","slug":"源码/并发","permalink":"http://www.baiyp.ren/categories/源码/并发/"},{"name":"高级","slug":"源码/并发/高级","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/"},{"name":"AQS","slug":"源码/并发/高级/AQS","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/AQS/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"高级","slug":"高级","permalink":"http://www.baiyp.ren/tags/高级/"},{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"AQS","slug":"AQS","permalink":"http://www.baiyp.ren/tags/AQS/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"并发","slug":"源码/并发","permalink":"http://www.baiyp.ren/categories/源码/并发/"},{"name":"高级","slug":"源码/并发/高级","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/"},{"name":"AQS","slug":"源码/并发/高级/AQS","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/AQS/"}]},{"title":"CLH队列锁的原理","slug":"CLH队列锁","date":"2019-08-11T09:24:14.000Z","updated":"2019-09-07T09:07:49.633Z","comments":true,"path":"CLH队列锁.html","link":"","permalink":"http://www.baiyp.ren/CLH队列锁.html","excerpt":"","text":"CLH队列锁的原理什么是CLH队列锁​ CLH锁是有由Craig, Landin, and Hagersten这三个人发明的锁，取了三个人名字的首字母，所以叫 CLH Lock。​ CLH锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性。​ CLH队列锁也是一种基于链表的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。就像这样当一个线程需要获取锁时创建一个的QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱结点的引用线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred线程B需要获得锁，同样的流程再来一遍线程就在前驱结点的locked字段上旋转，直到前驱结点释放锁(前驱节点的锁值 locked ==false)当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点如上图所示，前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。Java中的AQS是CLH队列锁的一种变体实现。扩展知识SMP(Symmetric Multi-Processor)​ 对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。​ SMP能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，​ 可能会导致CPU资源的浪费。常用的PC机就属于这种。NUMA(Non-Uniform Memory Access)​ 非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，​ 访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度，这也是非一致存储访问的由来。NUMA较好地解决SMP的扩展问题，当CPU数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。CLH 的缺点CLH唯一的缺点是在NUMA系统结构下性能很差，但是在SMP系统结构下该法还是非常有效的。解决NUMA系统结构的思路是MCS队列锁","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"高级","slug":"并发/高级","permalink":"http://www.baiyp.ren/categories/并发/高级/"},{"name":"队列锁","slug":"并发/高级/队列锁","permalink":"http://www.baiyp.ren/categories/并发/高级/队列锁/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"高级","slug":"高级","permalink":"http://www.baiyp.ren/tags/高级/"},{"name":"队列锁","slug":"队列锁","permalink":"http://www.baiyp.ren/tags/队列锁/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"高级","slug":"并发/高级","permalink":"http://www.baiyp.ren/categories/并发/高级/"},{"name":"队列锁","slug":"并发/高级/队列锁","permalink":"http://www.baiyp.ren/categories/并发/高级/队列锁/"}]},{"title":"java中的读写锁","slug":"java中的读写锁","date":"2019-08-11T08:35:32.000Z","updated":"2019-08-22T02:06:51.109Z","comments":true,"path":"java中的读写锁.html","link":"","permalink":"http://www.baiyp.ren/java中的读写锁.html","excerpt":"","text":"java中的读写锁ReentrantReadWriteLock 读写锁​ 之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。​ 除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。改用读写锁实现上述功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量ReentrantReadWriteLock其实实现的是ReadWriteLock接口ReadWriteLock接口123456public interface ReadWriteLock &#123; //获取读锁 Lock readLock(); //获取写锁 Lock writeLock();&#125;ReentrantReadWriteLock类构造方法12345//创建一个ReentrantReadWriteLock实例.ReentrantReadWriteLock() //创建一个具有给定公平策略的ReentrantReadWriteLock实例.ReentrantReadWriteLock(boolean fair)常用方法摘要1234567891011121314//返回用于读取操作的锁.Lock ReentrantReadWriteLock.ReadLock.readLock() //返回用于写入操作的锁.Lock ReentrantReadWriteLock.WriteLock.writeLock()//返回等待获取读取或写入锁的线程估计数目.int getQueueLength()//如果此锁的公平设置为 true,则返回 true.boolean isFair()//返回标识此锁及其锁状态的字符串.String toString()ReadLock/WriteLock静态内部类1234567891011121314151617181920//试图获取锁.void lock() //如果当前线程未被中断,则获取锁.void lockInterruptibly() //返回绑定到此 Lock 实例的新 Condition 实例.Condition newCondition() //仅在调用时锁为空闲状态才获取该锁.boolean tryLock() //如果锁在给定的等待时间内空闲,并且当前线程未被中断,则获取锁.boolean tryLock(long time， TimeUnit unit) //试图释放锁.void unlock()//返回标识此锁及其锁状态的字符串.String toString()因为ReadLock不支持条件，因此当调用了ReadLock的newCondition()方法时将会抛出UnsupportedOperationException异常。使用ReentrantReadWriteLock的读锁以及写锁，将会遵循读读共享、写写互斥、读写互斥。使用示例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class ReentrantReadWriteLockTest &#123; /** * 创建线程池 */ private static ExecutorService executorService = Executors.newCachedThreadPool(); /** * 创建读写锁 */ private static ReadWriteLock lock = new ReentrantReadWriteLock(); /** * 读锁 */ private static Lock readLock = lock.readLock(); /** * 获取写锁 */ private static Lock writeLock = lock.writeLock(); /** * 读操作 */ public static void reading() &#123; System.out.println(\"尝试获取读锁：\" + Thread.currentThread().getId()); readLock.lock(); System.out.println(\"获取读锁成功：\" + Thread.currentThread().getId()); try &#123; System.out.println(\"开始进行读操作：\" + Thread.currentThread().getId()); Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; System.out.println(\"释放读锁成功：\" + Thread.currentThread().getId()); readLock.unlock(); &#125; &#125; /** * 读操作 */ public static void writing() &#123; System.out.println(\"尝试获取写锁：\" + Thread.currentThread().getId()); writeLock.lock(); System.out.println(\"获取写锁成功：\" + Thread.currentThread().getId()); try &#123; System.out.println(\"开始进行写操作：\" + Thread.currentThread().getId()); &#125; finally &#123; System.out.println(\"释放写锁成功：\" + Thread.currentThread().getId()); writeLock.unlock(); &#125; &#125;&#125;读读共享1234567public static void main(String[] args) &#123; //读读共享 for (int i = 0; i &lt; 3; i++) &#123; executorService.submit(() -&gt; reading()); &#125; executorService.shutdown(); &#125;输出123456789101112尝试获取读锁：12尝试获取读锁：14尝试获取读锁：13获取读锁成功：14开始进行读操作：14获取读锁成功：12开始进行读操作：12获取读锁成功：13开始进行读操作：13释放读锁成功：12释放读锁成功：14释放读锁成功：13读锁能被多个线程同时获取，能提高读取的效率 (虽然只用读锁时可以不进行释放，但会影响写锁的获取)写写互斥1234567public static void main(String[] args) &#123; //读读共享 for (int i = 0; i &lt; 3; i++) &#123; executorService.submit(() -&gt; writing()); &#125; executorService.shutdown(); &#125;输出123456789101112尝试获取写锁：12尝试获取写锁：13尝试获取写锁：14获取写锁成功：12开始进行写操作：12释放写锁成功：12获取写锁成功：13开始进行写操作：13释放写锁成功：13获取写锁成功：14开始进行写操作：14释放写锁成功：14写锁同一时刻只能被一个线程获取。读写互斥123456789101112 public static void main(String[] args) &#123; //读写互斥 for (int i = 0; i &lt; 3; i++) &#123; executorService.submit(() -&gt; &#123; reading(); &#125;); executorService.submit(() -&gt; &#123; writing(); &#125;); &#125; executorService.shutdown();&#125;输出123456789101112131415161718192021222324尝试获取读锁：12获取读锁成功：12开始进行读操作：12尝试获取写锁：13尝试获取读锁：14尝试获取写锁：15尝试获取读锁：16尝试获取写锁：17释放读锁成功：12获取写锁成功：13开始进行写操作：13释放写锁成功：13获取读锁成功：14开始进行读操作：14释放读锁成功：14获取写锁成功：15开始进行写操作：15释放写锁成功：15获取读锁成功：16开始进行读操作：16释放读锁成功：16获取写锁成功：17开始进行写操作：17释放写锁成功：17​ 读的时候不能写，写的时候不能读，即获取读锁时如果写锁此时被线程持有则将等待写锁被释放，获取写锁时如果读锁此时有被线程持有则将等待读锁被释放且写锁未被持有。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"高级","slug":"并发/高级","permalink":"http://www.baiyp.ren/categories/并发/高级/"},{"name":"读写锁","slug":"并发/高级/读写锁","permalink":"http://www.baiyp.ren/categories/并发/高级/读写锁/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"高级","slug":"高级","permalink":"http://www.baiyp.ren/tags/高级/"},{"name":"读写锁","slug":"读写锁","permalink":"http://www.baiyp.ren/tags/读写锁/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"高级","slug":"并发/高级","permalink":"http://www.baiyp.ren/categories/并发/高级/"},{"name":"读写锁","slug":"并发/高级/读写锁","permalink":"http://www.baiyp.ren/categories/并发/高级/读写锁/"}]},{"title":"JAVA设计模式01-单例模式","slug":"JAVA设计模式01","date":"2019-08-11T01:42:30.000Z","updated":"2019-09-05T10:28:45.247Z","comments":true,"path":"JAVA设计模式01.html","link":"","permalink":"http://www.baiyp.ren/JAVA设计模式01.html","excerpt":"","text":"JAVA设计模式-单例模式(Singleton Pattern)​什么是单例模式​ 单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。​ 这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。​ 确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式是一种对象创建型模式。关键代码：构造函数是私有的。特点某个类只能有一个实它必须自行创建这个实例它必须自行向整个系统提供这个实例作用控制资源的使用，通过线程同步来控制资源的并发访问；控制实例产生的数量，达到节约资源的目的。作为通信媒介使用，也就是数据共享，它可以在不建立直接关联的条件下，让多个不相关的两个线程或者进程之间实现通信。适用场景系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器或资源管理器，或者需要考虑资源消耗太大而只允许创建一个对象。客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。优缺点优点提供了对唯一实例的受控访问。由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象单例模式无疑可以提高系统的性能。允许可变数目的实例。缺点由于单利模式中没有抽象层，因此单例类的扩展有很大的困难。单例类的职责过重，在一定程度上违背了“单一职责原则“。滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；如果实例化的对象长时间不被利用，系统会认为是垃圾而被回收，这将导致对象状态的丢失。实现方式1. 懒汉式，线程不安全这种方式是最基本的实现方式，这种实现最大的问题就是不支持多线程。因为没有加锁 synchronized，所以严格意义上它并不算单例模式。1234567891011public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125;这种写法lazy loading很明显，但是致命的是在多线程不能正常工作。2. 懒汉式，线程安全这种方式具备很好的 lazy loading，能够在多线程中很好的工作，但是，效率很低，99% 情况下不需要同步。优点：第一次调用才初始化，避免内存浪费。缺点：必须加锁 synchronized 才能保证单例，但加锁会影响效率。12345678910public class Singleton &#123; private static Singleton instance; private Singleton ()&#123;&#125; public static synchronized Singleton getInstance() &#123; if (instance == null) &#123; instance = new Singleton(); &#125; return instance; &#125; &#125;2. 饿汉式这种方式比较常用，但容易产生垃圾对象。优点：没有加锁，执行效率会提高。缺点：类加载时就初始化，浪费内存。1234567public class Singleton &#123; private static Singleton instance = new Singleton(); private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return instance; &#125; &#125;它基于 classloader 机制避免了多线程的同步问题，不过，instance 在类装载时就实例化，虽然导致类装载的原因有很多种，在单例模式中大多数都是调用 getInstance 方法， 但是也不能确定有其他的方式（或者其他的静态方法）导致类装载，这时候初始化 instance 显然没有达到 lazy loading 的效果。4. 饿汉式(变种)这种也比较常用，static静态块只会的Singleton类创建的时候执行一次。1234567891011121314public class Singleton &#123; private Singleton instance = null; static &#123; instance = new Singleton(); &#125; private Singleton ()&#123;&#125; public static Singleton getInstance() &#123; return this.instance; &#125; &#125;表面上看起来差别挺大，其实和第三种方式差不多，都是在类初始化即实例化instance。5. 静态内部类这种方式能达到双检锁方式一样的功效，但实现更简单。对静态域使用延迟初始化，应使用这种方式而不是双检锁方式。这种方式只适用于静态域的情况，双检锁方式可在实例域需要延迟初始化时使用。1234567891011121314public class Singleton &#123; private static class SingletonHolder &#123; private static final Singleton INSTANCE = new Singleton(); &#125; private Singleton ()&#123;&#125; public static final Singleton getInstance() &#123; return SingletonHolder.INSTANCE; &#125; &#125;由于静态单例对象没有作为Singleton的成员变量直接实例化，因此类加载时不会实例化Singleton，第一次调用getInstance()时将加载内部类HolderClass，在该内部类中定义了一个static类型的变量instance，此时会首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于getInstance()方法没有任何线程锁定，因此其性能不会造成任何影响。通过使用IoDH，我们既可以实现延迟加载，又可以保证线程安全，不影响系统性能，不失为一种最好的Java语言单例模式实现方式（其缺点是与编程语言本身的特性相关，很多面向对象语言不支持IoDH）6. 枚举这种实现方式还没有被广泛采用，但这是实现单例模式的最佳方法。它更简洁，自动支持序列化机制，绝对防止多次实例化。这种方式是 Effective Java 作者 Josh Bloch 提倡的方式，它不仅能避免多线程同步问题，而且还自动支持序列化机制，防止反序列化重新创建新的对象，绝对防止多次实例化。不过，由于 JDK1.5 之后才加入 enum 特性，用这种方式写不免让人感觉生疏，在实际工作中，也很少用。不能通过 reflection attack 来调用私有构造方法。12345public enum Singleton &#123; INSTANCE; public void whateverMethod() &#123; &#125; &#125;一般情况下，不建议使用懒汉方式，建议使用种饿汉方式。只有在要明确实现 lazy loading 效果时，才会使用登记方式。如果涉及到反序列化创建对象时，可以尝试使用枚举方式。如果有其他特殊的需求，可以考虑使用双检锁方式。7. 双重校验锁这种方式采用双锁机制，安全且在多线程情况下能保持高性能。1234567891011121314public class Singleton &#123; private volatile static Singleton singleton; private Singleton ()&#123;&#125; public static Singleton getSingleton() &#123; if (singleton == null) &#123; synchronized (Singleton.class) &#123; if (singleton == null) &#123; singleton = new Singleton(); &#125; &#125; &#125; return singleton; &#125; &#125;在JDK1.5之后，双重检查锁定才能够正常达到单例效果。总结​ 第三种和第五种方式，简单易懂，而且在JVM层实现了线程安全（如果不是多个类加载器环境），一般的情况下，我会使用第三种方式，只有在要明确实现lazy loading效果时才会使用第五种方式，另外，如果涉及到反序列化创建对象时，可以试着使用枚举的方式来实现单例，不过，我一直会保证我的程序是线程安全的，而且我永远不会使用第一种和第二种方式，如果有其他特殊的需求，我可能会使用第七种方式，毕竟，JDK1.5已经没有双重检查锁定的问题了。不过一般来说，第一种不算单例，第四种和第三种就是一种，如果算的话，第五种也可以分开写了。所以说，一般单例都是五种写法。懒汉，恶汉，双重校验锁，枚举和静态内部类。饿汉式和懒汉式饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多线程访问问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理好多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然涉及资源初始化，而资源初始化很有可能耗费大量时间，这意味着出现多线程同时首次引用此类的机率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"单例模式","slug":"设计模式/单例模式","permalink":"http://www.baiyp.ren/categories/设计模式/单例模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/tags/设计模式/"},{"name":"单例模式","slug":"单例模式","permalink":"http://www.baiyp.ren/tags/单例模式/"}],"keywords":[{"name":"设计模式","slug":"设计模式","permalink":"http://www.baiyp.ren/categories/设计模式/"},{"name":"单例模式","slug":"设计模式/单例模式","permalink":"http://www.baiyp.ren/categories/设计模式/单例模式/"}]},{"title":"java中AQS-02方法结构","slug":"java中的AQS-02","date":"2019-08-10T09:47:16.000Z","updated":"2019-09-07T09:07:49.637Z","comments":true,"path":"java中的AQS-02.html","link":"","permalink":"http://www.baiyp.ren/java中的AQS-02.html","excerpt":"","text":"java中AQS的方法结构AQS的方法结构如果我们理解了上一节的设计思路，我们大致就能知道AQS的主要数据结构了。组件数据结构同步状态volatile int state阻塞LockSupport类队列Node节点条件队列ConditionObject进而再来看下AQS的主要方法及其作用。属性、方法描述、作用int getState()获取当前同步状态void setState(int newState)设置当前同步状态boolean compareAndSetState(int expect, int update)通过CAS设置当前状态，此方法保证状态设置的原子性boolean tryAcquire(int arg)钩子方法，独占式获取同步状态，AQS没有具体实现，具体实现都在子类中，实现此方法需要查询当前同步状态并判断同步状态是否符合预期，然后再CAS设置同步状态boolean tryRelease(int arg)钩子方法，独占式释放同步状态，AQS没有具体实现，具体实现都在子类中，等待获取同步状态的线程将有机会获取同步状态int tryAcquireShared(int arg)钩子方法，共享式获取同步状态，AQS没有具体实现，具体实现都在子类中，返回大于等于0的值表示获取成功，反之失败boolean tryReleaseShared(int arg)钩子方法，共享式释放同步状态，AQS没有具体实现，具体实现都在子类中boolean isHeldExclusively()钩子方法，AQS没有具体实现，具体实现都在子类中，当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占void acquire(int arg)模板方法，独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则会进入同步队列等待，此方法会调用子类重写的tryAcquire方法void acquireInterruptibly(int arg)模板方法，与acquire相同，但是此方法可以响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，此方法会抛出InterruptedException并返回boolean tryAcquireNanos(int arg, long nanosTimeout)模板方法，在acquireInterruptibly基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，则会返回false,如果获取到了则会返回trueboolean release(int arg)模板方法，独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中的第一个节点包含的线程唤醒void acquireShared(int arg)模板方法，共享式的获取同步状态，如果当前系统未获取到同步状态，将会进入同步队列等待，与acquire的主要区别在于同一时刻可以有多个线程获取到同步状态void acquireSharedInterruptibly(int arg)模板方法，与acquireShared一致，但是可以响应中断boolean tryAcquireSharedNanos(int arg, long nanosTimeout)模板方法，在acquireSharedInterruptibly基础上增加了超时限制boolean releaseShared(int arg)模板方法，共享式的释放同步状态CollectiongetQueuedThreads()模板方法，获取等待在同步队列上的线程集合Node int waitStatus等待状态1、 CANCELLED，值为1，在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待，节点进入该状态后将不会变化；2、 SIGNAL，值为-1，后续节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后续节点，使后续节点的线程得以运行；3、 CONDITION，值为-2，节点在条件队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点将会从条件队列中转移到同步队列中，加入到对同步状态的获取中；4、 PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地传播下去Node prev前驱节点，当节点加入同步队列时被设置Node next后续节点Thread thread获取同步状态的线程Node nextWaiter条件队列中的后续节点，如果当前节点是共享的，那么这个字段将是一个SHARED变量，也就是说节点类型（独占和共享）和条件队列中的后续节点共用同一个字段LockSupport void park()阻塞当前线程，如果调用unpark方法或者当前线程被中断，才能从park方法返回LockSupport void unpark(Thread thread)唤醒处于阻塞状态的线程ConditionObject Node firstWaiter条件队列首节点ConditionObject Node lastWaiter条件队列尾节点void await()当前线程进入等待状态直到signal或中断，当前线程将进入运行状态且从await方法返回的情况，包括：其他线程调用该Condition的signal或者signalAll方法，且当前线程被选中唤醒；其他线程调用interrupt方法中断当前线程；如果当前线程从await方法返回表明该线程已经获取了Condition对象对应的锁void awaitUninterruptibly()和await方法类似，但是对中断不敏感long awaitNanos(long nanosTimeout)当前线程进入等待状态直到被signal、中断或者超时。返回值表示剩余的时间。boolean awaitUntil(Date deadline)当前线程进入等待状态直到被signal、中断或者某个时间。如果没有到指定时间就被通知，方法返回true，否则表示到了指定时间，返回falsevoid signal()唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁void signalAll()唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关联的锁看到这，我们对AQS的数据结构应该基本上有一个大致的认识，有了这个基本面的认识，我们就可以来看下AQS的源代码。","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"并发","slug":"源码/并发","permalink":"http://www.baiyp.ren/categories/源码/并发/"},{"name":"高级","slug":"源码/并发/高级","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/"},{"name":"AQS","slug":"源码/并发/高级/AQS","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/AQS/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"高级","slug":"高级","permalink":"http://www.baiyp.ren/tags/高级/"},{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"AQS","slug":"AQS","permalink":"http://www.baiyp.ren/tags/AQS/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"并发","slug":"源码/并发","permalink":"http://www.baiyp.ren/categories/源码/并发/"},{"name":"高级","slug":"源码/并发/高级","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/"},{"name":"AQS","slug":"源码/并发/高级/AQS","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/AQS/"}]},{"title":"java中的显示锁Lock","slug":"java中的显示锁","date":"2019-08-10T01:41:11.000Z","updated":"2019-09-07T09:07:49.641Z","comments":true,"path":"java中的显示锁.html","link":"","permalink":"http://www.baiyp.ren/java中的显示锁.html","excerpt":"","text":"java中的显示锁Lock​ 什么是显示锁在Java 1.5之前，协调对共享对象的访问可以使用的机制只有synchronized和volatile两种。Java1.5增加了一种新的机制,Lock,Lock是一个接口，提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有的加锁和解锁操作方法都是显示的，因而称为显示锁,Lock并不是替代内置加锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。Lock和synchronized的比较synchronized代码更简洁Lock可以在获取锁可以被中断，超时获取锁，尝试获取锁synchronized在1.8以前是性能低下的，到了1.8之后经过改良，性能基本行和Lock相持平，如果不是特殊场景推荐使用synchronized。Lock 的实现类ReentrantLockReentrantReadWriteLockLock的API1234567891011121314public interface Lock &#123; //获取锁 void lock(); //可中断锁，在获取锁的过程中可以中断线程 void lockInterruptibly() throws InterruptedException; //尝试获取锁，如果成功返回true，否则返回false boolean tryLock(); //超时获取锁， boolean tryLock(long time, TimeUnit unit) throws InterruptedException; //释放锁 void unlock(); //获取Condition 对象 Condition newCondition();Lock 使用的标准范式12345678 //加锁lock.lock();try &#123; //todo 需要加锁的代码&#125; finally &#123; //释放锁 lock.unlock();&#125;Condition接口​ 任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。12345678910111213141516171819202122public interface Condition &#123; //使当前线程在接收到信号前或被中断前一直保持等待状态. void await() throws InterruptedException; //使当前线程在接收到信号前或被中断前或达到指定时间前一直保持等待状态(TimeUnit为时间单位). boolean await(long time, TimeUnit unit) throws InterruptedException; //使当前线程在接收到信号前或被中断前或达到指定时间前一直保持等待状态(单位为毫秒). long awaitNanos(long nanosTimeout) throws InterruptedException; //使当前线程在接收到信号前或被中断前或达到最后日期期限前一直保持等待状态. boolean awaitUntil(Date deadline) throws InterruptedException; //是当前线程进入等待状态，对中断不敏感 void awaitUninterruptibly(); //唤醒一个在该Condition实例等待的线程. void signal(); //唤醒所有在该Condition实例等待的线程. void signalAll();Condition 使用的标准范式123456789101112131415161718192021222324252627282930313233343536/** * 创建一个显示锁对象 */private Lock lock = new ReentrantLock();/** * 创建 Condition 对象 */private Condition condition = lock.newCondition();/** * 等待方法 * * @throws InterruptedException */public void conditionWait() throws InterruptedException &#123; lock.lock(); try &#123; condition.await(); &#125; finally &#123; lock.unlock(); &#125;&#125;/** * 唤醒方法 * * @throws InterruptedException */public void conditionSignal() throws InterruptedException &#123; lock.lock(); try &#123; condition.signal(); &#125; finally &#123; lock.unlock(); &#125;&#125;ReentrantLock锁可重入​ 简单地讲就是：“同一个线程对于已经获得到的锁，可以多次继续申请到该锁的使用权”。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。ReentrantLock在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。公平和非公平锁​ 如果在时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。 ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高。​ 在激烈竞争的情况下,非公平锁的性能高于公平锁的性能的一个原因是:在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程A持有一个锁,并且线程B请求这个锁。由于这个锁已被线程A持有,因此B将被挂起。当A释放锁时,B将被唤醒,因此会再次尝试获取锁。与此同时,如果C也请求这个锁,那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面:B获得锁的时刻并没有推迟,C更早地获得了锁,并且吞吐量也获得了提高。使用示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 创建线程池 */private static ExecutorService executorService = Executors.newCachedThreadPool();/** * 创建一个显示锁对象 */private static Lock lock = new ReentrantLock();/** * 创建 Condition 对象 */private static Condition condition = lock.newCondition();/** * 生产者 */private static void handel() &#123; System.out.println(\"尝试获取锁,线程：\" + Thread.currentThread().getId()); lock.lock(); System.out.println(\"获取锁成功,线程：\" + Thread.currentThread().getId()); try &#123; System.out.println(\"使线程进入等待状态,线程：\" + Thread.currentThread().getId()); //进入等待状态并释放所资源 condition.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; lock.unlock(); System.out.println(\"释放锁,线程：\" + Thread.currentThread().getId()); &#125;&#125;/** * 通知全部 */private static void latch() &#123; lock.lock(); try &#123; condition.signalAll(); &#125; finally &#123; lock.unlock(); &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; for (int i = 0; i &lt; 5; i++) &#123; executorService.submit(() -&gt; &#123; handel(); &#125;); &#125; Thread.sleep(5000); latch(); executorService.shutdown();&#125;输出1234567891011121314151617181920尝试获取锁,线程：13尝试获取锁,线程：16尝试获取锁,线程：15尝试获取锁,线程：14尝试获取锁,线程：12获取锁成功,线程：13使线程进入等待状态,线程：13获取锁成功,线程：16使线程进入等待状态,线程：16获取锁成功,线程：15使线程进入等待状态,线程：15获取锁成功,线程：14使线程进入等待状态,线程：14获取锁成功,线程：12使线程进入等待状态,线程：12释放锁,线程：13释放锁,线程：16释放锁,线程：12释放锁,线程：14释放锁,线程：15","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"高级","slug":"并发/高级","permalink":"http://www.baiyp.ren/categories/并发/高级/"},{"name":"显示锁","slug":"并发/高级/显示锁","permalink":"http://www.baiyp.ren/categories/并发/高级/显示锁/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"高级","slug":"高级","permalink":"http://www.baiyp.ren/tags/高级/"},{"name":"显示锁","slug":"显示锁","permalink":"http://www.baiyp.ren/tags/显示锁/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"高级","slug":"并发/高级","permalink":"http://www.baiyp.ren/categories/并发/高级/"},{"name":"显示锁","slug":"并发/高级/显示锁","permalink":"http://www.baiyp.ren/categories/并发/高级/显示锁/"}]},{"title":"java中的AQS-01原理以及使用","slug":"java中的AQS-01","date":"2019-08-09T09:47:16.000Z","updated":"2019-09-07T09:07:49.635Z","comments":true,"path":"java中的AQS-01.html","link":"","permalink":"http://www.baiyp.ren/java中的AQS-01.html","excerpt":"","text":"java中的AQS什么是AQS​ AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。鉴于此，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了保证同步，必须原子地操作这些变量。​ AbstractQueuedSynchronizer中对state的操作是原子的，且不能被继承。所有的同步机制的实现均依赖于对改变量的原子操作。为了实现不同的同步机制，我们需要创建一个非共有的（non-public internal）扩展了AQS类的内部辅助类来实现相应的同步逻辑。AbstractQueuedSynchronizer并不实现任何同步接口，它提供了一些可以被具体实现类直接调用的一些原子操作方法来重写相应的同步逻辑。AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如ReadWriteLock。接下来将详细介绍AbstractQueuedSynchronizer的提供的一些具体实现方法。AQS的设计和结构设计思想同步器的核心方法是acquire和release操作，其背后的思想也比较简洁明确。acquire操作while (当前同步器的状态不允许获取操作) {​ 如果当前线程不在队列中，则将其插入队列阻塞当前线程}如果线程位于队列中，则将其移出队列release操作更新同步器的状态if (新的状态允许某个被阻塞的线程获取成功){​ 解除队列中一个或多个线程的阻塞状态}三大组件​ 从这两个操作中的思想中我们可以提取出三大关键操作：同步器的状态变更、线程阻塞和释放、插入和移出队列。所以为了实现这两个操作，需要协调三大关键操作引申出来的三个基本组件：同步器状态的原子性管理；线程阻塞与解除阻塞；队列的管理；由这三个基本组件，我们来看j.u.c是怎么设计的。同步状态​ AQS类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSet操作来读取和更新这个同步状态。其中属性state被声明为volatile，并且通过使用CAS指令来实现compareAndSetState，使得当且仅当同步状态拥有一个一致的期望值的时候，才会被原子地设置成新值，这样就达到了同步状态的原子性管理，确保了同步状态的原子性、可见性和有序性。1234567891011121314private volatile int state;protected final int getState() &#123; return state;&#125;protected final void setState(int newState) &#123; state = newState;&#125;protected final boolean compareAndSetState(int expect, int update) &#123; // See below for intrinsics setup to support this return unsafe.compareAndSwapInt(this, stateOffset, expect, update);&#125;基于AQS的具体实现类（如锁、信号量等）必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态。123456789//尝试获取 protected boolean tryAcquire(int arg) &#123; throw new UnsupportedOperationException(); &#125;//尝试释放 protected boolean tryRelease(int arg) &#123; throw new UnsupportedOperationException(); &#125;阻塞​ 通过JUC包提供了LockSupport类来解决这个问题。方法LockSupport.park阻塞当前线程直到有个LockSupport.unpark方法被调用。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可以有多余的unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地取消多余的unpark调用，但并不值得这样做。在需要的时候多次调用park会更高效。park方法同样支持可选的相对或绝对的超时设置，以及与JVM的Thread.interrupt结合 ，可通过中断来unpark一个线程。123456789101112131415public class LockSupport &#123; private LockSupport() &#123;&#125; // Cannot be instantiated. //唤醒指定线程 public static void unpark(Thread thread) &#123; if (thread != null) UNSAFE.unpark(thread); &#125; //阻塞当前线程 public static void park() &#123; UNSAFE.park(false, 0L); &#125;&#125;队列​ 整个框架的核心就是如何管理线程阻塞队列，该队列是严格的FIFO队列，因此不支持线程优先级的同步。同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，业界主要有两种选择，一种是MCS锁，另一种是CLH锁。其中CLH一般用于自旋，但是相比MCS，CLH更容易实现取消和超时，所以同步队列选择了CLH作为实现的基础。CLH队列实际并不那么像队列，它的出队和入队与实际的业务使用场景密切相关。它是一个链表队列，通过AQS的两个字段head（头节点）和tail（尾节点）来存取，这两个字段是volatile类型，初始化的时候都指向了一个空节点。​ 入队操作：CLH队列是FIFO队列，故新的节点到来的时候，是要插入到当前队列的尾节点之后。试想一下，当一个线程成功地获取了同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个CAS方法，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。入队操作示意图大致如下：​ 出队操作：因为遵循FIFO规则，所以能成功获取到AQS同步状态的必定是首节点，首节点的线程在释放同步状态时，会唤醒后续节点，而后续节点会在获取AQS同步状态成功的时候将自己设置为首节点。设置首节点是由获取同步成功的线程来完成的，由于只能有一个线程可以获取到同步状态，所以设置首节点的方法不需要像入队这样的CAS操作，只需要将首节点设置为原首节点的后续节点同时断开原节点、后续节点的引用即可。出队操作示意图大致如下：条件队列​ 上一节的队列其实是AQS的同步队列，这一节的队列是条件队列，队列的管理除了有同步队列，还有条件队列。AQS只有一个同步队列，但是可以有多个条件队列。AQS框架提供了一个ConditionObject类，给维护独占同步的类以及实现Lock接口的类使用。​ ConditionObject类实现了Condition接口，Condition接口提供了类似Object管程式的方法，如await、signal和signalAll操作，还扩展了带有超时、检测和监控的方法。ConditionObject类有效地将条件与其它同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，当且仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的。这样，一个ConditionObject关联到一个ReentrantLock上就表现的跟内置的管程（通过Object.wait等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。ConditionObject类和AQS共用了内部节点，有自己单独的条件队列。signal操作是通过将节点从条件队列转移到同步队列中来实现的，没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。signal操作大致示意图如下：await操作就是当前线程节点从同步队列进入条件队列进行等待，大致示意图如下：​ 实现这些操作主要复杂在，因超时或Thread.interrupt导致取消了条件等待时，该如何处理。await和signal几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133修订以后，就要求如果中断发生在signal操作之前，await方法必须在重新获取到锁后，抛出InterruptedException。但是，如果中断发生在signal后，await必须返回且不抛异常，同时设置线程的中断状态。AQS应用AQS被大量的应用在了同步工具上。ReentrantLock：ReentrantLock类使用AQS同步状态来保存锁重复持有的次数。当锁被一个线程获取时，ReentrantLock也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。ReentrantLock也使用了AQS提供的ConditionObject，还向外暴露了其它监控和监测相关的方法。ReentrantReadWriteLock：ReentrantReadWriteLock类使用AQS同步状态中的16位来保存写锁持有的次数，剩下的16位用来保存读锁的持有次数。WriteLock的构建方式同ReentrantLock。ReadLock则通过使用acquireShared方法来支持同时允许多个读线程。Semaphore：Semaphore类（信号量）使用AQS同步状态来保存信号量的当前计数。它里面定义的acquireShared方法会减少计数，或当计数为非正值时阻塞线程；tryRelease方法会增加计数，在计数为正值时还要解除线程的阻塞。CountDownLatch：CountDownLatch类使用AQS同步状态来表示计数。当该计数为0时，所有的acquire操作（对应到CountDownLatch中就是await方法）才能通过。FutureTask：FutureTask类使用AQS同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（FutureTask的set方法）或取消（FutureTask的cancel方法）一个FutureTask时会调用AQS的release操作，等待计算结果的线程的阻塞解除是通过AQS的acquire操作实现的。SynchronousQueues：SynchronousQueues类使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用AQS同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。​ 除了这些JUC提供的工具，还可以基于AQS自定义符合自己需求的同步器。","categories":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"并发","slug":"源码/并发","permalink":"http://www.baiyp.ren/categories/源码/并发/"},{"name":"高级","slug":"源码/并发/高级","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/"},{"name":"AQS","slug":"源码/并发/高级/AQS","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/AQS/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"高级","slug":"高级","permalink":"http://www.baiyp.ren/tags/高级/"},{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/tags/源码/"},{"name":"AQS","slug":"AQS","permalink":"http://www.baiyp.ren/tags/AQS/"}],"keywords":[{"name":"源码","slug":"源码","permalink":"http://www.baiyp.ren/categories/源码/"},{"name":"并发","slug":"源码/并发","permalink":"http://www.baiyp.ren/categories/源码/并发/"},{"name":"高级","slug":"源码/并发/高级","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/"},{"name":"AQS","slug":"源码/并发/高级/AQS","permalink":"http://www.baiyp.ren/categories/源码/并发/高级/AQS/"}]},{"title":"java原子操作CAS","slug":"java原子操作CAS","date":"2019-08-09T00:11:30.000Z","updated":"2019-09-07T09:07:49.643Z","comments":true,"path":"java原子操作CAS.html","link":"","permalink":"http://www.baiyp.ren/java原子操作CAS.html","excerpt":"","text":"java原子操作CAS什么是CASCAS（Compare and Swap），即比较并替换，是用于实现多线程同步的原子指令。​ 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。​ 实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，synchronized关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，​ 这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。​ 实现原子操作还可以使用当前的处理器基本都支持CAS的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。​ CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。​ CAS是怎么实现线程的安全呢？语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。悲观锁，乐观锁说到CAS，不得不提到两个专业词语：悲观锁，乐观锁。我们先来看看什么是悲观锁，什么是乐观锁。悲观锁​ 顾名思义，就是比较悲观的锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中synchronized和ReentrantLock等独占锁就是悲观锁思想的实现。乐观锁​ 反之，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。我们今天讲的CAS就是乐观锁。CAS 的优点​ 非阻塞的轻量级乐观锁, 通过CPU指令实现, 在资源竞争不激烈的情况下性能高, 相比synchronize重量级悲观锁, synchronize有复杂的加锁, 解锁和唤醒线程操作.。CAS实现原子操作的三大问题ABA问题​ 因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。​ 就像上图描述的一样，线程A原来的值是10，线程B修改为了20，但是线程C又将值修改为了10，这个时候线程A来读取了，与旧值做判断，发现还是10，没有修改过，就做了更新操作，但是我们知道，值有过变更。循环时间长开销大自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。只能保证一个共享变量的原子操作​ 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。​ 还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。Jdk中相关原子操作类的使用JDK的CAS原子操作类在JUC包下 我看看下JAVA中如何实现CAS操作先来一波操作123456789101112131415161718192021222324252627282930313233343536373839404142 // private static AtomicInteger count = new AtomicInteger(0); private static AtomicInteger count = new AtomicInteger(0); /** * Cas 自旋操作 */ public static void accumulation() &#123; //自旋 for (; ; ) &#123; //获取旧值 int oldValue = count.get(); //比较并且交换 boolean flag = count.compareAndSet(oldValue, oldValue + 1); //如果成功退出自旋 if (flag) &#123; break; &#125; //失败打印信息再来一次 System.out.println(\"数据已被修改自旋再来一次\"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; //五个线程再跑 for (int i = 0; i &lt; 5; i++) &#123; new Thread(() -&gt; &#123; try &#123; sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //每个线程让count自增100次 for (int n = 0; n &lt; 100; n++) &#123; accumulation(); &#125; &#125;).start(); &#125; sleep(2000); System.out.println(count); &#125;&#125;返回值12345数据已被修改自旋再来一次数据已被修改自旋再来一次数据已被修改自旋再来一次数据已被修改自旋再来一次500这个是我们自己实现了累加操作，但是实际上JDK给我们提供了累加操作方法将public static void accumulation() 方法替换为下面的方法就可以1count.incrementAndGet();我们进去看看他是怎么操作的123public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1; &#125;在进入getAndAddInt 方法1234567public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v; &#125;我们发现，JDK也是通过自旋来实现的，和我们的效果一摸一样，他的核心方法是compareAndSwapInt我们常用的CAS操作类AtomicInteger•int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。•boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。•int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。•int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。AtomicIntegerArray主要是提供原子的方式更新数组里的整型，其常用方法如下。•int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。•boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。更新引用类型​ 原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。AtomicReference原子更新引用类型。AtomicStampedReference​ 利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在ABA问题了。这就是AtomicStampedReference的解决方案。AtomicMarkableReference跟AtomicStampedReference差不多， AtomicStampedReference是使用pair的int stamp作为计数器使用，AtomicMarkableReference的pair使用的是boolean mark。 还是那个水的例子，AtomicStampedReference可能关心的是动过几次，AtomicMarkableReference关心的是有没有被人动过，方法都比较简单。AtomicMarkableReference：​ 原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，booleaninitialMark）。原子更新字段类​ 如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。​ 要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。AtomicLongFieldUpdater：原子更新长整型字段的更新器。AtomicReferenceFieldUpdater：原子更新引用类型里的字段。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"高级","slug":"并发/高级","permalink":"http://www.baiyp.ren/categories/并发/高级/"},{"name":"CAS","slug":"并发/高级/CAS","permalink":"http://www.baiyp.ren/categories/并发/高级/CAS/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"高级","slug":"高级","permalink":"http://www.baiyp.ren/tags/高级/"},{"name":"CAS","slug":"CAS","permalink":"http://www.baiyp.ren/tags/CAS/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"高级","slug":"并发/高级","permalink":"http://www.baiyp.ren/categories/并发/高级/"},{"name":"CAS","slug":"并发/高级/CAS","permalink":"http://www.baiyp.ren/categories/并发/高级/CAS/"}]},{"title":"java并发工具类-Exchanger","slug":"java并发工具类-06","date":"2019-08-07T10:04:39.000Z","updated":"2019-09-07T09:07:49.632Z","comments":true,"path":"java并发工具类-06.html","link":"","permalink":"http://www.baiyp.ren/java并发工具类-06.html","excerpt":"","text":"java并发工具类-ExchangerExchanger 简介​ Exchange位于JUC包下面，主要是用于线程之间数据交换的工具类，经常用于管道设计和遗传算法中，Exchanger用于进行线程间的数据交换，它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange 方法交换数据，如果第一个线程先执行exchange 方法，它会一直等待第二个线程也执行exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据。可以将Exchange看做是一个双向数据传输的SynchronousQueue。此类提供对外的操作是同步的；用于成对出现的线程之间交换数据；可以视作双向的同步队列；可应用于基因算法、流水线设计等场景。Exchanger 提供的方法构造方法123456/** * Creates a new Exchanger. */ public Exchanger() &#123; participant = new Participant(); &#125;创建一个新的Exchange。主要方法这个类提供对外的接口非常简洁，一个无参构造函数，两个重载的范型exchange方法：等待另外一个线程到达此交换点（除非当前线程被中断），将给定的对象x传送给该线程，并且接收该线程的对象。1public V exchange(V x) throws InterruptedException等待另外一个线程到达此交换点（除非当前线程被中断，或者超出了指定的等待时间），将指定的对象x传送给该线程，同时接收该线程的对象。12public V exchange(V x, long timeout, TimeUnit unit) throws InterruptedException, TimeoutExceptionExchanger的应用场景​ Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。​ 只要用于两个线程之间交换数据。​ 如果两个线程有一个没有到达exchange方法，则会一直等待,如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, long timeout, TimeUnit unit)设置最大等待时长。案例​ 比如生活中两个人，一个人有零食，另一个人有钱，他们两个想等价交换，对好口号在某个地方相见，一个人先到了之后，必须等另一个人带着需要的东西来了之后，才能开始交换。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class ExchangerTest &#123; public static void main(String[] args) &#123; Exchanger exchanger = new Exchanger(); ExecutorService service = Executors.newCachedThreadPool(); //线程1 拿着零食来交换 service.submit(() -&gt; &#123; String data1 = \"零食\"; System.out.println(\"线程\" + Thread.currentThread().getName() + \"正在把数据 \" + data1 + \" 换出去\"); String data2 = null; try &#123; System.out.println(\"正在交换等待10s\"); Thread.sleep((long) Math.random() * 10000); //开始交换数 data2 = (String) exchanger.exchange(data1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"线程 \" + Thread.currentThread().getName() + \"换回的数据为 \" + data2); &#125;); //线程2 拿着钱来交换 service.submit(() -&gt; &#123; String data1 = \"钱\"; System.out.println(\"线程\" + Thread.currentThread().getName() + \"正在把数据 \" + data1 + \" 交换出去\"); String data2 = null; try &#123; System.out.println(\"正在交换等待10s\"); Thread.sleep((long) (Math.random() * 10000)); //开始交换数 data2 = (String) exchanger.exchange(data1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"线程 \" + Thread.currentThread().getName() + \"交换回来的数据是: \" + data2); &#125;); service.shutdown(); &#125;&#125;输出123456线程pool-1-thread-1正在把数据 零食 换出去正在交换等待10s线程pool-1-thread-2正在把数据 钱 交换出去正在交换等待10s线程 pool-1-thread-2交换回来的数据是: 零食线程 pool-1-thread-1换回的数据为 钱","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"工具类","slug":"工具类","permalink":"http://www.baiyp.ren/tags/工具类/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}]},{"title":"java变得牛逼的方法","slug":"变得牛逼的方法","date":"2019-08-05T13:51:08.000Z","updated":"2019-08-22T02:03:39.580Z","comments":true,"path":"变得牛逼的方法.html","link":"","permalink":"http://www.baiyp.ren/变得牛逼的方法.html","excerpt":"","text":"变得牛逼的方法信息获取习惯使用百度让周围人都认为你习惯于使用百度多关注些大咖的微博让周围人都认为你的知识都是从大咖那里学来的，不要让周围人找到学习的重点知识学习和技能训练混淆认识 知识幻觉给周围人灌输知识很容易获取，通过很简单的方式就可以掌握，把各种不一样的知识混淆视听，让他们找不到重点，感觉自己很牛逼的样子。培养他人学习使用碎片化时间培养周围人在工作期间，多看CSDN，博客等文章，让他们感觉自己在学习，在进步。不断提供各种各样看起来有价值的学习资料大量提供几十个G的学习视频和资料，不要告诉他们重点是什么，让他们看到资料就头大，学几节课就放弃的那种。让他们去看一些枯燥的书，基础知识提供一些JAVA基础书籍，JAVA核心技术上下卷，让他们学完后忘记，忘记后继续学，到怀疑自己是不是学JAVA的料，到怀疑人生。框架只要使用培养周围人框架只用论，不要探究原理，并且嘲讽那些探究原理的人。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"装逼","slug":"架构/装逼","permalink":"http://www.baiyp.ren/categories/架构/装逼/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"装逼","slug":"装逼","permalink":"http://www.baiyp.ren/tags/装逼/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"装逼","slug":"架构/装逼","permalink":"http://www.baiyp.ren/categories/架构/装逼/"}]},{"title":"git生成并添加SSH key","slug":"git生成并添加SSH-key","date":"2019-08-05T12:36:43.000Z","updated":"2019-09-07T09:07:49.618Z","comments":true,"path":"git生成并添加SSH-key.html","link":"","permalink":"http://www.baiyp.ren/git生成并添加SSH-key.html","excerpt":"","text":"git生成并添加SSH key下载安装git下载地址https://git-scm.com/downloads启动git bash执行代码配置你的用户信息12git config --global user.name \"xxx\" //配置你的账户名字 注意用户后面的空格git config --global user.email \"xxx@qq.com\" //配置你的创建github账户的邮箱；查看已经配置好的用户信息12git config user.namegit config user.email生成SSH key1ssh-keygen -t rsa -C \"xxx@qq.com\"获取SSH key1cat ~/.ssh/id_rsa.pub将 SSH key 配置到码云","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"git","slug":"架构/git","permalink":"http://www.baiyp.ren/categories/架构/git/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"ssh key","slug":"ssh-key","permalink":"http://www.baiyp.ren/tags/ssh-key/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"git","slug":"架构/git","permalink":"http://www.baiyp.ren/categories/架构/git/"}]},{"title":"java并发工具类-Callable、Future 和FutureTask","slug":"java并发工具类-05","date":"2019-08-05T10:04:33.000Z","updated":"2019-09-07T09:07:49.629Z","comments":true,"path":"java并发工具类-05.html","link":"","permalink":"http://www.baiyp.ren/java并发工具类-05.html","excerpt":"","text":"java并发工具类-Callable、Future 和FutureTask前言创建线程的2种方式，一种是直接继承Thread，另外一种就是实现Runnable接口。这2种方式都有一个缺陷就是：在执行完任务之后无法获取执行结果。如果需要获取执行结果，就必须通过共享变量或者使用线程通信的方式来达到效果，这样使用起来就比较麻烦。而自从Java 1.5开始，就提供了Callable和Future，通过它们可以在任务执行完毕之后得到任务执行结果Callable接口Callable位于JUC包下，它也是一个接口，在它里面也只声明了一个方法叫做call()：12345678910@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125;​ Callable接口代表一段可以调用并返回结果的代码。​ Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。​ Callable接口使用泛型去定义它的返回类型。​ Executors类提供了一些有用的方法在线程池中执行Callable内的任务。由于Callable任务是并行的（并行就是整体看上去是并行的，其实在某个时间点只有一个线程在执行），我们必须等待它返回的结果。​ java.util.concurrent.Future对象为我们解决了这个问题。在线程池提交Callable任务后返回了一个Future对象，使用它可以知道Callable任务的状态和得到Callable返回的执行结果。Future提供了get()方法让我们可以等待Callable结束并获取它的执行结果。那么怎么使用Callable呢？一般情况下是配合ExecutorService来使用的，在ExecutorService接口中声明了若干个submit方法的重载版本：123&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);第一个方法：submit提交一个实现Callable接口的任务，并且返回封装了异步计算结果的Future。第二个方法：submit提交一个实现Runnable接口的任务，并且指定了在调用Future的get方法时返回的result对象。第三个方法：submit提交一个实现Runnable接口的任务，并且返回封装了异步计算结果的Future。因此我们只要创建好我们的线程对象（实现Callable接口或者Runnable接口），然后通过上面3个方法提交给线程池去执行即可。Future接口​ Future就是对于具体的Runnable或者Callable任务的执行结果进行取消、查询是否完成、获取结果。必要时可以通过get方法获取执行结果，该方法会阻塞直到任务返回结果。​ Future接口是用来获取异步计算结果的，说白了就是对具体的Runnable或者Callable对象任务执行的结果进行获取(get())，取消(cancel())，判断是否完成等操作。我们看看Future接口的源码：12345678public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125;在Future接口中声明了5个方法，下面依次解释每个方法的作用方法作用cance(boolean mayInterruptIfRunning)试图取消执行的任务，参数为true时直接中断正在执行的任务，否则直到当前任务执行完成，成功取消后返回true，否则返回falseisCancelled()方法表示任务是否被取消成功，如果在任务正常完成前被取消成功，则返回 true。isDone()方法表示任务是否已经完成，若任务完成，则返回true；get()方法用来获取执行结果，这个方法会产生阻塞，会一直等到任务执行完毕才返回；get(long timeout, TimeUnit unit)设定计算结果的返回时间，如果在规定时间内没有返回计算结果则抛出TimeOutExceptionFuture提供了三种功能判断任务是否完成；能够中断任务；能够获取任务执行结果。因为Future只是一个接口，所以是无法直接用来创建对象使用的，因此就有了下面的FutureTask。RunnableFuture接口RunnableFuture实现了Runnable和Future。因此FutureTask可以传递到线程对象Thread或Excutor(线程池)来执行。1234567public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; /** * Sets this Future to the result of its computation * unless it has been cancelled. */ void run();&#125;FutureTask我们先来看一下FutureTask的实现：1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt;FutureTask类实现了RunnableFuture接口，我们看一下RunnableFuture接口的实现1public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt;可以看出RunnableFuture继承了Runnable接口和Future接口，而FutureTask实现了RunnableFuture接口。所以它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值。分析FutureTask除了实现了Future接口外还实现了Runnable接口，因此FutureTask也可以直接提交给Executor执行。 当然也可以调用线程直接执行（FutureTask.run()）。接下来我们根据FutureTask.run()的执行时机来分析其所处的3种状态：未启动，FutureTask.run()方法还没有被执行之前，FutureTask处于未启动状态，当创建一个FutureTask，而且没有执行FutureTask.run()方法前，这个FutureTask也处于未启动状态。已启动，FutureTask.run()被执行的过程中，FutureTask处于已启动状态。已完成，FutureTask.run()方法执行完正常结束，或者被取消或者抛出异常而结束，FutureTask都处于完成状态。下面我们再来看看FutureTask的方法执行示意图（方法和Future接口基本是一样的，这里就不过多描述了）当FutureTask处于未启动或已启动状态时，如果此时我们执行FutureTask.get()方法将导致调用线程阻塞；当FutureTask处于已完成状态时，执行FutureTask.get()方法将导致调用线程立即返回结果或者抛出异常。当FutureTask处于未启动状态时，执行FutureTask.cancel()方法将导致此任务永远不会执行。当FutureTask处于已启动状态时，执行cancel(true)方法将以中断执行此任务线程的方式来试图停止任务，如果任务取消成功，cancel(…)返回true；但如果执行cancel(false)方法将不会对正在执行的任务线程产生影响(让线程正常执行到完成)，此时cancel(…)返回false。当任务已经完成，执行cancel(…)方法将返回false。最后我们给出FutureTask的两种构造函数：1234public FutureTask(Callable&lt;V&gt; callable) &#123;&#125;public FutureTask(Runnable runnable, V result) &#123;&#125;事实上，FutureTask是Future接口的一个唯一实现类。使用示例​ 通过上面的介绍，我们对Callable，Future，RunnableFuture，FutureTask都有了比较清晰的了解了，那么它们到底有什么用呢？我们前面说过通过这样的方式去创建线程的话，最大的好处就是能够返回结果，加入有这样的场景，我们现在需要计算一个数据，而这个数据的计算比较耗时，而我们后面的程序也要用到这个数据结果，那么这个时Callable岂不是最好的选择？我们可以开设一个线程去执行计算，而主线程继续做其他事，而后面需要使用到这个数据时，我们再使用Future获取不就可以了吗？下面我们就来编写一个这样的实例。Callable+Future 获取执行结果12345678910111213141516171819202122//创建线程池 long currentTime = System.currentTimeMillis(); ExecutorService executor = Executors.newFixedThreadPool(5); //创建Callable对象任务 Callable&lt;Integer&gt; task = () -&gt; &#123; System.out.println(\"Callable子线程在进行计算\"); Thread.sleep(3000); int sum = 0; for (int i = 0; i &lt; 100; i++) sum += i; return sum; &#125;; //提交任务并获取执行结果 Future&lt;Integer&gt; result = executor.submit(task); //关闭线程池 executor.shutdown(); System.out.println(\"主线程开始走到这里,耗时：\" + (System.currentTimeMillis() - currentTime)); //get方法会阻塞线程执行 Integer value = result.get(); System.out.println(\"获取值：\" + value + \"，共耗时：\" + (System.currentTimeMillis() - currentTime));运行结果123主线程开始走到这里,耗时139Callable子线程在进行计算获取值：4950，共耗时：3169Callable+FutureTask获取执行结果123456789101112131415161718192021222324//创建线程池 long currentTime = System.currentTimeMillis(); ExecutorService executor = Executors.newFixedThreadPool(5); //创建Callable对象任务 Callable&lt;Integer&gt; task = () -&gt; &#123; System.out.println(\"Callable子线程在进行计算\"); Thread.sleep(3000); int sum = 0; for (int i = 0; i &lt; 100; i++) sum += i; return sum; &#125;; //第二种方式，注意这种方式和第一种方式效果是类似的,需要创建FutureTask对象 FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(task); //提交任务并获取执行结果 // Future future = executor.submit(task); executor.submit(futureTask); //关闭线程池 executor.shutdown(); System.out.println(\"主线程开始走到这里,耗时：\" + (System.currentTimeMillis() - currentTime)); //get方法会阻塞线程执行 Integer value = futureTask.get(); System.out.println(\"获取值：\" + value + \"，共耗时：\" + (System.currentTimeMillis() - currentTime));输出结果123Callable子线程在进行计算主线程开始走到这里,耗时：89获取值：4950，共耗时：3089总结实现Runnable接口和实现Callable接口的区别：Runnable是自从java1.1就有了，而Callable是1.5之后才加上去的。Callable规定的方法是call(),Runnable规定的方法是run()。Callable的任务执行后可返回值，而Runnable的任务是不能返回值(是void)。call方法可以抛出异常，run方法不可以。运行Callable任务可以拿到一个Future对象，表示异步计算的结果。它提供了检查计算是否完成的方法，以等待计算的完成，并检索计算的结果。通过Future对象可以了解任务执行情况，可取消任务的执行，还可获取执行结果。加入线程池运行，Runnable使用ExecutorService的execute方法，Callable使用submit方法。Callable、Runnable、Future和FutureTask 的区别Callable、Runnable、Future和FutureTask 做为java 线程池运行的重要载体，有必要深入理解。Callable 和 Runnable 都是执行的任务的接口，区别在于Callable有返回值，而Runnable无返回值。Future 表示异步任务返回结果的接口RunnableFuture 继承了Runnable， Future，表示可以带有返回值的run接口FutureTask是一个实现类，实现了RunnableFuture接口，既能接受Runnable类型的任务，也可以接受Callable类型的任务，这个类的作用主要是 有一个protected void done()方法用来扩展使用，作为一个回调方法","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"工具类","slug":"工具类","permalink":"http://www.baiyp.ren/tags/工具类/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}]},{"title":"JAVA中的分布式事务06-MQ事务(最终一致性)","slug":"JAVA中的分布式事务06","date":"2019-08-05T02:05:25.000Z","updated":"2019-09-07T09:07:49.662Z","comments":true,"path":"JAVA中的分布式事务06.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的分布式事务06.html","excerpt":"","text":"JAVA中的分布式事务06-MQ事务(最终一致性)方案简介​ 基于MQ的分布式事务方案其实是对本地消息表的封装，将本地消息表基于MQ 内部，其他方面的协议基本与本地消息表一致。处理流程下面主要基于RocketMQ4.3之后的版本介绍MQ的分布式事务方案。在本地消息表方案中，保证事务主动方发写业务表数据和写消息表数据的一致性是基于数据库事务，RocketMQ的事务消息相对于普通MQ，相对于提供了2PC的提交接口，方案如下：正常情况——事务主动方发消息这种情况下，事务主动方服务正常，没有发生故障，发消息流程如下：1、发送方向 MQ服务端(MQ Server)发送half消息。2、MQ Server 将消息持久化成功之后，向发送方 ACK 确认消息已经发送成功。3、发送方开始执行本地事务逻辑。4、发送方根据本地事务执行结果向 MQ Server 提交二次确认（commit 或是 rollback）。5、MQ Server 收到 commit 状态则将半消息标记为可投递，订阅方最终将收到该消息；MQ Server 收到 rollback 状态则删除半消息，订阅方将不会接受该消息。异常情况——事务主动方消息恢复在断网或者应用重启等异常情况下，图中4提交的二次确认超时未到达 MQ Server，此时处理逻辑如下：5、MQ Server 对该消息发起消息回查。6、发送方收到消息回查后，需要检查对应消息的本地事务执行的最终结果。7、发送方根据检查得到的本地事务的最终状态再次提交二次确认8、MQ Server基于commit / rollback 对消息进行投递或者删除介绍完RocketMQ的事务消息方案后，由于前面已经介绍过本地消息表方案，这里就简单介绍RocketMQ分布式事务：事务主动方基于MQ通信通知事务被动方处理事务，事务被动方基于MQ返回处理结果。如果事务被动方消费消息异常，需要不断重试，业务处理逻辑需要保证幂等。如果是事务被动方业务上的处理失败，可以通过MQ通知事务主动方进行补偿或者事务回滚。方案总结相比本地消息表方案，MQ事务方案优点是：消息数据独立存储 ，降低业务系统与消息系统之间的耦合。吞吐量优于使用本地消息表方案。缺点是：一次消息发送需要两次网络请求(half消息 + commit/rollback消息)业务处理服务需要实现消息状态回查接口","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.baiyp.ren/tags/分布式事务/"},{"name":"MQ","slug":"MQ","permalink":"http://www.baiyp.ren/tags/MQ/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}]},{"title":"友情链接","slug":"friends","date":"2019-08-03T16:00:00.000Z","updated":"2019-08-22T01:42:35.157Z","comments":true,"path":"friends.html","link":"","permalink":"http://www.baiyp.ren/friends.html","excerpt":"","text":"","categories":[],"tags":[],"keywords":[]},{"title":"java并发工具类-Semaphore","slug":"java并发工具类-04","date":"2019-08-03T05:45:13.000Z","updated":"2019-09-07T09:07:49.626Z","comments":true,"path":"java并发工具类-04.html","link":"","permalink":"http://www.baiyp.ren/java并发工具类-04.html","excerpt":"","text":"java并发工具类-SemaphoreSemaphore简介​ Semaphore也叫信号量，在JDK1.5被引入，可以用来控制同时访问特定资源的线程数量，通过协调各个线程，以保证合理的使用资源。Semaphore内部维护了一组虚拟的许可，许可的数量可以通过构造函数的参数指定。访问特定资源前，必须使用acquire方法获得许可，如果许可数量为0，该线程则一直阻塞，直到有可用许可。访问资源后，使用release释放许可。Semaphore和ReentrantLock类似，获取许可有公平策略和非公平许可策略，默认情况下使用非公平策略。通俗的讲Semaphore是一种在多线程环境下使用的设施，该设施负责协调各个线程，以保证它们能够正确、合理的使用公共资源的设施，也是操作系统中用于控制进程同步互斥的量。Semaphore是一种计数信号量，用于管理一组资源，内部是基于AQS的共享模式。它相当于给线程规定一个量从而控制允许活动的线程数。是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源应用场景​ Semaphore 是 synchronized 的加强版，作用是控制线程的并发数量。就这一点而言，单纯的synchronized 关键字是实现不了的。​ Semaphore可以用于做流量控制，特别是公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发地读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有10个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，就可以使用Semaphore来做流量控制。工作原理​ 以一个停车场是运作为例。为了简单起见，假设停车场只有三个车位，一开始三个车位都是空的。这时如果同时来了五辆车，看门人允许其中三辆不受阻碍的进入，然后放下车拦，剩下的车则必须在入口等待，此后来的车也都不得不在入口处等待。这时，有一辆车离开停车场，看门人得知后，打开车拦，放入一辆，如果又离开两辆，则又可以放入两辆，如此往复。这个停车系统中，每辆车就好比一个线程，看门人就好比一个信号量，看门人限制了可以活动的线程。假如里面依然是三个车位，但是看门人改变了规则，要求每次只能停两辆车，那么一开始进入两辆车，后面得等到有车离开才能有车进入，但是得保证最多停两辆车。对于Semaphore类而言，就如同一个看门人，限制了可活动的线程数。Semaphore主要方法构造方法创建具有给定许可数的计数信号量并设置为非公平信号量1public Semaphore(int permits)当fair等于true时，创建具有给定许可数的计数信号量并设置为公平信号量。1public Semaphore(int permits, boolean fair)其他方法从此信号量获取一个许可前线程将一直阻塞。相当于一辆车占了一个车位1public void acquire() throws InterruptedException从此信号量获取给定数目许可，在提供这些许可前一直将线程阻塞。比如n=2，就相当于一辆车占了两个车位。1public void acquire(int permits) throws InterruptedException释放一个许可，将其返回给信号量。就如同车开走返回一个车位。1public void release()释放n个许可1public void release(int permits)获取当前可用许可数1public int availablePermits()代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public class SemaphoreTest &#123; private static ExecutorService executorService = Executors.newCachedThreadPool(); private static Random random = new Random(); //阻塞队列 private static BlockingQueue&lt;String&gt; parks = new LinkedBlockingQueue&lt;&gt;(5); public static void execute(Semaphore semaphore) &#123; //获取一个随机数 long sleepTime = random.nextInt(10); long threadId = Thread.currentThread().getId(); String park = null; try &#123; /** * 获取许可，首先判断semaphore内部的数字是否大于0，如果大于0， * 才能获得许可，然后将初始值5减去1，线程才会接着去执行；如果没有 * 获得许可(原因是因为已经有5个线程获得到许可，semaphore内部的数字为0)， * 线程会阻塞直到已经获得到许可的线程，调用release()方法，释放掉许可， * 也就是将semaphore内部的数字加1，该线程才有可能获得许可。 */ semaphore.acquire(); /** * 对应的线程会到阻塞对，对应车辆去获取到车位，如果没有拿到一致阻塞， * 直到其他车辆归还车位。 */ park = parks.take(); System.out.println(\"线程ID\" + threadId + \",开始占用车位:\" + park + \"，当前剩余车位\" + semaphore.availablePermits()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; try &#123; //睡眠随机秒 Thread.sleep(sleepTime * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //归还车位 parks.offer(park); System.out.println(\"线程ID\" + threadId + \",开始归还车位:\" + park + \",共占用\" + sleepTime + \"秒\"); //线程释放掉许可，通俗来将就是将semaphore内部的数字加1 semaphore.release(); &#125; public static void main(String[] args) &#123; //初始化线程数量 int threadNum = 100; parks.offer(\"车位一\"); parks.offer(\"车位二\"); parks.offer(\"车位三\"); parks.offer(\"车位四\"); parks.offer(\"车位五\"); // 初始化5个许可证 Semaphore semaphore = new Semaphore(5); for (int i = 0; i &lt; threadNum; i++) &#123; executorService.submit(() -&gt; &#123; execute(semaphore); &#125;); &#125; &#125;&#125;注意事项我们知道可以通过信号量控制共享资源的访问，底层还是AQS这一套，这没什么难的。但是有一点可能被大家忽略：声明信号量的时候，比如只有3个许可证，但是运行过程中，某个时刻的许可证数量是没有限制的。1234567891011121314151617181920212223public static void main(String[] args) &#123; //初始化线程数量 int threadNum = 100; parks.offer(\"车位一\"); parks.offer(\"车位二\"); parks.offer(\"车位三\"); parks.offer(\"车位四\"); parks.offer(\"车位五\"); // 初始化 0 个许可证 应该是不可以 放行的 Semaphore semaphore = new Semaphore(0); /** * 释放了5个许可证，Semaphore(5) 效果是一样的 * 实际使用中注意不能过多的释放release */ semaphore.release(5); for (int i = 0; i &lt; threadNum; i++) &#123; executorService.submit(() -&gt; &#123; execute(semaphore); &#125;); &#125; &#125;​​ 即使创建信号量的时候，指定了信号量的大小。但是在通过 release()操作释放信号量任然能超过配置的大小。也就有可能同时执行的线程数量比最开始设置的要大。没有任何线程获取信号量的时候，依然能够释放并且释放的有效。​ 推荐的做法是一个线程先 acquire 然后 release。如果释放线程和获取线程不是同一个，那么最好保证这种对应关系。不要释放过多的许可证。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"工具类","slug":"工具类","permalink":"http://www.baiyp.ren/tags/工具类/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}]},{"title":"ThreadLocal引发的内存泄漏分析","slug":"java多线程-ThreadLocal-02","date":"2019-08-03T01:23:46.000Z","updated":"2019-09-07T09:07:49.598Z","comments":true,"path":"java多线程-ThreadLocal-02.html","link":"","permalink":"http://www.baiyp.ren/java多线程-ThreadLocal-02.html","excerpt":"","text":"ThreadLocal引发的内存泄漏分析预备知识引用Object o = new Object();这个o，我们可以称之为对象引用，而new Object()我们可以称之为在内存中产生了一个对象实例。当写下 o=null时，只是表示o不再指向堆中object的对象实例，不代表这个对象实例不存在了。强引用: 就是指在程序代码之中普遍存在的，类似“Object obj=new Object（）”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象实例。软引用: 是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象实例列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2之后，提供了SoftReference类来实现软引用。弱引用: 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象实例只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象实例。在JDK 1.2之后，提供了WeakReference类来实现弱引用。虚引用: 也称为幽灵引用或者幻影引用，它是最弱的一种引用关系。一个对象实例是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象实例被收集器回收时收到一个系统通知。在之后，提供了类来实现虚引用内存泄漏的现象1234567891011121314151617181920212223242526272829303132333435363738/** * 类说明：ThreadLocal造成的内存泄漏演示 */public class ThreadLocalOOM &#123; private static final int TASK_LOOP_SIZE = 500; final static ThreadPoolExecutor poolExecutor = new ThreadPoolExecutor(5, 5, 1, TimeUnit.MINUTES, new LinkedBlockingQueue&lt;&gt;()); static class LocalVariable &#123; private byte[] a = new byte[1024*1024*5];/*5M大小的数组*/ &#125; final static ThreadLocal&lt;LocalVariable&gt; localVariable = new ThreadLocal&lt;&gt;(); public static void main(String[] args) throws InterruptedException &#123; Object o = new Object(); /*5*5=25*/ for (int i = 0; i &lt; TASK_LOOP_SIZE; ++i) &#123; poolExecutor.execute(new Runnable() &#123; public void run() &#123; //localVariable.set(new LocalVariable()); new LocalVariable(); System.out.println(\"use local varaible\"); //localVariable.remove(); &#125; &#125;); Thread.sleep(100); &#125; System.out.println(\"pool execute over\"); &#125;&#125;首先只简单的在每个任务中new出一个数组可以看到内存的实际使用控制在25M左右：因为每个任务中会不断new出一个5M的数组，5*5=25M，这是很合理的。当我们启用了ThreadLocal以后：内存占用最高升至150M，一般情况下稳定在90M左右，那么加入一个ThreadLocal后，内存的占用真的会这么多？于是，我们加入一行代码：再执行，看看内存情况:可以看见最高峰的内存占用也在25M左右，完全和我们不加ThreadLocal表现一样。这就充分说明，确实发生了内存泄漏。分析根据我们前面对ThreadLocal的分析，我们可以知道每个Thread 维护一个 ThreadLocalMap，这个映射表的 key 是 ThreadLocal实例本身，value 是真正需要存储的 Object，也就是说 ThreadLocal 本身并不存储值，它只是作为一个 key 来让线程从 ThreadLocalMap 获取 value。仔细观察ThreadLocalMap，这个map是使用 ThreadLocal 的弱引用作为 Key 的，弱引用的对象在 GC 时会被回收。因此使用了ThreadLocal后，引用链如图所示图中的虚线表示弱引用。​ 这样，当把threadlocal变量置为null以后，没有任何强引用指向threadlocal实例，所以threadlocal将会被gc回收。这样一来，ThreadLocalMap中就会出现key为null的Entry，就没有办法访问这些key为null的Entry的value，如果当前线程再迟迟不结束的话，这些key为null的Entry的value就会一直存在一条强引用链：​ Thread Ref -&gt; Thread -&gt; ThreaLocalMap -&gt; Entry -&gt; value，而这块value永远不会被访问到了，所以存在着内存泄露。​ 只有当前thread结束以后，current thread就不会存在栈中，强引用断开，Current Thread、Map value将全部被GC回收。最好的做法是不在需要使用ThreadLocal变量后，都调用它的remove()方法，清除数据。​ 其实考察ThreadLocal的实现，我们可以看见，无论是get()、set()在某些时候，调用了expungeStaleEntry方法用来清除Entry中Key为null的Value，但是这是不及时的，也不是每次都会执行的，所以一些情况下还是会发生内存泄露。只有remove()方法中显式调用了expungeStaleEntry方法。​ 从表面上看内存泄漏的根源在于使用了弱引用，但是另一个问题也同样值得思考：为什么使用弱引用而不是强引用？下面我们分两种情况讨论：​ key 使用强引用：引用ThreadLocal的对象被回收了，但是ThreadLocalMap还持有ThreadLocal的强引用，如果没有手动删除，ThreadLocal的对象实例不会被回收，导致Entry内存泄漏。​ key 使用弱引用：引用的ThreadLocal的对象被回收了，由于ThreadLocalMap持有ThreadLocal的弱引用，即使没有手动删除，ThreadLocal的对象实例也会被回收。value在下一次ThreadLocalMap调用set，get，remove都有机会被回收。​ 比较两种情况，我们可以发现：由于ThreadLocalMap的生命周期跟Thread一样长，如果都没有手动删除对应key，都会导致内存泄漏，但是使用弱引用可以多一层保障。​ 因此，ThreadLocal内存泄漏的根源是：由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除对应key就会导致内存泄漏，而不是因为弱引用。总结​ JVM利用设置ThreadLocalMap的Key为弱引用，来避免内存泄露。JVM利用调用remove、get、set方法的时候，回收弱引用。当ThreadLocal存储很多Key为null的Entry的时候，而不再去调用remove、get、set方法，那么将导致内存泄漏。使用线程池+ ThreadLocal 时要小心，因为这种情况下，线程是一直在不断的重复运行的，从而也就造成了value可能造成累积的情况。错误使用ThreadLocal导致线程不安全12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 非安全的ThreadLocal 演示 */public class ThreadLocalUnsafe implements Runnable &#123; public static ThreadLocal&lt;Number&gt; numberThreadLocal = new ThreadLocal&lt;Number&gt;(); /** * 使用threadLocal的静态变量 */ public static Number number = new Number(0); public void run() &#123; //每个线程计数加一 number.setNum(number.getNum() + 1); //将其存储到ThreadLocal中 numberThreadLocal.set(number); //延时2ms try &#123; Thread.sleep(10); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //输出num值 System.out.println(\"内存地址：\"+numberThreadLocal.get() + \"，\" + Thread.currentThread().getName() + \"=\" + numberThreadLocal.get().getNum()); &#125; public static void main(String[] args) &#123; for (int i = 0; i &lt; 5; i++) &#123; new Thread(new ThreadLocalUnsafe()).start(); &#125; &#125; /** * 一个私有的类 Number */ private static class Number &#123; public Number(int num) &#123; this.num = num; &#125; private int num; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; &#125;&#125;输出12345内存地址：com.test.thread.ThreadLocalUnsafe$Number@5658172e，Thread-2=5内存地址：com.test.thread.ThreadLocalUnsafe$Number@5658172e，Thread-0=5内存地址：com.test.thread.ThreadLocalUnsafe$Number@5658172e，Thread-4=5内存地址：com.test.thread.ThreadLocalUnsafe$Number@5658172e，Thread-1=5内存地址：com.test.thread.ThreadLocalUnsafe$Number@5658172e，Thread-3=5​ 为什么每个线程都输出5？难道他们没有独自保存自己的Number副本吗？为什么其他线程还是能够修改这个值？仔细考察下我们的代码，我们发现我们的number对象是静态的，所以每个ThreadLoalMap中保存的其实同一个对象的引用，这样的话，当有其他线程对这个引用指向的对象实例做修改时，其实也同时影响了所有的线程持有的对象引用所指向的同一个对象实例。这也就是为什么上面的程序为什么会输出一样的结果：5个线程中保存的是同一Number对象的引用，在线程睡眠的时候，其他线程将num变量进行了修改，而修改的对象Number的实例是同一份，因此它们最终输出的结果是相同的。而上面的程序要正常的工作，应该去掉number的static 修饰，让每个ThreadLoalMap中使用不同的number对象进行操作。总结：ThreadLocal只保证线程隔离，不保证线程安全","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"ThreadLocal","slug":"并发/ThreadLocal","permalink":"http://www.baiyp.ren/categories/并发/ThreadLocal/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://www.baiyp.ren/tags/ThreadLocal/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"ThreadLocal","slug":"并发/ThreadLocal","permalink":"http://www.baiyp.ren/categories/并发/ThreadLocal/"}]},{"title":"java并发工具类 CyclicBarrier","slug":"java并发工具类-03","date":"2019-08-01T05:45:08.000Z","updated":"2019-09-07T09:07:49.624Z","comments":true,"path":"java并发工具类-03.html","link":"","permalink":"http://www.baiyp.ren/java并发工具类-03.html","excerpt":"","text":"java并发工具类 CyclicBarrierCyclicBarrier简介CyclicBarrier，是JDK1.5的java.util.concurrent并发包中提供的一个并发工具类。所谓Cyclic即 循环 的意思，所谓Barrier即 屏障 的意思。所以综合起来，CyclicBarrier指的就是 循环屏障，虽然这个叫法很奇怪，但是确能很好地表示它的作用。它的作用就是会让所有线程都等待完成后才会继续下一步行动。​ 举个例子，就像生活中我们会约朋友们到某个餐厅一起吃饭，有些朋友可能会早到，有些朋友可能会晚到，但是这个餐厅规定必须等到所有人到齐之后才会让我们进去。这里的朋友们就是各个线程，餐厅就是 CyclicBarrier。CyclicBarrier栅栏​ CyclicBarrier和CountDownLatch是非常类似的，CyclicBarrier核心的概念是在于设置一个等待线程的数量边界，到达了此边界之后进行执行。CyclicBarrier类是一个同步辅助类，它允许一组线程互相等待，直到到达某个公共屏障点（Common Barrier Point）。​ CyclicBarrier类是一种同步机制，它能够对处理一些算法的线程实现同。换句话讲，它就是一个所有线程必须等待的一个栅栏，直到所有线程都到达这里，然后所有线程才可以继续做其他事情。​ 通过调用CyclicBarrier对象的await()方法，两个线程可以实现互相等待。一旦N个线程在等待CyclicBarrier达成，所有线程将被释放掉去继续执行。怎么使用 CyclicBarrier12public CyclicBarrier(int parties)public CyclicBarrier(int parties, Runnable barrierAction)parties : 是参与线程的个数​ 其参数表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。*barrierAction * : 优先执行线程​ 用于在线程到达屏障时，优先执行barrierAction，方便处理更复杂的业务场景。CyclicBarrier可以用于多线程计算数据，最后合并计算结果的场景。重要方法12public int await() throws InterruptedException, BrokenBarrierExceptionpublic int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException线程调用 await() 表示自己已经到达栅栏BrokenBarrierException 表示栅栏已经被破坏，破坏的原因可能是其中一个线程 await() 时被中断或者超时基本使用代码实现一个线程组的线程需要等待所有线程完成任务后再继续执行下一次任务1234567891011121314151617181920212223242526272829303132333435363738394041public class CyclicBarrierTest &#123; private static Random random = new Random(); public static void execute(CyclicBarrier barrier) &#123; //获取一个随机数 long sleepTime = random.nextInt(10); long threadId = Thread.currentThread().getId(); try &#123; //睡眠随机秒 Thread.sleep(sleepTime * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"线程ID\" + threadId + \",准备任务完成耗时：\" + sleepTime + \"当前时间\" + System.currentTimeMillis()); //线程等待其他任务完成后唤醒 try &#123; barrier.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (BrokenBarrierException e) &#123; e.printStackTrace(); &#125; System.out.println(\"线程ID\" + threadId + \",开始执行任务，当前时间：\" + System.currentTimeMillis()); &#125; public static void main(String[] args) &#123; //初始化线程数量 int threadNum = 10; //初始化一般的线程 CyclicBarrier barrier = new CyclicBarrier(5, () -&gt; System.out.println(\"整理任务开始...\")); ExecutorService executor = Executors.newFixedThreadPool(threadNum); for (int i = 0; i &lt; threadNum; i++) &#123; executor.submit(() -&gt; &#123; execute(barrier); &#125;); &#125; &#125;&#125;输出12345678910111213141516171819202122线程ID12,准备任务完成耗时：0当前时间1565163947881线程ID17,准备任务完成耗时：0当前时间1565163947881线程ID16,准备任务完成耗时：0当前时间1565163947881线程ID20,准备任务完成耗时：3当前时间1565163950881线程ID14,准备任务完成耗时：3当前时间1565163950881整理任务开始...线程ID14,开始执行任务，当前时间：1565163950881线程ID12,开始执行任务，当前时间：1565163950881线程ID17,开始执行任务，当前时间：1565163950881线程ID16,开始执行任务，当前时间：1565163950881线程ID20,开始执行任务，当前时间：1565163950881线程ID18,准备任务完成耗时：4当前时间1565163951881线程ID13,准备任务完成耗时：5当前时间1565163952881线程ID21,准备任务完成耗时：7当前时间1565163954881线程ID19,准备任务完成耗时：9当前时间1565163956882线程ID15,准备任务完成耗时：9当前时间1565163956882整理任务开始...线程ID15,开始执行任务，当前时间：1565163956882线程ID18,开始执行任务，当前时间：1565163956882线程ID13,开始执行任务，当前时间：1565163956882线程ID21,开始执行任务，当前时间：1565163956882线程ID19,开始执行任务，当前时间：1565163956882​ 从打印结果可以看出，所有线程会等待全部线程到达栅栏之后才会继续执行，并且最后到达的线程会完成 Runnable 的任务。CyclicBarrier 使用场景可以用于多线程计算数据，最后合并计算结果的场景。CyclicBarrier 与 CountDownLatch 区别CountDownLatch 是一次性的，CyclicBarrier 是可循环利用的CountDownLatch.await一般阻塞工作线程，所有的进行预备工作的线程执行countDown，而CyclicBarrier通过工作线程调用await从而自行阻塞，直到所有工作线程达到指定屏障，再大家一起往下走。CountDownLatch 参与的线程的职责是不一样的，有的在倒计时，有的在等待倒计时结束。CyclicBarrier 参与的线程职责是一样的。在控制多个线程同时运行上，CountDownLatch可以不限线程数量，而CyclicBarrier是固定线程数。同时，CyclicBarrier还可以提供一个barrierAction，合并多线程计算结果。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"工具类","slug":"工具类","permalink":"http://www.baiyp.ren/tags/工具类/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}]},{"title":"JAVA中的分布式事务05-本地消息表(最终一致性)","slug":"JAVA中的分布式事务05","date":"2019-08-01T02:05:25.000Z","updated":"2019-09-07T09:07:49.660Z","comments":true,"path":"JAVA中的分布式事务05.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的分布式事务05.html","excerpt":"","text":"JAVA中的分布式事务05-本地消息表(最终一致性)方案简介​ 本地消息表的方案最初是由ebay提出，核心思路是将分布式事务拆分成本地事务进行处理。​ 方案通过在事务主动发起方额外新建事务消息表，事务发起方处理业务和记录事务消息在本地事务中完成，轮询事务消息表的数据发送事务消息，事务被动方基于消息中间件消费事务消息表中的事务。​ 这样设计可以避免”业务处理成功 + 事务消息发送失败“，或”业务处理失败 + 事务消息发送成功“的棘手情况出现，保证2个系统事务的数据一致性。处理流程​ 下面把分布式事务最先开始处理的事务方成为事务主动方，在事务主动方之后处理的业务内的其他事务成为事务被动方。​ 为了方便理解，下面继续以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建2个步骤，库存服务和订单服务分别在不同的服务器节点上，其中库存服务是事务主动方，订单服务是事务被动方。事务的主动方需要额外新建事务消息表，用于记录分布式事务的消息的发生、处理状态。整个业务处理流程如下：步骤1 事务主动方处理本地事务。事务主动发在本地事务中处理业务更新操作和写消息表操作。上面例子中库存服务阶段再本地事务中完成扣减库存和写消息表(图中1、2)。步骤2 事务主动方通过消息中间件，通知事务被动方处理事务通知事务待消息。消息中间件可以基于Kafka、RocketMQ消息队列，事务主动方法主动写消息到消息队列，事务消费方消费并处理消息队列中的消息。上面例子中，库存服务把事务待处理消息写到消息中间件，订单服务消费消息中间件的消息，完成新增订单（图中3 - 5）。步骤3 事务被动方通过消息中间件，通知事务主动方事务已处理的消息。上面例子中，订单服务把事务已处理消息写到消息中间件，库存服务消费中间件的消息，并将事务消息的状态更新为已完成(图中6 - 8)​ 为了数据的一致性，当处理错误需要重试，事务发送方和事务接收方相关业务处理需要支持幂等。具体保存一致性的容错处理如下：1、当步骤1处理出错，事务回滚，相当于什么都没发生。2、当步骤2、步骤3处理出错，由于未处理的事务消息还是保存在事务发送方，事务发送方可以定时轮询为超时消息数据，再次发送的消息中间件进行处理。事务被动方消费事务消息重试处理。3、如果是业务上的失败，事务被动方可以发消息给事务主动方进行回滚。4、如果多个事务被动方已经消费消息，事务主动方需要回滚事务时需要通知事务被动方回滚。方案总结方案的优点如下：从应用设计开发的角度实现了消息数据的可靠性，消息数据的可靠性不依赖于消息中间件，弱化了对MQ中间件特性的依赖。方案轻量，容易实现。缺点如下：与具体的业务场景绑定，耦合性强，不可公用。消息数据与业务数据同库，占用业务系统资源。业务系统在使用关系型数据库的情况下，消息服务性能会受到关系型数据库并发性能的局限。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.baiyp.ren/tags/分布式事务/"},{"name":"本地消息表","slug":"本地消息表","permalink":"http://www.baiyp.ren/tags/本地消息表/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}]},{"title":"什么是ThreadLocal","slug":"java多线程-ThreadLocal-01","date":"2019-08-01T01:23:46.000Z","updated":"2019-09-07T09:07:49.596Z","comments":true,"path":"java多线程-ThreadLocal-01.html","link":"","permalink":"http://www.baiyp.ren/java多线程-ThreadLocal-01.html","excerpt":"","text":"什么是ThreadLocal**什么是ThreadLocal​ 早在JDK 1.2的版本中就提供java.lang.ThreadLocal，ThreadLocal为解决多线程程序的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。从线程的角度看，目标变量就象是线程的本地变量，这也是类名中“Local”所要表达的意思。​ 所以，在Java中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在Java开发者中得到很好的普及。与Synchonized的比较​ ThreadLocal和Synchonized都用于解决多线程并发訪问。可是ThreadLocal与synchronized有本质的差别。synchronized是利用锁的机制，使变量或代码块在某一时该仅仅能被一个线程访问。而ThreadLocal为每个线程都提供了变量的副本，使得每个线程在某一时间訪问到的并非同一个对象，这样就隔离了多个线程对数据的数据共享。​ Spring的事务就借助了ThreadLocal类。Spring会从数据库连接池中获得一个connection，然会把connection放进ThreadLocal中，也就和线程绑定了，事务需要提交或者回滚，只要从ThreadLocal中拿到connection进行操作。为何Spring的事务要借助ThreadLocal类？以JDBC为例，正常的事务代码可能如下：12345678910111213dbc = new DataBaseConnection();//第1行Connection con = dbc.getConnection();//第2行con.setAutoCommit(false);// //第3行con.executeUpdate(...);//第4行con.executeUpdate(...);//第5行con.executeUpdate(...);//第6行con.commit();////第7行上述代码，可以分成三个部分:事务准备阶段：第1～3行业务处理阶段：第4～6行事务提交阶段：第7行可以很明显的看到，不管我们开启事务还是执行具体的sql都需要一个具体的数据库连接。​ 现在我们开发应用一般都采用三层结构，如果我们控制事务的代码都放在DAO(DataAccessObject)对象中，在DAO对象的每个方法当中去打开事务和关闭事务，当Service对象在调用DAO时，如果只调用一个DAO，那我们这样实现则效果不错，但往往我们的Service会调用一系列的DAO对数据库进行多次操作，那么，这个时候我们就无法控制事务的边界了，因为实际应用当中，我们的Service调用的DAO的个数是不确定的，可根据需求而变化，而且还可能出现Service调用Service的情况。​ 但是需要注意一个问题，如何让三个DAO使用同一个数据源连接呢？我们就必须为每个DAO传递同一个数据库连接，要么就是在DAO实例化的时候作为构造方法的参数传递，要么在每个DAO的实例方法中作为方法的参数传递。这两种方式无疑对我们的Spring框架或者开发人员来说都不合适。为了让这个数据库连接可以跨阶段传递，又不显示的进行参数传递，就必须使用别的办法。​ Web容器中，每个完整的请求周期会由一个线程来处理。因此，如果我们能将一些参数绑定到线程的话，就可以实现在软件架构中跨层次的参数共享（是隐式的共享）。而JAVA中恰好提供了绑定的方法–使用ThreadLocal。结合使用Spring里的IOC和AOP，就可以很好的解决这一点。只要将一个数据库连接放入ThreadLocalThreadLocalThreadLocal的使用ThreadLocal类接口很简单，只有4个方法，我们先来了解一下：void set(Object value)设置当前线程的线程局部变量的值。public Object get()该方法返回当前线程所对应的线程局部变量。public void remove()将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是JDK 5.0新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。protected Object initialValue()返回该线程局部变量的初始值，该方法是一个protected的方法，显然是为了让子类覆盖而设计的。这个方法是一个延迟调用方法，在线程第1次调用get()或set(Object)时才执行，并且仅执行1次。ThreadLocal中的缺省实现直接返回一个null。1public final static ThreadLocal&lt;String&gt; RESOURCE = new ThreadLocal&lt;String&gt;();RESOURCE代表一个能够存放String类型的ThreadLocal对象。此时不论什么一个线程能够并发访问这个变量，对它进行写入、读取操作，都是线程安全的。实现解析threadLo1234567891011121314151617public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; @SuppressWarnings(\"unchecked\") T result = (T)e.value; return result; &#125; &#125; return setInitialValue(); &#125; ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals; &#125;​ 上面先取到当前线程，然后调用getMap方法获取对应的ThreadLocalMap，ThreadLocalMap是ThreadLocal的静态内部类，然后Thread类中有一个这样类型成员，所以getMap是直接返回Thread的成员。看下ThreadLocal的内部类ThreadLocalMap源码：​ 可以看到有个Entry内部静态类，它继承了WeakReference，总之它记录了两个信息，一个是ThreadLocal&lt;?&gt;类型，一个是Object类型的值。getEntry方法则是获取某个ThreadLocal对应的值，set方法就是更新或赋值相应的ThreadLocal对应的值。​ 回顾我们的get方法，其实就是拿到每个线程独有的ThreadLocalMap然后再用ThreadLocal的当前实例，拿到Map中的相应的Entry，然后就可以拿到相应的值返回出去。当然，如果Map为空，还会先进行map的创建，初始化等工作。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"ThreadLocal","slug":"并发/ThreadLocal","permalink":"http://www.baiyp.ren/categories/并发/ThreadLocal/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"http://www.baiyp.ren/tags/ThreadLocal/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"ThreadLocal","slug":"并发/ThreadLocal","permalink":"http://www.baiyp.ren/categories/并发/ThreadLocal/"}]},{"title":"java并发工具类-CountDownLatch","slug":"java并发工具类-02","date":"2019-07-28T05:45:01.000Z","updated":"2019-09-07T09:07:49.623Z","comments":true,"path":"java并发工具类-02.html","link":"","permalink":"http://www.baiyp.ren/java并发工具类-02.html","excerpt":"","text":"java并发工具类-CountDownLatchCountDownLatch的简介CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程执行完后再执行。CountDownLatch是在java1.5被引入的，跟它一起被引入的并发工具类还有CyclicBarrier、Semaphore、 ConcurrentHashMap和BlockingQueue，它们都存在于JUC (java.util.concurrent)包下CountDownLatch原理​ CountDownLatch是通过一个计数器来实现的，计数器的初始化值为线程的数量。每当一个线程完成了自己的任务后，计数器的值就相应得减1（CountDownLatch.countDown()方法）。当计数器到达0时，表示所有的线程都已完成任务,，然后在闭锁上等待CountDownLatch.await()方法的线程就可以恢复执行任务。注意：这是一个一次性操作 - 计数无法重置。 如果你需要一个重置的版本计数，考虑使用CyclicBarrier。应用场景​ 实现最大的并行性：有时我们想同时启动多个线程，实现最大程度的并行性。例如，我们想测试一个单例类。如果我们创建一个初始计数为1的CountDownLatch，并让所有线程都在这个锁上等待，那么我们可以很轻松地完成测试。我们只需调用 一次countDown()方法就可以让所有的等待线程同时恢复执行。​ 开始执行前等待n个线程完成各自任务：例如应用程序启动类要确保在处理用户请求前，所有N个外部系统已经启动和运行了，例如处理excel中多个表单。注意：一个线程不一定只能做countDown一次，也可以countDown多次CountDownLatch的示例1234567891011121314151617181920212223242526272829303132333435363738394041424344public class CountDownLatchTest &#123; private static ThreadPoolExecutor threadPool = new ThreadPoolExecutor(5, 10, 100, TimeUnit.SECONDS, new ArrayBlockingQueue&lt;Runnable&gt;(5)); private static Random random = new Random(); public static void execute(CountDownLatch countDownLatch) &#123; //获取一个随机数 long sleepTime = random.nextInt(10); long threadId = Thread.currentThread().getId(); System.out.println(\"线程ID\" + threadId + \",开始执行--countDown\"); try &#123; //睡眠随机秒 Thread.sleep(sleepTime * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; //计数器减1 countDownLatch.countDown(); System.out.println(\"线程ID\" + threadId + \",准备任务完成耗时：\" + sleepTime + \"当前时间\" + System.currentTimeMillis()); try &#123; //线程等待其他任务完成后唤醒 countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"线程ID\" + threadId + \",开始执行任务，当前时间：\" + System.currentTimeMillis()); &#125; public static void main(String[] args) throws InterruptedException &#123; CountDownLatch countDownLatch = new CountDownLatch(5); for (int i = 0; i &lt; 5; i++) &#123; threadPool.submit(() -&gt; &#123; execute(countDownLatch); &#125;); &#125; //线程等待其他任务完成后唤醒 countDownLatch.await(); Thread.sleep(1000); threadPool.shutdown(); System.out.println(\"全部任务执行完成\"); &#125;&#125;打印结果线程ID13,开始执行–countDown线程ID16,开始执行–countDown线程ID15,开始执行–countDown线程ID12,开始执行–countDown线程ID14,开始执行–countDown线程ID14,准备任务完成耗时：3当前时间1565159118048线程ID16,准备任务完成耗时：4当前时间1565159119047线程ID12,准备任务完成耗时：4当前时间1565159119048线程ID15,准备任务完成耗时：6当前时间1565159121047线程ID13,准备任务完成耗时：7当前时间1565159122048线程ID13,开始执行任务，当前时间：1565159122048线程ID14,开始执行任务，当前时间：1565159122048线程ID12,开始执行任务，当前时间：1565159122048线程ID16,开始执行任务，当前时间：1565159122048线程ID15,开始执行任务，当前时间：1565159122049全部任务执行完成使用CountDownLatch压测​ 在实战项目中，我们除了使用 jemter 等工具进行压测外，还可以自己动手使用 CountDownLatch 类编写压测代码。可以说 jemter 的并发压测背后也是使用的 CountDownLatch。可见掌握 CountDownLatch 类的使用是有多么的重要。​ CountDownLatch是Java多线程同步器的四大金刚之一，CountDownLatch能够使一个线程等待其他线程完成各自的工作后再执行。1234567891011121314151617181920212223242526272829private void latchTest() throws InterruptedException &#123; //压测线程数 int testThreads = 300; final CountDownLatch start = new CountDownLatch(1); final CountDownLatch end = new CountDownLatch(testThreads); //创建线程池 ExecutorService exce = Executors.newFixedThreadPool(testThreads); for (int i = 0; i &lt; testThreads; i++) &#123; exce.submit(() -&gt; &#123; try &#123; //启动后等待 唤醒 start.await(); //压测具体方法 testLoad(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally &#123; //结束CountDownLatch -1 end.countDown(); &#125; &#125;); &#125; //连接池线程初始化完成 开始压测 start.countDown(); //压测完成后结束 end.await(); exce.shutdown(); &#125;简简单单的几行代码就可以实现300的压测。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"工具类","slug":"工具类","permalink":"http://www.baiyp.ren/tags/工具类/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}]},{"title":"java多线程基础05-线程间的协作","slug":"java多线程基础-05","date":"2019-07-24T23:23:07.000Z","updated":"2019-09-07T09:07:49.611Z","comments":true,"path":"java多线程基础-05.html","link":"","permalink":"http://www.baiyp.ren/java多线程基础-05.html","excerpt":"","text":"线程间的协作线程间的协作​ 线程之间相互配合，完成某项工作，比如：一个线程修改了一个对象的值，而另一个线程感知到了变化，然后进行相应的操作，整个过程开始于一个线程，而最终执行又是另一个线程。前者是生产者，后者就是消费者，这种模式隔离了“做什么”（what）和“怎么做”（How），简单的办法是让消费者线程不断地循环检查变量是否符合预期在while循环中设置不满足的条件，如果条件满足则退出while循环，从而完成消费者的工作。却存在如下问题：1） 难以确保及时性。2）难以降低开销。如果降低睡眠的时间，比如休眠1毫秒，这样消费者能更加迅速地发现条件变化，但是却可能消耗更多的处理器资源，造成了无端的浪费。等待/通知机制​ 是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify/notifyAll()的关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。notify()：​ 通知一个在对象上等待的线程,使其从wait方法返回,而返回的前提是该线程获取到了对象的锁，没有获得锁的线程重新进入WAITING状态。notifyAll()：​ 通知所有等待在该对象上的线程wait()​ 调用该方法的线程进入 WAITING状态,只有等待另外线程的通知或被中断才会返回.需要注意,调用wait()方法后,会释放对象的锁wait(long)​ 超时等待一段时间,这里的参数时间是毫秒,也就是等待长达n毫秒,如果没有通知就超时返回wait (long,int)​ 对于超时时间更细粒度的控制,可以达到纳秒等待和通知的标准范式等待方遵循如下原则。1）获取对象的锁。2）如果条件不满足，那么调用对象的wait()方法，被通知后仍要检查条件。3）条件满足则执行对应的逻辑。123456synchronized (对象)&#123; while(条件不满足)&#123; 对象.wait(); &#125; 对应的处理逻辑 &#125;通知方遵循如下原则。1）获得对象的锁。2）改变条件。3）通知所有等待在对象上的线程1234synchronized (对象)&#123; 改变条件 对象.notifyAll();&#125;​ 在调用wait()、notify()系列方法之前，线程必须要获得该对象的对象级别锁，即只能在同步方法或同步块中调用wait()方法、notify()系列方法，进入wait()方法后，当前线程释放锁，在从wait()返回前，线程与其他线程竞争重新获得锁， 执行notify()系列方法的线程退出调用了notifyAll的synchronized代码块的时候后，他们就会去竞争。如果其中一个线程获得了该对象锁，它就会继续往下执行，在它退出synchronized代码块，释放锁后，其他的已经被唤醒的线程将会继续竞争获取该锁，一直进行下去，直到所有被唤醒的线程都执行完毕。notify和notifyAll应该用谁​ 尽可能用notifyall()，谨慎使用notify()，因为notify()只会唤醒一个线程，我们无法确保被唤醒的这个线程一定就是我们需要唤醒的线程。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"多线程基础","slug":"多线程基础","permalink":"http://www.baiyp.ren/tags/多线程基础/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}]},{"title":"JAVA中的分布式事务04-TCC(最终一致性)","slug":"JAVA中的分布式事务04","date":"2019-07-21T02:05:25.000Z","updated":"2019-09-07T09:07:49.658Z","comments":true,"path":"JAVA中的分布式事务04.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的分布式事务04.html","excerpt":"","text":"JAVA中的分布式事务04-TCC(最终一致性)方案简介​ TCC（Try-Confirm-Cancel）的概念，最早是由Pat Helland于2007年发表的一篇名为《Life beyond Distributed Transactions:an Apostate’s Opinion》的论文提出。TCC是服务化的二阶段编程模型，其Try、Confirm、Cancel 3个方法均由业务编码实现；Try操作作为一阶段，负责资源的检查和预留。Confirm操作作为二阶段提交操作，执行真正的业务。Cancel是预留资源的取消。TCC事务的Try、Confirm、Cancel可以理解为SQL事务中的Lock、Commit、Rollback。处理流程为了方便理解，下面以电商下单为例进行方案解析，这里把整个过程简单分为扣减库存，订单创建2个步骤，库存服务和订单服务分别在不同的服务器节点上。阶段1：Try 阶段​ 从执行阶段来看，与传统事务机制中业务逻辑相同。但从业务角度来看，却不一样。TCC机制中的Try仅是一个初步操作，它和后续的确认一起才能真正构成一个完整的业务逻辑，这个阶段主要完成：完成所有业务检查( 一致性 )预留必须业务资源( 准隔离性 )Try 尝试执行业务TCC事务机制以初步操作（Try）为中心的，确认操作（Confirm）和取消操作（Cancel）都是围绕初步操作（Try）而展开。因此，Try阶段中的操作，其保障性是最好的，即使失败，仍然有取消操作（Cancel）可以将其执行结果撤销。假设商品库存为100，购买数量为2，这里检查和更新库存的同时，冻结用户购买数量的库存，同时创建订单，订单状态为待确认。阶段2：Confirm / Cancel 阶段根据Try阶段服务是否全部正常执行，继续执行确认操作（Confirm）或取消操作（Cancel）。Confirm和Cancel操作满足幂等性，如果Confirm或Cancel操作执行失败，将会不断重试直到执行完成。Confirm：确认当Try阶段服务全部正常执行， 执行确认业务逻辑操作这里使用的资源一定是Try阶段预留的业务资源。在TCC事务机制中认为，如果在Try阶段能正常的预留资源，那Confirm一定能完整正确的提交。Confirm阶段也可以看成是对Try阶段的一个补充，Try+Confirm一起组成了一个完整的业务逻辑。Cancel：取消当Try阶段存在服务执行失败， 进入Cancel阶段Cancel取消执行，释放Try阶段预留的业务资源，上面的例子中，Cancel操作会把冻结的库存释放，并更新订单状态为取消。方案总结TCC事务机制相对于传统事务机制（X/Open XA），TCC事务机制相比于上面介绍的XA事务机制，有以下优点:性能提升具体业务来实现控制资源锁的粒度变小，不会锁定整个资源。数据最终一致性基于Confirm和Cancel的幂等性，保证事务最终完成确认或者取消，保证数据的一致性。可靠性解决了XA协议的协调者单点故障问题，由主业务方发起并控制整个业务活动，业务活动管理器也变成多点，引入集群。缺点：TCC的Try、Confirm和Cancel操作功能要按具体业务来实现，业务耦合度较高，提高了开发成本。实现方案","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.baiyp.ren/tags/分布式事务/"},{"name":"TCC","slug":"TCC","permalink":"http://www.baiyp.ren/tags/TCC/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}]},{"title":"java多线程基础04-Java多线程的同步","slug":"java多线程基础-04","date":"2019-07-19T23:23:07.000Z","updated":"2019-09-07T09:07:49.609Z","comments":true,"path":"java多线程基础-04.html","link":"","permalink":"http://www.baiyp.ren/java多线程基础-04.html","excerpt":"","text":"Java多线程的同步使用线程锁synchronized内置锁​ 线程开始运行，拥有自己的栈空间，就如同一个脚本一样，按照既定的代码一步一步地执行，直到终止。但是，每个运行中的线程，如果仅仅是孤立地运行，那么没有一点儿价值，或者说价值很少，如果多个线程能够相互配合完成工作，包括数据之间的共享，协同处理事情。这将会带来巨大的价值。​ Java支持多个线程同时访问一个对象或者对象的成员变量，关键字synchronized可以修饰方法或者以同步块的形式来进行使用，它主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，它保证了线程对变量访问的可见性和排他性，又称为内置锁机制。synchronized 的性质可重入性同一线程的外层方法获得锁后，内层方法可以直接再次获取该锁；避免死锁，提升封装性；关键字：同一线程，同一把锁不可中断性一旦这个锁已经被别人获得了，如果我还想获得，我只能选择等待或者阻塞，直到别的线程释放这个锁；如果别的线程永远不释放锁，那么我只能永远等待；相比之下，Lock类提供的锁，拥有中断能力；第一，如果我觉得等待的时间太长了，有权中断现在已经获取到锁的线程的执行；第二，如果我觉得等待的时间太长了不想再等待，也可以退出；对象锁和类锁​ 当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放，对象锁是用于对象实例方法，或者一个对象实例上的。同步静态方法/静态变量互斥体由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只由一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁。一旦一个静态变量被作为synchronized block的mutex。进入此同步区域时，都要先获得此静态变量的对象锁​ 用于类的静态方法或者一个类的class对象上的。我们知道，类的对象实例可以有很多个，但是每个类只有一个class对象，所以不同对象实例的对象锁是互不干扰的，但是每个类只有一个类锁。​ 但是有一点必须注意的是，其实类锁只是一个概念上的东西，并不是真实存在的，类锁其实锁的是每个类的对应的class对象。类锁和对象锁之间也是互不干扰的。synchronized 的加锁方式12345678910111213141516171819202122232425262728293031323334353637383940/** * synchronized 锁 */public class RunableTest &#123; private Object lock = new Object(); /** * 用同步代码块表示lock对象资源互斥 */ public void test1() &#123; synchronized (lock) &#123; System.out.println(\"test111###\" + System.currentTimeMillis()); sleep(2); &#125; &#125; /** * 用在方法上表示对象锁 表示 synchronized(调用方法的类的对象) */ public synchronized void test2() &#123; System.out.println(\"test222###\"+System.currentTimeMillis()); sleep(2); &#125; /** * 加载静态方法上表示类锁，是synchronized(类.class) &#123;&#125; */ public static synchronized void test3() &#123; System.out.println(\"test333###\"+System.currentTimeMillis()); sleep(2); &#125; public static void sleep(int sec) &#123; try &#123; Thread.sleep(sec * 1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;synchronized总结synchronized如果加在了非静态方法上，表示的是synchronized(调用方法的类的对象) {}如果加在了静态方法上，表示的是synchronized(类.class) {}如果是synchronized代码块表示资源互斥synchronized的缺陷效率低锁的释放情况少，只在程序正常执行完成和抛出异常时释放锁；试图获得锁是不能设置超时；不能中断一个正在试图获得锁的线程；无法知道是否成功获取到锁；错误的加锁和原因分析​ 我们常常在程序中使用多线程来处理任务，这个时候是否正确使用加锁就很重要了，有时候看着代码没啥问题，但是执行起来发现结果并不是看到的那样，比如我们看下面的代码12345678910private Integer num = 0; public void test1() &#123; synchronized (num) &#123; sleep(1); num++; System.out.println(\"test111\"+Thread.currentThread().getId()); &#125; &#125;​ 这个时候我们再去看代码，我们对Integer对象num进行加锁，这个时候就有个一个Java基础知识在里面，Integer是不可变对象，是实例对象，对象一但被创建就不能被修改，比如赋值是1，就是1，如果让它变成2，需要重新创建一个Integer对象。12345678public void test1() &#123; synchronized(this.num) &#123; sleep(1); Integer var2 = this.num; Integer var3 = this.num = this.num + 1; System.out.println(\"test111\" + Thread.currentThread().getId()); &#125;&#125;​​ 然后下面循环中进行num++,其实这里Java对这个进行了内部转换（ Java封箱拆箱） ，其实是执行的这个语句java Integer var3 = this.num = this.num + 1;，我们看反编译后的代码，它会返回一个Integer实例，因此num ++本质是创建一个Integer对象，并将它的引用赋值给num 。本质上是返回了一个新的Integer对象。也就是每个线程实际加锁的是不同的Integer对象。volatile，最轻量的同步机制​ volatile保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。​ 由于每个线程都有自己的工作内存区，因此当一个线程改变自己的工作内存中的数据时，对其他线程来说，可能是不可见的。为此，可以使用volatile关键字迫使所有线程读写内存中的变量，从而使得volatile变量在多线程间可见。​ 不加volatile时，子线程无法感知主线程修改了ready的值，从而不会退出循环，而加了volatile后，子线程可以感知主线程修改了ready的值，迅速退出循环。但是volatile不能保证数据在多个线程下同时写时的线程安全volatile最适用的场景：一个线程写，多个线程读。声明为volatile的变量可以做到如下保证：其他线程对变量的修改，可以及时反应在当前线程中；确保当前线程对volatile变量的修改，能及时写回到共享内存中，并被其他线程所见；使用volatile声明的变量，编译器会保证其有序性。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"多线程基础","slug":"多线程基础","permalink":"http://www.baiyp.ren/tags/多线程基础/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}]},{"title":"java多线程基础03-Java多线程更多了解","slug":"java多线程基础-03","date":"2019-07-17T23:23:07.000Z","updated":"2019-09-07T09:07:49.607Z","comments":true,"path":"java多线程基础-03.html","link":"","permalink":"http://www.baiyp.ren/java多线程基础-03.html","excerpt":"","text":"对Java里的线程再多一点点认识深入理解run()和start()​ Thread类是Java里对线程概念的抽象，可以这样理解：我们通过new Thread()其实只是new出一个Thread的实例，还没有操作系统中真正的线程挂起钩来。只有执行了start()方法后，才实现了真正意义上的启动线程。​ start()方法让一个线程进入就绪队列等待分配cpu，分到cpu后才调用实现的run()方法，start()方法不能重复调用，如果重复调用会抛出异常。​ 而run方法是业务逻辑实现的地方，本质上和任意一个类的任意一个成员方法并没有任何区别，可以重复执行，也可以被单独调用。其他的线程相关方法​ yield()方法：使当前线程让出CPU占有权，但让出的时间是不可设定的。也不会释放锁资源。注意：并不是每个线程都需要这个锁的，而且执行yield( )的线程不一定就会持有锁，我们完全可以在释放锁后再调用yield方法。所有执行yield()的线程有可能在进入到就绪状态后会被操作系统再次选中马上又被执行。wait()/notify()/notifyAll()：后面会单独讲述join方法​ 把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。(此处为常见面试考点)看个栗子12345678910111213141516171819202122232425Thread thread1 = new Thread(() -&gt; &#123; while(!Thread.currentThread().isInterrupted()) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"11111111111\"); &#125; &#125;); Thread thread2 = new Thread(() -&gt; &#123; while(!Thread.currentThread().isInterrupted()) &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(\"222222222222\"); &#125; &#125;); thread1.start(); //在此处join 其他线程会等待thread1 执行完成后在执行thread2 thread1.join(); thread2.start();执行结果12345678910111213141516171111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111第二种情况12345... thread1.start(); thread2.start(); //在此处join 因为下面没有等待启动的线程，所以和不加thread1.join();一样，是交替执行的 thread1.join();执行结果1234567891011121311111111111111111111112222222222221111111111122222222222211111111111222222222222111111111112222222222222222222222221111111111111111111111222222222222线程的优先级​ 在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分配时间片的数量要多于优先级低的线程。​ 设置线程优先级时，针对频繁阻塞（休眠或者I/O操作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，有些操作系统甚至会忽略对线程优先级的设定。守护线程​ Daemon（守护）线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调用Thread.setDaemon(true)将线程设置为Daemon线程。我们一般用不上，比如垃圾回收线程就是Daemon线程。​ Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块并不一定会执行。在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"多线程基础","slug":"多线程基础","permalink":"http://www.baiyp.ren/tags/多线程基础/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}]},{"title":"java流式计算Stream详解","slug":"java流式计算Stream详解","date":"2019-07-17T09:57:36.000Z","updated":"2019-09-07T09:07:49.614Z","comments":true,"path":"java流式计算Stream详解.html","link":"","permalink":"http://www.baiyp.ren/java流式计算Stream详解.html","excerpt":"","text":"java流式计算Stream详解Stream 是什么​ Stream是Java 8新增的重要特性, 它提供函数式编程支持并允许以管道方式操作集合. 流操作会遍历数据源, 使用管道式操作处理数据后生成结果集合, 这个过程通常不会对数据源造成影响.函数对象​ 使用Stream进行函数式编程时经常需要将操作作为参数传入流方法中, 函数对象即将方法或lambda表达式作为对象。1List&lt;String&gt; strArray = Arrays.asList(stringArrays).stream().filter(x&gt;x.contains(\"Tomas\")).collect(Collectors.toList());上述示例中filter的参数x&gt;x.contains(&quot;Tomas&quot;)即为一个lambda表达式.流的创建可以使用集合类的stream()或者parallelStream()方法创建流:12Stream&lt;Integer&gt; stream1 = Arrays.asList(1,2,3,4).stream();Stream&lt;Integer&gt; stream2 = Arrays.asList(1,2,3,4).parallelStream();java.util.stream.Stream是一个interface, 各种管道中间操作的返回值都是它的实现类, 这允许我们方便地进行参数传递。Stream的静态方法of()也可以用来创建流:1Stream&lt;String&gt; stream3 = Stream.of(new String[]&#123;\"1\",\"2\",\"3\",\"4\"&#125;);`Arrays也提供了创建流的静态方法stream()`:1Arrays.stream(new int[]&#123;1,2,3&#125;)一些类也提供了创建流的方法:123IntStream.range(start, stop);BufferedReader.lines();Random.ints();中间操作​ 流操作是惰性执行的, 中间操作会返回一个新的流对象, 当执行终点操作时才会真正进行计算，下面介绍流的中间操作，除非传入的操作函数有副作用, 函数本身不会对数据源进行任何修改。distinctdistinct保证数据源中的重复元素在结果中只出现一次, 它使用equals()方法判断两个元素是否相等.12Stream&lt;String&gt; stream3 = Stream.of(new String[]&#123;\"1\", \"2\", \"3\", \"4\", \"1\", \"2\", \"3\", \"4\"&#125;);System.out.println(stream3.distinct().collect(Collectors.toList()));输出[1, 2, 3, 4]filterfilter根据传入的断言函数对所有元素进行检查, 只有使断言函数返回真的元素才会出现在结果中. filter不会对数据源进行修改.123Stream&lt;String&gt; stream3 = Stream.of(new String[]&#123;\"1\", \"2\", \"3\", \"4\", \"6\", \"7\", \"8\", \"9\"&#125;);List&lt;String&gt; stringList = stream3.filter(x-&gt; Integer.parseInt(x)%2==0).collect(Collectors.toList());System.out.println(stringList);输出[2, 4, 6, 8]map​ map方法根据传入的mapper函数对元素进行一对一映射, 即数据源中的每一个元素都会在结果中被替换(映射)为mapper函数的返回值，也可以根据处理返回不同的数据类型。123Stream&lt;String&gt; stream3 = Stream.of(new String[]&#123;\"1\", \"2\", \"3\", \"4\", \"6\", \"7\", \"8\", \"9\"&#125;);List&lt;Integer&gt; integerList = stream3.map(x -&gt; Integer.parseInt(x)).collect(Collectors.toList());System.out.println(integerList);输出[1, 2, 3, 4, 6, 7, 8, 9]peek​ peek方法会对数据源中所有元素进行给定操作, 但在结果中仍然是数据源中的元素. 通常我们利用操作的副作用, 修改其它数据或进行输入输出.​ peek接收一个没有返回值的λ表达式，可以做一些输出，外部处理等。map接收一个有返回值的λ表达式，之后Stream的泛型类型将转换为map参数λ表达式返回的类型123Stream&lt;Integer&gt; stream3 = Stream.of(1,2,3,4,5,6,7,8,9);List&lt;Integer&gt; integerList = stream3.peek(x-&gt; System.out.println(x)).collect(Collectors.toList());System.out.println(integerList);输出1 …[1, 2, 3, 4, 5, 6, 7, 8, 9]flatMap与map不同flatMap进行多对一映射, 它要求若数据源的元素类型为R, 则mapper函数的返回值必须为Stream&lt;R&gt;.flatMap会使用mapper函数将数据源中的元素一一映射为Stream对象, 然后把这些Stream拼装成一个流.因此我们可以使用flatMap进行合并列表之类的操作:123Stream&lt;List&lt;Integer&gt;&gt; stream3 = Stream.of(Arrays.asList(1), Arrays.asList(2, 3), Arrays.asList(4, 5, 6));List&lt;Integer&gt; integerList = stream3.flatMap(x-&gt;x.stream()).collect(Collectors.toList());System.out.println(integerList);输出[1, 2, 3, 4, 5, 6]sortedsorted方法用于对数据源进行排序:123Stream&lt;Integer&gt; stream3 = Stream.of(4, 5, 2, 6, 9, 0, 1, 3, 6, 8); List&lt;Integer&gt; integerList = stream3.sorted((x, y) -&gt; x - y).collect(Collectors.toList());System.out.println(integerList);输出[0, 1, 2, 3, 4, 5, 6, 6, 8, 9]使用java.util.Comparator是更方便的方法, 默认进行升序排序:12345678910111213141516class Item &#123; public Item(int value) &#123; this.value = value; &#125; private int value; public int getValue() &#123; return value; &#125; public void setValue(int value) &#123; this.value = value; &#125; &#125;Stream&lt;Item&gt; stream3 = Stream.of(new Item(4), new Item(3), new Item(6), new Item(9));List&lt;Item&gt; itemList = stream3.sorted(Comparator.comparingInt(Item::getValue)).collect(Collectors.toList());itemList.forEach(x -&gt; System.out.print(x.getValue()+\",\"));输出3,4,6,9,使用reversed()方法进行降序排序:123Stream&lt;Item&gt; stream3 = Stream.of(new Item(4), new Item(3), new Item(6), new Item(9));List&lt;Item&gt; itemList = stream3.sorted(Comparator.comparingInt(Item::getValue).reversed()).collect(Collectors.toList());itemList.forEach(x -&gt; System.out.print(x.getValue()+\",\"));输出9,6,4,3,limitlimit(int n)当流中元素数大于n时丢弃超出的元素, 否则不进行处理, 达到限制流长度的目的.123Stream&lt;Integer&gt; stream3 = Stream.of(3,5,1,4,2,6,8,7);List&lt;Integer&gt; integerList = stream3.limit(3).collect(Collectors.toList());System.out.println(integerList);输出[3, 5, 1]skipskip(int)返回丢弃了前n个元素的流. 如果流中的元素小于或者等于n，则返回空的流123Stream&lt;Integer&gt; stream3 = Stream.of(3,5,1,4,2,6,8,7);List&lt;Integer&gt; integerList = stream3.skip(3).collect(Collectors.toList());System.out.println(integerList);输出[4, 2, 6, 8, 7]终点操作reducereduce(accumulator)是最基本的终点操作之一, 操作函数accumulator接受两个参数x,y返回r.reduce首先将数据源中的两个元素x1和x2传给accumulator得到r1, 然后将r1和x3传入得到r2. 如此进行直到处理完整个数据流.reduce方法还可以接受一个参数代替x1作为起始值:collectcollect是使用最广泛的终点操作, 也上文中多次出现:123List&lt;String&gt; list = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;) .distinct() .collect(Collectors.toList())toList()将流转换为List实例, 是最常见的用法, java.util.Collectors类中还有求和, 计算均值, 取最值, 字符串连接等多种收集方法.forEachforEach方法对流中所有元素执行给定操作, 没有返回值.1Stream.of(1,2,3,4,5).forEach(System.out::println);其它count() 返回流中的元素数toArray(): 转换为数组并发问题除非显式地创建并行流, 否则默认创建的都是串行流.Collection.stream()为集合创建串行流,而Collection.parallelStream()创建并行流.stream.parallel()方法可以将串行流转换成并行流,stream.sequential()方法将流转换成串行流.12Stream&lt;Integer&gt; stream3 = Stream.of(1,2,3,4,5,6,7,8,9);stream3.forEach(x-&gt; System.out.print(x+\",\"));输出1,2,3,4,5,6,7,8,9,流可以在非线程安全的集合上创建, 流操作不应该对非线程安全的数据源产生任何副作用, 否则将发生java.util.ConcurrentModificationException异常.12List&lt;String&gt; list = new ArrayList(Arrays.asList(&quot;x&quot;, &quot;y&quot;));list.stream().forEach(x-&gt; list.add(&quot;z&quot;));输出1234Exception in thread \"main\" java.util.ConcurrentModificationException at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1388) at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:580) at com.test.lambda.LambdaTest.main(LambdaTest.java:15)对于线程安全的容器不会存在这个问题:12345List&lt;String&gt; list = new CopyOnWriteArrayList(Arrays.asList(\"x\", \"y\"));list.stream().forEach(x-&gt;&#123; list.add(\"z\"); System.out.println(list);&#125;);输出[x, y, z][x, y, z, z]当然作者建议Stream操作不要对数据源进行任何修改. 当然, 修改其它数据或者输入输出是允许的:12345Set&lt;String&gt; set = new HashSet&lt;String&gt;();List&lt;String&gt; list = new CopyOnWriteArrayList(Arrays.asList(\"x\", \"y\"));list.stream().forEach(x-&gt;&#123; set.add(x);&#125;);理想的管道操作应该是无状态且与访问顺序无关的. 无状态是指操作的结果只与输入有关, 下面即是一个有状态的操作示例:12345678910State state = getState();List&lt;String&gt; list = new ArrayList(Arrays.asList(\"a\", \"b\"));list = list.stream().map(s -&gt; &#123; if (state.isReady()) &#123; return s; &#125; else &#123; return null; &#125;&#125;);无状态的操作保证无论系统状态如何管道的行为不变, 与顺序无关则有利于进行并行计算.函数式接口函数式接口会将签名匹配的函数对象(lambda表达式或方法)视作接口的实现。12345@FunctionalInterfaceinterface Greeter&#123; void hello(String message);&#125;函数式接口中有且只有一个非抽象方法。1Greeter greeter = message -&gt; System.out.println(\"Hello \" + message);这在 Java 8 之前通常使用匿名内部类实现的:123456Greeter greeter = new Greeter() &#123; @Override public void hello(String message) &#123; System.out.println(\"Hello \" + message); &#125; &#125;;Java 8 将已有的一些接口实现为函数式接口:java.lang.Runnablejava.util.concurrent.Callablejava.util.Comparatorjava.lang.reflect.InvocationHandlerjava.io.FileFilterjava.nio.file.PathMatcherjava.util.function中定义了一些常用的函数式接口:Consumer: 接受参数无返回Consumer&lt;T&gt; -&gt; void accept(T t);BiConsumer&lt;T,U&gt; -&gt; void accept(T t, U u);DoubleConsumer -&gt; void accept(double value);Supplier: 不接受参数有返回Supplier&lt;T&gt; -&gt; T get();DoubleSupplier -&gt; double getAsDouble();Function: 接受参数并返回Function&lt;T, R&gt; -&gt; R apply(T t);BiFunction&lt;T, U, R&gt; -&gt; R apply(T t, U u);DoubleFunction&lt;R&gt; -&gt; R apply(double value);DoubleToIntFunction -&gt; int applyAsInt(double value);BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt;Predicate: 接受参数返回booleanPredicate&lt;T&gt; -&gt; boolean test(T t);BiPredicate&lt;T, U&gt; -&gt; boolean test(T t, U u);DoublePredicate -&gt; boolean test(double value);默认构造器可以作为supplier: Supplier&lt;Item&gt; supplier = Item::new;","categories":[{"name":"流式计算","slug":"流式计算","permalink":"http://www.baiyp.ren/categories/流式计算/"},{"name":"stream","slug":"流式计算/stream","permalink":"http://www.baiyp.ren/categories/流式计算/stream/"}],"tags":[{"name":"流式计算","slug":"流式计算","permalink":"http://www.baiyp.ren/tags/流式计算/"},{"name":"stream","slug":"stream","permalink":"http://www.baiyp.ren/tags/stream/"}],"keywords":[{"name":"流式计算","slug":"流式计算","permalink":"http://www.baiyp.ren/categories/流式计算/"},{"name":"stream","slug":"流式计算/stream","permalink":"http://www.baiyp.ren/categories/流式计算/stream/"}]},{"title":"JAVA中的分布式事务02-2PC(二阶段提交)","slug":"JAVA中的分布式事务02","date":"2019-07-17T02:05:25.000Z","updated":"2019-09-07T09:07:49.653Z","comments":true,"path":"JAVA中的分布式事务02.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的分布式事务02.html","excerpt":"","text":"JAVA中的分布式事务02-2PC(二阶段提交)方案简介​ 二阶段提交协议（Two-phase Commit，即2PC）是常用的分布式事务解决方案，即将事务的提交过程分为两个阶段来进行处理：准备阶段和提交阶段。事务的发起者称协调者，事务的执行者称参与者。​ 在分布式系统里，每个节点都可以知晓自己操作的成功或者失败，却无法知道其他节点操作的成功或失败。当一个事务跨多个节点时，为了保持事务的原子性与一致性，而引入一个协调者来统一掌控所有参与者的操作结果，并指示它们是否要把操作结果进行真正的提交或者回滚（rollback）。​ 二阶段提交的算法思路可以概括为：参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情报决定各参与者是否要提交操作还是中止操作。​ 核心思想就是对每一个事务都采用先尝试后提交的处理方式，处理后所有的读操作都要能获得最新的数据，因此也可以将二阶段提交看作是一个强一致性算法。处理流程简单一点理解，可以把协调者节点比喻为带头大哥，参与者理解比喻为跟班小弟，带头大哥统一协调跟班小弟的任务执行。阶段1：准备阶段1、协调者向所有参与者发送事务内容，询问是否可以提交事务，并等待所有参与者答复。2、各参与者执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。3、如参与者执行成功，给协调者反馈yes，即可以提交；如执行失败，给协调者反馈no，即不可提交。阶段2：提交阶段​ 如果协调者收到了参与者的失败消息或者超时，直接给每个参与者发送回滚(rollback)消息；否则，发送提交(commit)消息；参与者根据协调者的指令执行提交或者回滚操作，释放所有事务处理过程中使用的锁资源。(注意:必须在最后阶段释放锁资源)接下来分两种情况分别讨论提交阶段的过程。情况1，当所有参与者均反馈yes，提交事务：1、协调者向所有参与者发出正式提交事务的请求（即commit请求）。2、参与者执行commit请求，并释放整个事务期间占用的资源。3、各参与者向协调者反馈ack(应答)完成的消息。4、协调者收到所有参与者反馈的ack消息后，即完成事务提交。情况2，当任何阶段1一个参与者反馈no，中断事务：1、协调者向所有参与者发出回滚请求（即rollback请求）。2、参与者使用阶段1中的undo信息执行回滚操作，并释放整个事务期间占用的资源。3、各参与者向协调者反馈ack完成的消息。4、协调者收到所有参与者反馈的ack消息后，即完成事务中断。方案总结2PC方案实现起来简单，实际项目中使用比较少，主要因为以下问题：性能问题所有参与者在事务提交阶段处于同步阻塞状态，占用系统资源，容易导致性能瓶颈。可靠性问题如果协调者存在单点故障问题，如果协调者出现故障，参与者将一直处于锁定状态。数据一致性问题在阶段2中，如果发生局部网络问题，一部分事务参与者收到了提交消息，另一部分事务参与者没收到提交消息，那么就导致了节点之间数据的不一致。只适用于单个服务中因为使用了XA规范，只支持单体服务的跨库分布式事务，不支持跨服务间的分布式事务。实现方案","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.baiyp.ren/tags/分布式事务/"},{"name":"2PC","slug":"2PC","permalink":"http://www.baiyp.ren/tags/2PC/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}]},{"title":"JAVA中的分布式事务03-3PC(三阶段提交)","slug":"JAVA中的分布式事务03","date":"2019-07-17T02:05:25.000Z","updated":"2019-09-07T09:07:49.656Z","comments":true,"path":"JAVA中的分布式事务03.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的分布式事务03.html","excerpt":"","text":"JAVA中的分布式事务03-3PC(三阶段提交)方案简介​ 三阶段提交协议，是二阶段提交协议的改进版本，与二阶段提交不同的是，引入超时机制。同时在协调者和参与者中都引入超时机制。​ 三阶段提交将二阶段的准备阶段拆分为2个阶段，插入了一个preCommit阶段，使得原先在二阶段提交中，参与者在准备之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。处理流程阶段1：canCommit​ 协调者向参与者发送commit请求，参与者如果可以提交就返回yes响应(参与者不执行事务操作)，否则返回no响应：1、协调者向所有参与者发出包含事务内容的canCommit请求，询问是否可以提交事务，并等待所有参与者答复。2、参与者收到canCommit请求后，如果认为可以执行事务操作，则反馈yes并进入预备状态，否则反馈no。阶段2：preCommit​ 协调者根据阶段1 canCommit参与者的反应情况来决定是否可以基于事务的preCommit操作。根据响应情况，有以下两种可能。情况1，阶段1所有参与者均反馈yes，参与者预执行事务：1、协调者向所有参与者发出preCommit请求，进入准备阶段。2、参与者收到preCommit请求后，执行事务操作，将undo和redo信息记入事务日志中（但不提交事务）。3、各参与者向协调者反馈ack响应或no响应，并等待最终指令。情况2，阶段1任何一个参与者反馈no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务:1、协调者向所有参与者发出abort请求。2、无论收到协调者发出的abort请求，或者在等待协调者请求过程中出现超时，参与者均会中断事务。阶段3：do Commit该阶段进行真正的事务提交，也可以分为以下两种情况：情况1：阶段2所有参与者均反馈ack响应，执行真正的事务提交：1、如果协调者处于工作状态，则向所有参与者发出do Commit请求。2、参与者收到do Commit请求后，会正式执行事务提交，并释放整个事务期间占用的资源。3、各参与者向协调者反馈ack完成的消息。4、协调者收到所有参与者反馈的ack消息后，即完成事务提交。阶段2任何一个参与者反馈no，或者等待超时后协调者尚无法收到所有参与者的反馈，即中断事务：1、如果协调者处于工作状态，向所有参与者发出abort请求。2、参与者使用阶段1中的undo信息执行回滚操作，并释放整个事务期间占用的资源。3、各参与者向协调者反馈ack完成的消息。4、协调者收到所有参与者反馈的ack消息后，即完成事务中断注意：进入阶段3后，无论协调者出现问题，或者协调者与参与者网络出现问题，都会导致参与者无法接收到协调者发出的do Commit请求或abort请求。此时，参与者都会在等待超时之后，继续执行事务提交。阶段三 只允许成功不允许失败，如果服务器宕机或者停电，因为记录的阶段二的数据，重启服务后在提交事务，所以，到了阶段三，失败了也不进行回滚，只允许成功，死也要活过来之后再执行。方案总结优点相比二阶段提交，三阶段贴近降低了阻塞范围，在等待超时后协调者或参与者会中断事务。避免了协调者单点问题，阶段3中协调者出现问题时，参与者会继续提交事务。缺点数据不一致问题依然存在，当在参与者收到preCommit请求后等待do commite指令时，此时如果协调者请求中断事务，而协调者无法与参与者正常通信，会导致参与者继续提交事务，造成数据不一致。实现方案","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.baiyp.ren/tags/分布式事务/"},{"name":"3PC","slug":"3PC","permalink":"http://www.baiyp.ren/tags/3PC/"},{"name":"三阶段提交","slug":"三阶段提交","permalink":"http://www.baiyp.ren/tags/三阶段提交/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}]},{"title":"java多线程基础02-认识Java里的线程","slug":"java多线程基础-02","date":"2019-07-14T23:23:07.000Z","updated":"2019-09-07T09:07:49.605Z","comments":true,"path":"java多线程基础-02.html","link":"","permalink":"http://www.baiyp.ren/java多线程基础-02.html","excerpt":"","text":"认识Java里的线程Java程序天生就是多线程的​ 一个Java程序从main()方法开始执行，然后按照既定的代码逻辑执行，看似没有其他线程参与，但实际上Java程序天生就是多线程程序，因为执行main()方法的是一个名称为main的线程。[6] Monitor Ctrl-Break //监控Ctrl-Break中断信号的[5] Attach Listener //内存dump，线程dump，类信息统计，获取系统属性等[4] Signal Dispatcher // 分发处理发送给JVM信号的线程[3] Finalizer // 调用对象finalize方法的线程[2] Reference Handler//清除Reference的线程[1] main //main线程，用户程序入口线程的启动与中止启动启动线程的方式有：1、X extends Thread;，然后X.start123456789101112public class ThreadTest extends Thread &#123; @Override public void run() &#123; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); &#125; public static void main(String[] args) &#123; new ThreadTest().start(); &#125;&#125;2、X implements Runnable；然后交给Thread运行12345678910111213public class RunableTest implements Runnable &#123; @Override public void run() &#123; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); &#125; public static void main(String[] args) &#123; RunableTest runableTest = new RunableTest(); new Thread(runableTest).start(); &#125;&#125;Thread和Runnable的区别​ Thread才是Java里对线程的唯一抽象，Runnable只是对任务（业务逻辑）的抽象。Thread可以接受任意一个Runnable的实例并执行。中止线程自然终止要么是run执行完成了，要么是抛出了一个未处理的异常导致线程提前结束。stop​ 暂停、恢复和停止操作对应在线程Thread的API就是suspend()、resume()和stop()。但是这些API是过期的，也就是不建议使用的。不建议使用的原因主要有：以suspend()方法为例，在调用后，线程不会释放已经占有的资源（比如锁），而是占有着资源进入睡眠状态，这样容易引发死锁问题。同样，stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。正因为suspend()、resume()和stop()方法带来的副作用，这些方法才被标注为不建议使用的过期方法。中断​ 安全的中止则是其他线程通过调用某个线程A的interrupt()方法对其进行中断操作, 中断好比其他线程对该线程打了个招呼，“A，你要中断了”，不代表线程A会立即停止自己的工作，同样的A线程完全可以不理会这种中断请求。因为java里的线程是协作式的，不是抢占式的。线程通过检查自身的中断标志位是否被置为true来进行响应，​ 线程通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()来进行判断当前线程是否被中断，不过Thread.interrupted()会同时将中断标识位改写为false。​ 如果一个线程处于了阻塞状态（如线程调用了thread.sleep、thread.join、thread.wait等），则在线程在检查中断标示时如果发现中断标示为true，则会在这些阻塞方法调用处抛出InterruptedException异常，并且在抛出异常后会立即将线程的中断标示位清除，即重新设置为false。​ 不建议自定义一个取消标志位来中止线程的运行。因为run方法里有阻塞调用时会无法很快检测到取消标志，线程必须从阻塞调用返回后，才会检查这个取消标志。这种情况下，使用中断会更好，因为，一般的阻塞方法，如sleep等本身就支持中断的检查，检查中断位的状态和检查取消标志位没什么区别，用中断位的状态还可以避免声明取消标志位，减少资源的消耗。注意：处于死锁状态的线程无法被中断样例代码1234567891011121314151617181920212223242526public class RunableTest implements Runnable &#123; private int i = 0; @Override public void run() &#123; while (!Thread.currentThread().isInterrupted()) &#123; i++; //todo 处理业务 System.out.println(\"xxxxxxxxxxxxx\"); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; if (i &gt; 10) &#123; Thread.currentThread().interrupt(); &#125; &#125; &#125; public static void main(String[] args) &#123; RunableTest runableTest = new RunableTest(); new Thread(runableTest).start(); &#125;&#125;","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"多线程基础","slug":"多线程基础","permalink":"http://www.baiyp.ren/tags/多线程基础/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}]},{"title":"JAVA中的分布式事务01-简介","slug":"JAVA中的分布式事务01","date":"2019-07-13T02:05:25.000Z","updated":"2019-09-07T09:07:49.651Z","comments":true,"path":"JAVA中的分布式事务01.html","link":"","permalink":"http://www.baiyp.ren/JAVA中的分布式事务01.html","excerpt":"","text":"JAVA中的分布式事务01-简介事务的具体定义​ 事务提供一种机制将一个活动涉及的所有操作纳入到一个不可分割的执行单元，组成事务的所有操作只有在所有操作均能正常执行的情况下方能提交，只要其中任一操作执行失败，都将导致整个事务的回滚。简单地说，事务提供一种“要么什么都不做，要么做全套（All or Nothing）”机制数据库本地事务说到数据库事务就不得不说，数据库事务中的四大特性，ACIDA:原子性(Atomicity)​ 一个事务(transaction)中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。​ 就像你买东西要么交钱收货一起都执行，要么要是发不出货，就退钱。C:一致性(Consistency)​ 事务的一致性指的是在一个事务执行之前和执行之后数据库都必须处于一致性状态。如果事务成功地完成，那么系统中所有变化将正确地应用，系统处于有效状态。如果在事务中出现错误，那么系统中的所有变化将自动地回滚，系统返回到原始状态。I:隔离性(Isolation)​ 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。事务查看数据更新时，数据所处的状态要么是另一事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看到中间状态的数据。打个比方，你买东西这个事情，是不影响其他人的D:持久性(Durability)​ 指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。打个比方，你买东西的时候需要记录在账本上，即使老板忘记了那也有据可查。简单而言，ACID是从不同维度描述事务的特性：原子性 —— 事务操作的整体性一致性 —— 事务操作下数据的正确性隔离性 —— 事务并发操作下数据的正确性持久性 —— 事务对数据修改的可靠性一个支持事务（Transaction）的数据库，需要具有这4种特性，否则在事务过程当中无法保证数据的正确性，处理结果极可能达不到请求方的要求。什么时候使用数据库事务​ 在介绍完事务基本概念之后，什么时候该使用数据库事务？简单而言，就是业务上有一组数据操作，需要如果其中有任何一个操作执行失败，整组操作全部不执行并恢复到未执行状态，要么全部成功，要么全部失败。​ 在使用数据库事务时需要注意，尽可能短的保持事务，修改多个不同表的数据的冗长事务会严重妨碍系统中的所有其他用户，这很有可能导致一些性能问题。什么是分布式事务分布式产生背景与概念​ 随着互联网快速发展，微服务，SOA等服务架构模式正在被大规模的使用，现在分布式系统一般由多个独立的子系统组成，多个子系统通过网络通信互相协作配合完成各个功能。​ 有很多用例会跨多个子系统才能完成，比较典型的是电子商务网站的下单支付流程，至少会涉及交易系统和支付系统，而且这个过程中会涉及到事务的概念，即保证交易系统和支付系统的数据一致性，此处我们称这种跨系统的事务为分布式事务，具体一点而言，分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。举个互联网常用的交易业务为例：​ 上图中包含了库存和订单两个独立的微服务，每个微服务维护了自己的数据库。在交易系统的业务逻辑中，一个商品在下单之前需要先调用库存服务，进行扣除库存，再调用订单服务，创建订单记录。可以看到，如果多个数据库之间的数据更新没有保证事务，将会导致出现子系统数据不一致，业务出现问题。分布式事务的难点事务的原子性事务操作跨不同节点，当多个节点某一节点操作失败时，需要保证多节点操作的**要么什么都不做，要么做全套（All or Nothing）**的原子性。事务的一致性​ 当发生网络传输故障或者节点故障，节点间数据复制通道中断，在进行事务操作时需要保证数据一致性，保证事务的任何操作都不会使得数据违反数据库定义的约束、触发器等规则。事务的隔离性​ 事务隔离性的本质就是如何正确多个并发事务的处理的读写冲突和写写冲突，因为在分布式事务控制中，可能会出现提交不同步的现象，这个时候就有可能出现“部分已经提交”的事务。此时并发应用访问数据如果没有加以控制，有可能出现“脏读”问题。分布式系统的一致性​ 前面介绍到的分布式事务的难点涉及的问题，最终影响是导致数据出现不一致，下面对分布式系统的一致性问题进行理论分析，后面将基于这些理论进行分布式方案的介绍。可用性和一致性的冲突 —— CAP理论​ CAP 定理又被称作布鲁尔定理，是加州大学的计算机科学家布鲁尔在 2000 年提出的一个猜想。2002 年，麻省理工学院的赛斯·吉尔伯特和南希·林奇发表了布鲁尔猜想的证明，使之成为分布式计算领域公认的一个定理。​ 布鲁尔在提出CAP猜想时并没有具体定义 Consistency、Availability、Partition Tolerance 这3个词的含义，不同资料的具体定义也有差别，为了更好地解释，下面选择Robert Greiner的文章《CAP Theorem》作为参考基础。CAP理论的定义在一个分布式系统（指互相连接并共享数据的节点的集合）中，当涉及读写操作时，只能保证一致性（Consistence）、可用性（Availability）、分区容错性（PartitionTolerance）三者中的两个，另外一个必须被牺牲。Consistency、Availability、Partition Tolerance具体解释如下：C - Consistency 一致性A read is guaranteed to return the most recent write for a given client.对某个指定的客户端来说，读操作保证能够返回最新的写操作结果。​ 这里并不是强调同一时刻拥有相同的数据，对于系统执行事务来说，在事务执行过程中，系统其实处于一个不一致的状态，不同的节点的数据并不完全一致。​ 一致性强调客户端读操作能够获取最新的写操作结果，是因为事务在执行过程中，客户端是无法读取到未提交的数据的，只有等到事务提交后，客户端才能读取到事务写入的数据，而如果事务失败则会进行回滚，客户端也不会读取到事务中间写入的数据。A - Availability 可用性A non-failing node will return a reasonable response within a reasonable amount of time (no error or timeout).非故障的节点在合理的时间内返回合理的响应（不是错误和超时的响应）。​ 这里强调的是合理的响应，不能超时，不能出错。注意并没有说“正确”的结果，例如，应该返回 100 但实际上返回了 90，肯定是不正确的结果，但可以是一个合理的结果。P - Partition Tolerance 分区容忍性The system will continue to function when network partitions occur.当出现网络分区后，系统能够继续“履行职责”。这里网络分区是指：一个分布式系统里面，节点组成的网络本来应该是连通的。然而可能因为一些故障（节点间网络连接断开、节点宕机），使得有些节点之间不连通了，整个网络就分成了几块区域，数据就散布在了这些不连通的区域中。一致性、可用性、分区容忍性的选择​ 虽然 CAP 理论定义是三个要素中只能取两个，但放到分布式环境下来思考，我们会发现必须选择 P（分区容忍）要素，因为网络本身无法做到 100% 可靠，有可能出故障，所以分区是一个必然的现象。​ 如果我们选择了 CA（一致性 + 可用性） 而放弃了 P（分区容忍性），那么当发生分区现象时，为了保证 C（一致性），系统需要禁止写入，当有写入请求时，系统返回 error（例如，当前系统不允许写入），这又和 A(可用性) 冲突了，因为 A（可用性）要求返回 no error 和 no timeout。因此，分布式系统理论上不可能选择 CA （一致性 + 可用性）架构，只能选择 CP（一致性 + 分区容忍性） 或者 AP （可用性 + 分区容忍性）架构，在一致性和可用性做折中选择。CP - Consistency + Partition Tolerance （一致性 + 分区容忍性）​ 如上图所示，因为Node1节点和Node2节点连接中断导致分区现象，Node1节点的数据已经更新到y，但是Node1 和 Node2 之间的复制通道中断，数据 y 无法同步到 Node2，Node2 节点上的数据还是旧数据x。​ 这时客户端C 访问 Node2 时，Node2 需要返回 Error，提示客户端 “系统现在发生了错误”，这种处理方式违背了可用性（Availability）的要求，因此 CAP 三者只能满足 CP。AP - Availability + Partition Tolerance （可用性 + 分区容忍性）​ 同样是Node2 节点上的数据还是旧数据x，这时客户端C 访问 Node2 时，Node2 将当前自己拥有的数据 x 返回给客户端 了，而实际上当前最新的数据已经是 y 了，这就不满足一致性（Consistency）的要求了，因此 CAP 三者只能满足 AP。​ 注意：这里 Node2 节点返回 x，虽然不是一个“正确”的结果，但是一个“合理”的结果，因为 x 是旧的数据，并不是一个错乱的值，只是不是最新的数据。​ 值得补充的是，CAP理论告诉我们分布式系统只能选择AP或者CP，但实际上并不是说整个系统只能选择AP或者CP，在 CAP 理论落地实践时，我们需要将系统内的数据按照不同的应用场景和要求进行分类，每类数据选择不同的策略（CP 还是 AP），而不是直接限定整个系统所有数据都是同一策略。​ 另外，只能选择CP或者AP是指系统发生分区现象时无法同时保证C（一致性）和A（可用性），但不是意味着什么都不做，当分区故障解决后，系统还是要保持保证CA。CAP理论的延伸——BASE理论​ BASE 是指基本可用（Basically Available）、软状态（ Soft State）、最终一致性（ Eventual Consistency），核心思想是即使无法做到强一致性（CAP 的一致性就是强一致性），但应用可以采用适合的方式达到最终一致性。BA - Basically Available 基本可用分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。​ 这里的关键词是“部分”和“核心”，实际实践上，哪些是核心需要根据具体业务来权衡。例如登录功能相对注册功能更加核心，注册不了最多影响流失一部分用户，如果用户已经注册但无法登录，那就意味用户无法使用系统，造成的影响范围更大。S - Soft State 软状态​ 允许系统存在中间状态，而该中间状态不会影响系统整体可用性。这里的中间状态就是 CAP 理论中的数据不一致。E - Eventual Consistency 最终一致性系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。​ 这里的关键词是“一定时间” 和 “最终”，“一定时间”和数据的特性是强关联的，不同业务不同数据能够容忍的不一致时间是不同的。例如支付类业务是要求秒级别内达到一致，因为用户时时关注；用户发的最新微博，可以容忍30分钟内达到一致的状态，因为用户短时间看不到明星发的微博是无感知的。而“最终”的含义就是不管多长时间，最终还是要达到一致性的状态。BASE 理论本质上是对 CAP 的延伸和补充，更具体地说，是对 CAP 中 AP 方案的一个补充：CP 理论是忽略延时的，而实际应用中延时是无法避免的。这一点就意味着完美的 CP 场景是不存在的，即使是几毫秒的数据复制延迟，在这几毫秒时间间隔内，系统是不符合 CP 要求的。因此 CAP 中的 CP 方案，实际上也是实现了最终一致性，只是“一定时间”是指几毫秒而已。AP 方案中牺牲一致性只是指发生分区故障期间，而不是永远放弃一致性。这一点其实就是 BASE 理论延伸的地方，分区期间牺牲一致性，但分区故障恢复后，系统应该达到最终一致性。数据一致性模型前面介绍的BASE模型提过“强一致性”和“最终一致性”，下面对这些一致性模型展开介绍。​ 分布式系统通过复制数据来提高系统的可靠性和容错性，并且将数据的不同的副本存放在不同的机器上，由于维护数据副本的一致性代价很高，因此许多系统采用弱一致性来提高性能，下面介绍常见的一致性模型：强一致性要求无论更新操作是在哪个数据副本上执行，之后所有的读操作都要能获得最新的数据。对于单副本数据来说，读写操作是在同一数据上执行的，容易保证强一致性。对多副本数据来说，则需要使用分布式事务协议。弱一致性在这种一致性下，用户读到某一操作对系统特定数据的更新需要一段时间，我们将这段时间称为&quot;不一致性窗口&quot;。最终一致性​ 是弱一致性的一种特例，在这种一致性下系统保证用户最终能够读取到某操作对系统特定数据的更新（读取操作之前没有该数据的其他更新操作）。”不一致性窗口”的大小依赖于交互延迟、系统的负载，以及数据的副本数等。总结​ 系统选择哪种一致性模型取决于应用对一致性的需求，所选取的一致性模型还会影响到系统如何处理用户的请求以及对副本维护技术的选择等。后面将基于上面介绍的一致性模型分别介绍分布式事务的解决方案。柔性事务柔性事务的概念​ 在电商等互联网场景下，传统的事务在数据库性能和处理能力上都暴露出了瓶颈。在分布式领域基于CAP理论以及BASE理论，有人就提出了柔性事务的概念。​ 基于BASE理论的设计思想，柔性事务下，在不影响系统整体可用性的情况下(Basically Available 基本可用)，允许系统存在数据不一致的中间状态(Soft State 软状态)，在经过数据同步的延时之后，最终数据能够达到一致。并不是完全放弃了ACID，而是通过放宽一致性要求，借助本地事务来实现最终分布式事务一致性的同时也保证系统的吞吐。实现柔性事务的一些特性下面介绍的是实现柔性事务的一些常见特性，这些特性在具体的方案中不一定都要满足，因为不同的方案要求不一样。可见性(对外可查询)​ 在分布式事务执行过程中，如果某一个步骤执行出错，就需要明确的知道其他几个操作的处理情况，这就需要其他的服务都能够提供查询接口，保证可以通过查询来判断操作的处理情况。​ 为了保证操作的可查询，需要对于每一个服务的每一次调用都有一个全局唯一的标识，可以是业务单据号（如订单号）、也可以是系统分配的操作流水号（如支付记录流水号）。除此之外，操作的时间信息也要有完整的记录。操作幂等性​ 幂等性，其实是一个数学概念。幂等函数，或幂等方法，是指可以使用相同参数重复执行，并能获得相同结果的函数。幂等操作的特点是其任意多次执行所产生的影响均与一次执行的影响相同。也就是说，同一个方法，使用同样的参数，调用多次产生的业务结果与调用一次产生的业务结果相同。​ 之所以需要操作幂等性，是因为为了保证数据的最终一致性，很多事务协议都会有很多重试的操作，如果一个方法不保证幂等，那么将无法被重试。幂等操作的实现方式有多种，如在系统中缓存所有的请求与处理结果、检测到重复操作后，直接返回上一次的处理结果等。常见分布式事务解决方案​ 介绍完分布式系统的一致性相关理论，下面基于不同的一致性模型介绍分布式事务的常见解决方案，后面会再介绍各个方案的使用场景。​ 分布式事务的实现有许多种，其中较经典是由Tuxedo提出的XA分布式事务协议，XA协议包含二阶段提交（2PC）和三阶段提交（3PC）两种实现。","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"分布式事务","slug":"分布式事务","permalink":"http://www.baiyp.ren/tags/分布式事务/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"分布式事务","slug":"架构/分布式事务","permalink":"http://www.baiyp.ren/categories/架构/分布式事务/"}]},{"title":"java多线程基础01-java多线程概述","slug":"java多线程基础-01","date":"2019-07-10T08:05:00.000Z","updated":"2019-09-07T09:07:49.603Z","comments":true,"path":"java多线程基础-01.html","link":"","permalink":"http://www.baiyp.ren/java多线程基础-01.html","excerpt":"","text":"多线程概述基础概念进程和线程进程是程序运行资源分配的最小单位​ 进程是操作系统进行资源分配的最小单位,其中资源包括:CPU、内存空间、磁盘IO等,同一进程中的多条线程共享该进程中的全部系统资源,而进程和进程之间是相互独立的。进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位。​ 进程是程序在计算机上的一次执行活动。当你运行一个程序,你就启动了一个进程。显然,程序是死的、静态的,进程是活的、动态的。进程可以分为系统进程和用户进程。凡是用于完成操作系统的各种功能的进程就是系统进程,它们就是处于运行状态下的操作系统本身,用户进程就是所有由你启动的进程。线程是CPU调度的最小单位,必须依赖于进程而存在​ 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的、能独立运行的基本单位。线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。线程无处不在​ 任何一个程序都必须要创建线程,特别是Java不管任何程序都必须启动一个main函数的主线程; Java Web开发里面的定时任务、定时器、JSP和 Servlet、异步消息处理机制,远程访问接口RM等,任何一个监听事件, onclick的触发事件等都离不开线程和并发的知识。CPU核心数和线程数的关系​ 多核心:也指单芯片多处理器( Chip Multiprocessors,简称CMP),CMP是由美国斯坦福大学提出的,其思想是将大规模并行处理器中的SMP(对称多处理器)集成到同一芯片内,各个处理器并行执行不同的进程。这种依靠多个CPU同时并行地运行程序是实现超高速计算的一个重要方向,称为并行处理多线程: Simultaneous Multithreading.简称SMT.让同一个处理器上的多个线程同步执行并共享处理器的执行资源。核心数、线程数:目前主流CPU都是多核的。增加核心数目就是为了增加线程数,因为操作系统是通过线程来执行任务的,一般情况下它们是1:1对应关系,也就是说四核CPU一般拥有四个线程。但 Intel引入超线程技术后,使核心数与线程数形成1:2的关系CPU时间片轮转机制​ 我们平时在开发的时候，感觉并没有受cpu核心数的限制，想启动线程就启动线程，哪怕是在单核CPU上，为什么？这是因为操作系统提供了一种CPU时间片轮转机制。​ 时间片轮转调度是一种最古老、最简单、最公平且使用最广的算法,又称RR调度。每个进程被分配一个时间段,称作它的时间片,即该进程允许运行的时间。百度百科对CPU时间片轮转机制原理解释如下:​ 如果在时间片结束时进程还在运行,则CPU将被剥夺并分配给另一个进程。如果进程在时间片结束前阻塞或结来,则CPU当即进行切换。调度程序所要做的就是维护一张就绪进程列表,当进程用完它的时间片后,它被移到队列的末尾​ 时间片轮转调度中唯一有趣的一点是时间片的长度。从一个进程切换到另一个进程是需要定时间的,包括保存和装入寄存器值及内存映像,更新各种表格和队列等。假如进程切( processwitch),有时称为上下文切换( context switch),需要5ms,再假设时间片设为20ms,则在做完20ms有用的工作之后,CPU将花费5ms来进行进程切换。CPU时间的20%被浪费在了管理开销上了。​ 为了提高CPU效率,我们可以将时间片设为5000ms。这时浪费的时间只有0.1%。但考虑到在一个分时系统中,如果有10个交互用户几乎同时按下回车键,将发生什么情况?假设所有其他进程都用足它们的时间片的话,最后一个不幸的进程不得不等待5s才获得运行机会。多数用户无法忍受一条简短命令要5才能做出响应,同样的问题在一台支持多道程序的个人计算机上也会发​ 结论可以归结如下:时间片设得太短会导致过多的进程切换,降低了CPU效率:而设得太长又可能引起对短的交互请求的响应变差。将时间片设为100ms通常是一个比较合理的折衷。​ 在CPU死机的情况下,其实大家不难发现当运行一个程序的时候把CPU给弄到了100%再不重启电脑的情况下,其实我们还是有机会把它KILL掉的,我想也正是因为这种机制的缘故。澄清并行和并发​ 我们举个例子,如果有条高速公路A上面并排有8条车道,那么最大的并行车辆就是8辆此条高速公路A同时并排行走的车辆小于等于8辆的时候,车辆就可以并行运行。CPU也是这个原理,一个CPU相当于一个高速公路A,核心数或者线程数就相当于并排可以通行的车道;而多个CPU就相当于并排有多条高速公路,而每个高速公路并排有多个车道。当谈论并发的时候一定要加个单位时间,也就是说单位时间内并发量是多少?离开了单位时间其实是没有意义的。​ 俗话说,一心不能二用,这对计算机也一样,原则上一个CPU只能分配给一个进程,以便运行这个进程。我们通常使用的计算机中只有一个CPU,也就是说只有一颗心,要让它一心多用同时运行多个进程,就必须使用并发技术。实现并发技术相当复杂,最容易理解的是“时间片轮转进程调度算法”。综合来说：​ 并发:指应用能够交替执行不同的任务,比如单CPU核心下执行多线程并非是同时执行多个任务,如果你开两个线程执行,就是在你几乎不可能察觉到的速度不断去切换这两个任务,已达到”同时执行效果”,其实并不是的,只是计算机的速度太快,我们无法察觉到而已.​ 并行:指应用能够同时执行不同的任务,例:吃饭的时候可以边吃饭边打电话,这两件事情可以同时执行两者区别:一个是交替执行,一个是同时执行.高并发编程的意义、好处和注意事项​ 由于多核多线程的CPU的诞生,多线程、高并发的编程越来越受重视和关注。多线程可以给程序带来如下好处。1. 充分利用CPU的资源​ 从上面的CPU的介绍,可以看的出来,现在市面上没有CPU的内核不使用多线程并发机制的,特别是服务器还不止一个CPU,如果还是使用单线程的技术做思路,明显就out了。因为程序的基本调度单元是线程,并且一个线程也只能在一个CPU的一个核的一个线程跑,如果你是个i3的CPU的话,最差也是双核心4线程的运算能力:如果是一个线程的程序的话,那是要浪费3/4的CPU性能:如果设计一个多线程的程序的话,那它就可以同时在多个CPU的多个核的多个线程上跑,可以充分地利用CPU,减少CPU的空闲时间,发挥它的运算能力,提高并发量。​ 就像我们平时坐地铁一样,很多人坐长线地铁的时候都在认真看书,而不是为了坐地铁而坐地铁,到家了再去看书,这样你的时间就相当于有了两倍。这就是为什么有些人时间很充裕,而有些人老是说没时间的一个原因,工作也是这样,有的时候可以并发地去做几件事情,充分利用我们的时间,CPU也是一样,也要充分利用。2. 加快响应用户的时间​ 比如我们经常用的迅雷下载,都喜欢多开几个线程去下载,谁都不愿意用一个线程去下载,为什么呢?答案很简单,就是多个线程下载快啊。​ 我们在做程序开发的时候更应该如此,特别是我们做互联网项目,网页的响应时间若提升1s,如果流量大的话,就能增加不少转换量。做过高性能web前端调优的都知道,要将静态资源地址用两三个子域名去加载,为什么?因为每多一个子域名,浏览器在加载你的页面的时候就会多开几个线程去加载你的页面资源,提升网站的响应速度。多线程,高并发真的是无处不在。3. 可以使你的代码模块化,异步化,简单化​ 例如我们实现电商系统，下订单和给用户发送短信、邮件就可以进行拆分，将给用户发送短信、邮件这两个步骤独立为单独的模块，并交给其他线程去执行。这样既增加了异步的操作，提升了系统性能，又使程序模块化,清晰化和简单化。多线程应用开发的好处还有很多,大家在日后的代码编写过程中可以慢慢体会它的魅力。多线程程序需要注意事项1. 线程之间的安全性​ 从前面的章节中我们都知道,在同一个进程里面的多线程是资源共享的,也就是都可以访问同一个内存地址当中的一个变量。例如:若每个线程中对全局变量、静态变量只有读操作,而无写操作,一般来说,这个全局变量是线程安全的:若有多个线程同时执行写操作,一般都需要考虑线程同步,否则就可能影响线程安全。2. 线程之间的死锁​ 为了解决线程之间的安全性引入了Java的锁机制,而一不小心就会产生Java线程死锁的多线程问题,因为不同的线程都在等待那些根本不可能被释放的锁,从而导致所有的工作都无法完成。假设有两个线程,分别代表两个饥饿的人,他们必须共享刀叉并轮流吃饭。他们都需要获得两个锁:共享刀和共享叉的锁。假如线程A获得了刀,而线程B获得了叉。线程A就会进入阻塞状态来等待获得叉,而线程B则阻塞来等待线程A所拥有的刀。这只是人为设计的例子,但尽管在运行时很难探测到,这类情况却时常发生3. 线程太多了会将服务器资源耗尽形成死机当机​ 线程数太多有可能造成系统创建大量线程而导致消耗完系统内存以及CPU的“过渡切换”,造成系统的死机,那么我们该如何解决这类问题呢?​ 某些系统资源是有限的,如文件描述符。多线程程序可能耗尽资源,因为每个线程都可能希望有一个这样的资源。如果线程数相当大,或者某个资源的侯选线程数远远超过了可用的资源数则最好使用资源池。一个最好的示例是数据库连接池。只要线程需要使用一个数据库连接,它就从池中取出一个,使用以后再将它返回池中。资源池也称为资源库。多线程应用开发的注意事项很多,希望大家在日后的工作中可以慢慢体会它的危险所在。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"多线程基础","slug":"多线程基础","permalink":"http://www.baiyp.ren/tags/多线程基础/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"多线程基础","slug":"并发/多线程基础","permalink":"http://www.baiyp.ren/categories/并发/多线程基础/"}]},{"title":"java并发工具类-Fork-Join","slug":"java并发工具类-01","date":"2019-07-05T23:10:45.000Z","updated":"2019-09-07T09:07:49.620Z","comments":true,"path":"java并发工具类-01.html","link":"","permalink":"http://www.baiyp.ren/java并发工具类-01.html","excerpt":"","text":"java并发工具类-Fork-JoinFork-Join​ java下多线程的开发可以我们自己启用多线程，线程池，还可以使用forkjoin，forkjoin可以让我们不去了解诸如Thread,Runnable等相关的知识，只要遵循forkjoin的开发模式，就可以写出很好的多线程并发程序，Fork-Join 是什么​ Fork/Join框架是Java7提供了的一个用于并行执行任务的框架， 是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。分而治之​ “分而治之” 一直是一个有效的处理大量数据的方法。著名的 MapReduce 也是采取了分而治之的思想。简单来说，就是如果你要处理1000个数据，但是你并不具备处理1000个数据的能力，那么你可以只处理其中的10个，然后，分阶段处理100次，将100次的结果进行合成，那就是最终想要的对原始的1000个数据的处理结果。​ 同时forkjoin在处理某一类问题时非常的有用，哪一类问题？分而治之的问题。十大计算机经典算法：快速排序、堆排序、归并排序、二分查找、线性查找、深度优先、广度优先、Dijkstra、动态规划、朴素贝叶斯分类，有几个属于分而治之？3个，快速排序、归并排序、二分查找，还有大数据中M/R都是。分治法的设计思想是：将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。分治策略是：对于一个规模为n的问题，若该问题可以容易地解决（比如说规模n较小）则直接解决，否则将其分解为k个规模较小的子问题，这些子问题互相独立且与原问题形式相同(子问题相互之间有联系就会变为动态规范算法)，递归地解这些子问题，然后将各子问题的解合并得到原问题的解。这种算法设计策略叫做分治法。归并排序​ 归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为2-路归并，与之对应的还有多路归并。​ 对于给定的一组数据，利用递归与分治技术将数据序列划分成为越来越小的半子表，在对半子表排序后，再用递归方法将排好序的半子表合并成为越来越大的有序序列。​ 为了提升性能，有时我们在半子表的个数小于某个数（比如15）的情况下，对半子表的排序采用其他排序算法，比如插入排序。Fork-Join原理Fork/Join框架要完成两件事情：任务分割​ Fork/Join框架的基本思想就是将一个大任务分解（Fork）成一系列子任务，子任务可以继续往下分解，当多个不同的子任务都执行完成后，可以将它们各自的结果合并（Join）成一个大结果，最终合并成大任务的结果：ForkJoinTask基本任务，使用forkjoin框架必须创建的对象，提供fork,join操作，常用的两个子类RecursiveAction : 无结果返回的任务RecursiveTask : 有返回结果的任务说明：fork : 让task异步执行join : 让task同步执行，可以获取返回值ForkJoinTask 在不显示使用ForkJoinPool.execute/invoke/submit()方法进行执行的情况下，也可以使用自己的fork/invoke方法进行执行结果合并ForkJoinPool 执行 ForkJoinTask任务分割出的子任务会添加到当前工作线程所维护的双端队列中，进入队列的头部。当一个工作线程的队列里暂时没有任务时，它会随机从其他工作线程的队列的尾部获取一个任务三中提交方式：execute： 异步，无返回结果submit ：异步，有返回结果 （返回Future&lt;T&gt;）invoke ：同步，有返回结果 （会阻塞）工作密取​ 即当前线程的Task已经全被执行完毕，则自动取到其他线程的Task池中取出Task继续执行。ForkJoinPool中维护着多个线程（一般为CPU核数）在不断地执行Task，每个线程除了执行自己职务内的Task之外，还会根据自己工作线程的闲置情况去获取其他繁忙的工作线程的Task，如此一来就能能够减少线程阻塞或是闲置的时间，提高CPU利用率。Fork/Join使用​ 我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork和join的操作机制，通常我们不直接继承ForkjoinTask类，只需要直接继承其子类。RecursiveAction，用于没有返回结果的任务RecursiveTask，用于有返回值的任务task要通过ForkJoinPool来执行，使用submit 或 invoke 提交，两者的区别是：invoke是同步执行，调用之后需要等待任务完成，才能执行后面的代码；submit是异步执行。join()和get方法当任务完成的时候返回计算结果。​ 在我们自己实现的compute方法里，首先需要判断任务是否足够小，如果足够小就直接执行任务。如果不足够小，就必须分割成两个子任务，每个子任务在调用invokeAll方法时，又会进入compute方法，看看当前子任务是否需要继续分割成孙任务，如果不需要继续分割，则执行当前子任务并返回结果。使用join方法会等待子任务执行完并得到其结果。Fork/Join的使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121public class SubmitTask extends RecursiveTask&lt;Long&gt; &#123; /** * 起始值 */ private long start; /** * 结束值 */ private long end; /** * 阈值 */ private long threshold = 10L; public SubmitTask(long start, long end) &#123; this.start = start; this.end = end; &#125; /** * 计算逻辑 * * @return */ @Override protected Long compute() &#123; //校验是否达到了阈值 if (isLessThanThreshold()) &#123; //处理并返回结果 return handle(); &#125; else &#123; //没有达到阈值 计算一个中间值 long mid = (start + end) / 2; //拆分 左边的 SubmitTask left = new SubmitTask(start, mid); //拆分右边的 SubmitTask right = new SubmitTask(mid + 1, end); //添加到任务列表 invokeAll(left, right); //合并结果并返回 return left.join() + right.join(); &#125; &#125; /** * 处理的任务 * * @return */ public Long handle() &#123; long sum = 0; for (long i = start; i &lt;= end; i++) &#123; sum += i; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return sum; &#125; /*是否达到了阈值*/ private boolean isLessThanThreshold() &#123; return end - start &lt;= threshold; &#125; /** * forkJoin 方式调用 * * @param start * @param end */ public static void forkJoinInvok(long start, long end) &#123; long sum = 0; long currentTime = System.currentTimeMillis(); //创建ForkJoinPool 连接池 ForkJoinPool forkJoinPool = new ForkJoinPool(); //创建初始化任务 SubmitTask submitTask = new SubmitTask(start, end); //讲初始任务扔进连接池中执行 forkJoinPool.invoke(submitTask); //等待返回结果 sum = submitTask.join(); System.out.println(\"forkJoin调用：result:\" + sum); System.out.println(\"forkJoin调用耗时：\" + (System.currentTimeMillis() - currentTime)); &#125; /** * 普通方式调用 * * @param start * @param end */ public static void normalInvok(long start, long end) &#123; long sum = 0; long currentTime = System.currentTimeMillis(); for (long i = start; i &lt;= end; i++) &#123; sum += i; try &#123; Thread.sleep(1); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println(\"普通调用：result:\" + sum); System.out.println(\"普通调用耗时：\" + (System.currentTimeMillis() - currentTime)); &#125; public static void main(String[] args) &#123; //起始值的大小 long start = 0; //结束值的大小 long end = 10000; //forkJoin 调用 forkJoinInvok(start, end); System.out.println(\"========================\"); //普通调用 normalInvok(start, end); &#125;&#125;运行结果forkJoin调用：result:50005000forkJoin调用耗时：2286普通调用：result:50005000普通调用耗时：17038Fork/Join 同步用法同步用法就是将初始化的任务扔进连接池，如果没有执行完成会阻塞forkJoinPool.invoke(submitTask);12345678910111213141516171819202122 /** * forkJoin 方式调用 * * @param start * @param end */public static void forkJoinInvok(long start, long end) &#123; long sum = 0; long currentTime = System.currentTimeMillis(); //创建ForkJoinPool 连接池 ForkJoinPool forkJoinPool = new ForkJoinPool(); //创建初始化任务 SubmitTask submitTask = new SubmitTask(start, end); //讲初始任务扔进连接池中执行 同步用法 forkJoinPool.invoke(submitTask); System.out.println(\"同步方式，任务结束才会调用该方法,当前耗时\"+(System.currentTimeMillis() - currentTime)); //等待返回结果 sum = submitTask.join(); System.out.println(\"任务执行完成，当前耗时：\"+(System.currentTimeMillis() - currentTime)); System.out.println(\"forkJoin调用：result:\" + sum); System.out.println(\"forkJoin调用耗时：\" + (System.currentTimeMillis() - currentTime));&#125;打进结果同步方式，任务结束才会调用该方法,当前耗时2367任务执行完成，当前耗时：2368forkJoin调用：result:50005000forkJoin调用耗时：2368Fork/Join 异步用法异步用法就是将初始化的任务扔进连接池，然后继续其他任务forkJoinPool.submit(submitTask);12345678910111213141516171819202122/** * forkJoin 方式调用 * * @param start * @param end */public static void forkJoinInvok(long start, long end) &#123; long sum = 0; long currentTime = System.currentTimeMillis(); //创建ForkJoinPool 连接池 ForkJoinPool forkJoinPool = new ForkJoinPool(); //创建初始化任务 SubmitTask submitTask = new SubmitTask(start, end); //讲初始任务扔进连接池中执行 异步方式 forkJoinPool.submit(submitTask); System.out.println(\"异步方式，任务结束才会调用该方法,当前耗时\"+(System.currentTimeMillis() - currentTime)); //等待返回结果 sum = submitTask.join(); System.out.println(\"任务执行完成，当前耗时：\"+(System.currentTimeMillis() - currentTime)); System.out.println(\"forkJoin调用：result:\" + sum); System.out.println(\"forkJoin调用耗时：\" + (System.currentTimeMillis() - currentTime));&#125;打印结果异步方式，任务结束才会调用该方法,当前耗时3任务执行完成，当前耗时：2315forkJoin调用：result:50005000forkJoin调用耗时：2315总结关于ForkJoinPool可以使用ForkJoinPool.execute(异步，不返回结果)/invoke(同步，返回结果)/submit(异步，返回结果)方法，来执行ForkJoinTask。ForkJoinPool有一个方法commonPool()，这个方法返回一个ForkJoinPool内部声明的静态ForkJoinPool实例。文档上说，这个方法适用于大多数的应用。这个静态实例的初始线程数，为“CPU核数-1 ”，（Runtime.getRuntime().availableProcessors() - 1）ForkJoinTask自己启动时，使用的就是这个静态实例。关于ForkJoinTask可以使用invokeAll(task)方法，主动执行其它的ForkJoinTask，并等待Task完成。（是同步的）还可以使用fork方法，让一个task执行（这个方法是异步的）还可以使用join方法，让一个task执行（这个方法是同步的，它和fork不同点是同步或者异步的区别）可以使用join来取得ForkJoinTask的返回值。由于RecursiveTask类实现了Future接口，所以也可以使用get()取得返回值。get()和join()有两个主要的区别：join()方法不能被中断。如果你中断调用join()方法的线程，这个方法将抛出InterruptedException异常。如果任务抛出任何未受检异常，get()方法将返回一个ExecutionException异常，而join()方法将返回一个RuntimeException异常。ForkJoinTask在不显示使用ForkJoinPool.execute/invoke/submit()方法进行执行的情况下，也可以使用自己的fork/invoke方法进行执行。使用fork/invoke方法执行时，其实原理也是在ForkJoinPool里执行，只不过使用的是一个“在ForkJoinPool内部生成的静态的”ForkJoinPool。ForkJoinTask有两个子类，RecursiveAction和RecursiveTask。他们之间的区别是，RecursiveAction没有返回值，RecursiveTask有返回值。看看ForkjoinTask的Complete方法的使用场景这个方法好要是用来使一个任务结束。这个方法被用在结束异步任务上，或者为那些能不正常结束的任务，提供一个选择。Task的completeExceptionally方法是怎么回事。这个方法被用来，在异步的Task中产生一个exception，或者强制结束那些“不会结束”的任务这个方法是在Task想要“自己结束自己”时，可以被使用。而cancel方法，被设计成被其它TASK调用。当你在一个任务中抛出一个未检查异常时，它也影响到它的父任务（把它提交到ForkJoinPool类的任务）和父任务的父任务，以此类推。","categories":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}],"tags":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/tags/并发/"},{"name":"工具类","slug":"工具类","permalink":"http://www.baiyp.ren/tags/工具类/"}],"keywords":[{"name":"并发","slug":"并发","permalink":"http://www.baiyp.ren/categories/并发/"},{"name":"工具类","slug":"并发/工具类","permalink":"http://www.baiyp.ren/categories/并发/工具类/"}]},{"title":"使用lambda表达式简化开发","slug":"用lambda表达式简化开发","date":"2019-06-15T09:57:36.000Z","updated":"2019-09-07T09:07:49.616Z","comments":true,"path":"用lambda表达式简化开发.html","link":"","permalink":"http://www.baiyp.ren/用lambda表达式简化开发.html","excerpt":"","text":"使用lambda表达式简化开发什么是lambda表达式​ “Lambda 表达式”(lambda expression)是一个匿名函数，Lambda表达式基于数学中的λ演算得名，直接对应于其中的lambda抽象(lambda abstraction)，是一个匿名函数，即没有函数名的函数。Lambda表达式可以表示闭包（注意和数学传统意义上的不同）。​ 将一个变量传入一个匿名函数然后对传入函数进行操作。由于java中并没有脱离类而存在的函数，所以通常独立函数是以一个匿名内部类+一个方法构成的。lambda表达式代替的函数既没有方法名也没有访问修饰符、明确的返回类型声明。Lambda 表达式的语法Lambda 表达式需要“函数式接口”的支持函数式接口​ 接口中只有一个抽象方法的接口，称为函数式接口。 可以使用注解 @FunctionalInterface 修饰 可以检查是否是函数式接口Lambda 表达式的基础语法Java8中引入了一个新的操作符 “-&gt;” 该操作符称为箭头操作符或 Lambda 操作符。箭头操作符将 Lambda 表达式拆分成两部分左侧：Lambda 表达式的参数列表右侧：Lambda 表达式中所需执行的功能， 即 Lambda 体语法格式一无参数，无返回值1() -&gt; System.out.println(&quot;Hello Lambda!&quot;);语法格式二有一个参数，并且无返回值1(x) -&gt; System.out.println(x)语法格式三若只有一个参数，小括号可以省略不写1x -&gt; System.out.println(x)语法格式四有两个以上的参数，有返回值，并且 Lambda 体中有多条语句1234Comparator&lt;Integer&gt; comparator = (x, y) -&gt; &#123; System.out.println(\"函数式接口\"); return Integer.compare(x, y); &#125;;语法格式五若 Lambda 体中只有一条语句， return 和 大括号都可以省略不写1Comparator&lt;Integer&gt; com = (x, y) -&gt; Integer.compare(x, y);语法格式六Lambda 表达式的参数列表的数据类型可以省略不写，因为JVM编译器通过上下文推断出，数据类型，即“类型推断”1Comparator&lt;Integer&gt; comparator = (Integer x, Integer y) -&gt; Integer.compare(x, y);Lambda 表达式的语法的使用遍历LIST原始的代码1234List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"));for (String str : list) &#123; System.out.println(str);&#125;Lambda 表达式123 List&lt;String&gt; list = new ArrayList&lt;String&gt;(Arrays.asList(\"a\", \"b\", \"c\", \"d\", \"e\"));//使用Lambda 表达式 list.forEach(str-&gt; System.out.println(str));MAP原始代码12345678910Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;() &#123;&#123; put(\"11\", \":11\"); put(\"22\", \":22\"); put(\"33\", \":33\"); put(\"44\", \":44\"); &#125;&#125;;//打印 key+value for(Map.Entry&lt;String,String&gt; m:map.entrySet())&#123; System.out.println(m.getKey()+m.getValue()); &#125;Lambda 表达式12//使用Lambda 更简单 map.forEach((k, v) -&gt; System.out.println(k + v));匿名内部类12345678910111213141516171819202122232425262728293031323334353637public class LambdaTest &#123; public static void main(String[] args) &#123; LambdaTest lambdaTest = new LambdaTest(); //原始关键代码进行回调并返回值 /*int num = lambdaTest.invok(new CallBack() &#123; @Override public int call(int x, int y) &#123; return x + y; &#125; &#125;);*/ // ------------------------------ //使用Lambda 更简单更简洁 int num = lambdaTest.invok((x, y) -&gt; x + y); System.out.println(num); &#125; /** * 调用方法 * * @param callBack * @return */ public int invok(CallBack callBack) &#123; System.out.println(\"方法执行前\"); int num = callBack.call(1, 2); System.out.println(\"方法执行后\"); return num; &#125; /** * 匿名内部类 */ interface CallBack &#123; public int call(int x, int y); &#125;&#125;Java 线程创建12345678910111213//普通方式创建线程 Thread thread1 = new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"我是普通线程\"); &#125; &#125;); // Lambda表达式创建线程 Thread thread2 = new Thread(() -&gt; System.out.println(\"我是Lambda线程\"));thread1.start(); thread2.start();排序12345678910111213141516String[] stringArrays = &#123;\"Rafael Nadal\", \"Novak Djokovic\", \"Stanislas Wawrinka\", \"David Ferrer\", \"Roger Federer\", \"Andy Murray\", \"Tomas Berdych\", \"Juan Martin Del Potro\", \"Richard Gasquet\", \"John Isner\"&#125;; // 使用匿名内部类根据 name 排序 stringArrays Arrays.sort(stringArrays, new Comparator&lt;String&gt;() &#123; @Override public int compare(String s1, String s2) &#123; return (s1.compareTo(s2)); &#125; &#125;); //使用Lambda 表达式进行排序 Arrays.sort(stringArrays,(x,y)-&gt;x.compareTo(y));就是这样,简洁又直观。 在下一节中我们将探索更多lambdas的能力,并将其与 stream 结合起来使用。","categories":[{"name":"lambda","slug":"lambda","permalink":"http://www.baiyp.ren/categories/lambda/"}],"tags":[{"name":"lambda","slug":"lambda","permalink":"http://www.baiyp.ren/tags/lambda/"}],"keywords":[{"name":"lambda","slug":"lambda","permalink":"http://www.baiyp.ren/categories/lambda/"}]},{"title":"JsonValidator工具类","slug":"JsonValidator工具类","date":"2018-05-19T23:08:50.000Z","updated":"2019-08-22T05:02:13.646Z","comments":true,"path":"JsonValidator工具类.html","link":"","permalink":"http://www.baiyp.ren/JsonValidator工具类.html","excerpt":"","text":"JsonValidator工具类JsonValidator 是用来校验字符串是否是JSON格式​ 是我用来加前后端段解密时候用到的，前端加密成JSON格式后端需要解密，所以需要对JSON格式做一个校验，网上找到了这个工具类，比较好用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246/** * 用于校验一个字符串是否是合法的JSON格式 */import com.google.common.cache.Cache;import com.google.common.cache.CacheBuilder;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import java.text.CharacterIterator;import java.text.StringCharacterIterator;import java.util.concurrent.Callable;import java.util.concurrent.ExecutionException;public class JsonValidator &#123; private static final Logger logger = LoggerFactory.getLogger(JsonValidator.class); private final static Cache&lt;String, JsonValidator&gt; jsonValidatorCache = CacheBuilder.newBuilder() //设置cache的初始大小为10，要合理设置该值 .initialCapacity(10) //设置并发数为5，即同一时间最多只能有5个线程往cache执行写入操作 .concurrencyLevel(10) //构建cache实例 .build(); private CharacterIterator it; private char c; private int col; private JsonValidator() &#123; &#125; public static JsonValidator getJsonValidator() throws ExecutionException &#123; return getJsonValidator(\"JsonValidator\"); &#125; public static JsonValidator getJsonValidator(final String key) throws ExecutionException &#123; return jsonValidatorCache.get(key, new Callable&lt;JsonValidator&gt;() &#123; @Override public JsonValidator call() throws Exception &#123; logger.info(\"[RBRequestParameter] - [getJsonValidator] - key:&#123;&#125; - 创建对象\", key); return new JsonValidator(); &#125; &#125;); &#125; private static boolean error(String type, int col) &#123; System.out.printf(\"type: %s, col: %s%s\", type, col, System.getProperty(\"line.separator\")); return false; &#125; public static void main(String[] args) throws ExecutionException &#123; boolean n = JsonValidator.getJsonValidator().validate(\"[\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\",\\\"703502\\\"]\"); System.out.println(n); n = JsonValidator.getJsonValidator().validate(\"[\\\"906102\\\",\\\"906102\\\",\\\"906102\\\",\\\"906102\\\",\\\"906101\\\",\\\"906101\\\",\\\"906101\\\",\\\"906101\\\",\\\"906101\\\",\\\"906101\\\"]\"); System.out.println(n); &#125; /** * 验证一个字符串是否是合法的JSON串 * * @param input 要验证的字符串 * @return true-合法 ，false-非法 */ public boolean validate(String input) &#123; input = input.trim(); boolean ret = valid(input); return ret; &#125; private boolean valid(String input) &#123; if (\"\".equals(input)) return true; boolean ret = true; it = new StringCharacterIterator(input); c = it.first(); col = 1; if (!value()) &#123; ret = error(\"value\", 1); &#125; else &#123; skipWhiteSpace(); if (c != CharacterIterator.DONE) &#123; ret = error(\"end\", col); &#125; &#125; return ret; &#125; private boolean value() &#123; return literal(\"true\") || literal(\"false\") || literal(\"null\") || string() || number() || object() || array(); &#125; private boolean literal(String text) &#123; CharacterIterator ci = new StringCharacterIterator(text); char t = ci.first(); if (c != t) return false; int start = col; boolean ret = true; for (t = ci.next(); t != CharacterIterator.DONE; t = ci.next()) &#123; if (t != nextCharacter()) &#123; ret = false; break; &#125; &#125; nextCharacter(); if (!ret) error(\"literal \" + text, start); return ret; &#125; private boolean array() &#123; return aggregate('[', ']', false); &#125; private boolean object() &#123; return aggregate('&#123;', '&#125;', true); &#125; private boolean aggregate(char entryCharacter, char exitCharacter, boolean prefix) &#123; if (c != entryCharacter) return false; nextCharacter(); skipWhiteSpace(); if (c == exitCharacter) &#123; nextCharacter(); return true; &#125; for (; ; ) &#123; if (prefix) &#123; int start = col; if (!string()) return error(\"string\", start); skipWhiteSpace(); if (c != ':') return error(\"colon\", col); nextCharacter(); skipWhiteSpace(); &#125; if (value()) &#123; skipWhiteSpace(); if (c == ',') &#123; nextCharacter(); &#125; else if (c == exitCharacter) &#123; break; &#125; else &#123; return error(\"comma or \" + exitCharacter, col); &#125; &#125; else &#123; return error(\"value\", col); &#125; skipWhiteSpace(); &#125; nextCharacter(); return true; &#125; private boolean number() &#123; if (!Character.isDigit(c) &amp;&amp; c != '-') return false; int start = col; if (c == '-') nextCharacter(); if (c == '0') &#123; nextCharacter(); &#125; else if (Character.isDigit(c)) &#123; while (Character.isDigit(c)) nextCharacter(); &#125; else &#123; return error(\"number\", start); &#125; if (c == '.') &#123; nextCharacter(); if (Character.isDigit(c)) &#123; while (Character.isDigit(c)) nextCharacter(); &#125; else &#123; return error(\"number\", start); &#125; &#125; if (c == 'e' || c == 'E') &#123; nextCharacter(); if (c == '+' || c == '-') &#123; nextCharacter(); &#125; if (Character.isDigit(c)) &#123; while (Character.isDigit(c)) nextCharacter(); &#125; else &#123; return error(\"number\", start); &#125; &#125; return true; &#125; private boolean string() &#123; if (c != '\"') return false; int start = col; boolean escaped = false; for (nextCharacter(); c != CharacterIterator.DONE; nextCharacter()) &#123; if (!escaped &amp;&amp; c == '\\\\') &#123; escaped = true; &#125; else if (escaped) &#123; if (!escape()) &#123; return false; &#125; escaped = false; &#125; else if (c == '\"') &#123; nextCharacter(); return true; &#125; &#125; return error(\"quoted string\", start); &#125; private boolean escape() &#123; int start = col - 1; if (\" \\\\\\\"/bfnrtu\".indexOf(c) &lt; 0) &#123; return error(\"escape sequence \\\\\\\",\\\\\\\\,\\\\/,\\\\b,\\\\f,\\\\n,\\\\r,\\\\t or \\\\uxxxx \", start); &#125; if (c == 'u') &#123; if (!ishex(nextCharacter()) || !ishex(nextCharacter()) || !ishex(nextCharacter()) || !ishex(nextCharacter())) &#123; return error(\"unicode escape sequence \\\\uxxxx \", start); &#125; &#125; return true; &#125; private boolean ishex(char d) &#123; return \"0123456789abcdefABCDEF\".indexOf(c) &gt;= 0; &#125; private char nextCharacter() &#123; c = it.next(); ++col; return c; &#125; private void skipWhiteSpace() &#123; while (Character.isWhitespace(c)) &#123; nextCharacter(); &#125; &#125;&#125;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"http://www.baiyp.ren/categories/代码片段/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"http://www.baiyp.ren/tags/代码片段/"},{"name":"json","slug":"json","permalink":"http://www.baiyp.ren/tags/json/"},{"name":"JsonValidator","slug":"JsonValidator","permalink":"http://www.baiyp.ren/tags/JsonValidator/"}],"keywords":[{"name":"代码片段","slug":"代码片段","permalink":"http://www.baiyp.ren/categories/代码片段/"}]},{"title":"HttpClient工具类","slug":"HttpClient工具类","date":"2018-05-03T23:00:42.000Z","updated":"2019-08-22T05:02:04.324Z","comments":true,"path":"HttpClient工具类.html","link":"","permalink":"http://www.baiyp.ren/HttpClient工具类.html","excerpt":"","text":"HttpClient工具类HttpClient 是用来远程访问页面或者调用Http接口的，可以用来调用接口喝着爬虫都可以​收藏好久的工具类展示以下，用了很长时间，也是从其他地方收集过来的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308import java.io.IOException;import java.io.UnsupportedEncodingException;import java.net.URISyntaxException;import java.util.ArrayList;import java.util.List;import java.util.Map;import com.alibaba.fastjson.JSON;import org.apache.commons.httpclient.HttpStatus;import org.apache.http.HttpEntity;import org.apache.http.HttpException;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.ClientProtocolException;import org.apache.http.client.HttpClient;import org.apache.http.client.config.RequestConfig;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpGet;import org.apache.http.client.methods.HttpPost;import org.apache.http.client.methods.HttpRequestBase;import org.apache.http.client.utils.URLEncodedUtils;import org.apache.http.entity.StringEntity;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.DefaultHttpRequestRetryHandler;import org.apache.http.impl.client.HttpClientBuilder;import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;import org.apache.http.message.BasicHeader;import org.apache.http.message.BasicNameValuePair;import org.apache.http.protocol.HTTP;import org.apache.http.util.EntityUtils;import org.springframework.util.Assert;public class HttpClientUtils &#123; private HttpClientUtils()&#123;&#125; /** * 连接超时时间 */ public static final int CONNECTION_TIMEOUT_MS = 5000; /** * 读取数据超时时间 */ public static final int SO_TIMEOUT_MS = 5000; public static final String utf8 = \"UTF-8\"; public static final String application_json = \"application/json\"; public static final String gbk = \"GBK\"; /** * 简单get调用 * * @param url * @param params * @return * @throws ClientProtocolException * @throws IOException * @throws URISyntaxException */ public static String get(String url, Map&lt;String, String&gt; params) throws IOException, URISyntaxException &#123; return get(url, params, utf8); &#125; /** * 简单get调用 * * @param url * @param params * @return * @throws ClientProtocolException * @throws IOException * @throws URISyntaxException */ public static String get(String url, Map&lt;String, String&gt; params, String charset) throws IOException, URISyntaxException &#123; HttpClient client = buildHttpClient(true); HttpGet get = buildHttpGet(url, params, charset); HttpResponse response = client.execute(get); assertStatus(response); HttpEntity entity = response.getEntity(); if (entity != null) &#123; return EntityUtils.toString(entity, charset); &#125; return null; &#125; /** * 简单post调用 * * @param url * @param params * @return * @throws URISyntaxException * @throws ClientProtocolException * @throws IOException */ public static String post(String url, Map&lt;String, String&gt; params) throws URISyntaxException, IOException &#123; return post(url, params, utf8); &#125; public static String postJSON(String url, Map&lt;String, String&gt; params) throws IOException, URISyntaxException &#123; return postJSON(url, params, utf8); &#125; /** * 简单post调用 * * @param url * @param params * @return * @throws URISyntaxException * @throws ClientProtocolException * @throws IOException */ public static String post(String url, Map&lt;String, String&gt; params, String charset) throws URISyntaxException, IOException &#123; HttpClient client = buildHttpClient(true); HttpPost postMethod = buildHttpPost(url, params, charset); HttpResponse response = client.execute(postMethod); assertStatus(response); HttpEntity entity = response.getEntity(); if (entity != null) &#123; return EntityUtils.toString(entity, charset); &#125; return null; &#125; public static String postJSON(String url, Map params, String charset) throws URISyntaxException, IOException &#123; HttpClient client = buildHttpClient(true); HttpPost postMethod = buildHttpJSONPost(url, params, charset); HttpResponse response = client.execute(postMethod); assertStatus(response); HttpEntity entity = response.getEntity(); if (entity != null) &#123; return EntityUtils.toString(entity, charset); &#125; return null; &#125; /** * 创建HttpClient * * @param isMultiThread * @return */ public static HttpClient buildHttpClient(boolean isMultiThread) &#123; CloseableHttpClient client; if (isMultiThread) client = HttpClientBuilder .create().setDefaultRequestConfig(buildRequestConfig()) .setRetryHandler(new DefaultHttpRequestRetryHandler()) .setConnectionManager( new PoolingHttpClientConnectionManager()).build(); else client = HttpClientBuilder.create().build(); return client; &#125; /** * 构建httpPost对象 * * @param url * @return * @throws UnsupportedEncodingException * @throws URISyntaxException */ public static HttpPost buildHttpPost(String url, Map&lt;String, String&gt; params, String charset) throws UnsupportedEncodingException, URISyntaxException &#123; Assert.notNull(url, \"构建HttpPost时,url不能为null\"); HttpPost post = new HttpPost(url); setCommonHttpMethod(post); if (params != null) &#123; List&lt;NameValuePair&gt; formparams = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; formparams.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); &#125; HttpEntity he = new UrlEncodedFormEntity(formparams, charset); post.setEntity(he); &#125; return post; &#125; public static HttpPost buildHttpJSONPost(String url, Map&lt;String, String&gt; params, String charset) throws UnsupportedEncodingException, URISyntaxException &#123; Assert.notNull(url, \"构建HttpPost时,url不能为null\"); HttpPost post = new HttpPost(url); setJSONHttpMethod(post); if (params != null) &#123; String json = JSON.toJSONString(params); System.out.println(json); StringEntity stringEntity = new StringEntity(json, utf8); stringEntity.setContentEncoding(new BasicHeader(HTTP.CONTENT_TYPE, application_json)); post.setEntity(stringEntity); &#125; return post; &#125; /** * 构建httpGet对象 * * @param url * @return * @throws URISyntaxException */ public static HttpGet buildHttpGet(String url, Map&lt;String, String&gt; params, String chatset) throws URISyntaxException &#123; Assert.notNull(url, \"构建HttpGet时,url不能为null\"); return new HttpGet(buildGetUrl(url, params, chatset)); &#125; /** * build getUrl str * * @param url * @param params * @return */ private static String buildGetUrl(String url, Map&lt;String, String&gt; params, String charset) &#123; StringBuilder uriStr = new StringBuilder(url); if (params != null) &#123; List&lt;NameValuePair&gt; ps = new ArrayList&lt;NameValuePair&gt;(); for (Map.Entry&lt;String, String&gt; entry : params.entrySet()) &#123; ps.add(new BasicNameValuePair(entry.getKey(), entry.getValue())); &#125; uriStr.append(\"?\"); uriStr.append(URLEncodedUtils.format(ps, charset)); &#125; return uriStr.toString(); &#125; /** * 设置HttpMethod通用配置 * * @param httpMethod */ public static void setCommonHttpMethod(HttpRequestBase httpMethod) &#123; httpMethod.setHeader(HTTP.CONTENT_ENCODING, utf8);// setting &#125; /* 设置HttpMethod通用配置 * * @param httpMethod */ public static void setJSONHttpMethod(HttpRequestBase httpMethod) &#123; httpMethod.setHeader(HTTP.CONTENT_ENCODING, utf8);// setting httpMethod.setHeader(HTTP.CONTENT_TYPE, application_json);// setting &#125; /** * 设置成消息体的长度 setting MessageBody length * * @param httpMethod * @param he */ public static void setContentLength(HttpRequestBase httpMethod, HttpEntity he) &#123; if (he == null) &#123; return; &#125; httpMethod.setHeader(HTTP.CONTENT_LEN, String.valueOf(he.getContentLength())); &#125; /** * 构建公用RequestConfig * * @return */ public static RequestConfig buildRequestConfig() &#123; // 设置请求和传输超时时间 return RequestConfig.custom() .setSocketTimeout(SO_TIMEOUT_MS) .setConnectTimeout(CONNECTION_TIMEOUT_MS).build(); &#125; /** * 强验证必须是200状态否则报异常 * * @param res * @throws HttpException */ static void assertStatus(HttpResponse res) throws IOException &#123; Assert.notNull(res, \"http响应对象为null\"); Assert.notNull(res.getStatusLine(), \"http响应对象的状态为null\"); switch (res.getStatusLine().getStatusCode()) &#123; case HttpStatus.SC_OK: break; default: throw new IOException(\"服务器响应状态异常,失败.\"); &#125; &#125; public static void main(String[] args) throws ClientProtocolException, IOException, URISyntaxException &#123; System.out.println(get(\"http://www.baidu.com\", new HashMap&lt;String, String&gt;())); &#125;&#125;","categories":[{"name":"代码片段","slug":"代码片段","permalink":"http://www.baiyp.ren/categories/代码片段/"}],"tags":[{"name":"代码片段","slug":"代码片段","permalink":"http://www.baiyp.ren/tags/代码片段/"},{"name":"httpClient","slug":"httpClient","permalink":"http://www.baiyp.ren/tags/httpClient/"}],"keywords":[{"name":"代码片段","slug":"代码片段","permalink":"http://www.baiyp.ren/categories/代码片段/"}]},{"title":"携程Apollo(阿波罗)安装部署以及java整合","slug":"携程Apollo-阿波罗-安装部署以及java整合","date":"2018-04-02T21:48:53.000Z","updated":"2019-09-07T09:07:49.600Z","comments":true,"path":"携程Apollo-阿波罗-安装部署以及java整合.html","link":"","permalink":"http://www.baiyp.ren/携程Apollo-阿波罗-安装部署以及java整合.html","excerpt":"","text":"携程Apollo（阿波罗）安装部署以及java整合服务器部署可以按照apollo wiki 进行部署https://github.com/ctripcorp/apollo/wiki/Quick-Start安装 Java 环境java创建数据库Apollo服务端共需要两个数据库：ApolloPortalDB和ApolloConfigDB，我们把数据库、表的创建和样例数据都分别准备了sql文件，只需要导入数据库即可。执行两个sql文件sql/apolloportaldb.sqlsql/apolloconfigdb.sql会创建两个数据库下载安装包https://github.com/nobodyiam/apollo-build-scripts服务器部署将快速部署包apollo-quick-start放进服务器解压文件服务器配置Apollo服务端需要知道如何连接到你前面创建的数据库，所以需要编辑demo.sh，修改ApolloPortalDB和ApolloConfigDB相关的数据库连接串信息。123456789#apollo config db infoapollo_config_db_url=jdbc:mysql://localhost:3306/ApolloConfigDB?characterEncoding=utf8apollo_config_db_username=用户名apollo_config_db_password=密码（如果没有密码，留空即可）# apollo portal db infoapollo_portal_db_url=jdbc:mysql://localhost:3306/ApolloPortalDB?characterEncoding=utf8apollo_portal_db_username=用户名apollo_portal_db_password=密码（如果没有密码，留空即可）修改服务器端口地址信息meta server url123config_server_url=http://10.168.16.125:8080admin_server_url=http://10.168.16.125:8090portal_url=http://10.168.16.125:8070如果部署在linux服务器上需要将地址改为服务器IP地址注意：不要修改demo.sh的其它部分确保端口未被占用Quick Start脚本会在本地启动3个服务，分别使用8070, 8080, 8090端口，请确保这3个端口当前没有被使用。例如，在Linux/Mac下，可以通过如下命令检查：lsof -i:8080执行启动脚本./demo.sh start当看到如下输出后，就说明启动成功了！123456789101112==== starting service ====Service logging file is ./service/apollo-service.logStarted [10768]Waiting for config service startup.......Config service started. You may visit http://localhost:8080 for service status now!Waiting for admin service startup....Admin service started==== starting portal ====Portal logging file is ./portal/apollo-portal.logStarted [10846]Waiting for portal startup......Portal started. You can visit http://localhost:8070 now!使用Apollo配置中心访问 服务器的IP:8070 可以进行访问例如 ：http://10.168.16.125:8070默认 用户名密码是 apollo admin登陆后如下界面可以创建自己的项目添加namespacenamespace 相当于配置文件名称在namespace中添加属性，可以以文本形式添加可以自己研究琢磨下java服务整合pom整合官方提供的maven12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt;&lt;/dependency&gt;发现拉不下来jar包解决方案下载源代码https://github.com/ctripcorp/apollo.git编译其中的 apollo-client 包并安装到本地引入编译后的jar包即可12345&lt;dependency&gt; &lt;groupId&gt;com.ctrip.framework.apollo&lt;/groupId&gt; &lt;artifactId&gt;apollo-client&lt;/artifactId&gt; &lt;version&gt;0.10.0-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt;现有应用接入在应用接入Apollo之后，这些配置是可以非常方便的迁移到Apollo的，具体步骤如下：在Apollo为应用新建项目在应用中配置好META-INF/app.properties把原先配置（必须是properties格式）复制一下，然后通过Apollo提供的文本编辑模式全部粘帖到应用的application namespace，发布配置如果原来是其它格式，如yml，请先转成properties格式把原先的配置文件如bootstrap.properties, application.properties从项目中删除app.properties 内容是创建项目的APPID（应用ID）如前面创建的1234512# testapp.id=12345并在resources 下加入apollo-env.properties 各环境的服务器地址123456local.meta=http://10.168.16.125:8080dev.meta=http://10.168.16.125:8080fat.meta=$&#123;fat_meta&#125;uat.meta=$&#123;uat_meta&#125;lpt.meta=$&#123;lpt_meta&#125;pro.meta=$&#123;pro_meta&#125;修改环境修改/opt/settings/server.properties（Mac/Linux）或C:\\opt\\settings\\server.properties（Windows）文件，设置env为DEV：1env=DEVSpring 整合apollo启动配置1&lt;apollo:config/&gt;apollo加载namespace配置1&lt;apollo:config namespaces=&quot;dubbo&quot; order=&quot;1&quot;/&gt;####官方配置如下Apollo也支持和Spring整合（Spring 3.1.1+），只需要做一些简单的配置就可以了。Apollo目前既支持比较传统的基于XML的配置，也支持目前比较流行的基于Java（推荐）的配置。需要注意的是，如果之前有使用org.springframework.beans.factory.config.PropertyPlaceholderConfigurer的，请替换成org.springframework.context.support.PropertySourcesPlaceholderConfigurer。Spring 3.1以后就不建议使用PropertyPlaceholderConfigurer了，要改用PropertySourcesPlaceholderConfigurer。基于XML的配置注：需要把apollo相关的xml namespace加到配置文件头上，不然会报xml语法错误。1.注入默认namespace的配置到Spring中12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:apollo=\"http://www.ctrip.com/schema/apollo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.ctrip.com/schema/apollo http://www.ctrip.com/schema/apollo.xsd\"&gt; &lt;!-- 这个是最简单的配置形式，一般应用用这种形式就可以了，用来指示Apollo注入application namespace的配置到Spring环境中 --&gt; &lt;apollo:config/&gt; &lt;bean class=\"com.ctrip.framework.apollo.spring.TestXmlBean\"&gt; &lt;property name=\"timeout\" value=\"$&#123;timeout:100&#125;\"/&gt; &lt;property name=\"batch\" value=\"$&#123;batch:200&#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt;2.注入多个namespace的配置到Spring中123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:apollo=\"http://www.ctrip.com/schema/apollo\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.ctrip.com/schema/apollo http://www.ctrip.com/schema/apollo.xsd\"&gt; &lt;!-- 这个是最简单的配置形式，一般应用用这种形式就可以了，用来指示Apollo注入application namespace的配置到Spring环境中 --&gt; &lt;apollo:config/&gt; &lt;!-- 这个是稍微复杂一些的配置形式，指示Apollo注入FX.apollo和FX.soa namespace的配置到Spring环境中 --&gt; &lt;apollo:config namespaces=\"FX.apollo,FX.soa\"/&gt; &lt;bean class=\"com.ctrip.framework.apollo.spring.TestXmlBean\"&gt; &lt;property name=\"timeout\" value=\"$&#123;timeout:100&#125;\"/&gt; &lt;property name=\"batch\" value=\"$&#123;batch:200&#125;\"/&gt; &lt;/bean&gt;&lt;/beans&gt;dubbo服务整合123456789101112 &lt;apollo:config/&gt;&lt;apollo:config namespaces=\"dubbo\" order=\"1\"/&gt; &lt;!-- 公共信息，也可以用dubbo.properties配置 --&gt; &lt;dubbo:application name=\"$&#123;dubbo.application.name&#125;\" /&gt; &lt;!-- 需要强制指定地址，配置文件默认可以不配置 --&gt; &lt;dubbo:registry address=\"$&#123;dubbo.registry.address&#125;\"/&gt; &lt;bean id=\"xxxService\" class=\"com.xxx.cache.service.impl.RedisServiceImpl\"/&gt; &lt;dubbo:service interface=\"com.xxx.xxx.service.RedisService\" ref=\"redisService\" version=\"$&#123;dubbo.version&#125;\"/&gt;dubbo 默认没有不需要配置，但使用apollo后没有自动注入dubbo注册地址，需要手动声明,原因待定1&lt;dubbo:registry address=&quot;$&#123;dubbo.registry.address&#125;&quot;/&gt;","categories":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"apollo","slug":"架构/apollo","permalink":"http://www.baiyp.ren/categories/架构/apollo/"}],"tags":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/tags/架构/"},{"name":"apollo","slug":"apollo","permalink":"http://www.baiyp.ren/tags/apollo/"}],"keywords":[{"name":"架构","slug":"架构","permalink":"http://www.baiyp.ren/categories/架构/"},{"name":"apollo","slug":"架构/apollo","permalink":"http://www.baiyp.ren/categories/架构/apollo/"}]},{"title":"系统加密服务-04","slug":"系统加密服务-04","date":"2018-03-02T23:07:18.000Z","updated":"2019-08-22T05:53:56.265Z","comments":true,"path":"系统加密服务-04.html","link":"","permalink":"http://www.baiyp.ren/系统加密服务-04.html","excerpt":"","text":"系统加密服务-后记开发中遇到的问题虽然说用起来直接引入js就能解决进行加密但是在使用过程中还是有很多问题的,这里面列出几个因为使用第三方校验框架，使得jquery监听form表单失效或者数据没有加密我们通过改写校验框架源码来实现，就是在校验中我们设置$.setSubmit(false)不进行提交，在校验通过后进行加密后再提交，设计的框架有jquery.validate,bootstrapValidate,validform 等form 表单中的重复的name值以“，”分割原来是这样来写的，以直没有问题，后来有一个很老的系统使用 request.getParameterValues() 方式来获取数组参数，因为解密后是“,”分割的字符串分不开数组和字符串所以对系统进行了重构js全部以数据的形式接收，因为数据形式数据量太大很多都是不重复的，所以就先生成一个JSON数组，然后检查如果是一个的话就将数据去掉，使用原始的JSON形式，如果有重复的name就保留数组，这样加密后就节省了很大的数据传输量pyload处理原来只有参数的解密后来发现对于ajax contentType为GBK的获取步到参数，发现是流的形式接收的，就增加了pyload形式，后来又发现上传文件失效了，原来将文件上传解密了，文件上传失败，就判断contentType不能包含multipart/form-data空对象处理因采用了JSON的压缩方式，如果一个参数值为空就不将这个参数传递过去了，因后台没有做任何处理，没有加密前是得到的是空字符串加密后得到的是null，造成了空指针，解决方法是加入了自定义配置默认不将空对象传过去，如果是指定一个配置，就将所以的参数传过去，如果对象为空的也传过去，但这样会造成很大的数据量增加，默认不传递空值的。其他的各种小问题也很多这里面不列举了系统响应情况因为引入了前端加密后端解密系统的响应速度肯定会下降，测试人员测试的是否发现系统明显慢了一些数据量越大的页面提交也越慢最慢的页面数据量特别大，提交约2分钟左右，加密的参数达到了恐怖了5万个各种各样的参数和值有些电脑甚至浏览器直接卡死崩溃但一般都能够接受，正常页面能够再1秒内提交响应总结安全问题解决了，积累了经验，特别累，涉及到十几个服务，三四个月以来几乎天天加班，处理各种各样的问题，后两个月几乎天天上线，回滚，测试人员一遍一遍的测试，线上还是问题不断，被骂了不知道多少遍，总算再规定的期限完成了，来检查的时候也是战战兢兢的，生怕出现问题，总算是完美完成，不辜负几个月的辛苦，拿到了安全证书，这几个月也学到很多知识。感谢各位查看和评阅第一次系列的写一些博客，感觉写的很乱，不能很系统的写出来，有什么问题欢迎指正。","categories":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/categories/加密/"}],"tags":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/tags/加密/"}],"keywords":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/categories/加密/"}]},{"title":"系统加密服务-03","slug":"系统加密服务-03","date":"2018-03-02T23:06:35.000Z","updated":"2019-08-22T05:53:47.331Z","comments":true,"path":"系统加密服务-03.html","link":"","permalink":"http://www.baiyp.ren/系统加密服务-03.html","excerpt":"","text":"系统加密服务-后台解密涉及的问题要知道解密是否成功对于AJAX传过来的PYLOAD 载荷的流的形式的数据解密并重构可重复读取的流要对后端透明后端不需要改动任何代码解密通过重写HttpServletRequestWrapper 实现构建可重复读取的的request流需要 spring-test jar支持使用DelegatingServletInputStream 实现构建ParameterRequestWrapper12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class ParameterRequestWrapper extends HttpServletRequestWrapper &#123; private static final Logger logger = LoggerFactory.getLogger(ParameterRequestWrapper.class); private Map&lt;String, String[]&gt; parameters = new LinkedHashMap&lt;String, String[]&gt;(); //是否可重复读取流 private boolean isReadInputStream = false; //pyload parameter 主体 private String parameterBody = null; //解密状态 private boolean decryptionState = false; /** * input stream 的buffer * */ public ParameterRequestWrapper(HttpServletRequest request) throws UnsupportedEncodingException &#123; super(request); //request 解密 RequestEnriry requestEnriry = ParameterUtils.decrypt(request); if (null != requestEnriry) &#123; //获取解密后的对象 Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); //流是否被读取了 isReadInputStream = requestEnriry.isReadInputStream(); if (isReadInputStream) &#123; parameterBody = requestEnriry.getParameterBody(); &#125; //解密是否成功 decryptionState = requestEnriry.isPass(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; parameters = parameterMap; &#125; &#125; &#125; @Override public String getParameter(String key) &#123; String[] values = parameters.get(key); return StringUtils.arrayToString(values); &#125; @Override public Map&lt;String, String[]&gt; getParameterMap() &#123; return parameters; &#125; @Override public Enumeration&lt;String&gt; getParameterNames() &#123; return new Vector&lt;String&gt;(parameters.keySet()).elements(); &#125; @Override public String[] getParameterValues(String name) &#123; String[] result = null; Object value = parameters.get(name); if (value == null) &#123; result = null; &#125; else if (value instanceof String[]) &#123; result = (String[]) value; &#125; else if (value instanceof String) &#123; result = new String[]&#123;(String) value&#125;; &#125; else &#123; result = new String[]&#123;value.toString()&#125;; &#125; return result; &#125; @Override public ServletInputStream getInputStream() throws IOException &#123; if (isReadInputStream) &#123; if (null != parameterBody) &#123; final ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(parameterBody.getBytes()); //构建可重复读取的流 return new DelegatingServletInputStream(byteArrayInputStream); &#125; &#125; else &#123; return super.getInputStream(); &#125; return null; &#125; public boolean isDecryptionState() &#123; return decryptionState; &#125; public void setDecryptionState(boolean decryptionState) &#123; this.decryptionState = decryptionState; &#125;构建filter123456789101112131415161718public class ParametersFilter extends OncePerRequestFilter &#123; @Override protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws ServletException, IOException &#123; //强制指定编码，解决解密后乱码问题 request.setCharacterEncoding(\"UTF-8\"); ParameterRequestWrapper parameterRequestWrapper = new ParameterRequestWrapper(request); //获取加密状态 boolean isDecryptionState = parameterRequestWrapper.isDecryptionState(); if (isDecryptionState) &#123; chain.doFilter(parameterRequestWrapper, response); &#125; else &#123; //返回加密失败的状态，可以在页面处理 response.setStatus(911); &#125; &#125;&#125;在web.xml 设置filter需要RequestContextListener 支持，在web.xml 中配置1234567891011121314!-- 参数过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;ParametersFilter&lt;/filter-name&gt; &lt;filter-class&gt;com.xxx.common.security.web.filter.ParametersFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;ParametersFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- request固化器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.request.RequestContextListener&lt;/listener-class&gt; &lt;/listener&gt;这样就配置完了对于普通的parameterMap参数解密先检查参数名称是否是加密的key 我们可以指定一个不容易重名的例如“$@$.ecryptedData“如果加密了 就就行解密 解密完成后通过fastJson将JSON串转换为MAP检查是否存在我们JS中定义的时间戳 如果不存在 则判断解密失败代码片段如下参数解密123456789101112131415161718192021public void decrypt(HttpServletRequest request, RequestEnriry requestEnriry) &#123;//检查是否是form表单提交的 if (check(request)) &#123; Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); //检查是否加密 boolean isEncrypt = isEncrypt(parameterMap); if (isEncrypt) &#123; requestEnriry.setEncrypt(isEncrypt); //获取加密的参数 String encParameter = getEncryptedParameter(parameterMap); //解密数据 String decParameter = decryptData(encParameter, getSecretKey(request)); if (StringUtils.isNotEmpty(decParameter)) &#123; //参数转换 Map&lt;String, String[]&gt; decParameterMap = encParameterConver(decParameter);//将参数封装到实体中 requestEnriry.putParameterMap(decParameterMap);//设置传过来的时间戳 requestEnriry.setTimestamp(getEncryptedTimestamp(decParameterMap)); &#125; &#125; &#125; &#125;检查参数是否加密123456789 public boolean isEncrypt(Map parameterMap) &#123;Map&lt;String, String[]&gt; parameterMap = requestEnriry.getParameterMap(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty() &amp;&amp; parameterMap.containsKey(\"$@$.ecryptedData\")) &#123; flag = true; &#125; &#125; return flag; &#125;获取加密的参数12345678910public String getEncryptedParameter(Map&lt;String, String[]&gt; parameterMap) &#123; String ecryptedParam = null; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; String[] parameterArray = parameterMap.get(\"$@$.ecryptedData\"); if (null != parameterArray &amp;&amp; parameterArray.length &gt; 0) &#123; ecryptedParam = parameterArray[0]; &#125; &#125; return ecryptedParam; &#125;检查是否需要解密操作1234567public boolean check(HttpServletRequest request) &#123; Map parameterMap = request.getParameterMap(); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; return true; &#125; return false; &#125;参数转换12345678910111213141516171819202122public Map&lt;String, String[]&gt; encParameterConver(String decryptionJson) &#123; Map&lt;String, String[]&gt; mappingMap = new LinkedHashMap&lt;String, String[]&gt;(); if (null != mappingMap &amp;&amp; StringUtils.isNotEmpty(decryptionJson)) &#123; Map&lt;String, String[]&gt; parameterMap = null; parameterMap = ParameterUtils.jsonToMap(decryptionJson); if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; Set&lt;String&gt; keys = parameterMap.keySet(); for (String key : keys) &#123; if (StringUtils.isNotEmpty(key)) &#123; String[] value = parameterMap.get(key); if (null != value) &#123; value = ParameterUtils.decodeURI(value); &#125; if (null != value) &#123; mappingMap.put(key, value); &#125; &#125; &#125; &#125; &#125; return mappingMap; &#125;获取时间戳12345678910public String getEncryptedTimestamp(Map&lt;String, String[]&gt; parameterMap) &#123; String timestamp = null; if (null != parameterMap &amp;&amp; !parameterMap.isEmpty()) &#123; String[] valueArray = parameterMap.get(\"$@$.tmp\"); if (null != valueArray &amp;&amp; valueArray.length &gt; 0) &#123; timestamp = valueArray[0]; &#125; &#125; return timestamp; &#125;对于AJAX PYLOAD 载荷的参数解密跟普通的一样解密一样只是有几点区别pyload需要有contentTypecontentType 不能包含multipart/form-data 即不支持文件上传pyload 需要吧解析的参数还原为原始的字符串 可能是JSON字符串或者是URL参数代码片段如下参数解密123456789101112131415161718192021222324252627282930public void decrypt(HttpServletRequest request, RequestEnriry requestEnriry) &#123;//检查是否需要解密 if (check(request)) &#123; //获取pyload 参数 String pyloadParameter = getPyloadParameter(request); //设置流读取状态为true requestEnriry.setReadInputStream(true); if (StringUtils.isNotEmpty(pyloadParameter)) &#123; requestEnriry.setParameterBody(pyloadParameter); //将pyload参数解析 Map&lt;String, String[]&gt; parameterMap = ParameterUtils.getUrlParams(pyloadParameter); //检查是否加密 boolean isEncrypt = isEncrypt(parameterMap); if (isEncrypt) &#123; requestEnriry.setEncrypt(isEncrypt); String encParameter = getEncryptedParameter(parameterMap); if (StringUtils.isNotEmpty(encParameter)) &#123; String decParameter = decryptData(encParameter, getSecretKey(request)); requestEnriry.setParameterBody(decParameter); Map&lt;String, String[]&gt; map = ParameterUtils.jsonToMap(decParameter); if (null != map &amp;&amp; !map.isEmpty()) &#123; requestEnriry.setTimestamp(getEncryptedTimestamp(map)); requestEnriry.putParameterMap(map); &#125; &#125; &#125; &#125; &#125; &#125;检查是否是pyload形式1234567public boolean check(HttpServletRequest request) &#123; String contentType = getContentType(request); if (StringUtils.isNotEmpty(contentType) &amp;&amp; !contentType.contains(\"multipart/form-data\")) &#123; return true; &#125; return false; &#125;获取pyload 参数12345678910111213141516171819202122232425262728public String getPyloadParameter(HttpServletRequest request) &#123; String ecryptedParam = null; InputStream inputStream = null; try &#123; inputStream = request.getInputStream(); &#125; catch (IOException e) &#123; logger.error(\"Error reading the request body…\", e); &#125; if (null != inputStream) &#123; StringBuilder stringBuilder = new StringBuilder(); if (inputStream != null) &#123; try &#123; BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(inputStream)); char[] charBuffer = new char[CHAR_BUFFER_LENGTH]; int bytesRead; while ((bytesRead = bufferedReader.read(charBuffer)) &gt; 0) &#123; stringBuilder.append(charBuffer, BUFFER_START_POSITION, bytesRead); &#125; &#125; catch (IOException e) &#123; logger.error(\"Fail to read input stream\", e); &#125; &#125; else &#123; stringBuilder.append(\"\"); &#125; ecryptedParam = stringBuilder.toString(); &#125; return ecryptedParam; &#125;其他公共类 RequestEnriry123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384public class RequestEnriry &#123; private Map&lt;String, String[]&gt; parameterMap = new HashMap&lt;String, String[]&gt;(); private String parameterBody; private boolean isEncrypt = false; private boolean isReadInputStream = false; private String timestamp = null; public RequestEnriry() &#123; &#125; public RequestEnriry(Map&lt;String, String[]&gt; requestParameterMap) &#123; if (null != requestParameterMap &amp;&amp; !requestParameterMap.isEmpty()) &#123; parameterMap.putAll(requestParameterMap); &#125; &#125; public void handle() &#123; parameterMap.remove(SecurityConstant.ECRYPTED_PARAM_NAME); &#125; public boolean isPass() &#123; boolean isPass = false; if (isEncrypt) &#123; if (StringUtils.isNotEmpty(timestamp)) &#123; isPass = true; &#125; &#125; else &#123; isPass = true; &#125; return isPass; &#125; public Map&lt;String, String[]&gt; getParameterMap() &#123; return parameterMap; &#125; public void setParameterMap(Map&lt;String, String[]&gt; parameterMap) &#123; this.parameterMap = parameterMap; &#125; public void putParameterMap(Map&lt;String, String[]&gt; subParameterMap) &#123; parameterMap.putAll(subParameterMap); &#125; public String getParameterBody() &#123; return parameterBody; &#125; public void setParameterBody(String parameterBody) &#123; this.parameterBody = parameterBody; &#125; public boolean isEncrypt() &#123; return isEncrypt; &#125; public void setEncrypt(boolean encrypt) &#123; isEncrypt = encrypt; &#125; public String getTimestamp() &#123; return timestamp; &#125; public void setTimestamp(String timestamp) &#123; this.timestamp = timestamp; &#125; public boolean isReadInputStream() &#123; return isReadInputStream; &#125; public void setReadInputStream(boolean readInputStream) &#123; isReadInputStream = readInputStream; &#125;&#125;到这一步已经全部完成了，核心思想和代码已经完成","categories":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/categories/加密/"}],"tags":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/tags/加密/"}],"keywords":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/categories/加密/"}]},{"title":"系统加密服务-02","slug":"系统加密服务-02","date":"2018-03-02T23:05:22.000Z","updated":"2019-08-22T05:53:35.408Z","comments":true,"path":"系统加密服务-02.html","link":"","permalink":"http://www.baiyp.ren/系统加密服务-02.html","excerpt":"","text":"系统加密服务-页面JS加密涉及的问题因涉及的页面较多不能一个一个改，只能统一引用，最好使用header引入js的形式能够捕获form表单提交，在提交之前将提交的数据进行加密，并将加密的数据提交，原始数据不提交form表单序列化AJAX数据加密加密方式选择文件上传对于和上传数据一起的参数数据加密问题解决对于第一个问题 写统一的JS进行解决做好兼容性，对于form表单提交加密解决方案： 使用jquery监听form表单的submit方案，如果监听到form提交就将form表单对应输入框的元素进行序列化，序列为JSON数组（因为后台Request接收数组，兼容类似于checkBox重复name）将序列化的JSON进行加密，并将加密的数据插入到表单中，并将加密的输入框元素设置为disabled（这样元素就不会提交了）提交表单就只剩下加密的数据了。123456789101112131415$(function () &#123;//监听form表单提交 $(\"form\").submit(function (data) &#123; //获取提交的URL var url = $(this).attr(\"action\"); //检查是否需要提交 if ($.getSubmit()) &#123; //检查是否需要加密 if ($.isEncrypt(url)) &#123; //数据加密 $(this).formEncryption(); &#125; &#125; &#125;);&#125;);对于form表单序列化解决方案：对于表单序列化要排除一些不需要加密的元素例如file,button,image等，对于checkbox和redio可能存在多个相同的name，要使用JSON数据来接收，用于区分后台接受到“,”分割的字符串springMvc 会自动将request参数数组转换为“,”分割的字符串，但有些很老的代码是不支持的，要兼容底层request区分数组和“,”分割的字符串要使用JSON数组来接收，并将序列化的name值进行保存，用于某些情况下将加密后disable后的元素去掉disabled，并将加密设置为jquery插件的形式使用。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253(function ($) &#123;//需要排除的元素 var excludeInputType = [\"file\", \"button\", \"submit\", \"image\", \"reset\"]; $.fn.extend(&#123; //序列化方法 \"serializeJSON\": function () &#123; //表单数据 var formData = &#123;&#125;; //加密的元素数组 var disabledKeys = []; this.find(\"input,select,textarea\").each(function () &#123; if (!$(this).is(\":disabled\")) &#123; var name = $(this).attr(\"name\"); var value = $(this).val(); var valueArray = new Array(value); var type = $(this).attr(\"type\"); var flag = true; for (var i = 0; i &lt; excludeInputType.length; i++) &#123; if (type == excludeInputType[i]) &#123; flag = false; return true; &#125; &#125; disabledKeys.push(name); switch (type) &#123; case \"checkbox\": if (!$(this).is(':checked')) &#123; return true; &#125; break; case \"radio\": if (!$(this).is(':checked')) &#123; return true; &#125; break; &#125; // var v = $.getJsonValue(formData, name); if (v) &#123; v.push(value); valueArray = v; &#125; formData = $.putJson(formData, name, valueArray); &#125; &#125;); $.setDisableKey(disabledKeys); formData = $.arrayParameterSerialize(formData); return formData; &#125; &#125;);&#125;)对于AJAX数据提交解决方案：使用 $.ajaxPrefilter 捕获ajax提交，得到提交的数据，并进行解析，加密并将原始数据覆盖为新的数据12345678910111213141516171819202122232425262728$.ajaxPrefilter(function (options, originalOptions, jqXHR) &#123;//获取ajax数据 var data = options.data; //获取ajaxurl var url = options.url; //是否需要加密 if ($.isEncrypt(url)) &#123; if (data) &#123; var parameter = &#123;&#125;; //检查字符串是否是json字符串 if ($.strIsJSON(data)) &#123; //将json字符串转换为json对象 parameter = JSON.parse(data); &#125; else &#123; //对于普通的数据?xxx=1&amp; 形式的数据进行解析转换为json对象 parameter = $.parseParameter(data); &#125; //添加时间戳 parameter = $.addTmp(parameter); //数据加密 data = $.encryptData(parameter); var dataJson = &#123;&#125;; dataJson = $.putJson(dataJson, $.getEcryptedParameterName(), data); data = $.jsonToParameter(dataJson); //将原始数据覆盖为加密的数据 options.data = data; &#125; &#125;数据加密解决方案 使用 des形式加密，可以自己定义加密方式，但要保证前后台都能加密解密。加密最好加上时间戳 用于后台检查是否解密成功（如果解密后没有这个时间戳字段代表解密失败）还可以用于其他的作用，例如检查加密的字符串超时时间。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980(function ($) &#123; var isSubmit_disabled = true; var disabled_keys = []; $.ajaxSetup(&#123; contentType: \"application/x-www-form-urlencoded;charset=utf-8\", complete: function (xhr, textStatus) &#123; if (xhr.status == 911) &#123; layer.msg('当前页面已失效，正在刷新浏览器', &#123;icon: 0, shade: 0.8&#125;, function () &#123; window.location.href = $.getRootPath(); &#125;); return false; &#125; &#125; &#125;); $.ajaxPrefilter(function (options, originalOptions, jqXHR) &#123; var data = options.data; var url = options.url; if ($.isEncrypt(url)) &#123; if (data) &#123; var parameter = &#123;&#125;; if ($.strIsJSON(data)) &#123; parameter = JSON.parse(data); &#125; else &#123; parameter = $.parseParameter(data); &#125; parameter = $.addTmp(parameter); data = $.encryptData(parameter); var dataJson = &#123;&#125;; dataJson = $.putJson(dataJson, $.getEcryptedParameterName(), data); data = $.jsonToParameter(dataJson); options.data = data; &#125; &#125; &#125;); $.fn.extend(&#123; formEncryption: function () &#123; var data = &#123;&#125;; var ecryptedParameterName = $.getEcryptedParameterName(); var url = $(this).attr(\"action\"); if ($.isEncrypt(url)) &#123; var inputArray = this.serializeJSON(); if (!inputArray[ecryptedParameterName]) &#123; $(this).disabledForm(); for (var key in inputArray) &#123; var value = inputArray[key]; data = $.putJson(data, key, value); &#125; data = $.addTmp(data); var encData = $.encryptData(data); if ($.isNotEmpty(encData)) &#123; var encDataInput = $(\"&lt;input type='hidden' name = '\" + ecryptedParameterName + \"' value='\" + encData + \"'/&gt;\"); this.append(encDataInput); &#125; &#125; &#125; &#125;, encryptionSubmit: function () &#123; this.formEncryption(); this.submit(); &#125;, disabledForm: function () &#123; var disableKeys = $.getDisableKey(); var ecryptedParameterName = $.getEcryptedParameterName(); for (var i = 0; i &lt; disableKeys.length; i++) &#123; if (disableKeys[i] != ecryptedParameterName) &#123; $(this).find(\"[name='\" + disableKeys[i] + \"']\").attr(\"disabled\", \"disabled\"); &#125; &#125; &#125;, enableForm: function () &#123; var disableKeys = $.getDisableKey(); var ecryptedParameterName = $.getEcryptedParameterName(); $(this).find(\"[name='\" + ecryptedParameterName + \"']\").remove(); for (var i = 0; i &lt; disableKeys.length; i++) &#123; $(this).find(\"[name='\" + disableKeys[i] + \"']\").attr(\"disabled\", false); &#125; &#125; &#125;);上下是一个文件 不知道怎么回事 makedown 显示不全一个完整的123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778 $.extend(&#123; urlDataEncrypt: function (url, extParams) &#123; var secretKey = $.getSecretKey(); var baseUrl = $.parseUrl(url); var params = $.parseUrlParameter(url); params = $.initEncryptParam(params); if ($.isNotEmpty(extParams) &amp;&amp; $.isJson(extParams)) &#123; $.putJson(params, extParams); &#125; var encryptUrl = url; if ($.isEmpty(secretKey)) &#123; encryptUrl = baseUrl + \"?\" + $.jsonToParameter(params); &#125; else &#123; var ecryptedData = $.encryptData(params); params = $.addTmp(params); encryptUrl = baseUrl + \"?\" + $.getEcryptedParameterName() + \"=\" + ecryptedData; &#125; return encryptUrl; &#125;, encryptData: function (data) &#123; var ecryptedData = \"\"; if ($.isJson(data)) &#123; var jsonStr = JSON.stringify(data); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; else &#123; if (!data.match(\"^\\&#123;(.+:.+,*)&#123;1,&#125;\\&#125;$\")) &#123; var params = $.parseParameter(data); var jsonStr = JSON.stringify(params); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; else &#123; var jsonStr = JSON.stringify(jsonData); ecryptedData = strEnc(jsonStr, $.getSecretKey()); &#125; &#125; return ecryptedData; &#125;, initEncryptParam: function (data) &#123; if ($.isEmpty(data)) &#123; data = &#123;&#125;; &#125; else if (!$.isJson(data)) &#123; data = jQuery.parseJSON(data); &#125; data = $.addTmp(data); return data; &#125;, isEncrypt: function (url) &#123; var flag = true; var secretKey = $.getSecretKey(); if ($.isEmpty(secretKey)) &#123; flag = false; &#125; else &#123; var encryptExclude = $.encryptExcludeUrl(); if (encryptExclude &amp;&amp; $.isArray(encryptExclude)) &#123; for (var i = 0; i &lt;= encryptExclude.length; i++) &#123; if (encryptExclude[i] == url) &#123; flag = false; break; &#125; &#125; &#125; &#125; return flag; &#125;, setSubmit: function (obj) &#123; isSubmit_disabled = obj; &#125;, getSubmit: function () &#123; return isSubmit_disabled; &#125;, setDisableKey: function (keys) &#123; if (keys &amp;&amp; keys[0] != $.getEcryptedParameterName()) &#123; disabled_keys = keys; &#125; &#125;, getDisableKey: function () &#123; return disabled_keys; &#125;, &#125;);&#125;)(window.jQuery);","categories":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/categories/加密/"}],"tags":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/tags/加密/"}],"keywords":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/categories/加密/"}]},{"title":"系统加密服务-01","slug":"系统加密服务-01","date":"2018-03-02T23:03:28.000Z","updated":"2019-08-22T01:56:50.871Z","comments":true,"path":"系统加密服务-01.html","link":"","permalink":"http://www.baiyp.ren/系统加密服务-01.html","excerpt":"","text":"系统加密服务需求背景我们公司因为要紧急对系统进行安全加密，以前系统都是参数暴漏的，能够直接获取操作链接等数据，为防止系统关键数据被窃取，系统要进行全面加密，时间只有一个月，上级部门要来进行检查，因涉及到多个系统，上万个页面不能一个一个页面进行加密，特需要一套框架来支持。需要实现的功能对后端透明 后端不需要该任何代码对前端透明 前端不需要或者最好不改代码实现表单放重复提交实现重放攻击拦截实现XSS 脚本跨站攻击实现方案我们系统的讨论了一周时间实现方案如下通过JS 监听ajax 请求和form表单请求 并对请求的数据进行加密通过继承HttpServletRequestWrapper 实现参数解析以及XSS防注入使用拦截器搭配注解实现表单放重复提交在提交的JS中加入时间戳的方式配合拦截器和注解实现防重放攻击总体实现方案加密方式前台数据通过JS对form表单以及AJAX数据进行加密要兼容一些校验框架加密数据需要加入时间戳用于后台检查是否解密成功以及其他用处后台得到加密的数据进行解密通过重写HttpServletRequestWrapper 和OncePerRequestFilter 来实现如果是AJAX提交可能需要PYLOAD形式通过流的形式进行解析表单防重通过TOKEN形式来实现，网上很多实现，这里不多说了XXS防跨站脚本攻击通过将参数中的html代码转义来实现对应的JS加密和Java解密的资源可以查看下载","categories":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/categories/加密/"}],"tags":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/tags/加密/"}],"keywords":[{"name":"加密","slug":"加密","permalink":"http://www.baiyp.ren/categories/加密/"}]},{"title":"MYBATIS热部署","slug":"MYBATIS热部署","date":"2017-08-02T14:41:56.000Z","updated":"2019-09-07T09:07:49.594Z","comments":true,"path":"MYBATIS热部署.html","link":"","permalink":"http://www.baiyp.ren/MYBATIS热部署.html","excerpt":"","text":"mybatis热部署最近在使用mybatis，由于是刚刚开始用，用的并不顺手，目前是感觉有2个地方非常的不好用：mybatis调试不方便​ 由于dao层只有接口，实现只是一个map的xml文件，想加断点都没有地方加，直接导致的后果就是有时候出错了，完全是各种闭眼尝试，抓狂中。。。倒是可以把调试级别改成debug，会把执行的sql，以及参数都输出到控制台，可是一改成debug，那控制台输出的内容，就实在多到让人发指，甚至都会影响到代码的编写及调试，而且输出日志跟打断点调试根本就不是一个级别的。目前仍旧无法解决改问题。mybatis改sql要不停的重启服务​ 这个真心不能忍，map文件在系统重动后，map文件只加载一次，再修改map文件就不会生效了，如果要生效，就需要不停的重启服务。​ 后来找到一个办法，就是使用Mybatis-Plus插件。Mybatis-Plus插件的用法pom.xml的内容：123456789101112131415161718 &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus&lt;/artifactId&gt; &lt;version&gt;1.5&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;systemPath&gt;$&#123;lib.dir&#125;/mybatis-plus-1.5.jar&lt;/systemPath&gt; &lt;/dependency&gt;​ 因为看Mybatis-Plus插件官网的说法，就是添加Mybatis-Plus插件会添加mybatis的依赖包，我已经引过mybatis的包了，不想让他再给我引了。Mybatis-Plus插件的地址：http://mvnrepository.com/artifact/com.baomidou/mybatis-plus/1.52. 然后修改spring的配置文件： 修改前 123&lt;bean id=\"sqlSessionFactory\" class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dynamicDataSource\" /&gt;&lt;property name=\"configLocation\" value=\"classpath:conf/mybatis-config.xml\"&gt;&lt;/property&gt; 1&lt;property name=\"mapperLocations\" value=\"classpath:com/huarui/mapping/$&#123;jdbc.dialect&#125;/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt;​ 修改后123456789 &lt;bean id=\"sqlSessionFactory\" class=\"com.baomidou.mybatisplus.spring.MybatisSqlSessionFactoryBean\"&gt; &lt;property name=\"dataSource\" ref=\"dynamicDataSource\" /&gt; &lt;property name=\"configLocation\" value=\"classpath:conf/mybatis-config.xml\"&gt;&lt;/property&gt; &lt;property name=\"mapperLocations\" value=\"classpath:com/huarui/mapping/$&#123;jdbc.dialect&#125;/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean class=\"com.baomidou.mybatisplus.spring.MybatisMapperRefresh\"&gt; &lt;constructor-arg name=\"sqlSessionFactory\" ref=\"sqlSessionFactory\"/&gt; &lt;constructor-arg name=\"mapperLocations\" value=\"classpath:com/huarui/mapping/$&#123;jdbc.dialect&#125;/*.xml\"/&gt; &lt;constructor-arg name=\"delaySeconds\" value=\"5\"/&gt; &lt;constructor-arg name=\"sleepSeconds\" value=\"10\"/&gt; &lt;constructor-arg name=\"enabled\" value=\"true\"/&gt;&lt;/bean&gt;修改后，改sql就会自动热加载了，其实也不是实时加载，原理是每隔一个时间刷新一下map，我这里设置的是delaySeconds是5秒，sleepSeconds是10秒。","categories":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.baiyp.ren/categories/mybatis/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.baiyp.ren/tags/mybatis/"},{"name":"热部署","slug":"热部署","permalink":"http://www.baiyp.ren/tags/热部署/"}],"keywords":[{"name":"mybatis","slug":"mybatis","permalink":"http://www.baiyp.ren/categories/mybatis/"}]},{"title":"关于我","slug":"about","date":"2016-08-03T22:27:45.000Z","updated":"2019-08-22T01:34:10.005Z","comments":true,"path":"about.html","link":"","permalink":"http://www.baiyp.ren/about.html","excerpt":"","text":"关于我白云鹏喜欢学习,研究技术,个人有点懒目前在北京工作，有一天突然发现JAVA 好多知识不会感觉饭碗要保不住了，然后边学习边把一些知识总结下以博客的形式展示出来，做个记录。联系我MAIL：baiyunpeng42@126.comGITHUB：baiyunpeng","categories":[],"tags":[],"keywords":[]}]}