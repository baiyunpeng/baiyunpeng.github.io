<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓风残月的博客</title>
  
  <subtitle>晓风残月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baiyp.ren/"/>
  <updated>2019-09-08T06:40:31.099Z</updated>
  <id>http://www.baiyp.ren/</id>
  
  <author>
    <name>晓风残月</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM整体介绍</title>
    <link href="http://www.baiyp.ren/JVM%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://www.baiyp.ren/JVM整体介绍.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T06:40:31.099Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JVM整体介绍"><a href="#JVM整体介绍" class="headerlink" title="JVM整体介绍"></a>JVM整体介绍</h2><h3 id="JAVA技术体系结构"><a href="#JAVA技术体系结构" class="headerlink" title="JAVA技术体系结构"></a>JAVA技术体系结构</h3><blockquote><p>Java虚拟机（Java Virtual Machine 简称 JVM）是<strong>运行所有Java程序</strong>的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。</p></blockquote><p><img src="../images/jvm/jvm01.png" alt></p><p>Java虚拟机是整个Java技术体系最重要的基础。</p><h3 id="为什么要了解虚拟机"><a href="#为什么要了解虚拟机" class="headerlink" title="为什么要了解虚拟机"></a>为什么要了解虚拟机</h3><ul><li><p>首先，Java 虚拟机提供了许多配置参数，用于满足不同应用场景下，对程序性能的需求。学习Java 虚拟机，你可以针对自己的应用，最优化匹配运行参数。</p></li><li><p>其次，Java 虚拟机本身是一种工程产品，在实现过程中自然存在不少局限性。学习 Java 虚拟机，可以更好地规避它在使用中的 Bug，也可以更快地识别出 Java 虚拟机中的错误</p></li><li><p>再次，Java 虚拟机拥有当前最前沿、最成熟的垃圾回收算法实现，以及即时编译器实现。学习Java 虚拟机，我们可以了解背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。</p></li><li><p>最后，Java 虚拟机发展到了今天，已经脱离 Java 语言，形成了一套相对独立的、高性能的执行方案。除了 Java 外，Scala、Clojure、Groovy，以及时下热门的 Kotlin，这些语言都可以运行在 Java 虚拟机之上。学习 Java 虚拟机，便可以了解这些语言的通用机制，甚至于让这些语言共享生态系统。</p></li></ul><h3 id="未来的Java技术"><a href="#未来的Java技术" class="headerlink" title="未来的Java技术"></a>未来的Java技术</h3><ul><li><p><strong>模块化</strong>:OSGI（动态化、模块化），应用层面就是微服务，互联网的发展方向</p></li><li><p><strong>混合语言</strong>：多个语言都可以运行在JVM中，google的Kotlin 成为了 Android 的官方语言。Scala(Kafka)</p></li><li><p><strong>多核并行</strong>：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)</p></li><li><p><strong>丰富语法：</strong>JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource</p></li><li><p><strong>64**</strong>位：**虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位，32位的JVM有4G的堆大小限制。</p></li><li><p><strong>更强的垃圾回收器（现在主流CMS、G1）：</strong>JDK11 –ZGC（暂停时间不超过10毫秒，且不会随着堆的增加而增加，TB级别的堆回收））：有色指针、加载屏障。JDK12支持并发类卸载，进一步缩短暂停时间 JDK13(计划于2019年9月)将最大堆大小从4TB增加到16TB</p></li></ul><h3 id="JVM的整体介绍"><a href="#JVM的整体介绍" class="headerlink" title="JVM的整体介绍"></a>JVM的整体介绍</h3><p><img src="../images/jvm/jvm02.jpg" alt></p><h4 id="JVM是如何工作的"><a href="#JVM是如何工作的" class="headerlink" title="JVM是如何工作的"></a>JVM是如何工作的</h4><blockquote><p>JVM分成3个主要的子系统</p><ul><li><p>类加载器子系统</p></li><li><p>运行时数据区</p></li><li><p>执行引擎</p></li></ul></blockquote><h5 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h5><blockquote><p>Java的动态类加载功能是通过类加载子系统去处理的。</p><p>它并不是在编译时候，而是在首次运行时加载引用类时、连接并初始化类文件。</p></blockquote><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><blockquote><p>类通过该组件加载。通过引导类加载器，扩展类加载器，应用类加载器这三个类加载器帮助完成加载。</p></blockquote><ol><li><p><strong>引导类加载器</strong></p><p>负责从引导类路径去加载类，除了rt.jar之外，没其他别的jar。给予该加载器最高的优先级。</p></li><li><p><strong>扩展类加载器</strong></p><p>负责加载ext目录（jre\lib）的类</p></li><li><p><strong>应用加载器</strong></p><p>负责加载类路径中应用级别的类，path提到的环境变量，等等。</p></li></ol><p>以上的类加载器在加载类文件的时候遵循委托层次算法。</p><h6 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h6><ol><li><strong>验证</strong>-字节码验证器验证生成的字节码是否正确，如果验证失败，我们将收到验证的错误信息。</li><li><strong>准备</strong>-为所有的静态变量分配内存和默认值</li><li><strong>解析</strong>-用方法区的原始引用代替所有符号内存引用。</li></ol><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><blockquote><p>这是类加载的最后一个阶段，此时所有的静态变量都用原始值去赋值，并且将运行静态代码块。</p></blockquote><h5 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h5><blockquote><p>运行时数据区域分成5个主要的组件</p></blockquote><h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><blockquote><p>所有类级的数据都存储在这里，包括静态变量。</p><p>每个JVM只有一个方法区，它是一个共享资源。</p></blockquote><h6 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h6><blockquote><p>所有的对象和对应的实例变量以及数组都存储在这里。</p><p>每个JVM只有一个堆区，由于方法区和堆区为多个线程共享内存，所以存储的数据不是线程安全的。</p></blockquote><h6 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h6><blockquote><p>为每个线程，创建一个单独的运行时栈。为每个方法调用，在栈内存创建一个条目，称之为栈帧。所有本地变量都会在栈内存中创建。由于它不是共享的资源，所有是线程安全的。</p><p>栈帧被分成3子实体</p></blockquote><ol><li>本地变量数组-涉及跟方法有关的本地变量和对应的值都存储在这里。</li><li>操作数栈-如果需要执行中间操作，操作数堆栈作为运行时工作区来执行操作。</li><li>帧数据-所有和对应方法的标记都存储在里面。在发生异常的情况下，捕捉块信息在这里维护。</li></ol><h6 id="程序计数器寄存器"><a href="#程序计数器寄存器" class="headerlink" title="程序计数器寄存器"></a>程序计数器寄存器</h6><blockquote><p>每个线程都有自己的程序计数器寄存器，持有当前执行指令的地址，一旦当前指令执行被运行，下一个指令将会更新到程序计数器寄存器。</p></blockquote><h5 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h5><blockquote><p>字节码被分配到执行引擎执行的运行时数据区。执行引擎一块一块的读取字节码并执行。</p></blockquote><h6 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h6><blockquote><p>解释器解释字节码很快，但是执行的很慢。解释器的缺点是当一个方法被调用多次，每次都需要一个新的解释。</p></blockquote><h6 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h6><blockquote><p>JIT弥补了解释器的缺点。执行引擎将利用解释器转换字节码，但是当他找到重复的编码，它就使用编译器。编译器编译全部的字节码并变成本地代码</p><p>这些本地码将直接被方法调用重复地使用，这就改善了系统的性能。</p></blockquote><ol><li><strong>中间代码生成器</strong>-生成中间代码。</li><li><strong>代码优化器</strong>-负责优化上面生成的代码</li><li><strong>目标代码生成器</strong>-负责生成机器码或者本地代码</li><li><strong>分析器</strong>-一个特殊的组件，负责寻找hotspots,即是否方法被调用多次。</li></ol><h6 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h6><blockquote><p>收集和清除未被引用的对象，可以通过System.gc()触发垃圾回收，但是不保证一定执行。创建收集对象的JVM垃圾收集。</p></blockquote><p><strong>Java Native Interface (JNI)：</strong>JNI和本地方法库互动，特供本地库所需的执行引擎。</p><p><strong>Native Method Libraries:</strong> 这是执行引擎所需的本地方法的一个集合</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM整体介绍
    
    </summary>
    
      <category term="JVM" scheme="http://www.baiyp.ren/categories/JVM/"/>
    
      <category term="内存结构" scheme="http://www.baiyp.ren/categories/JVM/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="JVM" scheme="http://www.baiyp.ren/tags/JVM/"/>
    
      <category term="整体介绍" scheme="http://www.baiyp.ren/tags/%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区-线程私有</title>
    <link href="http://www.baiyp.ren/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89.html"/>
    <id>http://www.baiyp.ren/JVM运行时数据区-线程私有.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T09:16:04.733Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JVM运行时数据区-线程私有"><a href="#JVM运行时数据区-线程私有" class="headerlink" title="JVM运行时数据区-线程私有"></a>JVM运行时数据区-线程私有</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="什么是运行时数据区"><a href="#什么是运行时数据区" class="headerlink" title="什么是运行时数据区"></a>什么是运行时数据区</h3><blockquote><p>JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域！</p><p>这个是抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）</p><p>计算机的运行=指令+数据，指令用于执行方法的，数据用于存放数据和对象的。</p></blockquote><p>​ Java虚拟机在执行Java程序的过程中会把它管理的内存分为若干个不同的数据区域。这些区域有着各自的用途，一级创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》中规定，jvm所管理的内存大致包括以下几个运行时数据区域。</p><ul><li><strong>线程私有</strong>:程序计数器、虚拟机栈、本地方法栈</li><li><strong>线程共享</strong>：堆、方法区</li></ul><p><img src="../images/jvm/jvm04.png" alt></p><p>与线程之间的关系：</p><table><thead><tr><th>区域</th><th>是否线程共享</th><th>是否会内存溢出</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>不会</td></tr><tr><td>虚拟机栈</td><td>否</td><td>会</td></tr><tr><td>本地方法栈</td><td>否</td><td>会</td></tr><tr><td>堆</td><td>是</td><td>会</td></tr><tr><td>方法区</td><td>是</td><td>会</td></tr></tbody></table><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote><p>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></blockquote><h4 id="特-点"><a href="#特-点" class="headerlink" title="特 点"></a>特 点</h4><ul><li><p>如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址</p></li><li><p>如果正在执行的是Native 方法，则这个技术器值为空（Undefined）</p></li><li><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p></li></ul><h4 id="为什么需要程序计数器"><a href="#为什么需要程序计数器" class="headerlink" title="为什么需要程序计数器"></a>为什么需要程序计数器</h4><ul><li><p>Java是多线程的，意味着线程切换</p></li><li><p>确保多线程情况下的程序正常执行</p></li></ul><h4 id="存储那些内容"><a href="#存储那些内容" class="headerlink" title="存储那些内容"></a>存储那些内容</h4><p>看一个代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的计算代码，我们先编译成Class 文件再使用 javap 反汇编工具看下class 文件中数据格式，如下图</p><img src="../images/jvm/jvm05.jpg" style="zoom:50%"><p>当执行到方法<strong>test()</strong>时在当前的线程中会创建相应的程序计数器，在计数器中为存放执行地址 （红框中的）0 2 3…等等。</p><p>这也说明在我们程序运行过程中计数器中改变的只是值，而不会随着程序的运行需要更大的空间，也就不会发生溢出情况。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h4><blockquote><p>虚拟机栈是用于描述java方法执行的内存模型。</p></blockquote><p>​ 每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“<strong>局部变量表、操作数栈、动态链接、方法出口</strong>”几个部分。我们常说的“堆内存、栈内存”中的“栈内存”指的便是虚拟机栈，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。</p><p>方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：</p><img src="../images/jvm/jvm06.png" style="zoom:75%"><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><blockquote><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p></blockquote><img src="../images/jvm/jvm07.png" style="zoom:75%"><h5 id="栈帧中的元素"><a href="#栈帧中的元素" class="headerlink" title="栈帧中的元素"></a>栈帧中的元素</h5><h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><p>​ 局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><img src="../images/jvm/jvm08.jpg" style="zoom:50%"><h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h6><p>​ 操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。</p><blockquote><p>操作数是运算符作用于的实体，是表达式中的一个组成部分，它规定了指令中进行数字运算的量 。<br>表达式是操作数与操作符的组合。</p></blockquote><h6 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h6><p>​ 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class文文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p><h6 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h6><p>​ 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><blockquote><p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p></blockquote><p>​ 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。</p><h4 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h4><ul><li>虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。</li><li>栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</li><li>在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</li></ul><h4 id="虚拟机栈的StackOverflowError"><a href="#虚拟机栈的StackOverflowError" class="headerlink" title="虚拟机栈的StackOverflowError"></a>虚拟机栈的StackOverflowError</h4><p>若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。</p><p>JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用。</p><h4 id="虚拟机栈的OutOfMemoryError"><a href="#虚拟机栈的OutOfMemoryError" class="headerlink" title="虚拟机栈的OutOfMemoryError"></a>虚拟机栈的OutOfMemoryError</h4><p>​ 不同于StackOverflowError，OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。</p><p>JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​ 本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。</p><p>不同的是，本地方法栈服务的对象是JVM执行的<strong>native</strong>方法，而虚拟机栈服务的是JVM执行的java方法。如何去服务native方法？native方法使用什么语言实现？怎么组织像栈帧这种为了服务方法的数据结构？虚拟机规范并未给出强制规定，因此不同的虚拟机实可以进行自由实现，我们常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM运行时数据区-线程私有
    
    </summary>
    
      <category term="JVM" scheme="http://www.baiyp.ren/categories/JVM/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="JVM" scheme="http://www.baiyp.ren/tags/JVM/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
      <category term="线程私有" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区-线程私有</title>
    <link href="http://www.baiyp.ren/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB.html"/>
    <id>http://www.baiyp.ren/JVM运行时数据区-线程共享.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T11:57:02.700Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JVM运行时数据区-线程共享"><a href="#JVM运行时数据区-线程共享" class="headerlink" title="JVM运行时数据区-线程共享"></a>JVM运行时数据区-线程共享</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="方法区-永久代"><a href="#方法区-永久代" class="headerlink" title="方法区(永久代)"></a>方法区(永久代)</h3><blockquote><p>方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p><p><strong>方法区（method area）</strong>只是<strong>JVM规范</strong>中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而<strong>永久代</strong>是<strong>Hotspot</strong>虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西</p></blockquote><p>​ 主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。</p><h4 id="方法区结构"><a href="#方法区结构" class="headerlink" title="方法区结构"></a>方法区结构</h4><h5 id="classLoader是如何加载class文件和存储文件信息的"><a href="#classLoader是如何加载class文件和存储文件信息的" class="headerlink" title="classLoader是如何加载class文件和存储文件信息的"></a>classLoader是如何加载class文件和存储文件信息的</h5><p>​ 当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader。那么方法区中的字节码内存块，除了记录一个class自己的class对象引用和一个加载自己的ClassLoader引用之外，还记录了什么信息呢？？</p><p><img src="../images/jvm/jvm09.png" alt></p><h4 id="方法区关键信息介绍"><a href="#方法区关键信息介绍" class="headerlink" title="方法区关键信息介绍"></a>方法区关键信息介绍</h4><h5 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h5><ul><li>类型的全限定名</li><li>超类的全限定名</li><li>直接超接口的全限定名</li><li>类型标志（该类是类类型还是接口类型）</li><li>类的访问描述符（public、private、default、abstract、final、static）</li></ul><h5 id="类型的常量池"><a href="#类型的常量池" class="headerlink" title="类型的常量池"></a>类型的常量池</h5><pre><code>存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的常量）和对其他类型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为常量池中保存中所有类型使用到的类型、字段、方法的字符引用，所以它也是动态连接的主要对象（在动态链接中起到核心作用）。</code></pre><h5 id="字段信息（该类声明的所有字段）"><a href="#字段信息（该类声明的所有字段）" class="headerlink" title="字段信息（该类声明的所有字段）"></a>字段信息（该类声明的所有字段）</h5><ul><li>字段修饰符（public、protect、private、default）</li><li>字段的类型</li><li>字段名称</li></ul><h5 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h5><blockquote><p>方法信息中包含类的所有方法，每个方法包含以下信息</p></blockquote><ul><li>方法修饰符</li><li>方法返回类型</li><li>方法名</li><li>方法参数个数、类型、顺序等</li><li>方法字节码</li><li>操作数栈和该方法在栈帧中的局部变量区大小</li><li>异常表</li></ul><h5 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h5><p>​ 指该类所有对象共享的变量，即使没有任何实例对象时，也可以访问的类变量。它们与类进行绑定。</p><h5 id="指向类加载器的引用"><a href="#指向类加载器的引用" class="headerlink" title="指向类加载器的引用"></a>指向类加载器的引用</h5><p>​ 每一个被JVM加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到。</p><h5 id="指向Class实例的引用"><a href="#指向Class实例的引用" class="headerlink" title="指向Class实例的引用"></a>指向Class实例的引用</h5><p>​ 类加载的过程中，虚拟机会创建该类型的Class实例，方法区中必须保存对该对象的引用。通过Class.forName(String className)来查找获得该实例的引用，然后创建该类的对象。</p><h5 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h5><p>​ 为了提高访问效率，JVM可能会对每个装载的非抽象类，都创建一个数组，数组的每个元素是实例可能调用的方法的直接引用，包括父类中继承过来的方法。这个表在抽象类或者接口中是没有的，类似C++虚函数表vtbl。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><h5 id="Class文件中的常量池"><a href="#Class文件中的常量池" class="headerlink" title="Class文件中的常量池"></a>Class文件中的常量池</h5><p>​ 在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p><p>​ 常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>​ Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>​ 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h5 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h5><p>​ 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>​ 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><ul><li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li></ul><h6 id="双等号-的含义"><a href="#双等号-的含义" class="headerlink" title="双等号==的含义"></a>双等号==的含义</h6><ul><li>基本数据类型之间应用双等号，比较的是他们的数值。</li><li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li></ul><h5 id="基本类型的包装类和常量池"><a href="#基本类型的包装类和常量池" class="headerlink" title="基本类型的包装类和常量池"></a>基本类型的包装类和常量池</h5><p>​ java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean。</p><p>​ 这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float,Double并没有实现常量池技术。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><blockquote><p>堆是需要重点关注的一块区域，因为涉及到内存的分配(new关键字，反射等)与回收(回收算法，收集器等)</p><p>几乎所有的对象都是在堆中分配。</p></blockquote><p>​ 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，<strong>在虚拟机启动时创建</strong>。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存</strong>。这一点在Java虚拟机规范中的描述是：<strong>所有的对象实例以及数组都要在堆上分配</strong>。但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得没那么绝对了。</p><p>​ Java堆是垃圾收集器管理的主要区域，因此很多时候也被称“GC堆”（Garbage Collected Heap）。从内存回收的角度看，现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、F rom Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer ,TLAB）。无论如何划分，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>​ 根据虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，可以是固定大小的，也可以是扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx -Xms 控制）。如果在堆中没有内存完成 实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>存储的全部是对象，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。</p></li><li><p>jvm只有一个堆区（heap）被所有线程共享，堆区中不存放基本类型和对象引用，只存放对象本身。</p></li><li><p>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。</p></li><li><p>缺点是，由于要在运行时动态分配内存，存取速度较慢。</p></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><img src="../images/jvm/jvm13.png" style="zoom:48%"><p>​ 直接内存不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK1.4中新加入了<strong>NIO（New Input/Output）</strong>类，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓冲区（Buffer）</strong>的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的<strong>DirectByteBuffer</strong>对象作为这块内存的引用 进行操作。<strong>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="../images/jvm/jvm12.png" style="zoom:75%"><h4 id="堆栈方法区的区别"><a href="#堆栈方法区的区别" class="headerlink" title="堆栈方法区的区别"></a>堆栈方法区的区别</h4><h5 id="存储内容的区别"><a href="#存储内容的区别" class="headerlink" title="存储内容的区别"></a>存储内容的区别</h5><p><strong>栈：</strong>为即时调用的方法开辟空间，<strong>存储局部变量值(基本数据类型)</strong>，<strong>局部变量引用</strong>,<strong>对象属性的引用</strong>。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放；注意：局部变量必须手动初始化。</p><p><strong>堆</strong>：<strong>存放引用类型的对象</strong>，即new出来的<strong>对象、数组值、类的非静态成员变量值(基本数据类型)、非静态成员变量引用</strong>。其中非静态成员变量在实例化时开辟空间初始化值。（类中属于全局变量的基本数据类型也存放在堆中）。一个java对象占用的内存空间,除了一个固定大小的空间用于描述这个对象属于哪个类,其它的就用于保存它的字段的值;堆比栈要大。</p><p><strong>方法区</strong>：<strong>存放class二进制文件</strong>。包含<strong>类信息、静态变量，常量池（String字符串和final修饰的常量值等），类的版本号等基本信息</strong>。静态成员变量是在方法区的静态域里面，而静态成员方法是在方法区的class二进制信息里面(.class文件和方法区里面的二进制信息不一样，读取.class文件按照虚拟机需要的格式存储在方法区，这种格式包括数据结构方面。）因为是共享的区域，所以如果静态成员变量的值或者常量值(String类型的值能够非修改)被修改了直接就会反应到其它类的对象中。</p><p><strong>基本类型的地址和值都存在栈中，但是两个相同值的基本类型的地址不同，其中的==比较被重写</strong></p><p><strong>成员变量存放在堆中，就算是int a[]=new int[10]，也都是存放在堆中，包括a[2]=1.而局部变量存放于栈中</strong></p><h5 id="定义的区别"><a href="#定义的区别" class="headerlink" title="定义的区别"></a>定义的区别</h5><p><strong>堆</strong>：FIFO队列优先，先进先出。jvm只有一个堆区被所有线程所共享！堆存放在二级缓存中，调用对象的速度相对慢一些，生命周期由虚拟机的垃圾回收机制定。</p><p><strong>栈</strong>：FILO先进后出，暂存数据的地方。每个线程都包含一个栈区！栈存放在一级缓存中，存取速度较快，“栈是限定仅在表头进行插入和删除操作的线性表”。</p><p><strong>方法区</strong>：用来存放方法和static变量。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>堆的优点-可以动态的分配内存大小，生命周期不确定。缺点-速度略慢</p><p>栈的优点-速度快，缺点-存在栈中的数据大小和生命周期必须是明确的，缺少灵活性。</p><h5 id="直接内存（堆外内存）与堆内存比较"><a href="#直接内存（堆外内存）与堆内存比较" class="headerlink" title="直接内存（堆外内存）与堆内存比较"></a>直接内存（堆外内存）与堆内存比较</h5><ul><li><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显</p></li><li><p>直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM运行时数据区-线程私有
    
    </summary>
    
      <category term="JVM" scheme="http://www.baiyp.ren/categories/JVM/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="JVM" scheme="http://www.baiyp.ren/tags/JVM/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
      <category term="线程私有" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>JVM永久代与元空间</title>
    <link href="http://www.baiyp.ren/JVM%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%8E%E5%85%83%E7%A9%BA%E9%97%B4.html"/>
    <id>http://www.baiyp.ren/JVM永久代与元空间.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T09:42:48.400Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JVM永久代与元空间"><a href="#JVM永久代与元空间" class="headerlink" title="JVM永久代与元空间"></a>JVM永久代与元空间</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="方法区与永久代"><a href="#方法区与永久代" class="headerlink" title="方法区与永久代"></a>方法区与永久代</h3><blockquote><p>方法区和永久代又有着本质的区别。<strong>前者是 JVM 的规范</strong>，<strong>而后者则是 JVM 规范的一种实现</strong>，并且只有 HotSpot 才有永久代，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出</p></blockquote><p>​ 在Java虚拟机规范中，方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择不在方法区实现垃圾回收与压缩。这个版本的虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。所以不同的JVM厂商，针对自己的JVM可能有不同的方法区实现方式。</p><p>​ 在HotSpot中，设计者将方法区纳入GC分代收集。HotSpot虚拟机堆内存被分为新生代和老年代，对堆内存进行分代管理，所以HotSpot虚拟机使用者更愿意将方法区称为老年代。</p><p>​ 方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。</p><p>​ 我们知道在HotSpot虚拟机中存在三种垃圾回收现象，minor GC、major GC和full GC。对新生代进行垃圾回收叫做minor GC，对老年代进行垃圾回收叫做major GC，同时对新生代、老年代和永久代进行垃圾回收叫做full GC。许多major GC是由minor GC触发的，所以很难将这两种垃圾回收区分开。major GC和full GC通常是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是major GC。</p><h4 id="大小调节"><a href="#大小调节" class="headerlink" title="大小调节"></a>大小调节</h4><blockquote><p>在1.7之前，可以使用如下参数来调节方法区的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法区初始大小</span></span><br><span class="line">-XX:PermSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法区最大大小, 超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen</span></span><br><span class="line">-XX:MaxPermSize</span><br></pre></td></tr></table></figure><h3 id="jdk8中的方法区"><a href="#jdk8中的方法区" class="headerlink" title="jdk8中的方法区"></a>jdk8中的方法区</h3><p>​ 在jdk8中已经将永久带移除了。也就是说-XX:PermSize这些参数在jdk8中将是无效的。<br>移除了，肯定有人来代替他。就是新出现的元空间(Metaspace)来代替原来的永久带。</p><p>方法区中主要存放的是一些描述性信息，即元数据。</p><p>​ 方法区是堆的逻辑组成部分。实际上JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，但是并没完全移除。</p><h4 id="大小调整"><a href="#大小调整" class="headerlink" title="大小调整"></a>大小调整</h4><blockquote><p>在1.8中，使用如下参数来调节方法区的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元空间初始大小</span></span><br><span class="line">-XX: MetaspaceSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元空间最大大小, 超过这个值将会抛出OutOfMemoryError异常：java.lang.OutOfMemoryError: Metadata space</span></span><br><span class="line">-XX: MaxMetaspaceSize</span><br></pre></td></tr></table></figure><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>​ 永久代中包含了虚拟机中所有可通过反射获取到的数据，比如Class和Method对象。不同的Java虚拟机之间可能会进行类共享，因此永久代又分为只读区和读写区。</p><p>​ JVM用于描述应用程序中用到的类和方法的元数据也存储在永久代中。JVM运行时会用到多少永久代的空间取决于应用程序用到了多少类。除此之外，Java SE库中的类和方法也都存储在这里。</p><p>​ 如果JVM发现有的类已经不再需要了，它会去回收（卸载）这些类，将它们的空间释放出来给其它类使用。Full GC会进行持久代的回收。</p><ul><li>JVM中类的元数据在Java堆中的存储区域。</li><li>Java类对应的HotSpot虚拟机中的内部表示也存储在这里。</li><li>类的层级信息，字段，名字。</li><li>方法的编译信息及字节码。</li><li>变量</li><li>常量池和符号解析</li></ul><h4 id="永久代大小"><a href="#永久代大小" class="headerlink" title="永久代大小"></a>永久代大小</h4><ul><li>它的上限是MaxPermSize，默认是64M</li><li>Java堆中的连续区域 : 如果存储在非连续的堆空间中的话，要定位出持久代到新对象的引用非常复杂并且耗时。卡表（card table），是一种记忆集（Remembered Set），它用来记录某个内存代中普通对象指针（oops）的修改。</li><li>持久代用完后，会抛出OutOfMemoryError “PermGen space”异常。解决方案：应用程序清理引用来触发类卸载；增加MaxPermSize的大小。</li><li>需要多大的持久代空间取决于类的数量，方法的大小，以及常量池的大小。</li></ul><h4 id="为什么移除持久代"><a href="#为什么移除持久代" class="headerlink" title="为什么移除持久代"></a>为什么移除持久代</h4><ul><li>它的大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？</li><li>HotSpot的内部类型也是Java对象：它可能会在Full GC中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。</li><li>简化Full GC：每一个回收器有专门的元数据迭代器。</li><li>可以在GC不进行暂停的情况下并发地释放类数据。</li><li>使得原来受限于持久代的一些改进未来有可能实现</li></ul><h3 id="元空间-metaspace"><a href="#元空间-metaspace" class="headerlink" title="元空间(metaspace)"></a>元空间(metaspace)</h3><blockquote><p>JDK 8的HotSpot JVM现在使用的是本地内存来表示类的元数据，这个区域就叫做元空间。</p></blockquote><p>​ 持久代的空间被彻底地删除了，它被一个叫元空间的区域所替代了。持久代删除了之后，很明显，JVM会忽略PermSize和MaxPermSize这两个参数，还有就是你再也看不到java.lang.OutOfMemoryError: PermGen error的异常了。原来类的静态变量和Interned Strings 都被转移到了java堆区，只有class元数据才在元空间。</p><h4 id="元空间的特点"><a href="#元空间的特点" class="headerlink" title="元空间的特点"></a>元空间的特点</h4><ul><li>充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。</li><li>每个加载器有专门的存储空间</li><li>只进行线性分配</li><li>不会单独回收某个类</li><li>省掉了GC扫描及压缩的时间</li><li>元空间里的对象的位置是固定的</li><li>如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉</li></ul><h4 id="元空间的内存分配模型"><a href="#元空间的内存分配模型" class="headerlink" title="元空间的内存分配模型"></a>元空间的内存分配模型</h4><ul><li>绝大多数的类元数据的空间都从本地内存中分配</li><li>用来描述类元数据的类也被删除了</li><li>分元数据分配了多个虚拟内存空间</li><li>给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些</li><li>归还内存块，释放内存块列表</li><li>一旦元空间的数据被清空了，虚拟内存的空间会被回收掉</li><li>减少碎片的策略</li></ul><h4 id="元空间内存管理"><a href="#元空间内存管理" class="headerlink" title="元空间内存管理"></a>元空间内存管理</h4><p>​ <strong>元空间的内存管理由元空间虚拟机来完成</strong>。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，<strong>类和其元数据的生命周期和其对应的类加载器是相同的</strong>。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。</p><p>​ 准确的来说，<strong>每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间</strong>。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p><p>​ <strong>元空间虚拟机负责元空间的分配</strong>，其采用的形式为<strong>组块分配</strong>。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个<strong>全局的空闲组块列表</strong>。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。<strong>组块中的块是线性分配（指针碰撞分配形式）</strong>。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p><p>​ 运行时常量池在<strong>JDK1.6及之前版本的JVM中是方法区的一部分</strong>，而在HotSpot虚拟机中方法区放在了”永久代(Permanent Generation)”。所以运行时常量池也是在永久代的，但是<strong>JDK1.7及之后版本的JVM已经将字符串常量池从方法区中移了出来，在Java 堆（Heap）中开辟了一块区域存放运行时常量池</strong>。</p><p>​ String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的<strong>引用</strong>。</p><h3 id="永久代与元空间"><a href="#永久代与元空间" class="headerlink" title="永久代与元空间"></a>永久代与元空间</h3><blockquote><p>JDK8 HotSpot JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）</p></blockquote><p>以下是JVM内存模型中方法区的变动</p><p><img src="../images/jvm/jvm11.jpg" alt></p><p>1.新生代：Eden+From Survivor+To Survivor</p><p>2.老年代：OldGen</p><p>3.永久代（方法区的实现） : PermGen—–&gt;替换为Metaspace(本地内存中)</p><p>​ 元空间的本质和永久代类似，<strong>都是对JVM规范中方法区的实现</strong>。不过元空间与永久代之间<strong>最大的区别在于：元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><p>​ 《Java虚拟机规范(JavaSE7)》中也说了<strong>方法区是堆的逻辑组成部分</strong>。<br>实际上JDK1.7中，存储在永久代的部分数据就已经转移到了<code>Java Heap</code>或者是 <code>Native Heap</code>。但永久代在JDK1.8才被移除</p><h4 id="移除永久代的影响"><a href="#移除永久代的影响" class="headerlink" title="移除永久代的影响"></a>移除永久代的影响</h4><p>​ 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，<strong>我们就不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情</strong>。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM会<strong>自动</strong>根据类的元数据大小动态增加元空间的容量。</p><p><strong>注意</strong>：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM永久代与元空间
    
    </summary>
    
      <category term="JVM" scheme="http://www.baiyp.ren/categories/JVM/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/JVM/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="JVM" scheme="http://www.baiyp.ren/tags/JVM/"/>
    
      <category term="永久代" scheme="http://www.baiyp.ren/tags/%E6%B0%B8%E4%B9%85%E4%BB%A3/"/>
    
      <category term="元空间" scheme="http://www.baiyp.ren/tags/%E5%85%83%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>并发面试题总结</title>
    <link href="http://www.baiyp.ren/%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.baiyp.ren/并发面试题总结.html</id>
    <published>2019-09-07T09:12:30.000Z</published>
    <updated>2019-09-07T09:56:25.851Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="并发面试题总结"><a href="#并发面试题总结" class="headerlink" title="并发面试题总结"></a>并发面试题总结</h2><h3 id="谈面试"><a href="#谈面试" class="headerlink" title="谈面试"></a>谈面试</h3><ol><li><p>面试主要分为两块：</p><ul><li>一块是考查工程师对基础知识（包括了技术广度、深度、对技术的热情度等）的掌握程度，因为<strong>基础知识决定了一个技术人员发展的上限</strong>；</li><li>另一块是考察工程师的工程能力，比如：做过哪些项目？遇到最难的问题怎样解决的？说说最有成就感的一项任务？<strong>工程能力是考察工程师当下能为公司带来的利益</strong>。当然还有其它考核方面：抗压性、合作能力。</li></ul></li><li><p>Java只是一门语言，即使是Java工程师也不能局限于Java，要从面向对象语言本身，甚至从整个计算机体系，从工程实际出发看Java。</p></li><li><p>很多知识在一般公司的开发中是用不到的，常有人戏称：“面试造火箭，工作拧螺丝”，但这只是通常情况下公司对程序员的标准——迅速产出，完成任务。所以，工程师为了自己职业的发展不能局限于公司对自己的要求，不能停留在应用层面，要能够很好地掌握基础知识，要多看源码，自己多实践，学成记得产出，比如多为开源社区贡献代码，帮助初学者指路等。</p></li></ol><p>其实“面试造火箭，工作拧螺丝”的背后其实是大家都普遍认可基础知识的重要性。</p><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="1-在java中守护线程和用户线程的区别？"><a href="#1-在java中守护线程和用户线程的区别？" class="headerlink" title="1.在java中守护线程和用户线程的区别？"></a>1.在java中守护线程和用户线程的区别？</h4><p>java中的线程分为两种：</p><ul><li>守护线程（Daemon）</li><li>用户线程（User）。</li></ul><p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。</p><p><strong>两者的区别：</strong></p><p>唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经结束，Daemon 没有可服务的线程，JVM关闭。</p><p>扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程</p><h4 id="2-线程与进程的区别"><a href="#2-线程与进程的区别" class="headerlink" title="2.线程与进程的区别"></a>2.线程与进程的区别</h4><p>​ 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p><p>​ 一个程序至少有一个进程,一个进程至少有一个线程。</p><h4 id="3-什么是多线程中的上下文切换"><a href="#3-什么是多线程中的上下文切换" class="headerlink" title="3.什么是多线程中的上下文切换"></a>3.什么是多线程中的上下文切换</h4><p>多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。</p><h4 id="4-死锁与活锁的区别，死锁与饥饿的区别？"><a href="#4-死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="4.死锁与活锁的区别，死锁与饥饿的区别？"></a>4.死锁与活锁的区别，死锁与饥饿的区别？</h4><p><strong>死锁</strong>：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><p><strong>产生死锁的必要条件：</strong></p><ul><li><p>互斥条件：所谓互斥就是进程在某一时间内独占资源。</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p></li><li><p>不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。</p></li><li><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p></li></ul><p><strong>活锁</strong>：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p><strong>饥饿</strong>：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><h4 id="5-synchronized底层实现原理"><a href="#5-synchronized底层实现原理" class="headerlink" title="5.synchronized底层实现原理"></a>5.synchronized底层实现原理</h4><p>​ synchronized (this)原理：涉及两条指令：<strong>monitorenter</strong>，<strong>monitorexit</strong>；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</p><p>​ JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><p>注意，这个问题可能会接着追问，java对象头信息，偏向锁，轻量锁，重量级锁及其他们相互间转化。</p><h4 id="6-什么是线程组，为什么在Java中不推荐使用？"><a href="#6-什么是线程组，为什么在Java中不推荐使用？" class="headerlink" title="6.什么是线程组，为什么在Java中不推荐使用？"></a>6.什么是线程组，为什么在Java中不推荐使用？</h4><p>ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p><ul><li><p>线程组ThreadGroup对象中比较有用的方法是stop、resume、suspend等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。</p></li><li><p>线程组ThreadGroup不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。</p></li></ul><h4 id="7-什么是Executors框架？为什么使用Executor框架？"><a href="#7-什么是Executors框架？为什么使用Executor框架？" class="headerlink" title="7.什么是Executors框架？为什么使用Executor框架？"></a>7.什么是Executors框架？为什么使用Executor框架？</h4><ul><li><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p></li><li><p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。</p></li><li><p>调用 new Thread()创建的线程缺乏管理，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</p></li><li><p>直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p></li></ul><h4 id="8-在Java中Executor和Executors的区别？"><a href="#8-在Java中Executor和Executors的区别？" class="headerlink" title="8.在Java中Executor和Executors的区别？"></a>8.在Java中Executor和Executors的区别？</h4><ul><li><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p></li><li><p>Executor 接口对象能执行我们的线程任务。</p></li><li><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</p></li><li><p>使用ThreadPoolExecutor 可以创建自定义线程池。</p></li></ul><h4 id="9-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#9-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="9.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>9.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h4><blockquote><p><strong>原子操作（atomic operation）</strong>意为”不可被中断的一个或一系列操作” 。</p></blockquote><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。</p><p>CAS操作——Compare And Set，或是 Compare And Swap，现在几乎所有的CPU指令都支持CAS的原子操作。java.util.concurrent.atomic下提供了大量的原子操作类，比如原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference ，原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray ，原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</p><h4 id="10-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比synchronized它有什么优势？"><a href="#10-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比synchronized它有什么优势？" class="headerlink" title="10.Java Concurrency API中的Lock接口(Lock interface)是什么？对比synchronized它有什么优势？"></a>10.Java Concurrency API中的Lock接口(Lock interface)是什么？对比synchronized它有什么优势？</h4><ul><li><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。</p></li><li><p>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p></li></ul><p><strong>它的优势有</strong>：可以使锁更公平，可以使线程在等待锁的时候响应中断，可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间，可以在不同的范围，以不同的顺序获取和释放锁。</p><p>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p><h4 id="11-什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#11-什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="11.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>11.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h4><blockquote><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p></blockquote><p>这两个附加的操作是：</p><ul><li>在队列为空时，获取元素的线程会等待队列变为非空。</li><li>当队列满时，存储元素的线程会等待队列可用。</li></ul><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7提供了7个阻塞队列。在实现上，主要是利用了Condition和Lock的等待通知模式。</p><h4 id="12-什么是Callable和Future"><a href="#12-什么是Callable和Future" class="headerlink" title="12.什么是Callable和Future?"></a>12.什么是Callable和Future?</h4><p>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。</p><p>可以认为是带有回调的Runnable。</p><p>Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p><h4 id="13-什么是FutureTask"><a href="#13-什么是FutureTask" class="headerlink" title="13.什么是FutureTask?"></a>13.什么是FutureTask?</h4><p>​ 在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p><h4 id="14-什么是并发容器的实现？"><a href="#14-什么是并发容器的实现？" class="headerlink" title="14.什么是并发容器的实现？"></a>14.什么是并发容器的实现？</h4><p><strong>何为同步容器</strong>：可以简单地理解为通过<strong>synchronized</strong>来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。</p><p>比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。</p><p>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。</p><h4 id="15-多线程同步和互斥有几种实现方法，都是什么？"><a href="#15-多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="15.多线程同步和互斥有几种实现方法，都是什么？"></a>15.多线程同步和互斥有几种实现方法，都是什么？</h4><p><strong>线程同步</strong>：是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p><p><strong>线程互斥</strong>：是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>线程间的同步方法大体可分为两类：</p><p>用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p><p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p><h4 id="16-什么是竞争条件？"><a href="#16-什么是竞争条件？" class="headerlink" title="16.什么是竞争条件？"></a>16.什么是竞争条件？</h4><p>​ 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。</p><h4 id="17-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#17-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="17.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>17.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h4><p>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。</p><p>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。</p><h4 id="18-在Java中CycliBarriar和CountdownLatch有什么区别？"><a href="#18-在Java中CycliBarriar和CountdownLatch有什么区别？" class="headerlink" title="18.在Java中CycliBarriar和CountdownLatch有什么区别？"></a>18.在Java中CycliBarriar和CountdownLatch有什么区别？</h4><p>CyclicBarrier可以重复使用，而CountdownLatch不能重复使用。</p><h4 id="19-什么是不可变对象，它对写并发应用有什么帮助？"><a href="#19-什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="19.什么是不可变对象，它对写并发应用有什么帮助？"></a>19.什么是不可变对象，它对写并发应用有什么帮助？</h4><blockquote><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p></blockquote><p>不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。</p><p>不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。</p><p><strong>不可变对象永远是线程安全的。</strong></p><p>只有满足如下状态，一个对象才是不可变的：</p><ul><li><p>它的状态不能在创建后再被修改；</p></li><li><p>所有域都是final类型；并且， 它被正确创建</p></li></ul><h4 id="20-notify-和notifyAll-有什么区别？"><a href="#20-notify-和notifyAll-有什么区别？" class="headerlink" title="20.notify()和notifyAll()有什么区别？"></a>20.notify()和notifyAll()有什么区别？</h4><p>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</p><p>如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。</p><h4 id="21-什么是可重入锁（ReentrantLock）？谈谈它的实现。"><a href="#21-什么是可重入锁（ReentrantLock）？谈谈它的实现。" class="headerlink" title="21.什么是可重入锁（ReentrantLock）？谈谈它的实现。"></a>21.什么是可重入锁（ReentrantLock）？谈谈它的实现。</h4><p>​ 线程可以重复进入任何一个它已经拥有的锁所同步着的代码块，synchronized、ReentrantLock都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每 释放一次锁，进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。</p><h4 id="22-当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#22-当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="22.当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"></a>22.当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</h4><p>如果其他方法没有synchronized的话，其他线程是可以进入的。</p><p>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p><h4 id="23-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#23-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="23.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>23.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p><strong>悲观锁：</strong>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java里面的同步原语synchronized关键字的实现是悲观锁。</p><p><strong>乐观锁：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。在Java中j原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>乐观锁的实现方式：</p><ul><li><p>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p></li><li><p>java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p></li></ul><h4 id="24-什么是CAS操作，缺点是什么？"><a href="#24-什么是CAS操作，缺点是什么？" class="headerlink" title="24.什么是CAS操作，缺点是什么？"></a>24.什么是CAS操作，缺点是什么？</h4><p>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p><p><strong>CAS缺点：</strong></p><ul><li><p>ABA问题：</p><p>​ 比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p></li><li><p>循环时间长开销大：</p><p>​ 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p></li><li><p>只能保证一个共享变量的原子操作：</p><p>​ 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p></li></ul><h4 id="25-SynchronizedMap和ConcurrentHashMap有什么区别？"><a href="#25-SynchronizedMap和ConcurrentHashMap有什么区别？" class="headerlink" title="25.SynchronizedMap和ConcurrentHashMap有什么区别？"></a>25.SynchronizedMap和ConcurrentHashMap有什么区别？</h4><ul><li><p>SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。</p></li><li><p>ConcurrentHashMap使用分段锁来保证在多线程下的性能。</p></li></ul><h4 id="26-写时复制容器可以用于什么应用场景？"><a href="#26-写时复制容器可以用于什么应用场景？" class="headerlink" title="26.写时复制容器可以用于什么应用场景？"></a>26.写时复制容器可以用于什么应用场景？</h4><p>CopyOnWrite并发容器用于对于绝大部分访问都是读，且<strong>只是偶尔写</strong>的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><p>透露的思想：</p><ul><li><p>读写分离，读和写分开</p></li><li><p>最终一致性</p></li><li><p>使用另外开辟空间的思路，来解决并发冲突</p></li></ul><h4 id="27-volatile有什么用？能否用一句话说明下volatile的应用场景？"><a href="#27-volatile有什么用？能否用一句话说明下volatile的应用场景？" class="headerlink" title="27.volatile有什么用？能否用一句话说明下volatile的应用场景？"></a>27.volatile有什么用？能否用一句话说明下volatile的应用场景？</h4><ul><li><p>volatile保证内存可见性和禁止指令重排。</p></li><li><p>volatile用于多线程环境下的一写多读，或者无关联的多写。</p></li></ul><h4 id="28-为什么代码会重排序？"><a href="#28-为什么代码会重排序？" class="headerlink" title="28.为什么代码会重排序？"></a>28.为什么代码会重排序？</h4><p>​ 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p><ul><li><p>在单线程环境下不能改变程序运行的结果；</p></li><li><p>存在数据依赖关系的不允许重排序</p></li></ul><h4 id="29-在java中wait和sleep方法的不同？"><a href="#29-在java中wait和sleep方法的不同？" class="headerlink" title="29.在java中wait和sleep方法的不同？"></a>29.在java中wait和sleep方法的不同？</h4><p>​ 最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p><h4 id="30-一个线程运行时发生异常会怎样？"><a href="#30-一个线程运行时发生异常会怎样？" class="headerlink" title="30.一个线程运行时发生异常会怎样？"></a>30.一个线程运行时发生异常会怎样？</h4><p>​ 如果异常没有被捕获该线程将会停止执行。hread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p><h4 id="31-为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#31-为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="31.为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>31.为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p>​ JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h4 id="32-什么是ThreadLocal变量？"><a href="#32-什么是ThreadLocal变量？" class="headerlink" title="32.什么是ThreadLocal变量？"></a>32.什么是ThreadLocal变量？</h4><p>​ ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p><h4 id="33-Java中interrupted-和-isInterrupted方法的区别？"><a href="#33-Java中interrupted-和-isInterrupted方法的区别？" class="headerlink" title="33.Java中interrupted 和 isInterrupted方法的区别？"></a>33.Java中interrupted 和 isInterrupted方法的区别？</h4><p>​ <strong>interrupted()</strong> 和 <strong>isInterrupted()</strong>的主要区别是前者会将中断状态清除而后者不会。</p><p>​ Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。</p><h4 id="34-为什么wait和notify方法要在同步块中调用？"><a href="#34-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="34.为什么wait和notify方法要在同步块中调用？"></a>34.为什么wait和notify方法要在同步块中调用？</h4><p>​ 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。</p><h4 id="35-为什么你应该在循环中检查等待条件"><a href="#35-为什么你应该在循环中检查等待条件" class="headerlink" title="35.为什么你应该在循环中检查等待条件?"></a>35.为什么你应该在循环中检查等待条件?</h4><p>​ 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因</p><h4 id="36-怎么检测一个线程是否拥有锁？"><a href="#36-怎么检测一个线程是否拥有锁？" class="headerlink" title="36.怎么检测一个线程是否拥有锁？"></a>36.怎么检测一个线程是否拥有锁？</h4><p>​ 在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p><h4 id="37-你如何在Java中获取线程堆栈？"><a href="#37-你如何在Java中获取线程堆栈？" class="headerlink" title="37.你如何在Java中获取线程堆栈？"></a>37.你如何在Java中获取线程堆栈？</h4><p><strong>kill -3 [java pid]</strong></p><p>不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，kill -3 tomcat pid, 输出堆栈到log目录下。</p><p><strong>Jstack [java pid]</strong></p><p>这个比较简单，在当前终端显示，也可以重定向到指定文件中。</p><p>或者使用Java提供的拟机线程系统的管理接口ManagementFactory.getThreadMXBean()。</p><h4 id="38-Java线程池中submit-和-execute-方法有什么区别？"><a href="#38-Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="38.Java线程池中submit() 和 execute()方法有什么区别？"></a>38.Java线程池中submit() 和 execute()方法有什么区别？</h4><p>​ 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。</p><p>而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口</p><h4 id="39-你对线程优先级的理解是什么？"><a href="#39-你对线程优先级的理解是什么？" class="headerlink" title="39.你对线程优先级的理解是什么？"></a>39.你对线程优先级的理解是什么？</h4><p>​ 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p><p>​ java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><h4 id="40-你如何确保main-方法所在的线程是Java-程序最后结束的线程？"><a href="#40-你如何确保main-方法所在的线程是Java-程序最后结束的线程？" class="headerlink" title="40.你如何确保main()方法所在的线程是Java 程序最后结束的线程？"></a>40.你如何确保main()方法所在的线程是Java 程序最后结束的线程？</h4><p>​ 可以使用Thread类的join()方法（或者CountDownLatch工具类）来确保所有程序创建的线程在main()方法退出前结束。</p><h4 id="41-为什么Thread类的sleep-和yield-方法是静态的？"><a href="#41-为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="41.为什么Thread类的sleep()和yield ()方法是静态的？"></a>41.为什么Thread类的sleep()和yield ()方法是静态的？</h4><p>​ Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><p>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</p><p>​ 可以用join方法实现。</p><h4 id="42-你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"><a href="#42-你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？" class="headerlink" title="42.你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"></a>42.你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</h4><p>​ volatile关键字，读写锁，写时复制等等都可以实现。</p><h4 id="43-用Java实现阻塞队列"><a href="#43-用Java实现阻塞队列" class="headerlink" title="43.用Java实现阻塞队列"></a>43.用Java实现阻塞队列</h4><p>​ 适用Lock或者synchronize，队列空的时候进行阻塞，有新的入队的时候唤醒阻塞。</p><h4 id="44-用Java写代码来解决生产者——消费者问题。"><a href="#44-用Java写代码来解决生产者——消费者问题。" class="headerlink" title="44.用Java写代码来解决生产者——消费者问题。"></a>44.用Java写代码来解决生产者——消费者问题。</h4><p>​ 阻塞队列实现即可，也可以用wait和notify来解决这个问题，或者用Semaphore</p><h4 id="45-用Java编程一个会导致死锁的程序，你将怎么解决？"><a href="#45-用Java编程一个会导致死锁的程序，你将怎么解决？" class="headerlink" title="45.用Java编程一个会导致死锁的程序，你将怎么解决？"></a>45.用Java编程一个会导致死锁的程序，你将怎么解决？</h4><blockquote><p>参照 JAVA中的死锁一章</p></blockquote><h4 id="46-Java中如何停止一个线程？"><a href="#46-Java中如何停止一个线程？" class="headerlink" title="46.Java中如何停止一个线程？"></a>46.Java中如何停止一个线程？</h4><ul><li><p>使用共享变量的方式</p><p>​ 在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p></li><li><p>使用interrupt方法终止线程</p><p>​ 如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。所以应该尽量使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态。</p></li></ul><h4 id="47-JVM中哪个参数是用来控制线程的栈堆栈大小的"><a href="#47-JVM中哪个参数是用来控制线程的栈堆栈大小的" class="headerlink" title="47.JVM中哪个参数是用来控制线程的栈堆栈大小的"></a>47.JVM中哪个参数是用来控制线程的栈堆栈大小的</h4><p><strong>-Xss</strong></p><h4 id="48-如果同步块内的线程抛出异常锁会释放吗？"><a href="#48-如果同步块内的线程抛出异常锁会释放吗？" class="headerlink" title="48.如果同步块内的线程抛出异常锁会释放吗？"></a>48.如果同步块内的线程抛出异常锁会释放吗？</h4><p><strong>会</strong></p><h4 id="49-单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？"><a href="#49-单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？" class="headerlink" title="49.单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？"></a>49.单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？</h4><p>​ 不安全的根本原因是重排序会导致未初始化完成的对象可以被其他线程看见而导致错误。创建安全的单例模式有：延迟占位模式、在声明的时候就new这个类的实例、枚举</p><h4 id="50-写出3条你遵循的多线程最佳实践"><a href="#50-写出3条你遵循的多线程最佳实践" class="headerlink" title="50.写出3条你遵循的多线程最佳实践"></a>50.写出3条你遵循的多线程最佳实践</h4><ul><li>给你的线程起个有意义的名字。 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</li><li>避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</li><li>多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li><li>多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。</li><li>比如并发编程的黄金原则，尽量无锁化编程等等……..</li></ul><h4 id="51-合理地配置线程池"><a href="#51-合理地配置线程池" class="headerlink" title="51.合理地配置线程池"></a>51.合理地配置线程池</h4><ul><li><p>CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。</p></li><li><p>IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。</p></li><li><p>混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>对于IO型的任务的最佳线程数，有个公式可以计算 Nthreads = NCPU * UCPU * (1 + W/C)</p></li></ul><h4 id="52-请概述锁的公平和非公平，JDK内部是如何实现的。"><a href="#52-请概述锁的公平和非公平，JDK内部是如何实现的。" class="headerlink" title="52.请概述锁的公平和非公平，JDK内部是如何实现的。"></a>52.请概述锁的公平和非公平，JDK内部是如何实现的。</h4><ul><li><p><strong>公平锁</strong>：是指所有试图获得锁的线程按照获取锁的顺序依次获得锁，而非公平锁则是当前的锁状态没有被占用时,当前线程可以直接占用,而不需要等待。在实现上，非公平锁逻辑基本跟公平锁一致，唯一的区别是，当前线程不需要判断同步队列中是否有等待线程。</p></li><li><p><strong>非公平锁</strong>：性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。</p></li></ul><p>​ 使用场景的话呢，其实还是和他们的属性一一相关，比如：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平锁其实效率并不明显，但是用公平锁可以保证不会有线程被饿死。</p><h4 id="53-请概述AQS"><a href="#53-请概述AQS" class="headerlink" title="53.请概述AQS"></a>53.请概述AQS</h4><p>​ 是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock和CountDownLatch就是基于AQS实现的。它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。它是CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。</p><p>​ AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如tryAcquire、tryReleaseShared等等。</p><p>​ 这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。</p><p>​ 在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。</p><p>同时与Condition相关的等待队列，节点类型也是Node，构成一个单向链表。</p><h4 id="54-请概述volatile"><a href="#54-请概述volatile" class="headerlink" title="54.请概述volatile"></a>54.请概述volatile</h4><p>volatile关键字的作用主要有两点：</p><p>​ 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。但是volatile不能保证操作的原子，对任意单个volatile变量的读/写具有原子性，但类似于++这种复合操作不具有原子性。。</p><p>​ 代码底层在执行时为了获取更好的性能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止重排序，当然这也一定程度上降低了代码执行效率。</p><p>​ 同时在内存语义上，当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存，当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>​ 在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序问题、强制刷新和读取。</p><p>​ 在具体实现上，volatile关键字修饰的变量会存在一个“lock:”的前缀。它不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。</p><p>​ 同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      并发面试题总结
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="面试题" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="面试题" scheme="http://www.baiyp.ren/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized锁优化</title>
    <link href="http://www.baiyp.ren/Synchronized%E9%94%81%E4%BC%98%E5%8C%96.html"/>
    <id>http://www.baiyp.ren/Synchronized锁优化.html</id>
    <published>2019-09-07T01:11:04.000Z</published>
    <updated>2019-09-07T10:04:05.963Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="Synchronized锁优化"><a href="#Synchronized锁优化" class="headerlink" title="Synchronized锁优化"></a>Synchronized锁优化</h2><blockquote><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。<br>锁主要存在四中状态，依次是：<strong>无锁</strong>-&gt; <strong>偏向锁</strong> -&gt; <strong>轻量级锁</strong> -&gt; <strong>重量级锁</strong>，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p></blockquote><p><img src="../images/thread/synchronized/synchronized010.png" alt></p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>​ 线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p><strong>何谓自旋锁？</strong><br>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋），和CAS类似。<br>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。<br>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；<br>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h4 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h4><p>​ JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>​ 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>​ 为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。<br>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">           vector.add(i + <span class="string">""</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(vector);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p><h6 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h6><p>如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行优化：</p><p>同步消除synchronization Elimination，如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>​ 我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。<br>​ 在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。<br>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如下面的例子，一个方法由两个加锁,因为num = x + y;耗时较短，对比两次锁短的多，就会锁粗化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 因为一个方法需要两个加锁解锁耗费资源</span></span><br><span class="line"><span class="comment">    * 对于  num = x + y; 耗费时间很短 就会将</span></span><br><span class="line"><span class="comment">    * 代码包裹进去组成一个锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lockCoarsening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           x++;</span><br><span class="line">           <span class="comment">//todo 处理部分业务</span></span><br><span class="line">       &#125;</span><br><span class="line">       num = x + y;</span><br><span class="line">       <span class="comment">//对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           y++;</span><br><span class="line">           <span class="comment">//todo 处理部分业务</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>粗化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用一个锁</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lockCoarsening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//只进行一次加锁解锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          x++;</span><br><span class="line">          <span class="comment">//todo 处理部分业务</span></span><br><span class="line">          num = x + y;</span><br><span class="line">          y++;</span><br><span class="line">          <span class="comment">//todo 处理部分业务</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>​ 引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p></blockquote><p><img src="../images/thread/synchronized/synchronized02.png" alt></p><h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h5><ol><li><p>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</p></li><li><p>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</p></li><li><p>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</p></li></ol><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><blockquote><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p></blockquote><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可</p></blockquote><p><img src="../images/thread/synchronized/synchronized03.png" alt></p><p>获取锁</p><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><p>释放锁<br>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>​ 重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p><blockquote><p>为什么重量级锁的开销比较大呢</p></blockquote><p>​ 原因是当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现，也就是相当于从用户态转化到内核态，而转化状态是需要消耗时间的</p><h4 id="三种锁的区别"><a href="#三种锁的区别" class="headerlink" title="三种锁的区别"></a>三种锁的区别</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要CAS，没有额外的性能消耗，和执行非同步方法相比，仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>只有一个线程访问同步块或者同步方法的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞提高响应速度</td><td>若线程长时间抢不到锁，自旋会消耗CPU性能</td><td>线程交替执行同步块或者同步方法的场景</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不消耗CPU</td><td>线程阻塞，响应时间缓慢,在多线程下,频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步块或者同步方法执行时间较长的场景</td></tr></tbody></table><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p><strong>偏向锁升级轻量级锁</strong>：当一个对象持有偏向锁，一旦第二个线程访问这个对象，如果产生竞争，偏向锁升级为轻量级锁。</p><p><strong>轻量级锁升级重量级锁</strong>：一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p><h3 id="wait和notify的原理"><a href="#wait和notify的原理" class="headerlink" title="wait和notify的原理"></a>wait和notify的原理</h3><blockquote><p>调用wait方法，首先会获取监视器锁，获得成功以后，会让当前线程进入等待状态进入等待队列并且释放锁。</p><p>当其他线程调用notify后，会选择从等待队列中唤醒任意一个线程，而执行完notify方法以后，并不会立马唤醒线程，原因是当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁。必须要等到当前的线程执行完按monitorexit指令以后，也就是锁被释放以后，处于等待队列中的线程就可以开始竞争锁了。</p></blockquote><p><strong>wait和notify为什么需要在synchronized里面？</strong></p><p>wait方法的语义有两个，<strong>一个是释放当前的对象锁、另一个是使得当前线程进入阻塞队列</strong>，而这些操作都和监视器是相关的，所以wait必须要获得一个监视器锁。</p><p>而对于notify来说也是一样，它是唤醒一个线程，既然要去唤醒，首先得知道它在哪里，所以就必须要找到这个对象获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Synchronized锁优化
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Synchronized" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/Synchronized/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Synchronized" scheme="http://www.baiyp.ren/tags/Synchronized/"/>
    
      <category term="锁优化" scheme="http://www.baiyp.ren/tags/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized实现原理</title>
    <link href="http://www.baiyp.ren/Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/Synchronized实现原理.html</id>
    <published>2019-09-07T01:11:04.000Z</published>
    <updated>2019-09-07T04:06:49.008Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="Synchronized实现原理"><a href="#Synchronized实现原理" class="headerlink" title="Synchronized实现原理"></a>Synchronized实现原理</h2><p><img src="../images/thread/synchronized/synchronized01.png" alt></p><h3 id="三种应用方式"><a href="#三种应用方式" class="headerlink" title="三种应用方式"></a>三种应用方式</h3><ol><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象。</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>被 synchronized 修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在 Java 中可以使用 synchronized 来保证方法和代码块内的操作是原子性的。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>synchronized 本身是无法禁止指令重排和处理器优化的，</p><p>as-if-serial 语义：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。</p><p>编译器和处理器无论如何优化，都必须遵守 as-if-serial 语义。</p><p>synchronized 修饰的代码，同一时间只能被同一线程执行。所以，可以保证其有序性。</p><h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p>​ 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性</p></blockquote><h4 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h4><p>​ synchronized同步块使用了monitorenter和monitorexit指令实现同步，这两个指令，本质上都是对一个对象的监视器(monitor)进行获取，这个过程是排他的，也就是说同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。</p><p>​ 线程执行到monitorenter指令时，会尝试获取对象所对应的monitor所有权，也就是尝试获取对象的锁，而执行monitorexit，就是释放monitor的所有权。</p><h4 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h4><p><strong>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</strong></p><p><strong>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量</strong></p><p><strong>所以锁的释放-获取和volatile的写-读具有相同的内存语义。volatile可以看过轻量级的锁，</strong></p><p>小结下：</p><ul><li>A释放锁 ，即 A向后来将拿锁的线程B发送一个消息</li><li>B拿锁，即B接收了之前释放锁的线程A的一个消息</li><li>A释放锁、B拿锁，其实就是A向B发送个消息。</li></ul><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ol><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ol><p>当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用javap工具查看生成的class文件信息来分析Synchronize的实现</p><p><img src="../images/thread/synchronized/synchronized09.jpg" alt></p><p>从上面可以看出，同步代码块是使用<strong>monitorenter</strong>和<strong>monitorexit</strong>指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。<br><strong>同步代码块</strong>：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；<br><strong>同步方法</strong>：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象</p><p>下面我们来继续分析，但是在深入之前我们需要了解两个重要的概念：Java对象头，Monitor。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><blockquote><p>在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头（Mark Word、Class Metadata Address）、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础。一般而言，synchronized使用的锁对象是存储在Java对象头里。它是轻量级锁和偏向锁的关键。</p></blockquote><p><img src="../images/thread/synchronized/synchronized05.jpg" alt></p><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><blockquote><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit）。</p></blockquote><p><img src="../images/thread/synchronized/synchronized04.png" alt></p><h5 id="Class-Metadata-Address"><a href="#Class-Metadata-Address" class="headerlink" title="Class Metadata Address"></a>Class Metadata Address</h5><blockquote><p>类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></blockquote><h5 id="Array-length"><a href="#Array-length" class="headerlink" title="Array length"></a>Array length</h5><blockquote><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p></blockquote><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><blockquote><p>我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：</p></blockquote><p><img src="../images/thread/synchronized/synchronized06.png" alt></p><ul><li><strong>Owner</strong>：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li><li><strong>EntryQ</strong>:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li><li><strong>RcThis</strong>:表示blocked或waiting在该monitor record上的所有线程的个数。</li><li><strong>Nest</strong>:用来实现重入锁的计数。</li><li><strong>HashCode</strong>:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li><li><strong>Candidate</strong>:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li></ul><p>在hotspot虚拟机中，通过ObjectMonitor类来实现monitor。</p><p><img src="../images/thread/synchronized/synchronized07.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Synchronized实现原理
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Synchronized" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/Synchronized/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="Synchronized" scheme="http://www.baiyp.ren/tags/Synchronized/"/>
    
      <category term="实现原理" scheme="http://www.baiyp.ren/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-02数据库连接池</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-02数据库连接池.html</id>
    <published>2019-09-04T08:58:57.000Z</published>
    <updated>2019-09-04T10:04:19.385Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS数据库连接池"><a href="#MYBATIS数据库连接池" class="headerlink" title="MYBATIS数据库连接池"></a>MYBATIS数据库连接池</h2><h3 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h3><p>​ 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><p>​ 在使用 Mybatis 的时候，数据库的连接一般都会使用第三方的数据源组件，如 C3P0，DBCP 和 Druid 等，其实 Mybatis 也有自己的数据源实现，可以连接数据库，还有连接池的功能，下面就来看看 Mybatis 自己实现的数据源头和连接池的一个实现原理。</p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>Mybatis 数据源的实现主要是在 datasource 包：</p><p><img src="../images/mybatis/pool01.jpg" alt></p><p>​ 我们常见的数据库连接池都需要实现javax.sql.DataSource接口mybatis提供了UnpooledDataSource和PooledDataSource的实现， 一个使用连接池，一个不使用连接池此外，对于这两个类，Mybatis 还提供了两个工厂类进行创建对象，是工厂方法模式的一个应用，首先来看下它们的一个类图：</p><p><img src="../images/mybatis/pool02.jpg" alt></p><p>我们先看下工厂类</p><h3 id="DataSourceFactory"><a href="#DataSourceFactory" class="headerlink" title="DataSourceFactory"></a>DataSourceFactory</h3><blockquote><p>数据源连接池工厂类接口</p></blockquote><p>该类是 JndiDataSourceFactory 和 UnpooledDataSourceFactory 两个工厂类的顶层接口，只定义了两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据源连接池 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数据源连接池</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnpooledDataSourceFactory"><a href="#UnpooledDataSourceFactory" class="headerlink" title="UnpooledDataSourceFactory"></a>UnpooledDataSourceFactory</h3><blockquote><p>UnpooledDataSourceFactory 主要用来创建 UnpooledDataSource 对象，它会在构造方法中初始化 UnpooledDataSource 对象，并在 setProperties 方法中完成对 UnpooledDataSource 对象的配置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnpooledDataSource 连接工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSourceFactory</span> <span class="keyword">implements</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数据库驱动前缀</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_PROPERTY_PREFIX = <span class="string">"driver."</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DRIVER_PROPERTY_PREFIX_LENGTH = DRIVER_PROPERTY_PREFIX.length();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应的数据源，即 UnpooledDataSource</span></span><br><span class="line">  <span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对数据源 UnpooledDataSource 进行配置</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据源属性文件</span></span><br><span class="line">    Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 创建 DataSource 相应的 MetaObject</span></span><br><span class="line">    MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">    <span class="comment">// 遍历 properties 集合，该集合中存放了数据源需要的信息</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : properties.keySet()) &#123;</span><br><span class="line">      String propertyName = (String) key;</span><br><span class="line">      <span class="comment">// 以 "driver." 开头的配置项是对 DataSource 的配置，记录到 driverProperties  中</span></span><br><span class="line">      <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">        String value = properties.getProperty(propertyName);</span><br><span class="line">        <span class="comment">//设置连接的属性和值</span></span><br><span class="line">        driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">        <span class="comment">// 该属性是否有 set 方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">        <span class="comment">// 获取对应的属性值</span></span><br><span class="line">        String value = (String) properties.get(propertyName);</span><br><span class="line">        <span class="comment">// 根据属性类型进行类型的转换，主要是 Integer, Long, Boolean 三种类型的转换</span></span><br><span class="line">        Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">        <span class="comment">// 设置DataSource 的相关属性值</span></span><br><span class="line">        metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">"Unknown DataSource property: "</span> + propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 DataSource.driverProerties 属性值</span></span><br><span class="line">    <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      metaDataSource.setValue(<span class="string">"driverProperties"</span>, driverProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回数据源</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型转</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">convertValue</span><span class="params">(MetaObject metaDataSource, String propertyName, String value)</span> </span>&#123;</span><br><span class="line">    Object convertedValue = value;</span><br><span class="line">    Class&lt;?&gt; targetType = metaDataSource.getSetterType(propertyName);</span><br><span class="line">    <span class="keyword">if</span> (targetType == Integer.class || targetType == <span class="keyword">int</span>.class) &#123;</span><br><span class="line">      convertedValue = Integer.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Long.class || targetType == <span class="keyword">long</span>.class) &#123;</span><br><span class="line">      convertedValue = Long.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Boolean.class || targetType == <span class="keyword">boolean</span>.class) &#123;</span><br><span class="line">      convertedValue = Boolean.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> convertedValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JndiDataSourceFactory 依赖 JNDI 服务器中获取用户配置的 DataSource，这里可以不看。</p></blockquote><p>UnpooledDataSourceFactory工厂类主要的作用是对数据源进行配置。</p><h3 id="PooledDataSourceFactory"><a href="#PooledDataSourceFactory" class="headerlink" title="PooledDataSourceFactory"></a>PooledDataSourceFactory</h3><blockquote><p>PooledDataSourceFactory 主要用来创建 PooledDataSource 对象，它继承了 UnpooledDataSource 类，设置 DataSource 参数的方法复用UnpooledDataSource 中的 setProperties 方法，只是数据源返回的是 PooledDataSource 对象而已。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceFactory</span> <span class="keyword">extends</span> <span class="title">UnpooledDataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建连接池对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上这些就是 Mybatis 用来创建数据源的工厂类，下面就来看下数据源的主要实现。</p></blockquote><h3 id="UnpooledDataSource"><a href="#UnpooledDataSource" class="headerlink" title="UnpooledDataSource"></a>UnpooledDataSource</h3><blockquote><p>UnpooledDataSource 不使用连接池来创建数据库连接，每次获取数据库连接时都会创建一个新的连接进行返回；</p></blockquote><h4 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h4><blockquote><p>在static静态块中进行驱动注册</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未使用连接池的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 加载 Driver 类的类加载器</span></span><br><span class="line">  <span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line">  <span class="comment">// 数据库连接驱动的相关配置</span></span><br><span class="line">  <span class="keyword">private</span> Properties driverProperties;</span><br><span class="line">  <span class="comment">// 缓存所有已注册的数据库连接驱动</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//数据源配置相关</span></span><br><span class="line">  <span class="keyword">private</span> String driver;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="comment">// 是否自动提交</span></span><br><span class="line">  <span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line">  <span class="comment">//默认事务隔离级别</span></span><br><span class="line">  <span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line">  <span class="comment">//默认超时时间</span></span><br><span class="line">  <span class="keyword">private</span> Integer defaultNetworkTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  静态块，在初始化的时候，从 DriverManager 中获取所有的已注册的驱动信息，并缓存到该类的 registeredDrivers集合中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//获取驱动信息</span></span><br><span class="line">    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();</span><br><span class="line">    <span class="keyword">while</span> (drivers.hasMoreElements()) &#123;</span><br><span class="line">      Driver driver = drivers.nextElement();</span><br><span class="line">      <span class="comment">//注册进集合中</span></span><br><span class="line">      registeredDrivers.put(driver.getClass().getName(), driver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 无参构造</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, Properties driverProperties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.driverProperties = driverProperties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取一个连接"><a href="#获取一个连接" class="headerlink" title="获取一个连接"></a>获取一个连接</h4><blockquote><p>这里面没有提供连接销毁的方法，在连接池中有销毁连接的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 获取一个连接</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@return</span> 连接对象</span><br><span class="line"> * <span class="meta">@throws</span> SQLException</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个数据库连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">if</span> (driverProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.putAll(driverProperties);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置用户</span></span><br><span class="line">  <span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置密码</span></span><br><span class="line">  <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个连接对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> properties 数据库属性文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数据库连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//初始化驱动信息</span></span><br><span class="line">  initializeDriver();</span><br><span class="line">  <span class="comment">// 通过 DriverManager 来获取一个数据库连接</span></span><br><span class="line">  Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">  <span class="comment">//配置连接信息</span></span><br><span class="line">  configureConnection(connection);</span><br><span class="line">  <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化驱动信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前的驱动还没有注册，则进行注册</span></span><br><span class="line">  <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">    Class&lt;?&gt; driverType;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//驱动的类加载器不为空</span></span><br><span class="line">      <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取驱动类型</span></span><br><span class="line">        driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driverType = Resources.classForName(driver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// DriverManager requires the driver to be loaded via the system ClassLoader.</span></span><br><span class="line">      <span class="comment">// http://www.kfu.com/~nsayer/Java/dyn-jdbc.html</span></span><br><span class="line">      <span class="comment">//创建驱动</span></span><br><span class="line">      Driver driverInstance = (Driver) driverType.newInstance();</span><br><span class="line">      <span class="comment">//向JDBC注册驱动</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">      <span class="comment">//向registeredDrivers注册驱动</span></span><br><span class="line">      registeredDrivers.put(driver, driverInstance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error setting driver on UnpooledDataSource. Cause: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置数据库连接信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureConnection</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//设置超时时间</span></span><br><span class="line">  <span class="keyword">if</span> (defaultNetworkTimeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conn.setNetworkTimeout(Executors.newSingleThreadExecutor(), defaultNetworkTimeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置是否自动提交</span></span><br><span class="line">  <span class="keyword">if</span> (autoCommit != <span class="keyword">null</span> &amp;&amp; autoCommit != conn.getAutoCommit()) &#123;</span><br><span class="line">    conn.setAutoCommit(autoCommit);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置事务隔离等级</span></span><br><span class="line">  <span class="keyword">if</span> (defaultTransactionIsolationLevel != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conn.setTransactionIsolation(defaultTransactionIsolationLevel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 以上代码就是 UnpooledDataSource 类的主要实现逻辑，每次获取连接都是从数据库新创建一个连接进行返回，又因为，数据库连接的创建是一个耗时的操作，且数据库连接是非常珍贵的资源，如果每次获取连接都创建一个，则可能会造成系统的瓶颈，拖垮响应速度等，这时就需要数据库连接池了，Mybatis 也提供了自己数据库连接池的实现，就是 PooledDataSource 类。</p><h3 id="PooledDataSource"><a href="#PooledDataSource" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><blockquote><p>PooledDataSource 是一个比较复杂的类，PooledDataSource 新创建数据库连接是使用 UnpooledDataSource 来实现的，且 PooledDataSource 并不会管理 java.sql.Connection 对象，而是管理 PooledConnection 对象，在 PooledConnection 中封装了真正的数据库连接对象和其代理对象；此外，由于它是一个连接池，所以还需要管理连接池的状态，比如有多少连接是空闲的，还可以创建多少连接，此时，就需要一个类来管理连接池的对象，即 PoolState 对象；先来看下 PooledDataSource 的一个 UML 图：</p></blockquote><p><img src="../images/mybatis/pool03.jpg" alt></p><h3 id="PooledConnection"><a href="#PooledConnection" class="headerlink" title="PooledConnection"></a>PooledConnection</h3><blockquote><p>它主要是用来管理数据库连接的，它是一个代理类，实现了 InvocationHandler 接口</p></blockquote><h4 id="主体方法"><a href="#主体方法" class="headerlink" title="主体方法"></a>主体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis 连接池对象 使用的是 动态代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledConnection</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//关闭方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOSE = <span class="string">"close"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IFACES = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Connection.class&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">  <span class="comment">// 记录当前的 PooledConnection 对象所在的 PooledDataSource 对象，该 PooledConnection 对象是从 PooledDataSource 对象中获取的，当调用 close 方法时会将 PooledConnection 放回该 PooledDataSource 中去</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PooledDataSource dataSource;</span><br><span class="line">  <span class="comment">//真实连接</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection realConnection;</span><br><span class="line">  <span class="comment">// 数据库连接的代理对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line">  <span class="comment">// 从连接池中取出该连接的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp;</span><br><span class="line">  <span class="comment">// 该连接创建的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp;</span><br><span class="line">  <span class="comment">// 该连接最后一次被使用的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp;</span><br><span class="line">  <span class="comment">// 用于标识该连接所在的连接池，由URL+username+password 计算出来的hash值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> connectionTypeCode;</span><br><span class="line">  <span class="comment">// 该连接是否有效</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in.</span></span><br><span class="line"><span class="comment">   * 创建连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> connection - the connection that is to be presented as a pooled connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource - the dataSource that the connection is from</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledConnection</span><span class="params">(Connection connection, PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashCode = connection.hashCode();</span><br><span class="line">    <span class="keyword">this</span>.realConnection = connection;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.createdTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.lastUsedTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invalidates the connection.</span></span><br><span class="line"><span class="comment">   *   废弃该连接 设置连接未不可用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    valid = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Method to see if the connection is usable.</span></span><br><span class="line"><span class="comment">   * 检查连接是否可用 连接可用并且能够被ping，</span></span><br><span class="line"><span class="comment">   *   1.判断 valid 字段</span></span><br><span class="line"><span class="comment">   *   2.向数据库中发送检测测试的SQL，查看真正的连接还是否有效</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> True if the connection is usable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> valid &amp;&amp; realConnection != <span class="keyword">null</span> &amp;&amp; dataSource.pingConnection(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error accessing PooledConnection. Connection is invalid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invok代理方法"><a href="#invok代理方法" class="headerlink" title="invok代理方法"></a>invok代理方法</h4><blockquote><p>该方法是 proxyConnection 这个连接代理对象的真正代理逻辑，它会对 close 方法进行代理，并且在调用真正的连接之前对连接进行检测。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Required for InvocationHandler implementation.</span></span><br><span class="line"><span class="comment">   * 动态代理的入口方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy  - not used</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method - the method to be executed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args   - the parameters to be passed to the method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="comment">//如果关闭连接 将当前连接放回连接池 资源复用</span></span><br><span class="line">    <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">      dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//不是Object对象的一些方法例如 toString等方法</span></span><br><span class="line">      <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">        <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">        <span class="comment">// 执行之前，需要进行连接的检测</span></span><br><span class="line">        checkConnection();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用数据库真正的连接进行执行</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="PoolState"><a href="#PoolState" class="headerlink" title="PoolState"></a>PoolState</h3><blockquote><p>PoolState 类主要是用来管理连接池的状态，比如哪些连接是空闲的，哪些是活动的，还可以创建多少连接等。该类中只是定义了一些属性来进行控制连接池的状态，并没有任何的方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolState</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 该 PoolState 属于哪个 PooledDataSource</span></span><br><span class="line">  <span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line">  <span class="comment">// 来用存放空闲的 pooledConnection 连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 用来存放活跃的 PooledConnection 连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 请求数据库连接的次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 请求数据库连接的次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// checkoutTime 表示从连接池中获取连接到归还连接的时间</span></span><br><span class="line">  <span class="comment">// accumulatedCheckoutTime 记录了所有连接的累计 checkoutTime 时长</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 连接超时的连接个数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 累计超时时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 累计等待时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 等待次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 无效的连接数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PoolState</span><span class="params">(PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PooledDataSource-1"><a href="#PooledDataSource-1" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><blockquote><p>终于等来了我们的主角，PooledDataSource 它是一个简单的，同步的，线程安全的数据库连接池</p></blockquote><p>​ 知道了 UnpooledDataSource 用来创建数据库新的连接，PooledConnection 用来管理连接池中的连接，PoolState 用来管理连接池的状态之后，来看下 PooledDataSource 的一个逻辑，该类中主要有以下几个方法：获取数据库连接的方法 popConnection，把连接放回连接池的方法 pushConnection，检测数据库连接是否有效的方法 pingConnection ，还有 关闭连接池中所有连接的方法 forceCloseAll</p><h4 id="主体方法-1"><a href="#主体方法-1" class="headerlink" title="主体方法"></a>主体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a simple, synchronous, thread-safe database connection pool.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 简单的 带有锁的 线程安全的 数据库连接池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(PooledDataSource.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据库连接池状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来创建真正的数据库连接对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OPTIONAL CONFIGURATION FIELDS</span></span><br><span class="line">  <span class="comment">// 最大活跃的连接数，默认为 10</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 最大空闲连接数，默认为 5</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// 最大获取连接的时长</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line">  <span class="comment">// 在无法获取到连接时，最大等待的时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line">  <span class="comment">//脸是失败重试次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 在检测一个连接是否可用时，会向数据库发送一个测试 SQL</span></span><br><span class="line">  <span class="keyword">protected</span> String poolPingQuery = <span class="string">"NO PING QUERY SET"</span>;</span><br><span class="line">  <span class="comment">//是否启动连接池ping</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line">  <span class="comment">// 当连接超过 poolPingConnectionsNotUsedFor 毫秒未使用时，会发送一次测试 SQL 语句，测试连接是否正常</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line">  <span class="comment">// 标志着当前的连接池，是 url+username+password 的 hash 值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建连接池</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(UnpooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  生成 连接的hash 值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">assembleConnectionTypeCode</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">""</span> + url + username + password).hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h4><blockquote><p>从 连接池中获取连接的方法主要是在 popConnection 中实现的，先来看下它的一个流程图：</p></blockquote><p><img src="../images/mybatis/pool04.jpg" alt></p><p>代码逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> popConnection(username, password).getProxyConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从连接池中获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待个数</span></span><br><span class="line">    <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// PooledConnection 对象</span></span><br><span class="line">    PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//耗时计算</span></span><br><span class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 无效的连接个数</span></span><br><span class="line">    <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        <span class="comment">// 检测是否还有空闲的连接</span></span><br><span class="line">        <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// Pool has available connection</span></span><br><span class="line">          <span class="comment">// 连接池中还有空闲的连接，则直接获取连接返回</span></span><br><span class="line">          conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Checked out connection "</span> + conn.getRealHashCode() + <span class="string">" from pool."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 连接池中已经没有空闲连接了</span></span><br><span class="line">          <span class="comment">// Pool does not have available connection</span></span><br><span class="line">          <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">            <span class="comment">// Can create new connection</span></span><br><span class="line">            <span class="comment">// 活跃的连接数没有达到最大值，则创建一个新的数据库连接</span></span><br><span class="line">            conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">"Created connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Cannot create new connection</span></span><br><span class="line">            <span class="comment">// 如果活跃的连接数已经达到允许的最大值了，则不能创建新的数据库连接</span></span><br><span class="line">            <span class="comment">// 获取最先创建的那个活跃的连接</span></span><br><span class="line">            PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">            <span class="comment">// 检测该连接是否超时</span></span><br><span class="line">            <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">              <span class="comment">// 如果该连接超时，则进行相应的统计</span></span><br><span class="line">              <span class="comment">// Can claim overdue connection</span></span><br><span class="line">              <span class="comment">//超时连接个数统计</span></span><br><span class="line">              state.claimedOverdueConnectionCount++;</span><br><span class="line">              <span class="comment">//统计过期的连接超时时间</span></span><br><span class="line">              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">              <span class="comment">//统计超时时间</span></span><br><span class="line">              state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">              <span class="comment">// 将超时连接移出 activeConnections 集合</span></span><br><span class="line">              state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">              <span class="comment">//如果没有设置自动提交</span></span><br><span class="line">              <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果超时未提交，则自动回滚</span></span><br><span class="line">                  oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     Just log a message for debug and continue to execute the following</span></span><br><span class="line"><span class="comment">                     statement like nothing happened.</span></span><br><span class="line"><span class="comment">                     Wrap the bad connection with a new PooledConnection, this will help</span></span><br><span class="line"><span class="comment">                     to not interrupt current executing thread and give current thread a</span></span><br><span class="line"><span class="comment">                     chance to join the next competition for another valid/good database</span></span><br><span class="line"><span class="comment">                     connection. At the end of this loop, bad &#123;@link @conn&#125; will be set as null.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  log.debug(<span class="string">"Bad connection. Could not roll back"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 创建新的 PooledConnection 对象，但是真正的数据库连接并没有创建</span></span><br><span class="line">              <span class="comment">//刚刚获取的真实连接 新瓶装旧酒</span></span><br><span class="line">              conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">//设置创建时间</span></span><br><span class="line">              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">              <span class="comment">//设置最后使用时间</span></span><br><span class="line">              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">              <span class="comment">// 设置该超时的旧的连接为无效</span></span><br><span class="line">              oldestActiveConnection.invalidate();</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"Claimed overdue connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果第一个连接还没有超时，说明其他的都没有超时，只能等待了</span></span><br><span class="line">              <span class="comment">// Must wait</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等待个数统计</span></span><br><span class="line">                <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                  <span class="comment">//等待计数</span></span><br><span class="line">                  state.hadToWaitCount++;</span><br><span class="line">                  <span class="comment">//下次不进行计数</span></span><br><span class="line">                  countedWait = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                  log.debug(<span class="string">"Waiting as long as "</span> + poolTimeToWait + <span class="string">" milliseconds for connection."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//超时等待 阻塞等待</span></span><br><span class="line">                state.wait(poolTimeToWait);</span><br><span class="line">                <span class="comment">//统计等待的时长</span></span><br><span class="line">                state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//异常退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经获取到连接，如果连接不为空</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// ping to server and check the connection is valid or not</span></span><br><span class="line">          <span class="comment">//连接状态可用</span></span><br><span class="line">          <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">            <span class="comment">// 如果连连接有效，事务未提交则回滚</span></span><br><span class="line">            <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">              <span class="comment">//进行回滚 恢复到最初状态</span></span><br><span class="line">              conn.getRealConnection().rollback();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置连接类型</span></span><br><span class="line">            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">            <span class="comment">//设置检查超时的时间</span></span><br><span class="line">            conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">//设置最后使用时间</span></span><br><span class="line">            conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">// 把连接加入到活跃集合中去</span></span><br><span class="line">            state.activeConnections.add(conn);</span><br><span class="line">            <span class="comment">//统计请求计数</span></span><br><span class="line">            state.requestCount++;</span><br><span class="line">            <span class="comment">//统计请求时长</span></span><br><span class="line">            state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果验证连接失败</span></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") was returned from the pool, getting another connection."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//统计错误连接个数</span></span><br><span class="line">            state.badConnectionCount++;</span><br><span class="line">            localBadConnectionCount++;</span><br><span class="line">            <span class="comment">//连接置为null 进行GC</span></span><br><span class="line">            conn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//无效连接个数 &gt; 最大空闲连接数 + 失败尝试次数</span></span><br><span class="line">            <span class="comment">//大部分无效连接，可以停止服务了</span></span><br><span class="line">            <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//抛异常 因为获取的都是不可用的连接</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果连接还未空</span></span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回连接</span></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上就是从连接池获取连接的主要逻辑。</p><h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><blockquote><p>把连接放入的连接池中以供下次重新使用，把连接放入到连接池中的方法为 pushConnection 方法,它也是 PooledDataSource 类的一个主要方法。</p></blockquote><p><img src="../images/mybatis/pool05.jpg" alt></p><p>代码逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  把不用的连接放入到连接池中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 首先从活跃的集合中移除掉该连接</span></span><br><span class="line">    state.activeConnections.remove(conn);</span><br><span class="line">    <span class="comment">//验证连接是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">      <span class="comment">// 如果空闲连接数没有达到最大值，且 PooledConnection 为该连接池的连接</span></span><br><span class="line">      <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">        <span class="comment">//验证超时时间汇总</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">//如果没有自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//进行回滚</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据真实连接创建一个新的池化的连接 真是链接还用当前的连接</span></span><br><span class="line">        PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//添加到空闲连接</span></span><br><span class="line">        state.idleConnections.add(newConn);</span><br><span class="line">        <span class="comment">//设置创建时间</span></span><br><span class="line">        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">        <span class="comment">//设置最后使用时间</span></span><br><span class="line">        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">        <span class="comment">//设置原来的连接为无效</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">"Returned connection "</span> + newConn.getRealHashCode() + <span class="string">" to pool."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒阻塞等待的线程</span></span><br><span class="line">        state.notifyAll();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空闲连接数已经达到最大值</span></span><br><span class="line">        <span class="comment">//计算超时时间汇总</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">//未设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//回滚</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真正的数据库连接</span></span><br><span class="line">        conn.getRealConnection().close();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">"Closed connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置该连接为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果连接状态失败</span></span><br><span class="line">      <span class="comment">//打印日志</span></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") attempted to return to the pool, discarding connection."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无效连接个数加1</span></span><br><span class="line">      state.badConnectionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是把不用的连接放入到连接池中以供下次使用，</p><p>在上面两个方法中，都调用了 isValid 方法来检测连接是否可用。</p><h4 id="检查连接"><a href="#检查连接" class="headerlink" title="检查连接"></a>检查连接</h4><blockquote><p>该方法除了检测 valid 字段外，还会调用 pingConnection 方法来尝试让数据库执行测试 SQL 语句，从而检测真正的数据库连接对象是否依然正常可用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method to check to see if a connection is still usable</span></span><br><span class="line"><span class="comment"> *   向数据库发送测试 SQL 来检测真正的数据库连接是否可用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn - the connection to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the connection is still usable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">pingConnection</span><span class="params">(PooledConnection conn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 结果</span></span><br><span class="line">  <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 检测真正的数据库连接是否已经关闭</span></span><br><span class="line">    result = !conn.getRealConnection().isClosed();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果真正的数据库连接还没关闭</span></span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 是否执行测试 SQL 语句</span></span><br><span class="line">    <span class="keyword">if</span> (poolPingEnabled) &#123;</span><br><span class="line">      <span class="comment">// 长时间（poolPingConnectionsNotUsedFor 指定的时长）未使用的连接，才需要ping操作来检测连接是否正常</span></span><br><span class="line">      <span class="keyword">if</span> (poolPingConnectionsNotUsedFor &gt;= <span class="number">0</span> &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Testing connection "</span> + conn.getRealHashCode() + <span class="string">" ..."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 发送测试 SQL 语句执行</span></span><br><span class="line">          Connection realConn = conn.getRealConnection();</span><br><span class="line">          <span class="keyword">try</span> (Statement statement = realConn.createStatement()) &#123;</span><br><span class="line">            statement.executeQuery(poolPingQuery).close();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//回滚</span></span><br><span class="line">          <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">            realConn.rollback();</span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is GOOD!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(<span class="string">"Execution of ping query '"</span> + poolPingQuery + <span class="string">"' failed: "</span> + e.getMessage());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//关闭真实连接</span></span><br><span class="line">            conn.getRealConnection().close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">            <span class="comment">//ignore</span></span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭所有连接"><a href="#关闭所有连接" class="headerlink" title="关闭所有连接"></a>关闭所有连接</h4><blockquote><p>当修改 PooledDataSource 相应的字段，如 数据库的 URL，用户名或密码等，需要将连接池中连接全部关闭，之后获取连接的时候从重新初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes all active and idle connections in the pool.</span></span><br><span class="line"><span class="comment"> * 关闭所有的活动以及空闲连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">    <span class="comment">//遍历关闭活动的连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置连接为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="comment">//获取真实连接</span></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="comment">//是否设置了自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//否则进行回滚，保证数据一致性</span></span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真实连接</span></span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历关闭空闲的连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="comment">//获取真实连接</span></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="comment">//如果没有设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//进行数据回滚</span></span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真实的链接</span></span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">"PooledDataSource forcefully closed/removed all connections."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在连接池中提到了 连接池中的最大连接数和最大空闲数，在 获取连接和把连接放入连接池中都有判断，</p><ol><li><p>获取连接：首先从连接池中进行获取，如果连接池中已经没有空闲的连接了，则会判断当前的活跃连接数是否已经达到允许的最大值了，如果没有，则还可以创建新的连接，之后把它放到活跃的集合中进行使用，如果当前活跃的已达到最大值，则阻塞。</p></li><li><p>返还连接到连接池，在返还连接的时候，进行判断，如果空闲连接数已达到允许的最大值，则直接关闭真正的数据库连接，否则把该连接放入到空闲集合中以供下次使用。</p></li></ol><p>Mybatis 数据源中，主要的代码逻辑还是在连接池类 PooledDataSource 中，对于获取连接的方法 popConnection，返还连接的方法 pushConnection ，需要结合上图来看，才能看得清楚。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis数据库连接池
    
    </summary>
    
      <category term="MYBATIS" scheme="http://www.baiyp.ren/categories/MYBATIS/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/MYBATIS/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据库连接池" scheme="http://www.baiyp.ren/categories/MYBATIS/%E6%BA%90%E7%A0%81/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="MYBATIS" scheme="http://www.baiyp.ren/tags/MYBATIS/"/>
    
      <category term="数据库连接池" scheme="http://www.baiyp.ren/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-01日志模块</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-01日志模块.html</id>
    <published>2019-09-04T06:58:57.000Z</published>
    <updated>2019-09-04T08:28:04.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS日志模块解析"><a href="#MYBATIS日志模块解析" class="headerlink" title="MYBATIS日志模块解析"></a>MYBATIS日志模块解析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​ mybatis 没有提供日志的实现类，需要接入第三方的日志组件，但第三方日志组件都有各自的Log级别，且各不相同。而Mybatis统一提供了trace/ debug/ warn/ error四个级别，mybatis使用适配器模式进行日志加载，我们来欣赏下mybatis源码的魅力。</p><h3 id="日志接口Log"><a href="#日志接口Log" class="headerlink" title="日志接口Log"></a>日志接口Log</h3><blockquote><p>mybatis 封装了统一的日志接口，其他日志接口接入需要实现该日志接口。</p><p>该接口只提供了trace/ debug/ warn/ error四个级别的日志输出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * mybatis log日志接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="comment">//是否启动debug</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否启动Trace</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//error日志级别</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志工厂LogFactory"><a href="#日志工厂LogFactory" class="headerlink" title="日志工厂LogFactory"></a>日志工厂LogFactory</h3><blockquote><p>在这里定义了日志框架的加载顺序</p><p>slf4j -&gt; commonsLoging -&gt; Log4J2 -&gt; Log4J -&gt; JdkLog</p><p>使得日志框架优雅的嵌入到mybatis中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis log 工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Marker to be used by logging implementations that support markers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MARKER = <span class="string">"MYBATIS"</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 记录正在使用的是那个日志框架的构造方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 顺序尝试找到一个可用的日志框架</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * :: 双冒号运算符就是java中的方法引用 方法引用的格式是 类名::方法名。</span></span><br><span class="line"><span class="comment">   * person -&gt;person.getAge(); 可以替换为 Person::getAge</span></span><br><span class="line"><span class="comment">   * （）-&gt; new HashMap&lt;&gt;(); 可以替换为 HashMap::new</span></span><br><span class="line"><span class="comment">   * 双冒号操作符返回的是一个接口的匿名实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="comment">//尝试使用某一种日志框架 第一个不成功到第二个 一直找到一个合适的</span></span><br><span class="line">    tryImplementation(LogFactory::useSlf4jLogging);</span><br><span class="line">    tryImplementation(LogFactory::useCommonsLogging);</span><br><span class="line">    tryImplementation(LogFactory::useLog4J2Logging);</span><br><span class="line">    tryImplementation(LogFactory::useLog4JLogging);</span><br><span class="line">    tryImplementation(LogFactory::useJdkLogging);</span><br><span class="line">    tryImplementation(LogFactory::useNoLogging);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// disable construction</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回具体实现的实现类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> aClass</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回具体实现的接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> logger 具体需要日志的 类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(String logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//使用当前可用的构造方法进行创建对象</span></span><br><span class="line">      <span class="keyword">return</span> logConstructor.newInstance(logger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">"Error creating logger for logger "</span> + logger + <span class="string">".  Cause: "</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useCustomLogging</span><span class="params">(Class&lt;? extends Log&gt; clazz)</span> </span>&#123;</span><br><span class="line">    setImplementation(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useSlf4jLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useCommonsLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useLog4JLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.log4j.Log4jImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useLog4J2Logging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.log4j2.Log4j2Impl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useJdkLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useStdOutLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.stdout.StdOutImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useNoLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.nologging.NoLoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 咋一看好像是多线程</span></span><br><span class="line"><span class="comment">   * 其实不然，只用用了下Runnable接口的钩子方法</span></span><br><span class="line"><span class="comment">   * 不用再自定义接口内部类实现了，用现成的Runnable接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryImplementation</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果构造方法为空就调用匿名内部类</span></span><br><span class="line">    <span class="keyword">if</span> (logConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用具体接口的方法</span></span><br><span class="line">        runnable.run();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置日志实现类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> implClass</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImplementation</span><span class="params">(Class&lt;? extends Log&gt; implClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取具体实现类的构造方法</span></span><br><span class="line">      Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);</span><br><span class="line">      <span class="comment">//创建一个实现类 并打印日志</span></span><br><span class="line">      Log log = candidate.newInstance(LogFactory.class.getName());</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"Logging initialized using '"</span> + implClass + <span class="string">"' adapter."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置否则方法为当前可用构造方法</span></span><br><span class="line">      logConstructor = candidate;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">"Error setting Log implementation.  Cause: "</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里是整个日志的加载顺序，尝试找到一个可用的构造方法，找到后返回该日志框架的实例。</p><p>这里面用到了Runable接口的钩子方法，也可以叫做接口回调，并没有使用多线程编程。</p><h3 id="日志系统转换"><a href="#日志系统转换" class="headerlink" title="日志系统转换"></a>日志系统转换</h3><blockquote><p>这里采用了很多日志框架，使用了适配器模式进行日志的转换，装饰着模式可以查看我的设计模式一节</p><p>这里我们就拿比较负责的sl4j来查看源码</p></blockquote><p><img src="../images/mybatis%5Cmybatis_log01.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式 Sl4j 实现类</span></span><br><span class="line"><span class="comment"> * 实现Log 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前类的实现类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Log log;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法 初始化 log</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> clazz 需要打印日志的类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Slf4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//logger的方式创建日志类</span></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(clazz);</span><br><span class="line">    <span class="comment">//如果返回的是 LocationAwareLogger 对象</span></span><br><span class="line">    <span class="keyword">if</span> (logger <span class="keyword">instanceof</span> LocationAwareLogger) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check for slf4j &gt;= 1.6 method signature</span></span><br><span class="line">        <span class="comment">//检查sl4j 版本是否&gt;=1.6</span></span><br><span class="line">        logger.getClass().getMethod(<span class="string">"log"</span>, Marker.class, String.class, <span class="keyword">int</span>.class, String.class, Object[].class, Throwable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 Slf4jLocationAwareLoggerImpl 实例</span></span><br><span class="line">        log = <span class="keyword">new</span> Slf4jLocationAwareLoggerImpl((LocationAwareLogger) logger);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SecurityException | NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="comment">// fail-back to Slf4jLoggerImpl</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Logger is not LocationAwareLogger or slf4j version &lt; 1.6</span></span><br><span class="line">    <span class="comment">//sl4j 版本小于1.6 使用Slf4jLoggerImpl</span></span><br><span class="line">    log = <span class="keyword">new</span> Slf4jLoggerImpl(logger);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.error(s, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.error(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.trace(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.warn(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意下Slf4j版本控制，如果Slf4j版本&gt;=1.6 使用 Slf4jLocationAwareLoggerImpl 否则使用Slf4jLoggerImpl</p><p>我们再拿Slf4jLoggerImpl看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slf4jLoggerImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Slf4jLoggerImpl</span><span class="params">(Logger logger)</span> </span>&#123;</span><br><span class="line">    log = logger;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.error(s, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.error(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.trace(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.warn(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就是mybatis日志框架的优雅封装实现，通过依次尝试加载，使用适配器模式进行日志接口的统一</p><h3 id="JDBC日志增强"><a href="#JDBC日志增强" class="headerlink" title="JDBC日志增强"></a>JDBC日志增强</h3><h4 id="JDBC模板类BaseJdbcLogger"><a href="#JDBC模板类BaseJdbcLogger" class="headerlink" title="JDBC模板类BaseJdbcLogger"></a>JDBC模板类BaseJdbcLogger</h4><blockquote><p>BaseJdbcLogger初始化了日志框架Log，SET_METHODS和jdbc执行方法列表EXECUTE_METHODS</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for proxies to do logging.</span></span><br><span class="line"><span class="comment"> * 基类 JDBC操作日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJdbcLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; SET_METHODS;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; EXECUTE_METHODS = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; columnMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; columnNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; columnValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Log statementLog;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> queryStack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Default constructor</span></span><br><span class="line"><span class="comment">   * 默认构造方法，将日志接口以及查询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BaseJdbcLogger</span><span class="params">(Log log, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.statementLog = log;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.queryStack = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.queryStack = queryStack;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Set方法设置进SET_METHODS</span></span><br><span class="line">    SET_METHODS = Arrays.stream(PreparedStatement.class.getDeclaredMethods())</span><br><span class="line">            .filter(method -&gt; method.getName().startsWith(<span class="string">"set"</span>))</span><br><span class="line">            .filter(method -&gt; method.getParameterCount() &gt; <span class="number">1</span>)</span><br><span class="line">            .map(Method::getName)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">//添加执行方法</span></span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"execute"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"executeUpdate"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"executeQuery"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"addBatch"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setColumn</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    columnMap.put(key, value);</span><br><span class="line">    columnNames.add(key);</span><br><span class="line">    columnValues.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">getColumn</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> columnMap.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取参数值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getParameterValueString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(columnValues.size());</span><br><span class="line">    <span class="keyword">for</span> (Object value : columnValues) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        typeList.add(<span class="string">"null"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        typeList.add(objectValueString(value) + <span class="string">"("</span> + value.getClass().getSimpleName() + <span class="string">")"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String parameters = typeList.toString();</span><br><span class="line">    <span class="keyword">return</span> parameters.substring(<span class="number">1</span>, parameters.length() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将Object转换为String</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">objectValueString</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Array) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ArrayUtil.toString(((Array) value).getArray());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取参数名称列表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getColumnString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> columnNames.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空参数map</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearColumnInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    columnMap.clear();</span><br><span class="line">    columnNames.clear();</span><br><span class="line">    columnValues.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清除换行符以及制表符</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> original</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">removeBreakingWhitespace</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    StringTokenizer whitespaceStripper = <span class="keyword">new</span> StringTokenizer(original);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (whitespaceStripper.hasMoreTokens()) &#123;</span><br><span class="line">      builder.append(whitespaceStripper.nextToken());</span><br><span class="line">      builder.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否启用debug</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementLog.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否启用Trace</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementLog.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 日志打印</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> input</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String text, <span class="keyword">boolean</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (statementLog.isDebugEnabled()) &#123;</span><br><span class="line">      statementLog.debug(prefix(input) + text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String text, <span class="keyword">boolean</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (statementLog.isTraceEnabled()) &#123;</span><br><span class="line">      statementLog.trace(prefix(input) + text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取输出的前缀</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> isInput</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">prefix</span><span class="params">(<span class="keyword">boolean</span> isInput)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[queryStack * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">    Arrays.fill(buffer, <span class="string">'='</span>);</span><br><span class="line">    buffer[queryStack * <span class="number">2</span> + <span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">if</span> (isInput) &#123;</span><br><span class="line">      buffer[queryStack * <span class="number">2</span>] = <span class="string">'&gt;'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer[<span class="number">0</span>] = <span class="string">'&lt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Connection日志增强"><a href="#Connection日志增强" class="headerlink" title="Connection日志增强"></a>Connection日志增强</h4><blockquote><p>Connection日志增加是基于动态代理实现的，具有很高的参考价值，他创建预处理等对象的时候并返回预处理对象的代理方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Connection proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 基于动态代理的日志增强</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据库连接</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn 连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ConnectionLogger</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.connection = conn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理的核心处理类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果是预处理方法 打印debug信息</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"prepareStatement"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">" Preparing: "</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用prepareStatement方法</span></span><br><span class="line">        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">        <span class="comment">//如果是调用存储过程</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"prepareCall"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">" Preparing: "</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用prepareCall 方法</span></span><br><span class="line">        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">        <span class="comment">//如果创建createStatement 方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"createStatement"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用 createStatement 方法</span></span><br><span class="line">        Statement stmt = (Statement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其他方法直接调用</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(connection, params);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a connection.</span></span><br><span class="line"><span class="comment">   * 创建 连接的代理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn - the original connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the connection with logging</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">newInstance</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> ConnectionLogger(conn, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = Connection.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;Connection.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * return the wrapped connection.</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the connection</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PreparedStatementLogger预处理日志增强"><a href="#PreparedStatementLogger预处理日志增强" class="headerlink" title="PreparedStatementLogger预处理日志增强"></a>PreparedStatementLogger预处理日志增强</h4><blockquote><p>预处理日志增强，对其中一些方法进行增强，对于查询以及获取结果集，返回结果集的日志动态代理增强。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PreparedStatement proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 基于动态代理的预处理日志增强</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 原始的预处理对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 私有的构造方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stmt         预处理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PreparedStatementLogger</span><span class="params">(PreparedStatement stmt, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.statement = stmt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理和核心方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//如果是Object对象直接调用</span></span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果包含定义的可执行方法 则打印日志 以及值列表</span></span><br><span class="line">      <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">"Parameters: "</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空 参数</span></span><br><span class="line">        clearColumnInfo();</span><br><span class="line">        <span class="comment">//如果是查询方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"executeQuery"</span>.equals(method.getName())) &#123;</span><br><span class="line">          <span class="comment">//调用 executeQuery 方法 并返回结果集</span></span><br><span class="line">          ResultSet rs = (ResultSet) method.invoke(statement, params);</span><br><span class="line">          <span class="comment">//返回结果集的 动态代理日志增强</span></span><br><span class="line">          <span class="keyword">return</span> rs == <span class="keyword">null</span> ? <span class="keyword">null</span> : ResultSetLogger.newInstance(rs, statementLog, queryStack);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其他方法直接调用不进行日志增强</span></span><br><span class="line">          <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果方法在SET_METHODS列表中</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SET_METHODS.contains(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//如果是 setNull 的方法 则设置为null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"setNull"</span>.equals(method.getName())) &#123;</span><br><span class="line">          setColumn(params[<span class="number">0</span>], <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其他设置具体参数的值</span></span><br><span class="line">          setColumn(params[<span class="number">0</span>], params[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用set方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//如果是getResultSet方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"getResultSet"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用具体的getResultSet方法</span></span><br><span class="line">        ResultSet rs = (ResultSet) method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//返回结果集日志曾倩</span></span><br><span class="line">        <span class="keyword">return</span> rs == <span class="keyword">null</span> ? <span class="keyword">null</span> : ResultSetLogger.newInstance(rs, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//如果是获取更新条数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"getUpdateCount"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用具体方法获取条数</span></span><br><span class="line">        <span class="keyword">int</span> updateCount = (Integer) method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//如果是不等于-1 打印结果日志</span></span><br><span class="line">        <span class="keyword">if</span> (updateCount != -<span class="number">1</span>) &#123;</span><br><span class="line">          debug(<span class="string">"   Updates: "</span> + updateCount, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回更新条数</span></span><br><span class="line">        <span class="keyword">return</span> updateCount;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不进行增加的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a PreparedStatement.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 创建动态代理的实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stmt         - the statement</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog - the statement log</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack   - the query stack</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the proxy</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PreparedStatement <span class="title">newInstance</span><span class="params">(PreparedStatement stmt, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> PreparedStatementLogger(stmt, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = PreparedStatement.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (PreparedStatement) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;PreparedStatement.class, CallableStatement.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the wrapped prepared statement.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the PreparedStatement</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">getPreparedStatement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatementLogger日志增加和PreparedStatementLogger这个类基本上一样，大家可以看一下。</p><h4 id="ResultSetLogger结果集日志增强"><a href="#ResultSetLogger结果集日志增强" class="headerlink" title="ResultSetLogger结果集日志增强"></a>ResultSetLogger结果集日志增强</h4><blockquote><p>结果集打印没有什么可说的了，基本上就是判断是否是blob类型，特殊处理，其他情况进行字符串拼接</p><p>这里使用了JDK1.8的StringJoiner 进行字符串拼接，可以简单的方式进行包含有分隔符的字符串拼接</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResultSet proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 结果集处理日志动态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSetLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Bolb 字段类型列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Integer&gt; BLOB_TYPES = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">  <span class="comment">//结果集原始对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultSet rs;</span><br><span class="line">  <span class="comment">//blob参数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; blobColumns = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//设置blob数据类型</span></span><br><span class="line">    BLOB_TYPES.add(Types.BINARY);</span><br><span class="line">    BLOB_TYPES.add(Types.BLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.CLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGNVARCHAR);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGVARBINARY);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGVARCHAR);</span><br><span class="line">    BLOB_TYPES.add(Types.NCLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.VARBINARY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 私有构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rs 结果集</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ResultSetLogger</span><span class="params">(ResultSet rs, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.rs = rs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理的核心方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//方法是Object类型 直接调用</span></span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用原始的方法</span></span><br><span class="line">      Object o = method.invoke(rs, params);</span><br><span class="line">      <span class="comment">//如果调用next方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"next"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//如果有下一行</span></span><br><span class="line">        <span class="keyword">if</span> ((Boolean) o) &#123;</span><br><span class="line">          <span class="comment">//行数++</span></span><br><span class="line">          rows++;</span><br><span class="line">          <span class="comment">//日志打印</span></span><br><span class="line">          <span class="keyword">if</span> (isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">//获取元数据</span></span><br><span class="line">            ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">            <span class="comment">//获取列数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">//如果是第一行 用来判断是否是第一行</span></span><br><span class="line">            <span class="keyword">if</span> (first) &#123;</span><br><span class="line">              <span class="comment">//设置第一行不显示</span></span><br><span class="line">              first = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//打印列标题</span></span><br><span class="line">              printColumnHeaders(rsmd, columnCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印参数结果集数据</span></span><br><span class="line">            printColumnValues(columnCount);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          debug(<span class="string">"     Total: "</span> + rows, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      clearColumnInfo();</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打印结果集日志</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rsmd 结果集元数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> columnCount 列行数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printColumnHeaders</span><span class="params">(ResultSetMetaData rsmd, <span class="keyword">int</span> columnCount)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    StringJoiner row = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>, <span class="string">"   Columns: "</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (BLOB_TYPES.contains(rsmd.getColumnType(i))) &#123;</span><br><span class="line">        blobColumns.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      row.add(rsmd.getColumnLabel(i));</span><br><span class="line">    &#125;</span><br><span class="line">    trace(row.toString(), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打印结果集数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> columnCount</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printColumnValues</span><span class="params">(<span class="keyword">int</span> columnCount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//StringJoiner 进行字符串拼接</span></span><br><span class="line">    StringJoiner row = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>, <span class="string">"       Row: "</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果包是blob类型 添加BLOB 标识</span></span><br><span class="line">        <span class="keyword">if</span> (blobColumns.contains(i)) &#123;</span><br><span class="line">          row.add(<span class="string">"&lt;&lt;BLOB&gt;&gt;"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//将值添加到字符串中</span></span><br><span class="line">          row.add(rs.getString(i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// generally can't call getString() on a BLOB column</span></span><br><span class="line">        row.add(<span class="string">"&lt;&lt;Cannot Display&gt;&gt;"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trace(row.toString(), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a ResultSet.</span></span><br><span class="line"><span class="comment">   * 创建结果集代理类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rs - the ResultSet to proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the ResultSet with logging</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title">newInstance</span><span class="params">(ResultSet rs, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> ResultSetLogger(rs, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = ResultSet.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (ResultSet) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;ResultSet.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the wrapped result set.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the resultSet</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSet <span class="title">getRs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ mybatis 日志模块使用适配器模式进行不同类型的日志框架的统一，使用动态代理对连接执行sql，结果集进行日志的增强，使其无缝的与mybatis结合起来，你们的日志是怎么打印的呢？</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis日志模块解析
    
    </summary>
    
      <category term="MYBATIS" scheme="http://www.baiyp.ren/categories/MYBATIS/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/MYBATIS/%E6%BA%90%E7%A0%81/"/>
    
      <category term="日志" scheme="http://www.baiyp.ren/categories/MYBATIS/%E6%BA%90%E7%A0%81/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="MYBATIS" scheme="http://www.baiyp.ren/tags/MYBATIS/"/>
    
      <category term="日志" scheme="http://www.baiyp.ren/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>volatile实现原理</title>
    <link href="http://www.baiyp.ren/volatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/volatile实现原理.html</id>
    <published>2019-09-03T01:11:04.000Z</published>
    <updated>2019-09-07T09:10:09.807Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><p><img src="../images/thread/volatile/volatile01.png" alt></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​ volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote><p>可以把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步</p></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p></blockquote><p>​ 原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：</p><ul><li>基本类型的读取和赋值操作，且赋值必须是数字赋值给变量，变量之间的相互赋值不是原子性操作。</li><li>所有引用reference的赋值操作</li><li>java.concurrent.Atomic.* 包中所有类的一切操作</li></ul><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote><p>指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p>​ 在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><p>即程序执行的顺序按照代码的先后顺序执行。</p></blockquote><p>​ java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。<br>​ 在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><h3 id="volatile变量的特性"><a href="#volatile变量的特性" class="headerlink" title="volatile变量的特性"></a>volatile变量的特性</h3><h4 id="保证可见性，不保证原子性"><a href="#保证可见性，不保证原子性" class="headerlink" title="保证可见性，不保证原子性"></a>保证可见性，不保证原子性</h4><p><img src="../images/thread/volatile/volatile07.png" alt></p><ul><li><p>当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；</p></li><li><p>这个写会操作会导致其他线程中的缓存无效。</p></li></ul><h4 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h4><blockquote><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：</p></blockquote><ul><li><p>重排序操作不会对存在数据依赖关系的操作进行重排序。</p><p>比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运</p><p>​ 行时这两个操作不会被重排序。</p></li><li><p>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</p><p>比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发</p></li></ul><p>​ 生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p><p>​ 重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p></blockquote><ul><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即写入主存；</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li></ul><h4 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h4><ul><li><p><strong>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</strong></p></li><li><p><strong>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</strong></p><p>​ 当主线程对stop进行修改后且子线程尚未对stop进行读时，主线程已经把stop的值刷新到了主内存。其示意图如下：</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile02.png" alt></p><p>​ 当子线程进行读取时，会把本地内存置为无效直接去主内存中读取。（这里的主线程和子线程可以了解为两个普通线程没有父子关系）其示意图如下：</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile03.png" alt></p></li></ul><h4 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h4><p>​ 为了实现volatile的内存语义，JMM会分别限制这两种类型的重排序。下图是JMM针对编译器指定的volatile重排序规则表。</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile04.png" alt></p><ul><li><strong>当第二个操作为volatile写操作时,不管第一个操作是什么(普通读写或者volatile读写),都不能进行重排序。这个规则确保volatile写之前的所有操作都不会被重排序到volatile写之后;</strong></li><li><strong>当第一个操作为volatile读操作时,不管第二个操作是什么,都不能进行重排序。这个规则确保volatile读之后的所有操作都不会被重排序到volatile读之前;</strong></li><li><strong>当第一个操作是volatile写操作时,第二个操作是volatile读操作,不能进行重排序。</strong></li></ul><p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。下面是基于保守策略的 JMM 内存屏障插入策略：</p><ul><li><p><strong>在每个 volatile 写操作的前面插入一个 StoreStore 屏障（禁止前面的写与volatile写重排序）。</strong></p></li><li><p><strong>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障（禁止volatile写与后面可能有的读和写重排序）。</strong></p></li><li><p><strong>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障（禁止volatile读与后面的读操作重排序）。</strong></p></li><li><p><strong>在每个 volatile 读操作的后面插入一个 LoadStore 屏障（禁止volatile读与后面的写操作重排序）。</strong></p><p><strong>其中重点说下StoreLaod屏障，它是确保可见性的关键，因为它会将屏障之前的写缓冲区中的数据全部刷新到主内存中</strong>。上述内存屏障插入策略非常保守，但它可以保证在任意处理平台，任意的程序中都能得到正确的volatile语义。下面是保守策略（为什么说保守呢，因为有些在实际的场景是可省略的）下，volatile 写操作 插入内存屏障后生成的指令序列示意图：</p></li></ul><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile05.png" alt></p><p>​ 其中StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作对任意处理器可见（把它刷新到主内存）。另外volatile写后面有StoreLoad屏障，此屏障的作用是避免volatile写与后面可能有的读或写操作进行重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）为了保证能正确实现volatile的内存语义，JMM采取了保守策略：<strong>在每个volatile写的后面插入一个StoreLoad屏障</strong>。因为volatile写-读内存语义的常见模式是：一个写线程写volatile变量，多个度线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里也可看出JMM在实现上的一个特点：首先确保正确性，然后再去追求效率（其实我们工作中编码也是一样）。</p><p>下面是在保守策略下，volatile读插入内存屏障后生产的指令序列示意图：</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile06.png" alt></p><p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况忽略不必要的屏障。在JMM基础中就有提到过各个处理器对各个屏障的支持度，其中x86处理器仅会对写-读操作做重排序。</p><h3 id="单例模式的双重锁为什么要加volatile"><a href="#单例模式的双重锁为什么要加volatile" class="headerlink" title="单例模式的双重锁为什么要加volatile"></a>单例模式的双重锁为什么要加volatile</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第8行会出现问题。</p><p>singleton = new Singleton();可以分解为3行伪代码</p><ol><li><p>memory = allocate() //分配内存</p><ol start="2"><li>ctorInstanc(memory) //初始化对象<ol start="3"><li>singleton= memory //设置instance指向刚分配的地址</li><li>上面的代码在编译运行时，可能会出现重排序从1-2-3排序为1-3-2。在多线程的情况下会出现以下问题。线程A在执行第5行代码时，B线程进来，而此时A执行了1和3，没有执行2，此时B线程判断instance不为null，直接返回一个未初始化的对象。</li></ol></li></ol></li></ol><h3 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h3><ul><li>volatile是线程同步的轻量级实现，所以volatile的性能要比synchronize好；volatile只能用于修饰变量，synchronize可以用于修饰方法、代码块。随着jdk技术的发展，synchronize在执行效率上会得到较大提升，所以synchronize在项目过程中还是较为常见的；</li><li>多线程访问volatile不会发生阻塞；而synchronize会发生阻塞；</li><li>volatile能保证变量在私有内存和主内存间的同步，但不能保证变量的原子性；synchronize可以保证变量原子性；</li><li>volatile是变量在多线程之间的可见性；synchronize是多线程之间访问资源的同步性；<br>对于volatile修饰的变量，可以解决变量读时可见性问题，无法保证原子性。对于多线程访问同一个实例变量还是需要加锁同步。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      volatile实现原理
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="volatile" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/volatile/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="实现原理" scheme="http://www.baiyp.ren/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="volatile" scheme="http://www.baiyp.ren/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>final实现原理</title>
    <link href="http://www.baiyp.ren/final%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/final实现原理.html</id>
    <published>2019-09-01T01:11:04.000Z</published>
    <updated>2019-09-07T04:48:19.073Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="final实现原理"><a href="#final实现原理" class="headerlink" title="final实现原理"></a>final实现原理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​ <strong>final</strong>关键字，实际的含义就一句话，不可改变。什么是不可改变？就是初始化完成之后就不能再做任何的修改，修饰成员变量的时候，成员变量变成一个常数；修饰方法的时候，方法不允许被重写；修饰类的时候，类不允许被继承；修饰参数列表的时候，入参的对象也是不可以改变。这个就是不可变，无论是引用新的对象，重写还是继承，都是改变的方法，而final就是把这个变更的路给堵死</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h4><ul><li>final成员变量表示常量，只能被赋值一次，赋值后值不再改变（final要求地址值不能改变）</li><li>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li><li>如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。</li><li>final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式。<ul><li>一种是在变量声明的时候初始化。</li><li>第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</li></ul></li></ul><h4 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h4><blockquote><p>使用final方法的原因有两个。</p></blockquote><ul><li><p>第一个原因是把方法锁定，以防任何继承类修改它的含义，不能被重写；</p></li><li><p>第二个原因是效率，final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。</p></li></ul><p><strong>注：类的private方法会隐式地被指定为final方法</strong></p><h4 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h4><blockquote><p>当用final修饰一个类时，表明这个类不能被继承。</p></blockquote><p>final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p><p>在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。</p><h3 id="final关键字的好处"><a href="#final关键字的好处" class="headerlink" title="final关键字的好处"></a>final关键字的好处</h3><ul><li><p>final关键字提高了性能。JVM和Java应用都会缓存final变量。</p></li><li><p>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</p></li><li><p>使用final关键字，JVM会对方法、变量及类进行优化。</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>final关键字可以用于成员变量、本地变量、方法以及类。</li><li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</li><li>你不能够对final变量再次赋值。</li><li>本地变量必须在声明时赋值。</li><li>在匿名类中所有变量都必须是final变量。</li><li>final方法不能被重写。</li><li>final类不能被继承。</li><li>final关键字不同于finally关键字，后者用于异常处理。</li><li>final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。</li><li>接口中声明的所有变量本身是final的。</li><li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li><li>final方法在编译阶段绑定，称为静态绑定(static binding)。</li><li>没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</li><li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li><li>按照Java代码惯例，final变量就是常量，而且通常常量名要大写。</li><li>对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h4><blockquote><p>写内存语义可以确保在对象的引用为任意线程可见之前，final 域已经被初始化过了。</p><p>读内存语义可以确保如果对象的引用不为 null，则说明 final 域已经被初始化过了。</p><p>总之，final 域的内存语义提供了初始化安全保证。</p></blockquote><ul><li><strong>写内存语义</strong>：在构造函数内对一个 final 域的写入，与随后将对象引用赋值给引用变量，这两个操作不能重排序。</li><li><strong>读内存语义</strong>：初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作不能重排序。</li></ul><h4 id="Final域是普通类型"><a href="#Final域是普通类型" class="headerlink" title="Final域是普通类型"></a>Final域是普通类型</h4><blockquote><p>对于final域，编译器和处理器要遵守两个重排序规则</p></blockquote><ol><li><p>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p><p>（先写入final变量，后调用该对象引用）</p><p>原因：编译器会在final域的写之后，插入一个StoreStore屏障</p></li><li><p>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p><p>（先读对象的引用，后读final变量）</p></li></ol><p>​ 编译器会在读final域操作的前面插入一个LoadLoad屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通变量</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// final 变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写普通域</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 写 final 域</span></span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写方法A执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程B执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读对象引用</span></span><br><span class="line">        FinalExample object = obj;</span><br><span class="line">        <span class="comment">// 读普通域         a=1或者a=0或者直接报错i没有初始化</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;</span><br><span class="line">        <span class="comment">/// 读 final域</span></span><br><span class="line">        <span class="keyword">int</span> b = object.j;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h5><p>写普通域的操作被编译器重排序到了构造函数之外</p><p>而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。</p><p><strong>写 final 域的重排序规则可以确保</strong>：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。</p><p><img src="../images/thread/final/final01.png" alt></p><h5 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h5><p>读对象的普通域的操作被处理器重排序到读对象引用之前</p><p>而读 final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。</p><p><strong>读 final 域的重排序规则可以确保</strong>：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。</p><p><img src="../images/thread/final/final02.png" alt></p><h4 id="final-域是引用类型"><a href="#final-域是引用类型" class="headerlink" title="final 域是引用类型"></a>final 域是引用类型</h4><blockquote><p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p><p>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * final域是引用类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// final 是引用类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] intArray;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>]; <span class="comment">// 1</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程 A 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> FinalReferenceExample(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程 B 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.intArray[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程 C 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; <span class="comment">// 5</span></span><br><span class="line">            <span class="comment">// temp1=1或者temp1=2，不可能等于0</span></span><br><span class="line">            <span class="keyword">int</span> temp1 = obj.intArray[<span class="number">0</span>]; <span class="comment">// 6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTwo() 方法，执行完后线程 C 执行 reader () 方法。</p><p><img src="../images/thread/final/final03.png" alt></p><p>在上图中<br>1 是对 final 域的写入；<br>2 是对这个 final 域引用的对象的成员域的写入；<br>3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。</p><p>JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p><h3 id="final、finally、-finalize区别"><a href="#final、finally、-finalize区别" class="headerlink" title="final、finally、 finalize区别"></a>final、finally、 finalize区别</h3><ul><li>final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final的变量是不可以修改的，而final的方法也是不可以重写的（override）。</li><li>finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</li><li>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      final实现原理
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="final" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/final/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="实现原理" scheme="http://www.baiyp.ren/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="final" scheme="http://www.baiyp.ren/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式08-建造者模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式08.html</id>
    <published>2019-08-31T01:42:30.000Z</published>
    <updated>2019-09-08T11:51:00.731Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-建造者模式（Builder-Pattern）"><a href="#JAVA设计模式-建造者模式（Builder-Pattern）" class="headerlink" title="JAVA设计模式-建造者模式（Builder Pattern）"></a>JAVA设计模式-建造者模式（Builder Pattern）</h2><p><img src="../images/design-patterns/builderpattern01.png" alt></p><h3 id="什么是建造者模式"><a href="#什么是建造者模式" class="headerlink" title="什么是建造者模式"></a>什么是建造者模式</h3><p>​ 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的</p><p>​ 创建者模式又叫建造者模式，是将一个复杂的对象的<strong>构建</strong>与它的<strong>表示</strong>分离，使<br>得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><strong>Product（产品角色）：</strong> 一个具体的产品对象。</li><li><strong>Builder（抽象建造者）：</strong>创建一个Product对象的各个部件指定的抽象接口。</li><li><strong>ConcreteBuilder（具体建造者）：</strong>实现抽象接口，构建和装配各个部件。</li><li><strong>Director（指挥者）：</strong>构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li><li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li><li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li><li>初始化一个对象时，参数过多，或者很多参数具有默认值</li><li>Builder模式不适合创建差异性很大的产品类</li><li>产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li><li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ul><h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3><blockquote><p>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</p></blockquote><ul><li>用户只需要给出指定复杂对象的类型和内容；</li><li>建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)</li></ul><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul><li>方便用户创建复杂的对象（不需要知道实现过程）</li><li>代码复用性 &amp; 封装性（将对象构建过程和细节进行封装 &amp; 复用）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><blockquote><p>需要进行构建的原始的产品类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要进行构建的产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单价</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">", num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Builder-接口"><a href="#Builder-接口" class="headerlink" title="Builder 接口"></a>Builder 接口</h4><blockquote><p>Builder 可以是接口也可以是抽象类，定义需要实现的构建模板</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建产品名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建单价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取构建的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体建造者（ConcreteBuilder）"><a href="#具体建造者（ConcreteBuilder）" class="headerlink" title="具体建造者（ConcreteBuilder）"></a>具体建造者（ConcreteBuilder）</h4><h5 id="构建苹果手机"><a href="#构建苹果手机" class="headerlink" title="构建苹果手机"></a>构建苹果手机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建苹果手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">"iphone手机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPrice(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setNum(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构建手表"><a href="#构建手表" class="headerlink" title="构建手表"></a>构建手表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建手表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">"手表"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPrice(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setNum(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指挥者-Director"><a href="#指挥者-Director" class="headerlink" title="指挥者(Director)"></a>指挥者(Director)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建造者接口</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建具体的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 构建出来的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildName();</span><br><span class="line">        builder.buildPrice();</span><br><span class="line">        builder.buildNum();</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印手机</span></span><br><span class="line">        printBuild(<span class="keyword">new</span> MobileBuilder());</span><br><span class="line">        <span class="comment">//打印手表</span></span><br><span class="line">        printBuild(<span class="keyword">new</span> WatchBuilder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印建造后的对象数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuild</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.getProduct();</span><br><span class="line">        System.out.println(product.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Product&#123;name=<span class="string">'iphone手机'</span>, price=<span class="number">8000.0</span>, num=<span class="number">1000</span>&#125;</span><br><span class="line">Product&#123;name=<span class="string">'手表'</span>, price=<span class="number">10000.0</span>, num=<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="通过链式调用优化-非常推荐"><a href="#通过链式调用优化-非常推荐" class="headerlink" title="通过链式调用优化(非常推荐)"></a>通过链式调用优化(非常推荐)</h3><blockquote><p>链式写法是在原型写法的基础上做优化，有些时候<code>Builder</code>的创建部分有默认值，或者不需要的情况下，而产生不同的<code>Product</code>，通过以上方式，就需要修改<code>Director</code>类和<code>Builder</code>类，再或者根据不同的创建顺序，生成不同的结果，也需要修改<code>Director</code>类。<code>Director</code>似乎显得很不稳定和多余。可以通过<code>Builder</code>自身的调用逻辑来生成<code>Product</code>，即链式调用</p></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链式的建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamProductBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单价</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamProductBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamProductBuilder</span><span class="params">(String name, <span class="keyword">float</span> price, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态类 Builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 产品名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单价</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//空的构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进行建造</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">price</span><span class="params">(<span class="keyword">float</span> prie)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.price = price;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">num</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回建造的对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> StreamProductBuilder <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StreamProductBuilder(name, price, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端使用-1"><a href="#客户端使用-1" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StreamProductBuilder builder = <span class="keyword">new</span> StreamProductBuilder.Builder().name(<span class="string">"iphone手机"</span>).price(<span class="number">8000</span>).num(<span class="number">100</span>).build();</span><br><span class="line">        System.out.println(builder.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码只是传入三个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性，代码更加简洁。</p><h4 id="相比于普通JavaBean的好处"><a href="#相比于普通JavaBean的好处" class="headerlink" title="相比于普通JavaBean的好处"></a>相比于普通JavaBean的好处</h4><p>​ 在建造者模式中,提供一个辅助的静态建造器<code>Builder</code>(静态内部类),可以在里面<code>set</code>实体类的属性,与<code>JavaBean</code>不同的是,建造者是先<code>set</code>,在通过<code>build</code>实例化实体类,这样既可以提高代码的阅读性,也可以防止对象没有实例化,就被调用;不会造成不一致性,同时解决了<code>Javabean</code>模式的线程安全问题</p><h3 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ <strong>Director角色并非多余，能把复杂的Product创建过程对外隐藏，使Builder部件和创建过程分离，各方易于扩展，降低了耦合度。当需要对一个对象设置很多属性，此时就能方便的使用链式调用来提高编码速度和代码可读性。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之建造者模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="建造者模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="建造者模式" scheme="http://www.baiyp.ren/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式07-代理模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式07.html</id>
    <published>2019-08-30T01:42:30.000Z</published>
    <updated>2019-09-05T09:23:26.677Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-代理模式（Proxy-Pattern）"><a href="#JAVA设计模式-代理模式（Proxy-Pattern）" class="headerlink" title="JAVA设计模式-代理模式（Proxy Pattern）"></a>JAVA设计模式-代理模式（Proxy Pattern）</h2><p><img src="../images/design-patterns/proxyparrern01.png" alt></p><h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3><p>​ 在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。</p><p>​ 代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，后面将学习这些不同的代理形式。</p><p>​ 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p><p>​ 代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。</p><h4 id="为什么要用代理模式"><a href="#为什么要用代理模式" class="headerlink" title="为什么要用代理模式"></a>为什么要用代理模式</h4><ul><li><strong>中介隔离作用：</strong>在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。</li><li><strong>开闭原则，增加功能：</strong>代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</li></ul><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><strong>Subject（抽象主题角色）：</strong> 它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li><li><strong>Proxy（代理主题角色）：</strong> 它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</li><li><strong>RealSubject（真实主题角色）：</strong> 它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>职责清晰。</li><li>高扩展性。</li><li>智能化。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>远程代理。</li><li>虚拟代理。</li><li>Copy-on-Write 代理。</li><li>保护（Protect or Access）代理。</li><li>Cache代理。</li><li>防火墙（Firewall）代理。</li><li>同步化（Synchronization）代理。</li><li>智能引用（Smart Reference）代理。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>其实代理的一般模式就是静态代理的实现模式：首先创建一个接口（JDK代理都是面向接口的），然后创建具体实现类来实现这个接口，在创建一个代理类同样实现这个接口，不同之处在于，具体实现类的方法中需要将接口中定义的方法的业务逻辑功能实现，而代理类中的方法只要调用具体类中的对应方法即可，这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可，将具体的实现类隐藏在底层。</p></blockquote><p><img src="../images/design-patterns/proxyparrern02.png" alt></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="公用接口"><a href="#公用接口" class="headerlink" title="公用接口"></a>公用接口</h5><blockquote><p>代理类和真实类的公用接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="真实类的请求"><a href="#真实类的请求" class="headerlink" title="真实类的请求"></a>真实类的请求</h5><blockquote><p>实现公有的接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"真实请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建代理类"><a href="#创建代理类" class="headerlink" title="创建代理类"></a>创建代理类</h5><blockquote><p>代理请求，引入了真实类对象，对方法进行了增强。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"><span class="comment">//真实请求接口</span></span><br><span class="line">    <span class="keyword">private</span> Subject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//转发真实请求</span></span><br><span class="line">        realSubject.request();</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态代理总结"><a href="#静态代理总结" class="headerlink" title="静态代理总结"></a>静态代理总结</h4><p>优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。</p><p>缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。</p></blockquote><h4 id="编写动态处理器"><a href="#编写动态处理器" class="headerlink" title="编写动态处理器"></a>编写动态处理器</h4><blockquote><p>动态代理需要实现InvocationHandler接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类只能代理接口（不支持抽象类），代理类都需要实现InvocationHandler类，实现invoke方法。</span></span><br><span class="line"><span class="comment"> * 该invoke方法就是调用被代理接口的所有方法时需要调用的，该invoke方法返回的值是被代理接口的一个实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定关系，也就是关联到哪个接口（与具体的实现类绑定）的哪些方法将被调用时，执行invoke方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object targetObject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetObject=targetObject;</span><br><span class="line">        <span class="comment">//该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span><br><span class="line">        <span class="comment">//第一个参数指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器</span></span><br><span class="line">        <span class="comment">//第二个参数要实现和目标对象一样的接口，所以只需要拿到目标对象的实现接口</span></span><br><span class="line">        <span class="comment">//第三个参数表明这些被拦截的方法在被拦截时需要执行哪个InvocationHandler的invoke方法</span></span><br><span class="line">        <span class="comment">//根据传入的目标返回一个代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),</span><br><span class="line">                targetObject.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联的这个实现类的方法被调用时将被执行</span></span><br><span class="line"><span class="comment">     * InvocationHandler接口的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 原对象被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 表示方法的参数*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//调用目标方法</span></span><br><span class="line">        Object result = method.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DynamicProxyHandler dynamicProxyHandler=<span class="keyword">new</span> DynamicProxyHandler();</span><br><span class="line">        UserManager userManager=(UserManager)dynamicProxyHandler.newProxyInstance(<span class="keyword">new</span> UserManagerImpl());</span><br><span class="line">        UserManager userManager=<span class="keyword">new</span> UserManagerImpl();</span><br><span class="line">        userManager.addUser(<span class="string">"1111"</span>, <span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理总结"><a href="#动态代理总结" class="headerlink" title="动态代理总结"></a>动态代理总结</h4><p>​ 虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。</p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><blockquote><p>JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。</p></blockquote><h4 id="创建CGLIB代理类"><a href="#创建CGLIB代理类" class="headerlink" title="创建CGLIB代理类"></a>创建CGLIB代理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//CGLIB enhancer增强类对象</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置代理类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.targetObject.getClass());</span><br><span class="line">        <span class="comment">//定义代理逻辑对象为当前对象   ，对象要继承MethodInterceptor。并实现逻辑方法intercept</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理逻辑方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//真的是代理对象，不像JDk代理，还是真实对象</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了CGLIB的加强者Enhancer,通过设置超类的方法setSuperclass，然后通过setCallback方法设置哪个类为它的代理类。其中，参数为this就意味着是当前对象，那就要求用this这个对象实现接口Methodlnterceptor的方法intercept，然后返回代理对象。那么此时当前类的intercept方法就是其代理逻辑方法，其参数内容见代码注解，我们在反射真实对象方法前后进行了打印，CGLIB是通过如下代码完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object result=methodProxy.invokeSuper(proxy,args);</span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        CglibProxy cglib = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        Dog dog = (Dog) cglib.getInstance(Dog.class);</span><br><span class="line">        <span class="comment">//调用代理对象的isAnimal()方法</span></span><br><span class="line">        dog.isAnimal(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CGLIB代理总结"><a href="#CGLIB代理总结" class="headerlink" title="CGLIB代理总结"></a>CGLIB代理总结</h4><p>​ CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之代理模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://www.baiyp.ren/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA字节码指令</title>
    <link href="http://www.baiyp.ren/JAVA%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.html"/>
    <id>http://www.baiyp.ren/JAVA字节码指令.html</id>
    <published>2019-08-29T06:20:57.000Z</published>
    <updated>2019-08-29T07:21:09.418Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JAVA字节码指令"><a href="#JAVA字节码指令" class="headerlink" title="JAVA字节码指令"></a>JAVA字节码指令</h2><p>​ Java程序是运行在Java虚拟机上的，而这里的“虚拟”是对什么东西进行虚拟呢？答案当然就是对“实体”机进行虚拟啦，虚拟机可以看做是对实体机进行了进一步的封装和抽象，隐藏了不同实体机之间的差别，从而达成“Write Once,Run AnyWhere”的目标。既然虚拟机是对实体机的虚拟，所以我认为虚拟机和实体机在结构和功能上必然存在某种程度上的对应与关联。因此我们在学习时应该注意发掘和类比两者之间的关系。<br>​ 本着这样的思想，我们进行Java字节码指令的学习。JAVA字节码在JAVA虚拟机中的地位相当于实体机的机器码，一切在Java虚拟机上运行的程序都要被解释或编译成字节码，一切在实体机上运行的程序最后也都要编译成机器码。Java字节码指令可以对字节码进行操作，在实体机中对机器码进行操作的是汇编语言。所以Java字节码指令对应汇编语言，Java字节码指令集对应汇编指令集。</p><h3 id="字节码简介"><a href="#字节码简介" class="headerlink" title="字节码简介"></a>字节码简介</h3><blockquote><p>Java汇编指令就是Java虚拟机能够听得懂、可执行的指令，也可以说是Java代码的最小执行单元。</p></blockquote><p>​ Java字节码指令由<em>一个</em>字节长度的，代表某种特定操作含义的数字（操作码）以及其后的零至多个代表此操作所需参数（操作数）。此外字节码指令是面向操作数栈的，这里操作数栈在功能上对应实体机的寄存器但是结构上有所区别。</p><h3 id="java字节码指令集"><a href="#java字节码指令集" class="headerlink" title="java字节码指令集"></a>java字节码指令集</h3><h4 id="常用指令集"><a href="#常用指令集" class="headerlink" title="常用指令集"></a>常用指令集</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x01</td><td>aconst_null</td><td></td><td>null值入栈。</td></tr><tr><td>0x02</td><td>iconst_m1</td><td></td><td>-1(int)值入栈。</td></tr><tr><td>0x03</td><td>iconst_0</td><td></td><td>0(int)值入栈。</td></tr><tr><td>0x04</td><td>iconst_1</td><td></td><td>1(int)值入栈。</td></tr><tr><td>0x05</td><td>iconst_2</td><td></td><td>2(int)值入栈。</td></tr><tr><td>0x06</td><td>iconst_3</td><td></td><td>3(int)值入栈。</td></tr><tr><td>0x07</td><td>iconst_4</td><td></td><td>4(int)值入栈。</td></tr><tr><td>0x08</td><td>iconst_5</td><td></td><td>5(int)值入栈。</td></tr><tr><td>0x09</td><td>lconst_0</td><td></td><td>0(long)值入栈。</td></tr><tr><td>0x0a</td><td>lconst_1</td><td></td><td>1(long)值入栈。</td></tr><tr><td>0x0b</td><td>fconst_0</td><td></td><td>0(float)值入栈。</td></tr><tr><td>0x0c</td><td>fconst_1</td><td></td><td>1(float)值入栈。</td></tr><tr><td>0x0d</td><td>fconst_2</td><td></td><td>2(float)值入栈。</td></tr><tr><td>0x0e</td><td>dconst_0</td><td></td><td>0(double)值入栈。</td></tr><tr><td>0x0f</td><td>dconst_1</td><td></td><td>1(double)值入栈。</td></tr><tr><td>0x10</td><td>bipush</td><td>valuebyte</td><td>valuebyte值带符号扩展成int值入栈。</td></tr><tr><td>0x11</td><td>sipush</td><td>valuebyte1，valuebyte2</td><td>(valuebyte1 &lt;&lt; 8) | valuebyte2 值带符号扩展成int值入栈。</td></tr><tr><td>0x12</td><td>ldc</td><td>indexbyte1</td><td>常量池中的常量值（int, float, string reference, object reference）入栈。</td></tr><tr><td>0x13</td><td>ldc_w</td><td>indexbyte1，indexbyte2</td><td>常量池中常量（int, float, string reference, object reference）入栈。</td></tr><tr><td>0x14</td><td>ldc2_w</td><td>indexbyte1，indexbyte2</td><td>常量池+A1:D24中常量（long, double）入栈。</td></tr></tbody></table><h4 id="局部变量值转载到栈中指令"><a href="#局部变量值转载到栈中指令" class="headerlink" title="局部变量值转载到栈中指令"></a>局部变量值转载到栈中指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x19</td><td>(wide)aload</td><td>indexbyte</td><td>从局部变量indexbyte中装载引用类型值入栈。</td></tr><tr><td>0x2a</td><td>aload_0</td><td></td><td>从局部变量0中装载引用类型值入栈。</td></tr><tr><td>0x2b</td><td>aload_1</td><td></td><td>从局部变量1中装载引用类型值入栈。</td></tr><tr><td>0x2c</td><td>aload_2</td><td></td><td>从局部变量2中装载引用类型值入栈。</td></tr><tr><td>0x2d</td><td>aload_3</td><td></td><td>从局部变量3中装载引用类型值入栈。</td></tr><tr><td>0x15</td><td>(wide)iload</td><td>indexbyte</td><td>从局部变量indexbyte中装载int类型值入栈。</td></tr><tr><td>0x1a</td><td>iload_0</td><td></td><td>从局部变量0中装载int类型值入栈。</td></tr><tr><td>0x1b</td><td>iload_1</td><td></td><td>从局部变量1中装载int类型值入栈。</td></tr><tr><td>0x1c</td><td>iload_2</td><td></td><td>从局部变量2中装载int类型值入栈。</td></tr><tr><td>0x1d</td><td>iload_3</td><td></td><td>从局部变量3中装载int类型值入栈。</td></tr><tr><td>0x16</td><td>(wide)lload</td><td>indexbyte</td><td>从局部变量indexbyte中装载long类型值入栈。</td></tr><tr><td>0x1e</td><td>lload_0</td><td></td><td>从局部变量0中装载int类型值入栈。</td></tr><tr><td>0x1f</td><td>lload_1</td><td></td><td>从局部变量1中装载int类型值入栈。</td></tr><tr><td>0x20</td><td>lload_2</td><td></td><td>从局部变量2中装载int类型值入栈。</td></tr><tr><td>0x21</td><td>lload_3</td><td></td><td>从局部变量3中装载int类型值入栈。</td></tr><tr><td>0x17</td><td>(wide)fload</td><td>indexbyte</td><td>从局部变量indexbyte中装载float类型值入栈。</td></tr><tr><td>0x22</td><td>fload_0</td><td></td><td>从局部变量0中装载float类型值入栈。</td></tr><tr><td>0x23</td><td>fload_1</td><td></td><td>从局部变量1中装载float类型值入栈。</td></tr><tr><td>0x24</td><td>fload_2</td><td></td><td>从局部变量2中装载float类型值入栈。</td></tr><tr><td>0x25</td><td>fload_3</td><td></td><td>从局部变量3中装载float类型值入栈。</td></tr><tr><td>0x18</td><td>(wide)dload</td><td>indexbyte</td><td>从局部变量indexbyte中装载double类型值入栈。</td></tr><tr><td>0x26</td><td>dload_0</td><td></td><td>从局部变量0中装载double类型值入栈。</td></tr><tr><td>0x27</td><td>dload_1</td><td></td><td>从局部变量1中装载double类型值入栈。</td></tr><tr><td>0x28</td><td>dload_2</td><td></td><td>从局部变量2中装载double类型值入栈。</td></tr><tr><td>0x29</td><td>dload_3</td><td></td><td>从局部变量3中装载double类型值入栈。</td></tr><tr><td>0x32</td><td>aaload</td><td></td><td>从引用类型数组中装载指定项的值。</td></tr><tr><td>0x2e</td><td>iaload</td><td></td><td>从int类型数组中装载指定项的值。</td></tr><tr><td>0x2f</td><td>laload</td><td></td><td>从long类型数组中装载指定项的值。</td></tr><tr><td>0x30</td><td>faload</td><td></td><td>从float类型数组中装载指定项的值。</td></tr><tr><td>0x31</td><td>daload</td><td></td><td>从double类型数组中装载指定项的值。</td></tr><tr><td>0x33</td><td>baload</td><td></td><td>从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td>0x34</td><td>caload</td><td></td><td>从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td>0x35</td><td>saload</td><td></td><td>从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr></tbody></table><h4 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xc4</td><td>wide</td><td></td><td>使用附加字节扩展局部变量索引（iinc指令特殊）。</td></tr></tbody></table><h4 id="将栈顶值保存到局部变量中指令"><a href="#将栈顶值保存到局部变量中指令" class="headerlink" title="将栈顶值保存到局部变量中指令"></a>将栈顶值保存到局部变量中指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x3a</td><td>(wide)astore</td><td>indexbyte</td><td>将栈顶引用类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x4b</td><td>astroe_0</td><td></td><td>将栈顶引用类型值保存到局部变量0中。</td></tr><tr><td>0x4c</td><td>astore_1</td><td></td><td>将栈顶引用类型值保存到局部变量1中。</td></tr><tr><td>0x4d</td><td>astore_2</td><td></td><td>将栈顶引用类型值保存到局部变量2中。</td></tr><tr><td>0x4e</td><td>astore_3</td><td></td><td>将栈顶引用类型值保存到局部变量3中。</td></tr><tr><td>0x36</td><td>(wide)istore</td><td>indexbyte</td><td>将栈顶int类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x3b</td><td>istore_0</td><td></td><td>将栈顶int类型值保存到局部变量0中。</td></tr><tr><td>0x3c</td><td>istore_1</td><td></td><td>将栈顶int类型值保存到局部变量1中。</td></tr><tr><td>0x3d</td><td>istore_2</td><td></td><td>将栈顶int类型值保存到局部变量2中。</td></tr><tr><td>0x3e</td><td>istore_3</td><td></td><td>将栈顶int类型值保存到局部变量3中。</td></tr><tr><td>0x37</td><td>(wide)lstore</td><td>indexbyte</td><td>将栈顶long类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x3f</td><td>lstore_0</td><td></td><td>将栈顶long类型值保存到局部变量0中。</td></tr><tr><td>0x40</td><td>lstore_1</td><td></td><td>将栈顶long类型值保存到局部变量1中。</td></tr><tr><td>0x41</td><td>lstore_2</td><td></td><td>将栈顶long类型值保存到局部变量2中。</td></tr><tr><td>0x42</td><td>lstroe_3</td><td></td><td>将栈顶long类型值保存到局部变量3中。</td></tr><tr><td>0x38</td><td>(wide)fstore</td><td>indexbyte</td><td>将栈顶float类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x43</td><td>fstore_0</td><td></td><td>将栈顶float类型值保存到局部变量0中。</td></tr><tr><td>0x44</td><td>fstore_1</td><td></td><td>将栈顶float类型值保存到局部变量1中。</td></tr><tr><td>0x45</td><td>fstore_2</td><td></td><td>将栈顶float类型值保存到局部变量2中。</td></tr><tr><td>0x46</td><td>fstore_3</td><td></td><td>将栈顶float类型值保存到局部变量3中。</td></tr><tr><td>0x39</td><td>(wide)dstore</td><td>indexbyte</td><td>将栈顶double类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x47</td><td>dstore_0</td><td></td><td>将栈顶double类型值保存到局部变量0中。</td></tr><tr><td>0x48</td><td>dstore_1</td><td></td><td>将栈顶double类型值保存到局部变量1中。</td></tr><tr><td>0x49</td><td>dstore_2</td><td></td><td>将栈顶double类型值保存到局部变量2中。</td></tr><tr><td>0x4a</td><td>dstore_3</td><td></td><td>将栈顶double类型值保存到局部变量3中。</td></tr><tr><td>0x53</td><td>aastore</td><td></td><td>将栈顶引用类型值保存到指定引用类型数组的指定项。</td></tr><tr><td>0x4f</td><td>iastore</td><td></td><td>将栈顶int类型值保存到指定int类型数组的指定项。</td></tr><tr><td>0x50</td><td>lastore</td><td></td><td>将栈顶long类型值保存到指定long类型数组的指定项。</td></tr><tr><td>0x51</td><td>fastore</td><td></td><td>将栈顶float类型值保存到指定float类型数组的指定项。</td></tr><tr><td>0x52</td><td>dastore</td><td></td><td>将栈顶double类型值保存到指定double类型数组的指定项。</td></tr><tr><td>0x54</td><td>bastroe</td><td></td><td>将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。</td></tr><tr><td>0x55</td><td>castore</td><td></td><td>将栈顶char类型值保存到指定char类型数组的指定项。</td></tr><tr><td>0x56</td><td>sastore</td><td></td><td>将栈顶short类型值保存到指定short类型数组的指定项。</td></tr></tbody></table><h4 id="通用（无类型）栈操作指令"><a href="#通用（无类型）栈操作指令" class="headerlink" title="通用（无类型）栈操作指令"></a>通用（无类型）栈操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x00</td><td>nop</td><td></td><td>空操作。</td></tr><tr><td>0x57</td><td>pop</td><td></td><td>从栈顶弹出一个字长的数据。</td></tr><tr><td>0x58</td><td>pop2</td><td></td><td>从栈顶弹出两个字长的数据。</td></tr><tr><td>0x59</td><td>dup</td><td></td><td>复制栈顶一个字长的数据，将复制后的数据压栈。</td></tr><tr><td>0x5a</td><td>dup_x1</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。</td></tr><tr><td>0x5b</td><td>dup_x2</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5c</td><td>dup2</td><td></td><td>复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。</td></tr><tr><td>0x5d</td><td>dup2_x1</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5e</td><td>dup2_x2</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。</td></tr><tr><td>0x5f</td><td>swap</td><td></td><td>交换栈顶两个字长的数据的位置。Java指令中没有提供以两个字长为单位的交换指令。</td></tr></tbody></table><h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x86</td><td>i2f</td><td></td><td>将栈顶int类型值转换为float类型值。</td></tr><tr><td>0x85</td><td>i2l</td><td></td><td>将栈顶int类型值转换为long类型值。</td></tr><tr><td>0x87</td><td>i2d</td><td></td><td>将栈顶int类型值转换为double类型值。</td></tr><tr><td>0x8b</td><td>f2i</td><td></td><td>将栈顶float类型值转换为int类型值。</td></tr><tr><td>0x8c</td><td>f2l</td><td></td><td>将栈顶float类型值转换为long类型值。</td></tr><tr><td>0x8d</td><td>f2d</td><td></td><td>将栈顶float类型值转换为double类型值。</td></tr><tr><td>0x88</td><td>l2i</td><td></td><td>将栈顶long类型值转换为int类型值。</td></tr><tr><td>0x89</td><td>l2f</td><td></td><td>将栈顶long类型值转换为float类型值。</td></tr><tr><td>0x8a</td><td>l2d</td><td></td><td>将栈顶long类型值转换double类型值。</td></tr><tr><td>0x8e</td><td>d2i</td><td></td><td>将栈顶double类型值转换为int类型值。</td></tr><tr><td>0x90</td><td>d2f</td><td></td><td>将栈顶double类型值转换为float类型值。</td></tr><tr><td>0x8f</td><td>d2l</td><td></td><td>将栈顶double类型值转换为long类型值。</td></tr><tr><td>0x91</td><td>i2b</td><td></td><td>将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x92</td><td>i2c</td><td></td><td>将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x93</td><td>i2s</td><td></td><td>将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。</td></tr></tbody></table><h4 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x60</td><td>iadd</td><td></td><td>将栈顶两int类型数相加，结果入栈。</td></tr><tr><td>0x64</td><td>isub</td><td></td><td>将栈顶两int类型数相减，结果入栈。</td></tr><tr><td>0x68</td><td>imul</td><td></td><td>将栈顶两int类型数相乘，结果入栈。</td></tr><tr><td>0x6c</td><td>idiv</td><td></td><td>将栈顶两int类型数相除，结果入栈。</td></tr><tr><td>0x70</td><td>irem</td><td></td><td>将栈顶两int类型数取模，结果入栈。</td></tr><tr><td>0x74</td><td>ineg</td><td></td><td>将栈顶int类型值取负，结果入栈。</td></tr><tr><td>0x61</td><td>ladd</td><td></td><td>将栈顶两long类型数相加，结果入栈。</td></tr><tr><td>0x65</td><td>lsub</td><td></td><td>将栈顶两long类型数相减，结果入栈。</td></tr><tr><td>0x69</td><td>lmul</td><td></td><td>将栈顶两long类型数相乘，结果入栈。</td></tr><tr><td>0x6d</td><td>ldiv</td><td></td><td>将栈顶两long类型数相除，结果入栈。</td></tr><tr><td>0x71</td><td>lrem</td><td></td><td>将栈顶两long类型数取模，结果入栈。</td></tr><tr><td>0x75</td><td>lneg</td><td></td><td>将栈顶long类型值取负，结果入栈。</td></tr><tr><td>0x84</td><td>(wide)iinc</td><td>indexbyte，constbyte</td><td>将整数值constbyte加到indexbyte指定的int类型的局部变量中。</td></tr></tbody></table><h4 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x62</td><td>fadd</td><td></td><td>将栈顶两float类型数相加，结果入栈。</td></tr><tr><td>0x66</td><td>fsub</td><td></td><td>将栈顶两float类型数相减，结果入栈。</td></tr><tr><td>0x6a</td><td>fmul</td><td></td><td>将栈顶两float类型数相乘，结果入栈。</td></tr><tr><td>0x6e</td><td>fdiv</td><td></td><td>将栈顶两float类型数相除，结果入栈。</td></tr><tr><td>0x72</td><td>frem</td><td></td><td>将栈顶两float类型数取模，结果入栈。</td></tr><tr><td>0x76</td><td>fneg</td><td></td><td>将栈顶float类型值取反，结果入栈。</td></tr><tr><td>0x63</td><td>dadd</td><td></td><td>将栈顶两double类型数相加，结果入栈。</td></tr><tr><td>0x67</td><td>dsub</td><td></td><td>将栈顶两double类型数相减，结果入栈。</td></tr><tr><td>0x6b</td><td>dmul</td><td></td><td>将栈顶两double类型数相乘，结果入栈。</td></tr><tr><td>0x6f</td><td>ddiv</td><td></td><td>将栈顶两double类型数相除，结果入栈。</td></tr><tr><td>0x73</td><td>drem</td><td></td><td>将栈顶两double类型数取模，结果入栈。</td></tr><tr><td>0x77</td><td>dneg</td><td></td><td>将栈顶double类型值取负，结果入栈。</td></tr></tbody></table><h4 id="逻辑运算——移位运算"><a href="#逻辑运算——移位运算" class="headerlink" title="逻辑运算——移位运算"></a>逻辑运算——移位运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x78</td><td>ishl</td><td></td><td>左移int类型值。</td></tr><tr><td>0x79</td><td>lshl</td><td></td><td>左移long类型值。</td></tr><tr><td>0x7a</td><td>ishr</td><td></td><td>算术右移int类型值。</td></tr><tr><td>0x7b</td><td>lshr</td><td></td><td>算术右移long类型值。</td></tr><tr><td>0x7c</td><td>iushr</td><td></td><td>逻辑右移int类型值。</td></tr><tr><td>0x7d</td><td>lushr</td><td></td><td>逻辑右移long类型值。</td></tr></tbody></table><h4 id="逻辑运算——按位布尔运算"><a href="#逻辑运算——按位布尔运算" class="headerlink" title="逻辑运算——按位布尔运算"></a>逻辑运算——按位布尔运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x73</td><td>iand</td><td></td><td>对int类型按位与运算。</td></tr><tr><td>0x7f</td><td>land</td><td></td><td>对long类型的按位与运算。</td></tr><tr><td>0x80</td><td>ior</td><td></td><td>对int类型的按位或运算。</td></tr><tr><td>0x81</td><td>lor</td><td></td><td>对long类型的按位或运算。</td></tr><tr><td>0x82</td><td>ixor</td><td></td><td>对int类型的按位异或运算。</td></tr><tr><td>0x83</td><td>lxor</td><td></td><td>对long类型的按位异或运算。</td></tr></tbody></table><h4 id="控制流指令——条件跳转指令"><a href="#控制流指令——条件跳转指令" class="headerlink" title="控制流指令——条件跳转指令"></a>控制流指令——条件跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x99</td><td>ifeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值为0则跳转。</td></tr><tr><td>0x9a</td><td>ifne</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值不为0则跳转。</td></tr><tr><td>0x9b</td><td>iflt</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值小于0则跳转。</td></tr><tr><td>0x9e</td><td>ifle</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值小于等于0则跳转。</td></tr><tr><td>0x9d</td><td>ifgt</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值大于0则跳转。</td></tr><tr><td>0x9c</td><td>ifge</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值大于等于0则跳转。</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值相等则跳转。</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值不相等则跳转。</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前小于后则跳转。</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前小于等于后则跳转。</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前大于后则跳转。</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前大于等于后则跳转。</td></tr><tr><td>0xc6</td><td>ifnull</td><td>branchbyte1，branchbyte2</td><td>若栈顶引用值为null则跳转。</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>branchbyte1，branchbyte2</td><td>若栈顶引用值不为null则跳转。</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶两引用类型值相等则跳转。</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>branchbyte1，branchbyte2</td><td>若栈顶两引用类型值不相等则跳转。</td></tr></tbody></table><h4 id="控制流指令——比较指令"><a href="#控制流指令——比较指令" class="headerlink" title="控制流指令——比较指令"></a>控制流指令——比较指令</h4><table><thead><tr><th>0x94</th><th>lcmp</th><th></th><th>比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。</th></tr></thead><tbody><tr><td>0x95</td><td>fcmpl</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x96</td><td>fcmpg</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x97</td><td>dcmpl</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x98</td><td>dcmpg</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr></tbody></table><h4 id="控制流指令——无条件跳转指令"><a href="#控制流指令——无条件跳转指令" class="headerlink" title="控制流指令——无条件跳转指令"></a>控制流指令——无条件跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xa7</td><td>goto</td><td>branchbyte1，branchbyte2</td><td>无条件跳转到指定位置。</td></tr><tr><td>0xc8</td><td>goto_w</td><td>branchbyte1，branchbyte2，branchbyte3，branchbyte4</td><td>无条件跳转到指定位置（宽索引）。</td></tr></tbody></table><h4 id="控制流指令——表跳转指令"><a href="#控制流指令——表跳转指令" class="headerlink" title="控制流指令——表跳转指令"></a>控制流指令——表跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xaa</td><td>tableswitch</td><td>&lt;0-3bytepad&gt;,<br>defaultbyte1,<br>defaultbyte2,<br>defaultbyte3,<br>defaultbyte4,<br>lowbyte1,<br>lowbyte2,<br>lowbyte3,<br>lowbyte4,<br>highbyte1,<br>highbyte2,<br>highbyte3,<br>highbyte4,<br>jump offsets…</td><td>通过索引访问跳转表，并跳转。</td></tr><tr><td>0xab</td><td>lookupswitch</td><td>&lt;0-3bytepad&gt;,<br>defaultbyte1,<br>defaultbyte2,<br>defaultbyte3,<br>defaultbyte4,<br>npairs1,<br>npairs2,<br>npairs3,<br>npairs4,<br>match offsets</td><td>通过键值访问跳转表，并跳转。</td></tr></tbody></table><h4 id="控制流指令——异常和finally"><a href="#控制流指令——异常和finally" class="headerlink" title="控制流指令——异常和finally"></a>控制流指令——异常和finally</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbf</td><td>athrow</td><td></td><td>抛出异常。</td></tr><tr><td>0xa8</td><td>jsr</td><td>branchbyte1,<br>branchbyte2</td><td>跳转到子例程序。</td></tr><tr><td>0xc9</td><td>jsr_w</td><td>branchbyte1,<br>branchbyte2,<br>branchbyte3,<br>branchbyte4</td><td>跳转到子例程序（宽索引）。</td></tr><tr><td>0xa9</td><td>(wide)ret</td><td>indexbyte</td><td>返回子例程序。</td></tr></tbody></table><h4 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbb</td><td>new</td><td>indexbyte1,indexbyte2</td><td>创建新的对象实例。</td></tr><tr><td>0xc0</td><td>checkcast</td><td>indexbyte1,indexbyte2</td><td>类型强转。</td></tr><tr><td>0xc1</td><td>instanceof</td><td>indexbyte1,indexbyte2</td><td>判断类型。</td></tr><tr><td>0xb4</td><td>getfield</td><td>indexbyte1,indexbyte2</td><td>获取对象字段的值。</td></tr><tr><td>0xb5</td><td>putfield</td><td>indexbyte1,indexbyte2</td><td>给对象字段赋值。</td></tr><tr><td>0xb2</td><td>getstatic</td><td>indexbyte1,indexbyte2</td><td>获取静态字段的值。</td></tr><tr><td>0xb3</td><td>putstatic</td><td>indexbyte1,indexbyte2</td><td>给静态字段赋值。</td></tr></tbody></table><h4 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbc</td><td>newarray</td><td>atype</td><td>创建type类型的数组。</td></tr><tr><td>0xbd</td><td>anewarray</td><td>indexbyte1,indexbyte2</td><td>创建引用类型的数组。</td></tr><tr><td>0xbe</td><td>arraylength</td><td></td><td>获取一维数组的长度。</td></tr><tr><td>0xc5</td><td>multianewarray</td><td>indexbyte1,indexbyte2,dimension</td><td>创建dimension维度的数组。</td></tr></tbody></table><h4 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xb7</td><td>invokespecial</td><td>indexbyte1,indexbyte2</td><td>编译时方法绑定调用方法。</td></tr><tr><td>0xb6</td><td>invokevirtual</td><td>indexbyte1,indexbyte2</td><td>运行时方法绑定调用方法。</td></tr><tr><td>0xb8</td><td>invokestatic</td><td>indexbyte1,indexbyte2</td><td>调用静态方法。</td></tr><tr><td>0xb9</td><td>invokeinterface</td><td>indexbyte1,indexbyte2,count,0</td><td>调用接口方法。</td></tr></tbody></table><h4 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xac</td><td>ireturn</td><td></td><td>返回int类型值。</td></tr><tr><td>0xad</td><td>lreturn</td><td></td><td>返回long类型值。</td></tr><tr><td>0xae</td><td>freturn</td><td></td><td>返回float类型值。</td></tr><tr><td>0xaf</td><td>dreturn</td><td></td><td>返回double类型值。</td></tr><tr><td>0xb0</td><td>areturn</td><td></td><td>返回引用类型值。</td></tr><tr><td>0xb1</td><td>return</td><td></td><td>void函数返回。</td></tr></tbody></table><h4 id="线程同步指令"><a href="#线程同步指令" class="headerlink" title="线程同步指令"></a>线程同步指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xc2</td><td>monitorenter</td><td></td><td>进入并获得对象监视器。</td></tr><tr><td>0xc3</td><td>monitorexit</td><td></td><td>释放并退出对象监视器。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      AVA字节码指令
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="指令" scheme="http://www.baiyp.ren/categories/jvm/%E6%8C%87%E4%BB%A4/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="指令" scheme="http://www.baiyp.ren/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式的六大原则</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式的六大原则.html</id>
    <published>2019-08-29T01:42:30.000Z</published>
    <updated>2019-08-30T03:18:19.015Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式的六大原则"><a href="#JAVA设计模式的六大原则" class="headerlink" title="JAVA设计模式的六大原则"></a>JAVA设计模式的六大原则</h2><p><img src="../images/design-patterns/designpatterns01.png" alt></p><h3 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h3><blockquote><p><strong>开闭原则，对于扩展是开放的，对于修改是关闭。</strong></p></blockquote><p><img src="../images/design-patterns/designpatterns02.png" alt></p><p>​ 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><p>​ 可以通过“<strong>抽象约束、封装变化</strong>”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>​ 开闭原则无非就是想表达这样一层意思：<strong>用抽象构建框架，用实现扩展细节</strong>。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p><p>开闭原则的好处是：</p><ul><li>由于对于软件原来的模块不需要修改，因此不担心软件的稳定性。</li><li>对软件进行扩展，加入新的功能，这样，这个软件就可以通过不断地增加新模块满足不断变化的新需求。</li></ul><h4 id="和其他原则的关系"><a href="#和其他原则的关系" class="headerlink" title="和其他原则的关系"></a>和其他原则的关系</h4><blockquote><p>开闭原则具有理想主义的色彩，它是面向对象设计的终极目标</p></blockquote><p>​ 因此，针对开闭原则的实现方法，一直都有面向对象设计的大师费尽心机，研究开闭原则的实现方式。后面要提到的里氏替换原则（LSP）、依赖倒转原则（DIP）、接口隔离原则（ISP）以及抽象类（Abstract Class）、接口(Interface)等等，都可以看作是开闭原则的实现方法。</p><h3 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h3><blockquote><p>就一个类而言，应该仅有一个引起它变化的原因（一个类只负责一项职责）</p></blockquote><p><img src="../images/design-patterns/designpatterns07.png" alt></p><p>为什么要使用单一职责原则：</p><p>​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计。</p><p>优点：</p><ul><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li><li>提高类的可读性，提高系统的可维护性；</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><h3 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h3><blockquote><ul><li><p>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</p></li><li><p>子类中可以增加自己特有的方法。</p></li><li><p>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</p></li><li><p>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p></li></ul></blockquote><p><img src="../images/design-patterns/designpatterns06.png" alt></p><p>​ 里氏代换原则是对“<strong>开闭</strong>”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p>​ 简单的理解为一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类都替换成它的子类，程序的行为没有变化。</p><p>但是反过来的代换却不成立，一个软件实体如果使用的是一个子类的话，那么它不能适用于其父类。</p><p>例如：</p><p>​ 在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅却不能继承鸟。在面向对象设计时，子类拥有父类所有非private的行为和属性，鸟会飞，但企鹅不会飞，所以企鹅不能继承鸟类。</p><p><strong>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p><h3 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h3><blockquote><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul></blockquote><p><img src="../images/design-patterns/designpatterns05.jpg" alt></p><p><strong>也可以说高层模块，低层模块，细节都应该依赖抽象</strong></p><p>​ 依赖倒转其实就是谁也不要依靠谁，除了约定的接口，大家都可以灵活自如。依赖倒转可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。如果设计的各个部件或类相互依赖，这样就是耦合度高，难以维护和扩展，这也就体现不出面向对象的好处了。</p><p>​ 赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>​ <strong>依赖倒置原则的中心思想是面向接口编程</strong>，传递依赖关系有三种方式，以上的说的是是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p><p><strong>DIP的好处：</strong> 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</p><p>在实际编程中，我们一般需要做到如下3点：</p><ul><li><p><strong>低层模块尽量都要有抽象类或接口，或者两者都有。</strong></p></li><li><p><strong>变量的声明类型尽量是抽象类或接口。</strong></p></li><li><p><strong>使用继承时遵循里氏替换原则。</strong></p></li></ul><h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h3><blockquote><ul><li>客户端不应该依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ul></blockquote><p><img src="../images/design-patterns/designpatterns04.jpg" alt></p><p>​ 接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>​ 说到这里，很多人会觉的接口隔离原则跟单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ol><li><p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</p></li><li><p>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</p></li><li><p>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p></li></ol><p><strong>好处:</strong></p><p>​ 现在我们知道，接口隔离原则的要点，就是要细化我们的接口。那么这样做具体有什么好处呢？主要有四个好处，分别是：</p><ol><li>避免接口污染；</li><li>提高灵活性；</li><li>提供定制服务；</li><li>实现高内聚。</li></ol><h3 id="迪米特法则（Law-Of-Demeter）"><a href="#迪米特法则（Law-Of-Demeter）" class="headerlink" title="迪米特法则（Law Of Demeter）"></a>迪米特法则（Law Of Demeter）</h3><blockquote><p>一个对象应该对其他对象保持最少的了解</p></blockquote><p><img src="../images/design-patterns/designpatterns03.jpg" alt></p><p>​ <strong>迪米特法则的意义在于降低类之间的耦合</strong>。由于每个对象尽量减少对其他对象的了解，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>​ 迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。</p><p>​ 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p><p>模式中的<strong>外观模式</strong>和<strong>中介模式</strong>就是迪米特法则的实现</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式的六大原则
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式06-模板模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式06.html</id>
    <published>2019-08-29T01:42:30.000Z</published>
    <updated>2019-09-05T10:28:05.539Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-模板模式（Template-Pattern）"><a href="#JAVA设计模式-模板模式（Template-Pattern）" class="headerlink" title="JAVA设计模式-模板模式（Template Pattern）"></a>JAVA设计模式-模板模式（Template Pattern）</h2><p><img src="../images/design-patterns/templatepattern01.jpg" alt></p><h3 id="什么是模板模式"><a href="#什么是模板模式" class="headerlink" title="什么是模板模式"></a>什么是模板模式</h3><p>​ 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>​ 使用了JAVA的继承机制，在抽象类中定义一个模板方法，该方法引用了若干个抽象方法（由子类实现）或具体方法（子类可以覆盖重写）；</p><p>​ 其实就是JAVA的继承以及抽象方法、重写覆盖的使用；</p><p>​ <strong>注意</strong>：为防止恶意操作，一般模板方法都加上 final 关键词</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><p>AbstractClass（抽象模板）：定义了一个模板方法和若干抽象方法和具体方法，</p></li><li><p>ConcreteClass（具体模板）：继承抽象模板类并实现抽象方法</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>封装不变部分，扩展可变部分。</li><li>提取公共代码，便于维护。</li><li>行为由父类控制，子类实现。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>多个子类有公有的方法,而且逻辑基本相同时.</p></li><li><p>重要,复杂的算法,可以把核心算法设计为模板方法,周边的相关细节功能由各个子类实现.</p></li><li><p>重构时,模板方法模式是一个经常使用的模式,把相同的代码抽取到父类中,庵后通过函数约束其行为。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>我们将创建一个定义操作的 <em>Game</em> 抽象类，其中，模板方法设置为 final，这样它就不会被重写。<em>Cricket</em> 和 <em>Football</em> 是扩展了 <em>Game</em> 的实体类，它们重写了抽象类的方法。</p><p><em>TemplatePatternDemo*，我们的演示类使用 *Game</em> 来演示模板模式的用法。</p></blockquote><h4 id="创建一个抽象类"><a href="#创建一个抽象类" class="headerlink" title="创建一个抽象类"></a>创建一个抽象类</h4><blockquote><p>它的模板方法被设置为 final。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//模板</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//初始化游戏</span></span><br><span class="line">      initialize();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//开始游戏</span></span><br><span class="line">      startPlay();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//结束游戏</span></span><br><span class="line">      endPlay();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建扩展的子类"><a href="#创建扩展的子类" class="headerlink" title="创建扩展的子类"></a>创建扩展的子类</h4><h5 id="Cricket-类"><a href="#Cricket-类" class="headerlink" title="Cricket 类"></a>Cricket 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Initialized! Start playing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Started. Enjoy the game!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Football-类"><a href="#Football-类" class="headerlink" title="Football 类"></a>Football 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Initialized! Start playing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Started. Enjoy the game!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      Game game = <span class="keyword">new</span> Cricket();</span><br><span class="line">      game.play();</span><br><span class="line">      System.out.println();</span><br><span class="line">      game = <span class="keyword">new</span> Football();</span><br><span class="line">      game.play();      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之模板模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板模式" scheme="http://www.baiyp.ren/tags/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的伪共享与缓存行</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%AB.html"/>
    <id>http://www.baiyp.ren/JAVA中的伪共享.html</id>
    <published>2019-08-28T07:33:17.000Z</published>
    <updated>2019-09-07T09:07:49.684Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的伪共享"><a href="#JAVA中的伪共享" class="headerlink" title="JAVA中的伪共享"></a>JAVA中的伪共享</h2><p><img src="../images/thread/cacheline/cacheline06.png" alt></p><h3 id="Java中的伪共享"><a href="#Java中的伪共享" class="headerlink" title="Java中的伪共享"></a>Java中的伪共享</h3><p>​ 解决伪共享最直接的方法就是填充（padding），例如下面的VolatileLong，一个long占8个字节，Java的对象头占用8个字节（32位系统）或者12字节（64位系统，默认开启对象头压缩，不开启占16字节）。一个缓存行64字节，那么我们可以填充6个long（6 * 8 = 48 个字节）。</p><p>​ 现在，我们学习JVM对象的内存模型。所有的Java对象都有8字节的对象头，前四个字节用来保存对象的哈希码和锁的状态，前3个字节用来存储哈希码，最后一个字节用来存储锁状态，一旦对象上锁，这4个字节都会被拿出对象外，并用指针进行链接。剩下4个字节用来存储对象所属类的引用。对于数组来讲，还有一个保存数组大小的变量，为4字节。每一个对象的大小都会对齐到8字节的倍数，不够8字节部分需要填充。为了保证效率，Java编译器在编译Java对象的时候，通过字段类型对Java对象的字段进行排序，如下表所示。</p><table><thead><tr><th>顺序</th><th>类型</th><th>字节数量</th></tr></thead><tbody><tr><td>1</td><td>double</td><td>8字节</td></tr><tr><td>2</td><td>long</td><td>8字节</td></tr><tr><td>3</td><td>int</td><td>4字节</td></tr><tr><td>4</td><td>float</td><td>4字节</td></tr><tr><td>5</td><td>short</td><td>2字节</td></tr><tr><td>6</td><td>char</td><td>2字节</td></tr><tr><td>7</td><td>boolean</td><td>1字节</td></tr><tr><td>8</td><td>byte</td><td>1字节</td></tr><tr><td>9</td><td>对象引用</td><td>4字节或者8字节</td></tr><tr><td>10</td><td>子类字段</td><td>重新排序</td></tr></tbody></table><p>​ 因此，我们可以在任何字段之间通过填充长整型的变量把热点变量隔离在不同的缓存行中，通过减少伪同步，在多核心CPU中能够极大的提高效率。</p><h4 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存行填充父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataPadding</span> </span>&#123;</span><br><span class="line">    <span class="comment">//填充 6个long类型字段 8*4 = 48 个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">    <span class="comment">//需要操作的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为JDK1.7以后就自动优化代码会删除无用的代码，在JDK1.7以后的版本这些不生效了。</p><h4 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存行填充父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataPadding</span> </span>&#123;</span><br><span class="line">    <span class="comment">//填充 6个long类型字段 8*4 = 48 个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承缓存填充类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承DataPadding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileData</span> <span class="keyword">extends</span> <span class="title">DataPadding</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 占用 8个字节 +48 + 对象头 = 64字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolatileData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolatileData</span><span class="params">(<span class="keyword">long</span> defValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = defValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">accumulationAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//因为单线程操作不需要加锁</span></span><br><span class="line">         data++;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在JDK1.8中是可以使用的</p><h4 id="Contended注解"><a href="#Contended注解" class="headerlink" title="@Contended注解"></a>@Contended注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Contended &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ Contended注解可以用于类型上和属性上，加上这个注解之后虚拟机会自动进行填充，从而避免伪共享。这个注解在Java8 ConcurrentHashMap、ForkJoinPool和Thread等类中都有应用。我们来看一下Java8中ConcurrentHashMap中如何运用Contended这个注解来解决伪共享问题。以下说的ConcurrentHashMap都是Java8版本。</p><p><strong>注意</strong>：在Java8中提供了<strong>@sun.misc.Contended</strong>来避免伪共享时，在运行时需要设置JVM启动参数<strong>-XX:-RestrictContended</strong>否则可能不生效。</p><h3 id="缓存行填充的威力"><a href="#缓存行填充的威力" class="headerlink" title="缓存行填充的威力"></a>缓存行填充的威力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存行测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用缓存行填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDataPadding = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常定义的变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过缓存行填充的变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataX = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataY = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataZ = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> size = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算耗时</span></span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//使用缓存行填充的方式</span></span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataX.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不使用缓存行填充的方式 因为时单线程操作不需要加锁</span></span><br><span class="line">                value = (++x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//打印耗时</span></span><br><span class="line">        System.out.println(<span class="string">"耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataY.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = ++y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(<span class="string">"耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataZ.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = ++z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(<span class="string">"耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        CacheLineTest cacheRowTest = <span class="keyword">new</span> CacheLineTest();</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//启动三个线程个调用他们各自的方法</span></span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationX());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationY());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationZ());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不使用缓存行填充测试"><a href="#不使用缓存行填充测试" class="headerlink" title="不使用缓存行填充测试"></a>不使用缓存行填充测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否启用缓存行填充</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDataPadding = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">7960</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">7984</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">7989</span></span><br></pre></td></tr></table></figure><h4 id="使用缓存行填充测试"><a href="#使用缓存行填充测试" class="headerlink" title="使用缓存行填充测试"></a>使用缓存行填充测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否启用缓存行填充</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDataPadding = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">176</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">178</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">182</span></span><br></pre></td></tr></table></figure><p>同样的结构他们之间差了 将近 50倍的速度差距</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ 当多个线程同时对共享的缓存行进行写操作的时候，因为缓存系统自身的缓存一致性原则，会引发伪共享问题，解决的常用办法是将共享变量根据缓存行大小进行补充对齐，使其加载到缓存时能够独享缓存行，避免与其他共享变量存储在同一个缓存行。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的伪共享与缓存行
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="伪共享" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="伪共享" scheme="http://www.baiyp.ren/tags/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>伪共享与缓存行</title>
    <link href="http://www.baiyp.ren/%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C.html"/>
    <id>http://www.baiyp.ren/伪共享与缓存行.html</id>
    <published>2019-08-28T07:33:17.000Z</published>
    <updated>2019-09-07T09:07:49.686Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="伪共享与缓存行"><a href="#伪共享与缓存行" class="headerlink" title="伪共享与缓存行"></a>伪共享与缓存行</h2><h3 id="CPU缓存架构"><a href="#CPU缓存架构" class="headerlink" title="CPU缓存架构"></a>CPU缓存架构</h3><p>CPU 是计算机的心脏，所有运算和程序最终都要由它来执行。</p><p>主内存（RAM）是数据存放的地方，CPU 和主内存之间有好几级缓存，因为即使直接访问主内存也是非常慢的。</p><p>CPU的速度要远远大于内存的速度，为了解决这个问题，CPU引入了三级缓存：L1，L2和L3三个级别，L1最靠近CPU，L2次之，L3离CPU最远，L3之后才是主存。速度是L1&gt;L2&gt;L3&gt;主存。越靠近CPU的容量越小。CPU获取数据会依次从三级缓存中查找。</p><p><img src="../images/thread/cacheline/cpu01.jpg" alt></p><p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取，由此可见一级缓存是整个CPU缓存架构中最为重要的部分。<br><img src="../images/thread/cacheline/cpu02.jpg" alt></p><p>下表是一些缓存未命中的消耗数据：</p><table><thead><tr><th>从CPU到</th><th>大约需要的CPU周期</th><th>大约需要的时间</th></tr></thead><tbody><tr><td>主存</td><td></td><td>约60-80ns</td></tr><tr><td>QPI总线</td><td></td><td>约20ns</td></tr><tr><td>L3 cache</td><td>约40-45cycles</td><td>约15ns</td></tr><tr><td>L2 cache</td><td>约10cycles</td><td>约3ns</td></tr><tr><td>L1 cache</td><td>约3-4cycles</td><td>约1ns</td></tr><tr><td>寄存器</td><td>1cycle</td><td></td></tr></tbody></table><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><h4 id="缓存行状态"><a href="#缓存行状态" class="headerlink" title="缓存行状态"></a>缓存行状态</h4><p>CPU的缓存是以缓存行(cache line)为单位的，MESI协议描述了多核处理器中一个缓存行的状态。在MESI协议中，每个缓存行有4个状态，分别是：</p><ul><li>M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；</li><li>E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；</li><li>S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；</li><li>I（无效，Invalid）：缓存行失效, 不能使用。</li></ul><p>缓存行的E状态如下图：</p><p><img src="../images/thread/cacheline/cacheline01.png" alt></p><p>此时只有core1访问缓存行，它的缓存行的状态为E，表示core1独占。</p><p>缓存行的S状态如下图：</p><p><img src="../images/thread/cacheline/cacheline02.png" alt></p><p>此时core1和core2都会访问缓存行，他们的缓存行状态为S，表示缓存行处于共享状态。</p><p>缓存行的M和I状态如下图：</p><p><img src="../images/thread/cacheline/cacheline03.png" alt></p><p>此时core1修改了缓存行，因此core1的缓存行状态为M，代表已经修改，而core2的缓存行状态为I，代表已经失效，需要从主存中读取。</p><h3 id="缓存行状态转换"><a href="#缓存行状态转换" class="headerlink" title="缓存行状态转换"></a>缓存行状态转换</h3><p>​ 在MESI协议中，每个Cache的Cache控制器不仅知道自己的读写操作，而且也监听(snoop)其它Cache的读写操作。每个Cache line所处的状态根据本核和其它核的读写操作在4个状态间进行迁移。MESI协议状态迁移图如下：</p><p><img src="../images/thread/cacheline/cacheline04.png" alt></p><p>初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。</p><p>本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。</p><p>本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）</p><p>远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。</p><p>远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。</p><h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>​ CPU缓存是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节，并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。下图是一个CPU缓存行的示意图：</p><p><img src="../images/thread/cacheline/cacheline07.png" alt></p><p>上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。</p><p>表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p><h3 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h3><p>​ 计算机系统中为了解决主内存与CPU运行速度的差距，在CPU与主内存之间添加了一级或者多级高速缓冲存储器（Cache），这个Cache一般是集成到CPU内部的，所以也叫 CPU Cache，如下图是两级cache结构：</p><p><img src="../images/thread/cacheline/cpu03.jpg" alt></p><p>Cache内部是按行存储的，其中每一行称为一个cache行，cache行是Cache与主内存进行数据交换的单位，cache行的大小一般为2的幂次数字节。</p><p><img src="../images/thread/cacheline/cacheline05.png" alt></p><p>​ 当CPU访问某一个变量时候，首先会去看CPU Cache内是否有该变量，如果有则直接从中获取，否者就去主内存里面获取该变量，然后把该变量所在内存区域的一个Cache行大小的内存拷贝到Cache（cache行是Cache与主内存进行数据交换的单位）。由于存放到Cache行的的是内存块而不是单个变量，所以可能会把多个变量存放到了一个cache行。当多个线程同时修改一个缓存行里面的多个变量时候，由于同时只能有一个线程操作缓存行，所以相比每个变量放到一个缓存行性能会有所下降，这就是伪共享。</p><p><img src="../images/thread/cacheline/cacheline06.png" alt></p><p>​ 如上图变量x,y同时被放到了CPU的一级和二级缓存，当线程1使用CPU1对变量x进行更新时候，首先会修改cpu1的一级缓存变量x所在缓存行，这时候缓存一致性协议会导致cpu2中变量x对应的缓存行失效，那么线程2写入变量x的时候就只能去二级缓存去查找，这就破坏了一级缓存，而一级缓存比二级缓存更快。更坏的情况下如果cpu只有一级缓存，那么会导致频繁的直接访问主内存。</p><h4 id="为何会出现伪共享"><a href="#为何会出现伪共享" class="headerlink" title="为何会出现伪共享"></a>为何会出现伪共享</h4><p>​ 伪共享的产生是因为多个变量被放入了一个缓存行，并且多个线程同时去写入缓存行中不同变量。那么为何多个变量会被放入一个缓存行那。其实是因为Cache与内存交换数据的单位就是Cache，当CPU要访问的变量没有在Cache命中时候，根据程序运行的局部性原理会把该变量在内存中大小为Cache行的内存放如缓存行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure><p>​ 如上代码，声明了四个long变量，假设cache行的大小为32个字节，那么当cpu访问变量a时候发现该变量没有在cache命中，那么就会去主内存把变量a以及内存地址附近的b,c,d放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中，当创建数组时候，数组里面的多个元素就会被放入到同一个缓存行。那么单线程下多个变量放入缓存行对性能有影响？其实正常情况下单线程访问时候由于数组元素被放入到了一个或者多个cache行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      伪共享与缓存行
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="伪共享" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="伪共享" scheme="http://www.baiyp.ren/tags/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式05-装饰器模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F05.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式05.html</id>
    <published>2019-08-27T01:42:30.000Z</published>
    <updated>2019-09-05T10:28:13.423Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-装饰器模式（Decorator-Pattern）"><a href="#JAVA设计模式-装饰器模式（Decorator-Pattern）" class="headerlink" title="JAVA设计模式-装饰器模式（Decorator Pattern）"></a>JAVA设计模式-装饰器模式（Decorator Pattern）</h2><blockquote><p><strong>装饰器模式(Decorator Pattern)，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更灵活。 —-《大话设计模式》</strong></p></blockquote><p><img src="../images/design-patterns/decoratorpattern01.jpg" alt></p><h3 id="什么是装饰器模式"><a href="#什么是装饰器模式" class="headerlink" title="什么是装饰器模式"></a>什么是装饰器模式</h3><p>​ 允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>​ 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>Component（抽象构件）：给出一个抽象接口，装饰器模式中公共方法的类，在装饰器模式结构图的顶层，以规范准备接收附加责任的对象。</li><li>ConcreteComponent（具体构件）：是要动态扩展的对象，转换器模式中具体的被装饰的类，它继承自Component。</li><li>Decorator（装饰器）：持有一个构件(Component)对象的实例，它是装饰器模式中的核心对象，所有具体装饰器对象的父类，完成装饰器的部分职能。可以只对被装饰的对象进行一些简单的包裹，也可包含对Component中方法的实现。</li><li>ConcreteDecorator（具体装饰）：完成具体的装饰功能。装饰功能的实现是通过调用被装饰对象对应的方法，加上装饰对象自身的方法。这是装饰器模式动机中的添加额外功能的关键。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”或者除掉一个“装饰”，继承关系是静态的，它在系统运行前就决定了；</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合；</li><li>装饰者类可以在被装饰者的行为前面或后面加上自己的行为，甚至取代被装饰者的行为，达到特定的目的；</li><li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>多层装饰比较复杂。</li><li>由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>运行时，你需要动态地为对象增加额外职责时；</li><li>当你需要一个能够代替子类的类，借助它提供额外方法时。</li><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；</li><li>处理那些可以撤销的职责；</li><li>当不能采用生成子类的方式进行扩充时。</li></ul><h3 id="装饰器模式与适配器模式的比较"><a href="#装饰器模式与适配器模式的比较" class="headerlink" title="装饰器模式与适配器模式的比较"></a>装饰器模式与适配器模式的比较</h3><p>共同点：都拥有一个目标对象。装饰器通过包装一个装饰对象来扩展其功能，而又不改变其接口，这实际上是基于对象的适配器模式的一种变种。<br>不同点：适配器模式需要实现另外一个接口，而装饰器模式必须实现该对象的接口。适配器模式主要是为了接口的转换，而装饰者模式关注的是通过组合来动态的为被装饰者注入新的功能或行为(即所谓的责任)。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>假设我去买咖啡，首先服务员给我冲了一杯原味咖啡，我希望服务员给我加些牛奶和白糖混合入原味咖啡中。使用装饰器模式就可以解决这个问题。</p></blockquote><h4 id="咖啡接口"><a href="#咖啡接口" class="headerlink" title="咖啡接口"></a>咖啡接口</h4><blockquote><p>定义了获取花费和配料的接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取咖啡</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原味咖啡"><a href="#原味咖啡" class="headerlink" title="原味咖啡"></a>原味咖啡</h4><blockquote><p>实现Coffe接口，花费1元，配料中，只有咖啡</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原味咖啡类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OriginalCoffee</span> <span class="keyword">implements</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"原味咖啡"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h4><blockquote><p>咖啡对象的装饰器类，同样实现Coffee接口，定义一个Coffe对象的引用，在构造器中进行初始化。并且将getPrice（）和getCoffee()方法转发给被装饰对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡的"装饰器"，可以给咖啡添加各种"配料"</span></span><br><span class="line"><span class="comment"> * 该类是一个抽象类需要具体子类来实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorAbstractCoffee</span> <span class="keyword">implements</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体咖啡的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span>  Coffee coffee;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，初始化咖啡对象的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coffee</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorAbstractCoffee</span><span class="params">(Coffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取价格，装饰器父类中直接转发"请求"至引用对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取咖啡，装饰器父类中直接转发"请求"至引用对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体的装饰器类"><a href="#具体的装饰器类" class="headerlink" title="具体的装饰器类"></a>具体的装饰器类</h4><h5 id="添加牛奶"><a href="#添加牛奶" class="headerlink" title="添加牛奶"></a>添加牛奶</h5><blockquote><p>具体的装饰器类，负责往咖啡中“添加”牛奶，注意看getPrice（）方法和getCoffee()方法，可以在转发请求之前或者之后，增加功能。如果是代理模式，这里的结构就有所不同，通常代理模式根据运行时的条件来判断是否转发请求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 混合牛奶到蜂蜜中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreamCoffee</span> <span class="keyword">extends</span> <span class="title">DecoratorAbstractCoffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = (<span class="keyword">float</span>) <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用父类的构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coffee</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreamCoffee</span><span class="params">(Coffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加配料需要加钱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getPrice()+price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对咖啡进行加工</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCoffee()+<span class="string">"；添加牛奶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加糖"><a href="#添加糖" class="headerlink" title="添加糖"></a>添加糖</h5><blockquote><p>另一个具体装饰器类，用来给咖啡加蜂蜜，一样的逻辑。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoneyCoffee</span> <span class="keyword">extends</span> <span class="title">DecoratorAbstractCoffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = (<span class="keyword">float</span>) <span class="number">1.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoneyCoffee</span><span class="params">(Coffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getPrice()+price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCoffee()+<span class="string">"；添加蜂蜜"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是不是很像 javaIO中的 stream流</span></span><br><span class="line">        Coffee coffee = <span class="keyword">new</span> CreamCoffee(<span class="keyword">new</span> HoneyCoffee(<span class="keyword">new</span> OriginalCoffee()));</span><br><span class="line">        System.out.println(coffee.getCoffee());</span><br><span class="line">        System.out.println(coffee.getPrice());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ 装饰器模式是代替增加子类的一种解决方案，体现了聚合/合成复用原则的思想，尽量使用组合的方式来扩展功能，这样就把基本功能和扩展功能解耦了，使得代码可复用，可维护，灵活。关键点在于装饰器模式可以动态地为对象增加扩展功能。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之装饰器模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰器模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰器模式" scheme="http://www.baiyp.ren/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的线程安全</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.html"/>
    <id>http://www.baiyp.ren/JAVA中的线程安全.html</id>
    <published>2019-08-26T07:33:17.000Z</published>
    <updated>2019-09-07T09:07:49.682Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 08 2019 20:00:31 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的线程安全"><a href="#JAVA中的线程安全" class="headerlink" title="JAVA中的线程安全"></a>JAVA中的线程安全</h2><p><img src="../images/thread/safe/threadsafety01.jpg" alt></p><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>​ 指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行程序时出现意外结果。</p><p>线程不安全：是指不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p><h3 id="线程安全的解决方案"><a href="#线程安全的解决方案" class="headerlink" title="线程安全的解决方案"></a>线程安全的解决方案</h3><h4 id="栈封闭（局部变量）"><a href="#栈封闭（局部变量）" class="headerlink" title="栈封闭（局部变量）"></a>栈封闭（局部变量）</h4><p>​ 栈限制是线程封闭的一种特例，只能通过局部变量才可以访问对象，局部使对象限制在执行线程中，存在于执行线程栈，其他线程无法访问这个栈，从而确保线程安全。（每一个线程都有一个工作内存，工作内存中班包括有栈，局部的基本类型变量是处于栈中，引用类型的引用处于栈中，而引用指向的对象处于堆中）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//x,y 传递进来，因为x，y都是基本数据类型作为变量副本传递过来</span></span><br><span class="line">        <span class="comment">//z变量被封闭在了方法内部</span></span><br><span class="line">        <span class="keyword">int</span> z = x + y;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无状态（No-State）"><a href="#无状态（No-State）" class="headerlink" title="无状态（No State）"></a>无状态（No State）</h4><blockquote><p>如果一个类的同一个实例被多个线程共享并不会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为<strong>无状态对象</strong>；反之，如果一个类的同一个实例被多个线程共享，会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为<strong>有状态对象</strong></p></blockquote><p>无状态对象不包含任何实例变量，且不包含任何静态变量或者其包含的静态变量都是只读的（常量）</p><p>​ 即使一个类不包含任何实例变量或者静态变量，执行该类方法的多个线程也仍然可能存在共享状态；因为类方法中可能存在的实例对象中包含有静态变量或实例变量。此时就需要在方法中加锁来保障</p><p>​ 当多个线程访问相同的实例或静态变量时，必须以某种方式来协调对此变量的访问。最简单的方法就是避免使用实例或静态变量。对于没有实例变量的类，它的方法只使用局部变量和方法参数</p><p>以下示例显示了java.lang.Math类的其中一部分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subtractExact</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = x - y;</span><br><span class="line">    <span class="comment">// HD 2-12 Overflow iff the arguments have different signs and</span></span><br><span class="line">    <span class="comment">// the sign of the result is different than the sign of x</span></span><br><span class="line">    <span class="keyword">if</span> (((x ^ y) &amp; (x ^ r)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"integer overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>​ 使用volatile可以保证变量的可见性与有序性，但是volatile不能保证线程的安全性，适合于一写多读的场景。</p><h4 id="加锁与CAS"><a href="#加锁与CAS" class="headerlink" title="加锁与CAS"></a>加锁与CAS</h4><p>​ 通过加内置锁 synchronize或者 显示锁Lock可以解决线程同步问题，但是线程比较多的情况下会产生上下文切花问题，对于变量的同步可以使用CAS原子操作。</p><h4 id="安全的发布"><a href="#安全的发布" class="headerlink" title="安全的发布"></a>安全的发布</h4><h4 id="TheadLocal"><a href="#TheadLocal" class="headerlink" title="TheadLocal"></a>TheadLocal</h4><p>使用ThreadLocal 来进行线程的隔离，因为TheadLocal都保存这线程对象的副本，所以可以避免线程安全问题。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的线程安全
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程安全" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="并发安全" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="线程安全" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
</feed>
