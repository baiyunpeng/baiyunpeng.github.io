<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓风残月的博客</title>
  
  <subtitle>晓风残月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baiyp.ren/"/>
  <updated>2019-09-21T10:13:45.667Z</updated>
  <id>http://www.baiyp.ren/</id>
  
  <author>
    <name>晓风残月</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MYBATIS源码解析-代理封装</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-06%E4%BB%A3%E7%90%86%E5%B0%81%E8%A3%85.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-06代理封装.html</id>
    <published>2019-09-20T08:58:57.000Z</published>
    <updated>2019-09-21T10:13:45.667Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:36 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS代理封装"><a href="#MYBATIS代理封装" class="headerlink" title="MYBATIS代理封装"></a>MYBATIS代理封装</h2><h3 id="binding模块"><a href="#binding模块" class="headerlink" title="binding模块"></a>binding模块</h3><p><img src="../images/mybatis/proxy01.png" alt></p><p>​ 这个模块有四个类，这四个类是层层调用的关系，对外的是MapperRegistry，映射器注册器。它会被Configuration类直接调用，用于将用户自定义的映射器全部注册到注册器中，而这个注册器显而易见会保存在Configuration实例中备用。</p><p>​ 其实看到这个名称，我们就会想起之前解析的类型别名注册器与类型处理器注册器，其实他们之间的目的差不多，就是注册的内容不同罢了，映射器注册器注册的是MyBatis使用者自定义的各种映射器。</p><h3 id="MapperRegistry类"><a href="#MapperRegistry类" class="headerlink" title="MapperRegistry类"></a>MapperRegistry类</h3><blockquote><p>MapperRegistry是Mapper接口及其对应的代理对象工厂的注册中心</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 映射器注册器</span></span><br><span class="line"><span class="comment"> * 是Mapper接口及其对应的代理对象工厂的注册中心</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lasse Voss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperRegistry</span> </span>&#123;</span><br><span class="line">  <span class="comment">//mybatis全局唯一的配置对象，包含所有信息</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Configuration config;</span><br><span class="line">  <span class="comment">//mapper接口与MapperProxyFactory代理工厂之间的关系</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, MapperProxyFactory&lt;?&gt;&gt; knownMappers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperRegistry</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.config = config;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行sql语句的时候会调用这个方法获取实现了Mapper接口的代理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">getMapper</span><span class="params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory&lt;T&gt;) knownMappers.get(type);</span><br><span class="line">    <span class="keyword">if</span> (mapperProxyFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is not known to the MapperRegistry."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//创建实现了type接口的代理对象</span></span><br><span class="line">      <span class="keyword">return</span> mapperProxyFactory.newInstance(sqlSession);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Error getting mapper instance. Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包含Mapper</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">hasMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> knownMappers.containsKey(type);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mybatis初始化过程中会调用这个方法填充knownMappers集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type 类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addMapper</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//只填充接口</span></span><br><span class="line">    <span class="keyword">if</span> (type.isInterface()) &#123;</span><br><span class="line">      <span class="comment">//是否已经加载过了</span></span><br><span class="line">      <span class="keyword">if</span> (hasMapper(type)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Type "</span> + type + <span class="string">" is already known to the MapperRegistry."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">boolean</span> loadCompleted = <span class="keyword">false</span>;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        knownMappers.put(type, <span class="keyword">new</span> MapperProxyFactory&lt;&gt;(type));</span><br><span class="line">        <span class="comment">//注解和xml相关解析</span></span><br><span class="line">        MapperAnnotationBuilder parser = <span class="keyword">new</span> MapperAnnotationBuilder(config, type);</span><br><span class="line">        parser.parse();</span><br><span class="line">        loadCompleted = <span class="keyword">true</span>;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!loadCompleted) &#123;</span><br><span class="line">          knownMappers.remove(type);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取所有的mapper集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Class&lt;?&gt;&gt; getMappers() &#123;</span><br><span class="line">    <span class="keyword">return</span> Collections.unmodifiableCollection(knownMappers.keySet());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 批量注册mapper</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> packageName 包名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> superType</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName, Class&lt;?&gt; superType)</span> </span>&#123;</span><br><span class="line">    ResolverUtil&lt;Class&lt;?&gt;&gt; resolverUtil = <span class="keyword">new</span> ResolverUtil&lt;&gt;();</span><br><span class="line">    resolverUtil.find(<span class="keyword">new</span> ResolverUtil.IsA(superType), packageName);</span><br><span class="line">    Set&lt;Class&lt;? extends Class&lt;?&gt;&gt;&gt; mapperSet = resolverUtil.getClasses();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; mapperClass : mapperSet) &#123;</span><br><span class="line">      addMapper(mapperClass);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 批量注册mapper</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> packageName</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMappers</span><span class="params">(String packageName)</span> </span>&#123;</span><br><span class="line">    addMappers(packageName, Object.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 上面的集合knownMappers中键值的类型分别为Class类型与MapperProxyFactory类型，MapperProxyFactory是映射器代理工厂，通过这个工厂类可以获取到对应的映射器代理类MapperProxy，这里只需要保存一个映射器的代理工厂，根据工厂就可以获取到对应的映射器。</p><p>​ 注册器中必然定义了添加映射器和获取映射器的方法来对外提供服务（供外部调取）。这里就是addMapper()方法与getMapper()方法，在该注册器中还有一种根据包名来注册映射器的方法addMappers()方法。因为该方法最后会调用addMapper()方法来完成具体的注册功能</p><h3 id="MapperProxyFactory类"><a href="#MapperProxyFactory类" class="headerlink" title="MapperProxyFactory类"></a>MapperProxyFactory类</h3><blockquote><p>主要负责创建代理对象</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Mapper 代理工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Lasse Voss</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxyFactory</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mapper 的接口对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * method 和 Mappermethod 的缓存 ，由 MapperProxy 进行添加和处理</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxyFactory</span><span class="params">(Class&lt;T&gt; mapperInterface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Class&lt;T&gt; <span class="title">getMapperInterface</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mapperInterface;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;Method, MapperMethod&gt; <span class="title">getMethodCache</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建实现了mapperInterface接口的代理对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mapperProxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">protected</span> T <span class="title">newInstance</span><span class="params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (T) Proxy.newProxyInstance(mapperInterface.getClassLoader(), <span class="keyword">new</span> Class[]&#123;mapperInterface&#125;, mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据sqlSession创建代理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> T <span class="title">newInstance</span><span class="params">(SqlSession sqlSession)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建mapperProxy对象，每一次调用都会创建新的mapperProxy对象</span></span><br><span class="line">    <span class="keyword">final</span> MapperProxy&lt;T&gt; mapperProxy = <span class="keyword">new</span> MapperProxy&lt;&gt;(sqlSession, mapperInterface, methodCache);</span><br><span class="line">    <span class="keyword">return</span> newInstance(mapperProxy);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 该类内部先调用MapperProxy的构造器生成MapperProxy映射器代理实例，然后以之使用JDK自带的动态代理来生成映射器代理实例</p><p>​ 在这个代理工厂中定义了一个缓存集合，其实为了调用MapperProxy的构造器而设，这个缓存集合用于保存当前映射器中的映射方法的。</p><p>映射方法单独定义，是因为这里并不存在一个真正的类和方法供调用，只是通过反射和代理的原理来实现的假的调用，映射方法是调用的最小单位（独立个体），将映射方法定义之后，它就成为一个实实在在的存在，我们可以将调用过的方法保存到对应的映射器的缓存中，以供下次调用，避免每次调用相同的方法的时候都需要重新进行方法的生成。很明显，方法的生成比较复杂，会消耗一定的时间，将其保存在缓存集合中备用，可以极大的解决这种时耗问题。</p><p>即使是在一般的项目中也会存在很多的映射器，这些映射器都要注册到注册器中，注册器集合中的每个映射器中都保存着一个独有的映射器代理工厂实例，而不是映射器实例，映射器实例只在需要的时候使用代理工厂进行创建，所以我们可以这么来看，MapperProxyFactory会存在多个实例，针对每个映射器有一个实例，这个实例就作为值保存在注册器中，而下一节中的MapperProxy被MapperProxyFactory调用来生成代理实例，同样也是与映射器接口一一对应的存在（即存在多个实例，只不过这个实例只会在需要的时候进行创建，不需要的时候是不存在的）。</p><h3 id="MapperProxy类"><a href="#MapperProxy类" class="headerlink" title="MapperProxy类"></a>MapperProxy类</h3><blockquote><p>实现了InvocationHandler接口，是代理对象的核心逻辑</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * MapperProxy 代理实现类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperProxy</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">InvocationHandler</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">6424540398559729838L</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlSession sqlSession;</span><br><span class="line">  <span class="comment">//mapper接口对应的class对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;T&gt; mapperInterface;</span><br><span class="line">  <span class="comment">//用于缓存MapperMethod、可以在多个代理对象之间共享</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Method, MapperMethod&gt; methodCache;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperProxy</span><span class="params">(SqlSession sqlSession, Class&lt;T&gt; mapperInterface, Map&lt;Method, MapperMethod&gt; methodCache)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.sqlSession = sqlSession;</span><br><span class="line">    <span class="keyword">this</span>.mapperInterface = mapperInterface;</span><br><span class="line">    <span class="keyword">this</span>.methodCache = methodCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 代理对象执行的主要逻辑</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//代理以后，所有Mapper的方法调用时，都会调用这个invoke方法</span></span><br><span class="line">      <span class="comment">//并不是任何一个方法都需要执行调用代理对象进行执行，如果这个方法是Object中通用的方法（toString、hashCode等）无需执行</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">        <span class="comment">//是abstract，或者static的public方法，也就是jdk8的默认实现方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.isDefault()) &#123;</span><br><span class="line">        <span class="keyword">return</span> invokeDefaultMethod(proxy, method, args);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//这里优化了，去缓存中找MapperMethod</span></span><br><span class="line">    <span class="keyword">final</span> MapperMethod mapperMethod = cachedMapperMethod(method);</span><br><span class="line">    <span class="comment">//执行</span></span><br><span class="line">    <span class="keyword">return</span> mapperMethod.execute(sqlSession, args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓存Mapper的method</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MapperMethod <span class="title">cachedMapperMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从缓存中获取MapperMethod对象，有就获取没有就存入</span></span><br><span class="line">    <span class="keyword">return</span> methodCache.computeIfAbsent(method, k -&gt; <span class="keyword">new</span> MapperMethod(mapperInterface, method, sqlSession.getConfiguration()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * abstract，或者static的public方法的调用</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">invokeDefaultMethod</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;MethodHandles.Lookup&gt; constructor = MethodHandles.Lookup.class</span><br><span class="line">      .getDeclaredConstructor(Class.class, <span class="keyword">int</span>.class);</span><br><span class="line">    <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">      constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    <span class="keyword">return</span> constructor</span><br><span class="line">      .newInstance(declaringClass,</span><br><span class="line">        MethodHandles.Lookup.PRIVATE | MethodHandles.Lookup.PROTECTED</span><br><span class="line">          | MethodHandles.Lookup.PACKAGE | MethodHandles.Lookup.PUBLIC)</span><br><span class="line">      .unreflectSpecial(method, declaringClass).bindTo(proxy).invokeWithArguments(args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="该类中的三个参数"><a href="#该类中的三个参数" class="headerlink" title="该类中的三个参数"></a>该类中的三个参数</h4><ul><li>sqlSession：session会话</li><li>mapperInterface：映射器接口</li><li>methodCache：方法缓存</li></ul><p></p><p>​ 以上三个参数需要在构造器中进行赋值，首先session会话用于指明操作的来源，映射器接口指明操作的目标，方法缓存则用于保存具体的操作方法实例。在每个映射器代理中都存在以上三个参数，也就是说我们一旦我们使用过某个操作，那么这个操作过程中产生的代理实例将会一直存在，且具体操作方法会保存在这个代理实例的方法缓存中备用。</p><p>MapperProxy是使用JDK动态代理实现的代理功能，其重点就在invoke()方法中，首先过滤掉Object类的方法，然后从先从缓存中获取指定的方法，如果缓存中不存在则新建一个MapperMethod实例并将其保存在缓存中，如果缓存中存在这个指定的方法实例，则直接获取执行。</p><p>这里使用缓存进行流程优化，极大的提升了MyBatis的执行速率。</p><h3 id="MapperMethod"><a href="#MapperMethod" class="headerlink" title="MapperMethod"></a>MapperMethod</h3><blockquote><p>封装了Mapper接口与中对应的信息，以及对应sql语句的信息。也就是说MapperMethod是连接Mapper接口欧以及配置文件中定义的sql语句的桥梁</p></blockquote><p>​ 映射器方法是最底层的被调用者，同时也是binding模块中最复杂的内容。它是MyBatis中对SqlSession会话操作的封装，那么这意味着什么呢？意味着这个类可以看做是整个MyBatis中数据库操作的枢纽，所有的数据库操作都需要经过它来得以实现。</p><p>我们单独使用MyBatis时，有时会直接操作SqlSession会话进行数据库操作，但是在SSM整合之后，这个数据库操作却是自动完成的，那么Sqlsession就需要被自动执行，那么组织执行它的就是这里的MapperMethod。</p><p>SqlSession会作为参数在从MapperRegisty中getMapper()中一直传递到MapperMethod中的execute()方法中，然后在这个方法中进行执行。</p><h4 id="结构信息"><a href="#结构信息" class="headerlink" title="结构信息"></a>结构信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapperMethod</span> </span>&#123;</span><br><span class="line">  <span class="comment">//记录sql语句的名称和类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommand command;</span><br><span class="line">  <span class="comment">//mapper接口中对应方法相关信息</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MethodSignature method;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapperMethod</span><span class="params">(Class&lt;?&gt; mapperInterface, Method method, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.command = <span class="keyword">new</span> SqlCommand(config, mapperInterface, method);</span><br><span class="line">    <span class="keyword">this</span>.method = <span class="keyword">new</span> MethodSignature(config, mapperInterface, method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个字段类型都是以MapperMethod中的静态内部类的方式定义的，分别表示sql命令与接口中的方法。</p><p>这两个字段都是final修饰，表示不可变，即一旦赋值，就永远是该值。</p><h4 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 执行器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">execute</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Object result;</span><br><span class="line">    <span class="comment">//根据sql类型调用sqlSession对应的方法</span></span><br><span class="line">    <span class="comment">//可以看到执行时就是4种情况，insert|update|delete|select，分别调用SqlSession的4大类方法</span></span><br><span class="line">    <span class="keyword">switch</span> (command.getType()) &#123;</span><br><span class="line">      <span class="keyword">case</span> INSERT: &#123;</span><br><span class="line">        <span class="comment">//负责将args[]实际参数数组转为sql语句对应的参数列表</span></span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.insert(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> UPDATE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.update(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> DELETE: &#123;</span><br><span class="line">        Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">        result = rowCountResult(sqlSession.delete(command.getName(), param));</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">case</span> SELECT:</span><br><span class="line">        <span class="keyword">if</span> (method.returnsVoid() &amp;&amp; method.hasResultHandler()) &#123;</span><br><span class="line">          <span class="comment">//如果有结果处理器</span></span><br><span class="line">          executeWithResultHandler(sqlSession, args);</span><br><span class="line">          result = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMany()) &#123;</span><br><span class="line">          <span class="comment">//如果结果有多条记录</span></span><br><span class="line">          result = executeForMany(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsMap()) &#123;</span><br><span class="line">          <span class="comment">//如果结果是map</span></span><br><span class="line">          result = executeForMap(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.returnsCursor()) &#123;</span><br><span class="line">          <span class="comment">//是否是游标</span></span><br><span class="line">          result = executeForCursor(sqlSession, args);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//否则就是一条记录</span></span><br><span class="line">          Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">          result = sqlSession.selectOne(command.getName(), param);</span><br><span class="line">          <span class="keyword">if</span> (method.returnsOptional()</span><br><span class="line">            &amp;&amp; (result == <span class="keyword">null</span> || !method.getReturnType().equals(result.getClass()))) &#123;</span><br><span class="line">            result = Optional.ofNullable(result);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> FLUSH:</span><br><span class="line">        result = sqlSession.flushStatements();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + command.getName());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span> &amp;&amp; method.getReturnType().isPrimitive() &amp;&amp; !method.returnsVoid()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName()</span><br><span class="line">        + <span class="string">" attempted to return null from a method with a primitive return type ("</span> + method.getReturnType() + <span class="string">")."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​ 这里可以很明显的看出，在这个执行方法中封装了对SqlSession的操作，而且将所有的数据库操作分类为增删改查四大类型，分别通过调用SqlSession的4大类方法来完成功能。</p><p>param表示的是SQL执行参数，可以通过静态内部类MethodSignature的convertArgsToSqlCommandParam()方法获取。</p><p>对SqlSession的增、删、改操作使用了rowCountResult()方法进行封装，这个方法对SQL操作的返回值类型进行验证检查，保证返回数据的安全。</p><p>针对SqlSession的查询操作较为复杂，分为多种情况：</p><ul><li>针对拥有结果处理器的情况：执行executeWithResultHandler(SqlSession sqlSession, Object[] args)方法这种有结果处理器的情况，就不需要本方法进行结果处理，自然有指定的结果处理器来进行处理，所以其result返回值设置为null。</li><li>针对返回多条记录的情况：执行executeForMany(SqlSession sqlSession, Object[] args)方法内部调用SqlSession的selectList(String statement, Object parameter, RowBounds rowBounds)方法针对Collections以及arrays进行支持，以解决#510BUG</li><li>针对返回Map的情况：执行executeForMap(SqlSession sqlSession, Object[] args)方法内部调用SqlSession的selectMap(String statement, Object parameter, String mapKey, RowBounds rowBounds)方法</li><li>针对Cursor的返回情况：执行executeForCursor(SqlSession sqlSession, Object[] args)方法针对游标处理。</li><li>针对返回一条记录的情况：执行SqlSession的selectOne(String statement, Object parameter)方法</li></ul><p>针对前三种情况返回的都不是一条数据，在实际项目必然会出现需要分页的情况，MyBatis中为我们提供了RowBounds来进行分页设置，在需要进行分页的情况，直接将设置好的分页实例传到SqlSession中即可。只不过这种方式的分页属于内存分页，针对数据量小的情况比较适合，对于大数据量的查询分页并不适合，大型项目中的分页也不会使用这种方式来实现分页，而是采用之后会解析的分页插件来时限物理分页，即直接修改SQL脚本来实现查询级的分页，再不会有大量查询数据占据内存。</p><h5 id="rowCountResult方法"><a href="#rowCountResult方法" class="headerlink" title="rowCountResult方法"></a>rowCountResult方法</h5><blockquote><p>返回影响条数，将sql插入等方法返回的int转为mapper中方法需要的返回类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将sql插入等方法返回的int转为mapper中方法需要的返回类型</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> rowCount</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> Object <span class="title">rowCountResult</span><span class="params">(<span class="keyword">int</span> rowCount)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">final</span> Object result;</span><br><span class="line">   <span class="keyword">if</span> (method.returnsVoid()) &#123;</span><br><span class="line">     result = <span class="keyword">null</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Integer.class.equals(method.getReturnType()) || Integer.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">     result = rowCount;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Long.class.equals(method.getReturnType()) || Long.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">     result = (<span class="keyword">long</span>) rowCount;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Boolean.class.equals(method.getReturnType()) || Boolean.TYPE.equals(method.getReturnType())) &#123;</span><br><span class="line">     result = rowCount &gt; <span class="number">0</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Mapper method '"</span> + command.getName() + <span class="string">"' has an unsupported return type: "</span> + method.getReturnType());</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h5 id="executeWithResultHandler方法"><a href="#executeWithResultHandler方法" class="headerlink" title="executeWithResultHandler方法"></a>executeWithResultHandler方法</h5><blockquote><p>结果处理器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 结果处理器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeWithResultHandler</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    MappedStatement ms = sqlSession.getConfiguration().getMappedStatement(command.getName());</span><br><span class="line">    <span class="keyword">if</span> (!StatementType.CALLABLE.equals(ms.getStatementType())</span><br><span class="line">      &amp;&amp; <span class="keyword">void</span>.class.equals(ms.getResultMaps().get(<span class="number">0</span>).getType())) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"method "</span> + command.getName()</span><br><span class="line">        + <span class="string">" needs either a @ResultMap annotation, a @ResultType annotation,"</span></span><br><span class="line">        + <span class="string">" or a resultType attribute in XML so a ResultHandler can be used as a parameter."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">      sqlSession.select(command.getName(), param, rowBounds, method.extractResultHandler(args));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      sqlSession.select(command.getName(), param, method.extractResultHandler(args));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="executeForMany方法"><a href="#executeForMany方法" class="headerlink" title="executeForMany方法"></a>executeForMany方法</h5><blockquote><p>多条结果处理器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 多条结果处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;E&gt; <span class="function">Object <span class="title">executeForMany</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  List&lt;E&gt; result;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    result = sqlSession.selectList(command.getName(), param, rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.selectList(command.getName(), param);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// issue #510 Collections &amp; arrays support</span></span><br><span class="line">  <span class="keyword">if</span> (!method.getReturnType().isAssignableFrom(result.getClass())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (method.getReturnType().isArray()) &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToArray(result);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> convertToDeclaredCollection(sqlSession.getConfiguration(), result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="executeForMap方法"><a href="#executeForMap方法" class="headerlink" title="executeForMap方法"></a>executeForMap方法</h5><blockquote><p>map 结果处理器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * map结果处理器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;K&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;V&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> &lt;K, V&gt; <span class="function">Map&lt;K, V&gt; <span class="title">executeForMap</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">  Map&lt;K, V&gt; result;</span><br><span class="line">  Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">  <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">    RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">    result = sqlSession.selectMap(command.getName(), param, method.getMapKey(), rowBounds);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    result = sqlSession.selectMap(command.getName(), param, method.getMapKey());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="executeForCursor方法"><a href="#executeForCursor方法" class="headerlink" title="executeForCursor方法"></a>executeForCursor方法</h5><blockquote><p>游标处理器</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 游标处理器</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sqlSession</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">Cursor&lt;T&gt; <span class="title">executeForCursor</span><span class="params">(SqlSession sqlSession, Object[] args)</span> </span>&#123;</span><br><span class="line">    Cursor&lt;T&gt; result;</span><br><span class="line">    Object param = method.convertArgsToSqlCommandParam(args);</span><br><span class="line">    <span class="keyword">if</span> (method.hasRowBounds()) &#123;</span><br><span class="line">      RowBounds rowBounds = method.extractRowBounds(args);</span><br><span class="line">      result = sqlSession.selectCursor(command.getName(), param, rowBounds);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result = sqlSession.selectCursor(command.getName(), param);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="SqlCommand静态内部类"><a href="#SqlCommand静态内部类" class="headerlink" title="SqlCommand静态内部类"></a>SqlCommand静态内部类</h4><blockquote><p>MapperMethod的内部类，使用name字段记录sql语句的名称，type字段记录sql语句的类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * SQL命令，静态内部类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SqlCommand</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">  <span class="comment">// SqlCommandType是枚举类型包含crud等</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SqlCommandType type;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">SqlCommand</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> String methodName = method.getName();</span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; declaringClass = method.getDeclaringClass();</span><br><span class="line">    <span class="comment">//解析获取MappedStatement</span></span><br><span class="line">    MappedStatement ms = resolveMappedStatement(mapperInterface, methodName, declaringClass, configuration);</span><br><span class="line">    <span class="keyword">if</span> (ms == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">//@flushz注解处理</span></span><br><span class="line">      <span class="keyword">if</span> (method.getAnnotation(Flush.class) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        name = <span class="keyword">null</span>;</span><br><span class="line">        type = SqlCommandType.FLUSH;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Invalid bound statement (not found): "</span></span><br><span class="line">          + mapperInterface.getName() + <span class="string">"."</span> + methodName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//获取到name和type</span></span><br><span class="line">      name = ms.getId();</span><br><span class="line">      type = ms.getSqlCommandType();</span><br><span class="line">      <span class="keyword">if</span> (type == SqlCommandType.UNKNOWN) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BindingException(<span class="string">"Unknown execution method for: "</span> + name);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> SqlCommandType <span class="title">getType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析映射</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mapperInterface</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> methodName</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> declaringClass</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> MappedStatement <span class="title">resolveMappedStatement</span><span class="params">(Class&lt;?&gt; mapperInterface, String methodName,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                 Class&lt;?&gt; declaringClass, Configuration configuration)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//mapper接口的名称+对应方法（config配置文件中各个组件的id）</span></span><br><span class="line">    String statementId = mapperInterface.getName() + <span class="string">"."</span> + methodName;</span><br><span class="line">    <span class="keyword">if</span> (configuration.hasStatement(statementId)) &#123;</span><br><span class="line">      <span class="comment">//MappedStatement封装了sql语句的相关信息，在初始化时候创建</span></span><br><span class="line">      <span class="keyword">return</span> configuration.getMappedStatement(statementId);</span><br><span class="line">      <span class="comment">//如果父类类型和接口一样说明不是接口</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mapperInterface.equals(declaringClass)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//向上遍历接口</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; superInterface : mapperInterface.getInterfaces()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (declaringClass.isAssignableFrom(superInterface)) &#123;</span><br><span class="line">        <span class="comment">//递归</span></span><br><span class="line">        MappedStatement ms = resolveMappedStatement(superInterface, methodName,</span><br><span class="line">          declaringClass, configuration);</span><br><span class="line">        <span class="keyword">if</span> (ms != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> ms;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个内部类比较简单，是对SQL命令的封装，定义两个字段，name和type，前者表示SQL命令的名称，这个名称就是接口的全限定名+方法名称（中间以.连接），后者表示的是SQL命令的类型，无非增删改查四种。</p><p>内部类中有一个带参数的构造器用于对字段赋值，里面涉及到了MappedStatement类，这个类封装的是映射语句的信息，在构建Configuration实例时会创建一个Map集合用于存储所有的映射语句，而这些映射语句的解析存储是在构建映射器的时候完成的（MapperBuilderAssistant类中）。</p><h4 id="MethodSignature-静态内部类"><a href="#MethodSignature-静态内部类" class="headerlink" title="MethodSignature 静态内部类"></a>MethodSignature 静态内部类</h4><blockquote><p>也是其内部类，封装了Mapper接口中定义的方法的相关信息</p></blockquote><h5 id="结构信息-1"><a href="#结构信息-1" class="headerlink" title="结构信息"></a>结构信息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodSignature</span> </span>&#123;</span><br><span class="line">  <span class="comment">//返回值是否是collection类型或者数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMany;</span><br><span class="line">  <span class="comment">//返回值是否是Map类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsMap;</span><br><span class="line">  <span class="comment">//返回值是否是void</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsVoid;</span><br><span class="line">  <span class="comment">//返回值是否是cursor类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsCursor;</span><br><span class="line">  <span class="comment">//返回值是否是Optional类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> returnsOptional;</span><br><span class="line">  <span class="comment">//返回值类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; returnType;</span><br><span class="line">  <span class="comment">//返回为map则该字段记录作为key的列名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String mapKey;</span><br><span class="line">  <span class="comment">//标记ResultHandler类性参数的位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Integer resultHandlerIndex;</span><br><span class="line">  <span class="comment">//rowBounds类型的位置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Integer rowBoundsIndex;</span><br><span class="line">  <span class="comment">//ParamNameResolver对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ParamNameResolver paramNameResolver;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 解析相应的method，初始化上述的字段</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> configuration</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> mapperInterface</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MethodSignature</span><span class="params">(Configuration configuration, Class&lt;?&gt; mapperInterface, Method method)</span> </span>&#123;</span><br><span class="line">    Type resolvedReturnType = TypeParameterResolver.resolveReturnType(method, mapperInterface);</span><br><span class="line">    <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> Class&lt;?&gt;) &#123;</span><br><span class="line">      <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) resolvedReturnType;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resolvedReturnType <span class="keyword">instanceof</span> ParameterizedType) &#123;</span><br><span class="line">      <span class="keyword">this</span>.returnType = (Class&lt;?&gt;) ((ParameterizedType) resolvedReturnType).getRawType();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.returnType = method.getReturnType();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.returnsVoid = <span class="keyword">void</span>.class.equals(<span class="keyword">this</span>.returnType);</span><br><span class="line">    <span class="keyword">this</span>.returnsMany = configuration.getObjectFactory().isCollection(<span class="keyword">this</span>.returnType) || <span class="keyword">this</span>.returnType.isArray();</span><br><span class="line">    <span class="keyword">this</span>.returnsCursor = Cursor.class.equals(<span class="keyword">this</span>.returnType);</span><br><span class="line">    <span class="keyword">this</span>.returnsOptional = Optional.class.equals(<span class="keyword">this</span>.returnType);</span><br><span class="line">    <span class="keyword">this</span>.mapKey = getMapKey(method);</span><br><span class="line">    <span class="keyword">this</span>.returnsMap = <span class="keyword">this</span>.mapKey != <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//以下重复循环2遍调用getUniqueParamIndex，是不是降低效率了</span></span><br><span class="line">    <span class="comment">//记下RowBounds是第几个参数</span></span><br><span class="line">    <span class="keyword">this</span>.rowBoundsIndex = getUniqueParamIndex(method, RowBounds.class);</span><br><span class="line">    <span class="comment">//记下ResultHandler是第几个参数</span></span><br><span class="line">    <span class="keyword">this</span>.resultHandlerIndex = getUniqueParamIndex(method, ResultHandler.class);</span><br><span class="line">    <span class="keyword">this</span>.paramNameResolver = <span class="keyword">new</span> ParamNameResolver(configuration, method);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 构造器的参数分别为Configuration与Method，我们的字段的值部分是需要从这两个参数中获取的。</p><p>​ 返回类型returnType从Method中获取</p><p>​ hasNamedParameters表示是否存在注解方式定义的参数</p><p>​ 获取Method中RowBounds类型参数与ResultHandler类型参数的位置</p><h5 id="convertArgsToSqlCommandParam方法"><a href="#convertArgsToSqlCommandParam方法" class="headerlink" title="convertArgsToSqlCommandParam方法"></a>convertArgsToSqlCommandParam方法</h5><blockquote><p>这个方法是中转方法最终调用的是paramNameResolver类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">convertArgsToSqlCommandParam</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> paramNameResolver.getNamedParams(args);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="paramNameResolver类"><a href="#paramNameResolver类" class="headerlink" title="paramNameResolver类"></a>paramNameResolver类</h3><blockquote><p>主要用来处理接口形式的参数，最后会把参数处放在一个map中map的key为参数的位置，value为参数的名字</p></blockquote><h4 id="结构信息-2"><a href="#结构信息-2" class="headerlink" title="结构信息"></a>结构信息</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数解析类</span></span><br><span class="line"><span class="comment"> * 主要用来处理接口形式的参数，最后会把参数处放在一个map中map的key为参数的位置，value为参数的名字</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParamNameResolver</span> </span>&#123;</span><br><span class="line">  <span class="comment">//可以使用@param注解进行参数设置</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String GENERIC_NAME_PREFIX = <span class="string">"param"</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//存放参数的位置和对应的参数名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; names;</span><br><span class="line">  <span class="comment">//是否使用param注解</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasParamAnnotation;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ParamNameResolver</span><span class="params">(Configuration config, Method method)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取参数类型数组</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt;[] paramTypes = method.getParameterTypes();</span><br><span class="line">    <span class="comment">//参数列表上的注解</span></span><br><span class="line">    <span class="keyword">final</span> Annotation[][] paramAnnotations = method.getParameterAnnotations();</span><br><span class="line">    <span class="comment">//用于记录参数索引与参数名称之间的关系</span></span><br><span class="line">    <span class="keyword">final</span> SortedMap&lt;Integer, String&gt; map = <span class="keyword">new</span> TreeMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> paramCount = paramAnnotations.length;</span><br><span class="line">    <span class="comment">// get names from @Param annotations</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> paramIndex = <span class="number">0</span>; paramIndex &lt; paramCount; paramIndex++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isSpecialParameter(paramTypes[paramIndex])) &#123;</span><br><span class="line">        <span class="comment">// skip special parameters</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String name = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (Annotation annotation : paramAnnotations[paramIndex]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> Param) &#123;</span><br><span class="line">          hasParamAnnotation = <span class="keyword">true</span>;</span><br><span class="line">          name = ((Param) annotation).value();</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// @Param was not specified.根据配置决定是否采用实际名称作为其名称</span></span><br><span class="line">        <span class="keyword">if</span> (config.isUseActualParamName()) &#123;</span><br><span class="line">          name = getActualParamName(method, paramIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (name == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// use the parameter index as the name ("0", "1", ...)</span></span><br><span class="line">          <span class="comment">// gcode issue #71</span></span><br><span class="line">          name = String.valueOf(map.size());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      map.put(paramIndex, name);</span><br><span class="line">    &#125;</span><br><span class="line">    names = Collections.unmodifiableSortedMap(map);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>构造方法的会经历如下的步骤</p><ol><li>通过反射得到方法的参数类型和方法的参数注解注解，method.getParameterAnnotations()方法返回的是注解的二维数组，每一个方法的参数包含一个注解数组。</li><li>遍历所有的参数</li></ol><ul><li>首先判断这个参数的类型是否是特殊类型,RowBounds和ResultHandler，是的话跳过，咱不处理</li><li>判断这个参数是否是用来Param注解，如果使用的话name就是Param注解的值，并把name放到map中，键为参数在方法中的位置，value为Param的值</li><li>如果没有使用Param注解,判断是否开启了UseActualParamName，如果开启了，则使用java8的反射得到方法的名字，此处容易造成异常，<br>具体原因参考上一篇博文.</li><li>如果以上条件都不满足的话,则这个参数的名字为参数的下标</li></ul><h4 id="getNamedParams方法"><a href="#getNamedParams方法" class="headerlink" title="getNamedParams方法"></a>getNamedParams方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 参数名和实际参数的绑定</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">getNamedParams</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">int</span> paramCount = names.size();</span><br><span class="line">  <span class="keyword">if</span> (args == <span class="keyword">null</span> || paramCount == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//没有使用注解@param且只有一个参数</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasParamAnnotation &amp;&amp; paramCount == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> args[names.firstKey()];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//将参数名和实际参数记录到param中</span></span><br><span class="line">    <span class="keyword">final</span> Map&lt;String, Object&gt; param = <span class="keyword">new</span> ParamMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : names.entrySet()) &#123;</span><br><span class="line">      param.put(entry.getValue(), args[entry.getKey()]);</span><br><span class="line">      <span class="comment">// 创建索引默认值例如 (param1, param2, ...)</span></span><br><span class="line">      <span class="keyword">final</span> String genericParamName = GENERIC_NAME_PREFIX + String.valueOf(i + <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 如果@param注解指定的参数名称就是param+索引格式的就不需要再添加了</span></span><br><span class="line">      <span class="keyword">if</span> (!names.containsValue(genericParamName)) &#123;</span><br><span class="line">        param.put(genericParamName, args[entry.getKey()]);</span><br><span class="line">      &#125;</span><br><span class="line">      i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> param;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>mybatis中使用Binding模块对Mapper代理接口的产生进行包装。MapperRegistry用于Mapper接口的注册和代理Mapper接口的产生，然后由MapperProxyFactory创建代理对象MapperProxy，MapperProxy实现了InvocationHandler接口，是代理对象的核心逻辑，当客户端调用代理对象的方法时候就会调用MapperProxy对象的invoke方法完成动态代理过程。</li><li>调用invoke方法后最终执行的是MapperMethod的execute方法，再此之前会创建MapperMethod实现两个内部类SqlCommand和MethodSignature的初始化。最后会根据配置执行相应的crud方法（具体的执行流程会在后面仔细讲解）</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis代理封装
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="代理封装" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E4%BB%A3%E7%90%86%E5%B0%81%E8%A3%85/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="代理封装" scheme="http://www.baiyp.ren/tags/%E4%BB%A3%E7%90%86%E5%B0%81%E8%A3%85/"/>
    
      <category term="binding模块" scheme="http://www.baiyp.ren/tags/binding%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-初始化流程</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-05%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-05初始化流程.html</id>
    <published>2019-09-20T08:58:57.000Z</published>
    <updated>2019-09-21T09:03:24.597Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS初始化流程"><a href="#MYBATIS初始化流程" class="headerlink" title="MYBATIS初始化流程"></a>MYBATIS初始化流程</h2><h3 id="加载配置文件关键类"><a href="#加载配置文件关键类" class="headerlink" title="加载配置文件关键类"></a>加载配置文件关键类</h3><p><img src="../images/mybatis/build01.png" alt></p><ul><li><p>BaseBuilder</p><p>​ 所有解析器的父类，包含配置文件实例，为解析文件提供的一些通用的方<br>法</p></li><li><p>XMLConfigBuilder</p><p>​ 主要负责解析mybatis-config.xml；</p></li><li><p>XMLMapperBuilder</p><p>主要负责解析映射配置文件；</p></li><li><p>XMLStatementBuilder</p><p>主要负责解析映射配置文件中的SQL节点；</p></li></ul><p>XMLConfigBuilder、 XMLMapperBuilder、 XMLStatementBuilder 这三个类在配置文件加载<br>过程中非常重要，具体分工如下图所示：</p><p><img src="../images/mybatis/build02.png" alt></p><h3 id="映射器关键类"><a href="#映射器关键类" class="headerlink" title="映射器关键类"></a>映射器关键类</h3><ul><li><p>Configuration</p><p>​ Mybatis启动初始化的核心就是将所有xml配置文件信息加载到Configuration对象中， Configuration是单例的，生命周期是应用级的；</p></li><li><p>MapperRegistry</p><p>​ mapper接口动态代理工厂类的注册中心。在MyBatis中，通过mapperProxy实现InvocationHandler接口，MapperProxyFactory用于生成动态代理的实例对象；</p></li><li><p>ResultMap</p><p>​ 用于解析mapper.xml文件中的resultMap节点，使用ResultMapping来封装id，result等子元素；</p></li><li><p>MappedStatement</p><p>​ 用于存储mapper.xml文件中的select、insert、update和delete节点，同时还包含了这些节点的很多重要属性；</p></li><li><p>SqlSource</p><p>​ mapper.xml文件中的sql语句会被解析成SqlSource对象，经过解析SqlSource包含的语句最终仅仅包含？占位符，可以直接提交给数据库执行；</p></li></ul><h3 id="Configuration-对象"><a href="#Configuration-对象" class="headerlink" title="Configuration 对象"></a>Configuration 对象</h3><blockquote><p>实例化并初始化 Configuration 对象是第一个阶段的最终目的，所以熟悉 configuration 对<br>象是理解第一个阶段代码的核心； configuration 对象的关键属性解析如下</p></blockquote><ul><li><p><strong>MapperRegistry</strong></p><p>​ mapper 接口动态代理工厂类的注册中心。在 MyBatis 中，通过mapperProxy 实现 InvocationHandler 接口， MapperProxyFactory 用于生成动态代理的实例对象</p></li><li><p><strong>ResultMap</strong></p></li></ul><p>​ 用于解析 mapper.xml 文件中的 resultMap 节点，使用 ResultMapping 来封装id， result 等子元素；</p><ul><li><p><strong>MappedStatement</strong></p><p>​ 用于存储 mapper.xml 文件中的 select、insert、update 和 delete 节点，同时还包含了这些节点的很多重要属性；</p></li><li><p><strong>SqlSource</strong></p><p>​ 用于创建 BoundSql， mapper.xml 文件中的 sql 语句会被解析成 BoundSql 对<br>象，经过解析 BoundSql 包含的语句最终仅仅包含？占位符，可以直接提交给数据库执<br>行；</p><p>​</p></li></ul><p>​ 需要特别注意的是 Configuration 对象在 MyBatis 中是单例的，生命周期是应用级的，换句话说只要 MyBatis 运行 Configuration 对象就会独一无二的存在；在 MyBatis 中仅在<br>org.apache.ibatis.builder.xml.XMLConfigBuilder.XMLConfigBuilder(XPathParser, String, Properties)中有实例化 configuration 对象的代码。</p><p>代码如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * mybatis 最重要的一个配置 保存着mybatis的关键配置信息</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Configuration</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mybatis 环境相关配置</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Environment environment;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 允许在嵌套语句中使用分页（RowBounds）默认值False</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> safeRowBoundsEnabled;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> safeResultHandlerEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 否开启自动驼峰命名规则（camel case）映射，即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。  默认false</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> mapUnderscoreToCamelCase;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载（参考lazyLoadTriggerMethods).</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> aggressiveLazyLoading;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否允许单一语句返回多结果集（需要兼容驱动）。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> multipleResultSetsEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 允许 JDBC 支持自动生成主键，需要驱动兼容。</span></span><br><span class="line"><span class="comment">   * 如果设置为 true 则这个设置强制使用自动生成主键，尽管一些驱动不能兼容但仍可正常工作（比如 Derby）。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> useGeneratedKeys;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用列标签代替列名。不同的驱动在这方面会有不同的表现， 具体可参考相关驱动文档或通过测试这两种不同的模式来观察所用驱动的结果。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> useColumnLabel = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 全局地开启或关闭配置文件中的所有映射器已经配置的任何缓存。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> cacheEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，</span></span><br><span class="line"><span class="comment">   * 这对于有 Map.keySet() 依赖或 null 值初始化的时候是有用的。注意基本类型（int、boolean等）是不能设置成 null 的。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> callSettersOnNulls;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 允许使用方法签名中的名称作为语句参数名称。</span></span><br><span class="line"><span class="comment">   * 为了使用该特性，你的工程必须采用Java 8编译，并且加上-parameters选项。（从3.4.1开始）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> useActualParamName = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当返回行的所有列都是空时，MyBatis默认返回null。</span></span><br><span class="line"><span class="comment">   * 当开启这个设置时，MyBatis会返回一个空实例。</span></span><br><span class="line"><span class="comment">   * 请注意，它也适用于嵌套的结果集 (i.e. collectioin and association)。（从3.4.2开始）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> returnInstanceForEmptyRow;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定 MyBatis 增加到日志名称的前缀。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> String logPrefix;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;? extends Log&gt; logImpl;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定VFS的实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;? extends VFS&gt; vfsImpl;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * MyBatis 利用本地缓存机制（Local Cache）防止循环引用（circular references）和加速重复嵌套查询。</span></span><br><span class="line"><span class="comment">   * 默认值为 SESSION，这种情况下会缓存一个会话中执行的所有查询。</span></span><br><span class="line"><span class="comment">   * 若设置值为 STATEMENT，本地会话仅用在语句执行上，</span></span><br><span class="line"><span class="comment">   * 对相同 SqlSession 的不同调用将不会共享数据。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> LocalCacheScope localCacheScope = LocalCacheScope.SESSION;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当没有为参数提供特定的 JDBC 类型时，为空值指定 JDBC 类型。</span></span><br><span class="line"><span class="comment">   * 某些驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> JdbcType jdbcTypeForNull = JdbcType.OTHER;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定哪个对象的方法触发一次延迟加载。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Set&lt;String&gt; lazyLoadTriggerMethods = <span class="keyword">new</span> HashSet&lt;&gt;(Arrays.asList(<span class="string">"equals"</span>, <span class="string">"clone"</span>, <span class="string">"hashCode"</span>, <span class="string">"toString"</span>));</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置超时时间，它决定驱动等待数据库响应的秒数。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Integer defaultStatementTimeout;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 为驱动的结果集获取数量（fetchSize）设置一个提示值。此参数只可以在查询设置中被覆盖。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Integer defaultFetchSize;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> ResultSetType defaultResultSetType;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 配置默认的执行器。</span></span><br><span class="line"><span class="comment">   * SIMPLE 就是普通的执行器；</span></span><br><span class="line"><span class="comment">   * REUSE 执行器会重用预处理语句（prepared statements）；</span></span><br><span class="line"><span class="comment">   * BATCH 执行器将重用语句并执行批量更新。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> ExecutorType defaultExecutorType = ExecutorType.SIMPLE;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定 MyBatis 应如何自动映射列到字段或属性。</span></span><br><span class="line"><span class="comment">   * NONE 表示取消自动映射；</span></span><br><span class="line"><span class="comment">   * PARTIAL 只会自动映射没有定义嵌套结果集映射的结果集。</span></span><br><span class="line"><span class="comment">   * FULL 会自动映射任意复杂的结果集（无论是否嵌套）。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> AutoMappingBehavior autoMappingBehavior = AutoMappingBehavior.PARTIAL;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定发现自动映射目标未知列（或者未知属性类型）的行为。</span></span><br><span class="line"><span class="comment">   * NONE: 不做任何反应</span></span><br><span class="line"><span class="comment">   * WARNING: 输出提醒日志 (‘org.apache.ibatis.session.AutoMappingUnknownColumnBehavior’ 的日志等级必须设置为 WARN)</span></span><br><span class="line"><span class="comment">   * FAILING: 映射失败 (抛出 SqlSessionException)</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> AutoMappingUnknownColumnBehavior autoMappingUnknownColumnBehavior = AutoMappingUnknownColumnBehavior.NONE;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> Properties variables = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">protected</span> ReflectorFactory reflectorFactory = <span class="keyword">new</span> DefaultReflectorFactory();</span><br><span class="line">  <span class="keyword">protected</span> ObjectFactory objectFactory = <span class="keyword">new</span> DefaultObjectFactory();</span><br><span class="line">  <span class="keyword">protected</span> ObjectWrapperFactory objectWrapperFactory = <span class="keyword">new</span> DefaultObjectWrapperFactory();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置fetchType属性来覆盖该项的开关状态。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> lazyLoadingEnabled = <span class="keyword">false</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定 Mybatis 创建具有延迟加载能力的对象所用到的代理工具。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> ProxyFactory proxyFactory = <span class="keyword">new</span> JavassistProxyFactory(); <span class="comment">// #224 Using internal Javassist instead of OGNL</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> String databaseId;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 指定一个提供Configuration实例的类。</span></span><br><span class="line"><span class="comment">   * 这个被返回的Configuration实例用来加载被反序列化对象的懒加载属性值。</span></span><br><span class="line"><span class="comment">   * 这个类必须包含一个签名方法static Configuration getConfiguration(). (从 3.2.3 版本开始)</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> &lt;a href='https://code.google.com/p/mybatis/issues/detail?id=300'&gt;Issue 300 (google code)&lt;/a&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; configurationFactory;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mapper 接口动态代理工厂类的注册中心。在 MyBatis 中，</span></span><br><span class="line"><span class="comment">   * 通过mapperProxy 实现 InvocationHandler 接口，</span></span><br><span class="line"><span class="comment">   * MapperProxyFactory 用于生成动态代理的实例对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> MapperRegistry mapperRegistry = <span class="keyword">new</span> MapperRegistry(<span class="keyword">this</span>);</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 拦截器链</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> InterceptorChain interceptorChain = <span class="keyword">new</span> InterceptorChain();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 类型处理器注册中心</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TypeHandlerRegistry typeHandlerRegistry = <span class="keyword">new</span> TypeHandlerRegistry();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 类型别名注册</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TypeAliasRegistry typeAliasRegistry = <span class="keyword">new</span> TypeAliasRegistry();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 方言驱动注册</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> LanguageDriverRegistry languageRegistry = <span class="keyword">new</span> LanguageDriverRegistry();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * mapper文件的声明</span></span><br><span class="line"><span class="comment">   * MappedStatement用于存储 mapper.xml 文件中的 select、insert、update 和 delete 节点，同时还包含了这些节点的很多重要属性；</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">"Mapped Statements collection"</span>)</span><br><span class="line">    .conflictMessageProducer((savedValue, targetValue) -&gt;</span><br><span class="line">      <span class="string">". please check "</span> + savedValue.getResource() + <span class="string">" and "</span> + targetValue.getResource());</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, Cache&gt; caches = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Caches collection"</span>);</span><br><span class="line">  <span class="comment">//用于解析 mapper.xml 文件中的 resultMap 节点，使用 ResultMapping 来封装id， result 等子元素；</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Result Maps collection"</span>);</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ParameterMap&gt; parameterMaps = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Parameter Maps collection"</span>);</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, KeyGenerator&gt; keyGenerators = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"Key Generators collection"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Set&lt;String&gt; loadedResources = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, XNode&gt; sqlFragments = <span class="keyword">new</span> StrictMap&lt;&gt;(<span class="string">"XML fragments parsed from previous mappers"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;XMLStatementBuilder&gt; incompleteStatements = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;CacheRefResolver&gt; incompleteCacheRefs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;ResultMapResolver&gt; incompleteResultMaps = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Collection&lt;MethodResolver&gt; incompleteMethods = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * A map holds cache-ref relationship. The key is the namespace that</span></span><br><span class="line"><span class="comment">   * references a cache bound to another namespace and the value is the</span></span><br><span class="line"><span class="comment">   * namespace which the actual cache is bound to.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, String&gt; cacheRefMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="配置加载过程"><a href="#配置加载过程" class="headerlink" title="配置加载过程"></a>配置加载过程</h3><blockquote><p>Mybatis初始化流程，其实就是组装重量级All-In-One对象Configuration的过程，主要分为系统环境参数初始化和Mapper映射初始化，其中Mapper映射初始化尤为重要。</p></blockquote><h4 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">inputStream = Resources.getResourceAsStream(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream)</span><br></pre></td></tr></table></figure><p>进入方法看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建SqlSessionFactory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> inputStream mybatis-config.xml文件流</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> environment 环境</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> properties 属性信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> ExceptionFactory.wrapException(<span class="string">"Error building SqlSession."</span>, e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    ErrorContext.instance().reset();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      inputStream.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      <span class="comment">// Intentionally ignore. Prefer previous error.</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(Configuration config)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DefaultSqlSessionFactory(config);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>parser.parse()方法，已经返回了组装完毕的Configuration对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 解析配置文件</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Configuration <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (parsed) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Each XMLConfigBuilder can only be used once."</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   parsed = <span class="keyword">true</span>;</span><br><span class="line">   parseConfiguration(parser.evalNode(<span class="string">"/configuration"</span>));</span><br><span class="line">   <span class="keyword">return</span> configuration;</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 解析Configuration配置</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//issue #117 read properties first</span></span><br><span class="line">     <span class="comment">//解析properties属性</span></span><br><span class="line">     propertiesElement(root.evalNode(<span class="string">"properties"</span>));</span><br><span class="line">     <span class="comment">//解析settings配置</span></span><br><span class="line">     Properties settings = settingsAsProperties(root.evalNode(<span class="string">"settings"</span>));</span><br><span class="line">     loadCustomVfs(settings);</span><br><span class="line">     loadCustomLogImpl(settings);</span><br><span class="line">     <span class="comment">//解析typeAliases配置</span></span><br><span class="line">     typeAliasesElement(root.evalNode(<span class="string">"typeAliases"</span>));</span><br><span class="line">     <span class="comment">//解析插件配置</span></span><br><span class="line">     pluginElement(root.evalNode(<span class="string">"plugins"</span>));</span><br><span class="line">     <span class="comment">//解析objectFactory配置</span></span><br><span class="line">     objectFactoryElement(root.evalNode(<span class="string">"objectFactory"</span>));</span><br><span class="line">     <span class="comment">//解析objectWrapperFactory配置</span></span><br><span class="line">     objectWrapperFactoryElement(root.evalNode(<span class="string">"objectWrapperFactory"</span>));</span><br><span class="line">     <span class="comment">//解析reflectorFactory配置</span></span><br><span class="line">     reflectorFactoryElement(root.evalNode(<span class="string">"reflectorFactory"</span>));</span><br><span class="line">     <span class="comment">//设置元素配置</span></span><br><span class="line">     settingsElement(settings);</span><br><span class="line">     <span class="comment">// read it after objectFactory and objectWrapperFactory issue #631</span></span><br><span class="line">     <span class="comment">//解析环境environments</span></span><br><span class="line">     environmentsElement(root.evalNode(<span class="string">"environments"</span>));</span><br><span class="line">     <span class="comment">//解析数据库ID配置</span></span><br><span class="line">     databaseIdProviderElement(root.evalNode(<span class="string">"databaseIdProvider"</span>));</span><br><span class="line">     <span class="comment">//解析类型转换器</span></span><br><span class="line">     typeHandlerElement(root.evalNode(<span class="string">"typeHandlers"</span>));</span><br><span class="line">     <span class="comment">//sql mapper.xml 配置解析</span></span><br><span class="line">     mapperElement(root.evalNode(<span class="string">"mappers"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing SQL Mapper Configuration. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>以上代码，对mybatis-config.xml配置文件内的元素，使用XPath进行逐一读取。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"jdbc.properties"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"STATEMENT"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"multipleResultSetsEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"REUSE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25000"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Student"</span> <span class="attr">type</span>=<span class="string">"com.mybatis3.domain.Student"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Teacher"</span> <span class="attr">type</span>=<span class="string">"com.mybatis3.domain.Teacher"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"com.mybatis3.typehandlers.PhoneTypeHandler"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/mybatis3/mappers/StudentMapper.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">"com/mybatis3/mappers/TeacherMapper.xml"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="mapper配置文件解析"><a href="#mapper配置文件解析" class="headerlink" title="mapper配置文件解析"></a>mapper配置文件解析</h4><blockquote><p>其中最关键的一行代码 <strong>mapperElement(root.evalNode(“mappers”));</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析核心mapper.xml 配置</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> parent</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapperElement</span><span class="params">(XNode parent)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (XNode child : parent.getChildren()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"package"</span>.equals(child.getName())) &#123;</span><br><span class="line">        String mapperPackage = child.getStringAttribute(<span class="string">"name"</span>);</span><br><span class="line">        configuration.addMappers(mapperPackage);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//解析resource属性</span></span><br><span class="line">        String resource = child.getStringAttribute(<span class="string">"resource"</span>);</span><br><span class="line">        <span class="comment">//解析URL属性</span></span><br><span class="line">        String url = child.getStringAttribute(<span class="string">"url"</span>);</span><br><span class="line">        <span class="comment">//解析class属性</span></span><br><span class="line">        String mapperClass = child.getStringAttribute(<span class="string">"class"</span>);</span><br><span class="line">        <span class="comment">//resource属性不为空url为空</span></span><br><span class="line">        <span class="keyword">if</span> (resource != <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(resource);</span><br><span class="line">          <span class="comment">//获取mapper.xml的路径并转换为流</span></span><br><span class="line">          InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">          <span class="comment">//创建Mapper文件解析器</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, resource, configuration.getSqlFragments());</span><br><span class="line">         <span class="comment">//解析mapper配置文件</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">          <span class="comment">//resource为空URL不为空</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url != <span class="keyword">null</span> &amp;&amp; mapperClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">          ErrorContext.instance().resource(url);</span><br><span class="line">          <span class="comment">//根据URL获取流</span></span><br><span class="line">          InputStream inputStream = Resources.getUrlAsStream(url);</span><br><span class="line">          <span class="comment">//创建Mapper文件解析器</span></span><br><span class="line">          XMLMapperBuilder mapperParser = <span class="keyword">new</span> XMLMapperBuilder(inputStream, configuration, url, configuration.getSqlFragments());</span><br><span class="line">          <span class="comment">//解析mapper配置文件</span></span><br><span class="line">          mapperParser.parse();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resource == <span class="keyword">null</span> &amp;&amp; url == <span class="keyword">null</span> &amp;&amp; mapperClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//获取Mapper 的接口</span></span><br><span class="line">          Class&lt;?&gt; mapperInterface = Resources.classForName(mapperClass);</span><br><span class="line">          <span class="comment">//添加mapper接口到配置中</span></span><br><span class="line">          configuration.addMapper(mapperInterface);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"A mapper element may only specify a url, resource or class, but not more than one."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 解析mapper 配置文件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//mapper文件未被加载</span></span><br><span class="line">  <span class="keyword">if</span> (!configuration.isResourceLoaded(resource)) &#123;</span><br><span class="line">    <span class="comment">//配置 mapper 信息</span></span><br><span class="line">    configurationElement(parser.evalNode(<span class="string">"/mapper"</span>));</span><br><span class="line">    <span class="comment">//加载mapper</span></span><br><span class="line">    configuration.addLoadedResource(resource);</span><br><span class="line">    <span class="comment">//构建mapper的命名控件</span></span><br><span class="line">    bindMapperForNamespace();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//解析结果集配置</span></span><br><span class="line">  parsePendingResultMaps();</span><br><span class="line">  <span class="comment">//缓存配置解析</span></span><br><span class="line">  parsePendingCacheRefs();</span><br><span class="line">  <span class="comment">//MapperStatement 解析</span></span><br><span class="line">  parsePendingStatements();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="配置configuration"><a href="#配置configuration" class="headerlink" title="配置configuration"></a>配置configuration</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * configuration</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> context</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configurationElement</span><span class="params">(XNode context)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     String namespace = context.getStringAttribute(<span class="string">"namespace"</span>);</span><br><span class="line">     <span class="keyword">if</span> (namespace == <span class="keyword">null</span> || namespace.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Mapper's namespace cannot be empty"</span>);</span><br><span class="line">     &#125;</span><br><span class="line">     builderAssistant.setCurrentNamespace(namespace);</span><br><span class="line">     cacheRefElement(context.evalNode(<span class="string">"cache-ref"</span>));</span><br><span class="line">     cacheElement(context.evalNode(<span class="string">"cache"</span>));</span><br><span class="line">     <span class="comment">//参数配置解析</span></span><br><span class="line">     parameterMapElement(context.evalNodes(<span class="string">"/mapper/parameterMap"</span>));</span><br><span class="line">     <span class="comment">//结果元素解析</span></span><br><span class="line">     resultMapElements(context.evalNodes(<span class="string">"/mapper/resultMap"</span>));</span><br><span class="line">     <span class="comment">//sql元素解析</span></span><br><span class="line">     sqlElement(context.evalNodes(<span class="string">"/mapper/sql"</span>));</span><br><span class="line">     <span class="comment">//编译 StatementFromContext 添加node 到 incompleteStatements</span></span><br><span class="line">     buildStatementFromContext(context.evalNodes(<span class="string">"select|insert|update|delete"</span>));</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> BuilderException(<span class="string">"Error parsing Mapper XML. The XML location is '"</span> + resource + <span class="string">"'. Cause: "</span> + e, e);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>逐一读取Mapper.xml文件内的各个元素。为了更为直观的了解xml元素至Mybatis的内部数据结构。</p><p><img src="../images/mybatis/build03.png" alt></p><p>​ 这些Xml配置元素，Mybatis将它们分别封装成了ParameterMap、ParameterMapping、ResultMap、ResultMapping、MappedStatement、BoundSql等内部数据结构对象。</p><p>这些数据库结构对象，均放置于Configuration内部保存起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, MappedStatement&gt; mappedStatements = <span class="keyword">new</span> StrictMap&lt;MappedStatement&gt;(<span class="string">"Mapped Statements collection"</span>);</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ResultMap&gt; resultMaps = <span class="keyword">new</span> StrictMap&lt;ResultMap&gt;(<span class="string">"Result Maps collection"</span>);</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Map&lt;String, ParameterMap&gt; parameterMaps = <span class="keyword">new</span> StrictMap&lt;ParameterMap&gt;(<span class="string">"Parameter Maps collection"</span>);</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis初始化流程
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="初始化流程" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="初始化流程" scheme="http://www.baiyp.ren/tags/%E5%88%9D%E5%A7%8B%E5%8C%96%E6%B5%81%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-反射模块04</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-04%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%9704.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-04反射模块04.html</id>
    <published>2019-09-19T08:58:57.000Z</published>
    <updated>2019-09-21T10:20:03.674Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:36 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS反射模块"><a href="#MYBATIS反射模块" class="headerlink" title="MYBATIS反射模块"></a>MYBATIS反射模块</h2><p><img src="../images/mybatis/reflect01.png" alt></p><h3 id="Wrapper包"><a href="#Wrapper包" class="headerlink" title="Wrapper包"></a>Wrapper包</h3><blockquote><p>对各种对象的包装器,Wrapper包装器的大部分功能都是委托<code>MetaClass和MetaObject</code>对象实现的，现在来具体看下它们的实现。</p></blockquote><h4 id="ObjectWrapper-类"><a href="#ObjectWrapper-类" class="headerlink" title="ObjectWrapper 类"></a>ObjectWrapper 类</h4><blockquote><p>ObjectWrapper对象包装器接口，基于 MetaClass工具类，定义对指定对象的各种操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象包装器接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据prop获取对象的属性值</span></span><br><span class="line"><span class="comment">   * 1.如果封装的是普通的Bean对象，则调用相应属性的getter方法</span></span><br><span class="line"><span class="comment">   * 2.如果封装的集合类，则获取指定key或下标对应的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop PropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据prop设置对象的属性值</span></span><br><span class="line"><span class="comment">   * 1.如果封装的是普通的Bean对象，则调用相应属性的setter方法</span></span><br><span class="line"><span class="comment">   * 2.如果封装的集合类，则设置指定key或下标对应的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> propPropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 要设置的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找属性表达式指定的属性，第二个参数表示是否忽略属性表达式中的下划线</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> useCamelCaseMapping 是否开启驼峰命名映射</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对象的可读属性数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String[] getGetterNames();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对象的可写属性数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String[] getSetterNames();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性表达式获取对应的setter方法的参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;?&gt; getSetterType(String name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性表达式获取对应的getter方法的返回值类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;?&gt; getGetterType(String name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否有该属性表达式对应的setter方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否有该属性表达式对应的getter方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性表达式实例化对象，并set到当前对象</span></span><br><span class="line"><span class="comment">   * 主要作用于初始化对象属性也是对象的场景</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否是集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加元素到集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 批量添加到集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BaseWrapper-类"><a href="#BaseWrapper-类" class="headerlink" title="BaseWrapper 类"></a>BaseWrapper 类</h4><blockquote><p>BaseWrapper抽象类，实现ObjectWrapper接口，为子类BeanWrapper和MapWrapper提供公共的方法和属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类，实现ObjectWrapper接口</span></span><br><span class="line"><span class="comment"> * 为子类BeanWrapper和MapWrapper提供公共的方法和属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseWrapper</span> <span class="keyword">implements</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 无参数对象，主要用于执行getter方法所需</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] NO_ARGUMENTS = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// metaObject对象</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> MetaObject metaObject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">BaseWrapper</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metaObject = metaObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理集合：</span></span><br><span class="line"><span class="comment">   * 根据PropertyTokenizer获取对应属性的集合（Array、List、Map）对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop   PropertyTokenizer 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object 指定 Object 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">resolveCollection</span><span class="params">(PropertyTokenizer prop, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">""</span>.equals(prop.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> metaObject.getValue(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据PropertyTokenizer获取集合（Array、List、Map）的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop       PropertyTokenizer 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> collection 集合（Array、List、Map）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 对应下标或key的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">getCollectionValue</span><span class="params">(PropertyTokenizer prop, Object collection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="comment">// 如果是Map类型，则index为key</span></span><br><span class="line">      <span class="keyword">return</span> ((Map) collection).get(prop.getIndex());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是其他集合类型，则index为下标</span></span><br><span class="line">      <span class="keyword">int</span> i = Integer.parseInt(prop.getIndex());</span><br><span class="line">      <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((List) collection).get(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Object[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">char</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">char</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">boolean</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">byte</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">double</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">float</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">float</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">int</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">long</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">short</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">short</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是集合对象抛ReflectionException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"The '"</span> + prop.getName() + <span class="string">"' property of "</span> + collection + <span class="string">" is not a List or Array."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据PropertyTokenizer设置集合（Array、List、Map）的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop       PropertyTokenizer 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> collection 集合（Array、List、Map）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value      值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setCollectionValue</span><span class="params">(PropertyTokenizer prop, Object collection, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="comment">// 如果是Map类型，则index为key</span></span><br><span class="line">      ((Map) collection).put(prop.getIndex(), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是其他集合类型，则index为下标</span></span><br><span class="line">      <span class="keyword">int</span> i = Integer.parseInt(prop.getIndex());</span><br><span class="line">      <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">        ((List) collection).set(i, value);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">        ((Object[]) collection)[i] = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">char</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">char</span>[]) collection)[i] = (Character) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">boolean</span>[]) collection)[i] = (Boolean) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">byte</span>[]) collection)[i] = (Byte) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">double</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">double</span>[]) collection)[i] = (Double) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">float</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">float</span>[]) collection)[i] = (Float) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">int</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">int</span>[]) collection)[i] = (Integer) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">long</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">long</span>[]) collection)[i] = (Long) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">short</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">short</span>[]) collection)[i] = (Short) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是集合对象抛ReflectionException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"The '"</span> + prop.getName() + <span class="string">"' property of "</span> + collection + <span class="string">" is not a List or Array."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BeanWrapper类"><a href="#BeanWrapper类" class="headerlink" title="BeanWrapper类"></a>BeanWrapper类</h4><blockquote><p>BeanWrapper普通对象包装器，继承BaseWrapper类，基于MetaClass实现对Object的属性操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承BaseWrapper，普通Bean包装器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapper</span> <span class="keyword">extends</span> <span class="title">BaseWrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 封装的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object object;</span><br><span class="line">  <span class="comment">// 封装的对象对应的MetaClass对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MetaClass metaClass;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BeanWrapper</span><span class="params">(MetaObject metaObject, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(metaObject);</span><br><span class="line">    <span class="keyword">this</span>.object = object;</span><br><span class="line">    <span class="keyword">this</span>.metaClass = MetaClass.forClass(object.getClass(), metaObject.getReflectorFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性获取对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop PropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在索引信息，则表示该属性表达式中的name部分为集合类型</span></span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过BaseWrapper中的公共方法获取集合对象和集合属性</span></span><br><span class="line">      Object collection = resolveCollection(prop, object);</span><br><span class="line">      <span class="keyword">return</span> getCollectionValue(prop, collection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在索引信息，则name部分为普通对象，查找并调用Invoker相关方法获取属性</span></span><br><span class="line">      <span class="keyword">return</span> getBeanProperty(prop, object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数值属性的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop  PropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 要设置的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在索引信息，则表示该属性表达式中的name部分为集合类型</span></span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object collection = resolveCollection(prop, object);</span><br><span class="line">      <span class="comment">// 通过BaseWrapper中的公共方法获取集合对象,然后设置集合属性</span></span><br><span class="line">      setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在索引信息，则name部分为普通对象，查找并调用Invoker相关方法设置属性</span></span><br><span class="line">      setBeanProperty(prop, object, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据名称查找属性</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name                名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> useCamelCaseMapping 是否开启驼峰命名映射</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> metaClass.findProperty(name, useCamelCaseMapping);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取Get属性的数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> metaClass.getGetterNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取set属性的数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> metaClass.getSetterNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性名称获取set方法的type</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 属性类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 对应的属性值为null</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> metaClass.getSetterType(name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaValue.getSetterType(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaClass.getSetterType(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性获取get方法的type</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 对应的属性值为null</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> metaClass.getGetterType(name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaValue.getGetterType(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaClass.getGetterType(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断属性是否包含set方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      <span class="keyword">if</span> (metaClass.hasSetter(prop.getIndexedName())) &#123;</span><br><span class="line">        MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="comment">//对应的属性值为null</span></span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">          <span class="keyword">return</span> metaClass.hasSetter(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> metaValue.hasSetter(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaClass.hasSetter(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断属性是否包含get方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      <span class="keyword">if</span> (metaClass.hasGetter(prop.getIndexedName())) &#123;</span><br><span class="line">        MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="comment">//对应的属性值为null</span></span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">          <span class="keyword">return</span> metaClass.hasGetter(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> metaValue.hasGetter(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaClass.hasGetter(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 主要针对嵌套属性的场景</span></span><br><span class="line"><span class="comment">   * 即 address.street address.city时</span></span><br><span class="line"><span class="comment">   * address 也是一个对象，且未初始化</span></span><br><span class="line"><span class="comment">   * 首次设置address初始化相关对象并赋值到相关属性</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name          属性名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">    MetaObject metaValue;</span><br><span class="line">    <span class="comment">// 获得 setter 方法的方法参数类型</span></span><br><span class="line">    Class&lt;?&gt; type = getSetterType(prop.getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建对象</span></span><br><span class="line">      Object newObject = objectFactory.create(type);</span><br><span class="line">      <span class="comment">// 创建 MetaObject 对象</span></span><br><span class="line">      metaValue = MetaObject.forObject(newObject, metaObject.getObjectFactory(), metaObject.getObjectWrapperFactory(), metaObject.getReflectorFactory());</span><br><span class="line">      <span class="comment">// 设置当前对象的值</span></span><br><span class="line">      set(prop, newObject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Cannot set value of property '"</span> + name + <span class="string">"' because '"</span> + name + <span class="string">"' is null and cannot be instantiated on instance of "</span> + type.getName() + <span class="string">". Cause:"</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metaValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取Object对应PropertyTokenizer的属性值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop   PropertyTokenizer对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">getBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据属性名称，查找Reflector.getMethods集合中相应的GetFieldInvoker或MethodInvoker</span></span><br><span class="line">      Invoker method = metaClass.getGetInvoker(prop.getName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//反射 获取属性</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(object, NO_ARGUMENTS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Could not get property '"</span> + prop.getName() + <span class="string">"' from "</span> + object.getClass() + <span class="string">".  Cause: "</span> + t.toString(), t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置Object对应PropertyTokenizer的属性值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据属性名称，查找Reflector.getMethods集合中相应的GetFieldInvoker或MethodInvoker</span></span><br><span class="line">      Invoker method = metaClass.getSetInvoker(prop.getName());</span><br><span class="line">      Object[] params = &#123;value&#125;;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//反射 设置属性</span></span><br><span class="line">        method.invoke(object, params);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Could not set property '"</span> + prop.getName() + <span class="string">"' of '"</span> + object.getClass() + <span class="string">"' with value '"</span> + value + <span class="string">"' Cause: "</span> + t.toString(), t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MapWrapper类"><a href="#MapWrapper类" class="headerlink" title="MapWrapper类"></a>MapWrapper类</h4><blockquote><p>MapWrapper是Map对象包装器，继承BaseWrapper类，基于<code>java.util.Map</code>接口方法实现对属性的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map 对象包装器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapWrapper</span> <span class="keyword">extends</span> <span class="title">BaseWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装的Map对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; map;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapWrapper</span><span class="params">(MetaObject metaObject, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(metaObject);</span><br><span class="line">    <span class="keyword">this</span>.map = map;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在索引信息，则表示该属性表达式中的name部分为集合类型</span></span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过BaseWrapper中的公共方法获取集合对象和集合属性</span></span><br><span class="line">      Object collection = resolveCollection(prop, map);</span><br><span class="line">      <span class="keyword">return</span> getCollectionValue(prop, collection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在索引信息，则name部分为普通对象，直接从Map中获取值</span></span><br><span class="line">      <span class="keyword">return</span> map.get(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * set方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop  PropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 要设置的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在索引信息，则表示该属性表达式中的name部分为集合类型</span></span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过BaseWrapper中的公共方法获取集合对象并设置集合属性</span></span><br><span class="line">      Object collection = resolveCollection(prop, map);</span><br><span class="line">      setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在索引信息，则name部分为普通对象，直接Map.put设置值</span></span><br><span class="line">      map.put(prop.getName(), value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找属性</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name                名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> useCamelCaseMapping 是否开启驼峰命名映射</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取key的数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().toArray(<span class="keyword">new</span> String[map.keySet().size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取key的数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().toArray(<span class="keyword">new</span> String[map.keySet().size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取set方法的类型</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 对应的属性值为null</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子表达式由MetaObject处理</span></span><br><span class="line">        <span class="keyword">return</span> metaValue.getSetterType(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">if</span> (map.get(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(name).getClass();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取getet方法的类型</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 对应的属性值为null</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子表达式由MetaObject处理</span></span><br><span class="line">        <span class="keyword">return</span> metaValue.getGetterType(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">if</span> (map.get(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(name).getClass();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包含get方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (map.containsKey(prop.getIndexedName())) &#123;</span><br><span class="line">        <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">        MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="comment">// 对应的属性值为null</span></span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 子表达式由MetaObject处理</span></span><br><span class="line">          <span class="keyword">return</span> metaValue.hasGetter(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> map.containsKey(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 主要针对嵌套属性的场景</span></span><br><span class="line"><span class="comment">   * 即 address.street address.city时</span></span><br><span class="line"><span class="comment">   * 首次设置address会创建一个 key为address value为new HashMap&lt;&gt;()</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Map</span></span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    set(prop, map);</span><br><span class="line">    <span class="comment">// 返回封装map的MetaObject对象</span></span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(map, metaObject.getObjectFactory(), metaObject.getObjectWrapperFactory(), metaObject.getReflectorFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否是集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CollectionWrapper类"><a href="#CollectionWrapper类" class="headerlink" title="CollectionWrapper类"></a>CollectionWrapper类</h4><blockquote><p>CollectionWrapper是Collection对象包装器，直接实现ObjectWrapper接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合包装器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionWrapper</span> <span class="keyword">implements</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 封装的集合对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Object&gt; object;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CollectionWrapper</span><span class="params">(MetaObject metaObject, Collection&lt;Object&gt; object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.object = object;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否是集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加元素到集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">    object.add(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 批量添加元素到集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span> </span>&#123;</span><br><span class="line">    object.addAll(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ObjectWrapperFactory类"><a href="#ObjectWrapperFactory类" class="headerlink" title="ObjectWrapperFactory类"></a>ObjectWrapperFactory类</h4><blockquote><p>ObjectWrapperFactory对象包装器工厂接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象包装器工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapperFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包装了指定对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object 指定对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasWrapperFor</span><span class="params">(Object object)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得指定对象的 ObjectWrapper 对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> metaObject MetaObject 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object     指定对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">ObjectWrapper <span class="title">getWrapperFor</span><span class="params">(MetaObject metaObject, Object object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultObjectWrapperFactory类"><a href="#DefaultObjectWrapperFactory类" class="headerlink" title="DefaultObjectWrapperFactory类"></a>DefaultObjectWrapperFactory类</h4><blockquote><p>DefaultObjectWrapperFactory实现ObjectWrapperFactory接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> * 默认Object包装类工厂</span><br><span class="line"> * <span class="meta">@author</span> Clinton Begin</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultObjectWrapperFactory</span> <span class="keyword">implements</span> <span class="title">ObjectWrapperFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包装了对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object 指定对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWrapperFor</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 未实现的包装工厂</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> metaObject MetaObject 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object     指定对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectWrapper <span class="title">getWrapperFor</span><span class="params">(MetaObject metaObject, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"The DefaultObjectWrapperFactory should never be called to provide an ObjectWrapper."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ObjectWrapperFactory扩展点"><a href="#ObjectWrapperFactory扩展点" class="headerlink" title="ObjectWrapperFactory扩展点"></a>ObjectWrapperFactory扩展点</h5><blockquote><p>可以看到DefaultObjectWrapperFactory并未做任何功能性的设计，但是Mybatis提供了基于mybatis-config配置的扩展。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectWrapperFactory</span> <span class="attr">type</span>=<span class="string">"org.apache.ibatis.builder.ExampleObjectWrapperFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis反射模块
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="反射模块" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="反射模块" scheme="http://www.baiyp.ren/tags/%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-反射模块03</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-04%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%9703.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-04反射模块03.html</id>
    <published>2019-09-18T08:58:57.000Z</published>
    <updated>2019-09-21T08:02:52.810Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:36 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS反射模块"><a href="#MYBATIS反射模块" class="headerlink" title="MYBATIS反射模块"></a>MYBATIS反射模块</h2><p><img src="../images/mybatis/reflect01.png" alt></p><h3 id="MetaObject-类"><a href="#MetaObject-类" class="headerlink" title="MetaObject 类"></a>MetaObject 类</h3><blockquote><p>MetaObject对象的元数据，Mybatis对象操作的工具类，等同于MetaClass。提供了基于对复杂的属性表达式为对象的属性值的获得和设置等方法。</p></blockquote><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/mybatis/metaObject01.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象元数据</span></span><br><span class="line"><span class="comment"> * Mybatis对象操作的工具类，等同于MetaClass</span></span><br><span class="line"><span class="comment"> * 提供了基于对复杂的属性表达式为对象的属性值的获得和设置等方法。</span></span><br><span class="line"><span class="comment"> * 通过组合的方式(封装ObjectWrapper)，对BaseWrapper操作进一步增强。</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 使用了门面模式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetaObject</span> </span>&#123;</span><br><span class="line">  <span class="comment">//原始的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object originalObject;</span><br><span class="line">  <span class="comment">// 包装过的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapper objectWrapper;</span><br><span class="line">  <span class="comment">//对象工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ObjectFactory objectFactory;</span><br><span class="line">  <span class="comment">// 对象包装器工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ObjectWrapperFactory objectWrapperFactory;</span><br><span class="line">  <span class="comment">//反射工厂</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ReflectorFactory reflectorFactory;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构建元对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectWrapperFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> reflectorFactory</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">MetaObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.originalObject = object;</span><br><span class="line">    <span class="keyword">this</span>.objectFactory = objectFactory;</span><br><span class="line">    <span class="keyword">this</span>.objectWrapperFactory = objectWrapperFactory;</span><br><span class="line">    <span class="keyword">this</span>.reflectorFactory = reflectorFactory;</span><br><span class="line">    <span class="comment">// 根据object类型，创建对应的Wrapper对象</span></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> ObjectWrapper) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = (ObjectWrapper) object;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (objectWrapperFactory.hasWrapperFor(object)) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = objectWrapperFactory.getWrapperFor(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> MapWrapper(<span class="keyword">this</span>, (Map) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (object <span class="keyword">instanceof</span> Collection) &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> CollectionWrapper(<span class="keyword">this</span>, (Collection) object);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.objectWrapper = <span class="keyword">new</span> BeanWrapper(<span class="keyword">this</span>, object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 静态的MetaObject创建方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectWrapperFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> reflectorFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MetaObject <span class="title">forObject</span><span class="params">(Object object, ObjectFactory objectFactory, ObjectWrapperFactory objectWrapperFactory, ReflectorFactory reflectorFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// object为null，创建默认的SystemMetaObject.NULL_META_OBJECT</span></span><br><span class="line">      <span class="keyword">return</span> SystemMetaObject.NULL_META_OBJECT;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MetaObject(object, objectFactory, objectWrapperFactory, reflectorFactory);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectFactory <span class="title">getObjectFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objectFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectWrapperFactory <span class="title">getObjectWrapperFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapperFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ReflectorFactory <span class="title">getReflectorFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> reflectorFactory;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getOriginalObject</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> originalObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String propName, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.findProperty(propName, useCamelCaseMapping);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.getGetterNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.getSetterNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.getSetterType(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.getGetterType(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.hasSetter(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.hasGetter(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对象属性的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getValue</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 递归判断子表达式 children ，获取值</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaValue.getValue(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> objectWrapper.get(prop);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置对象的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(String name, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="comment">// 如果对应的属性值为null</span></span><br><span class="line">        <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// don't instantiate child path if value is null</span></span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 调用对应的objectWrapper初始化属性值</span></span><br><span class="line">          metaValue = objectWrapper.instantiatePropertyValue(name, prop, objectFactory);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 递归判断子表达式 children ，设置值</span></span><br><span class="line">      metaValue.setValue(prop.getChildren(), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      objectWrapper.set(prop, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性表达式获取属性值，然后创建MetaObject对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaObject <span class="title">metaObjectForProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    Object value = getValue(name);</span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(value, objectFactory, objectWrapperFactory, reflectorFactory);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectWrapper <span class="title">getObjectWrapper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> objectWrapper.isCollection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">    objectWrapper.add(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    objectWrapper.addAll(list);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Wrapper包"><a href="#Wrapper包" class="headerlink" title="Wrapper包"></a>Wrapper包</h3><blockquote><p>对各种对象的包装器,Wrapper包装器的大部分功能都是委托<code>MetaClass和MetaObject</code>对象实现的，现在来具体看下它们的实现。</p></blockquote><h4 id="ObjectWrapper-类"><a href="#ObjectWrapper-类" class="headerlink" title="ObjectWrapper 类"></a>ObjectWrapper 类</h4><blockquote><p>ObjectWrapper对象包装器接口，基于 MetaClass工具类，定义对指定对象的各种操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象包装器接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据prop获取对象的属性值</span></span><br><span class="line"><span class="comment">   * 1.如果封装的是普通的Bean对象，则调用相应属性的getter方法</span></span><br><span class="line"><span class="comment">   * 2.如果封装的集合类，则获取指定key或下标对应的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop PropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据prop设置对象的属性值</span></span><br><span class="line"><span class="comment">   * 1.如果封装的是普通的Bean对象，则调用相应属性的setter方法</span></span><br><span class="line"><span class="comment">   * 2.如果封装的集合类，则设置指定key或下标对应的value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> propPropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 要设置的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找属性表达式指定的属性，第二个参数表示是否忽略属性表达式中的下划线</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> useCamelCaseMapping 是否开启驼峰命名映射</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对象的可读属性数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String[] getGetterNames();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对象的可写属性数组</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  String[] getSetterNames();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性表达式获取对应的setter方法的参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;?&gt; getSetterType(String name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性表达式获取对应的getter方法的返回值类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;?&gt; getGetterType(String name);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否有该属性表达式对应的setter方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否有该属性表达式对应的getter方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性表达式实例化对象，并set到当前对象</span></span><br><span class="line"><span class="comment">   * 主要作用于初始化对象属性也是对象的场景</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否是集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加元素到集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 批量添加到集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BaseWrapper-类"><a href="#BaseWrapper-类" class="headerlink" title="BaseWrapper 类"></a>BaseWrapper 类</h4><blockquote><p>BaseWrapper抽象类，实现ObjectWrapper接口，为子类BeanWrapper和MapWrapper提供公共的方法和属性</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象类，实现ObjectWrapper接口</span></span><br><span class="line"><span class="comment"> * 为子类BeanWrapper和MapWrapper提供公共的方法和属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseWrapper</span> <span class="keyword">implements</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 无参数对象，主要用于执行getter方法所需</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] NO_ARGUMENTS = <span class="keyword">new</span> Object[<span class="number">0</span>];</span><br><span class="line">  <span class="comment">// metaObject对象</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> MetaObject metaObject;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="title">BaseWrapper</span><span class="params">(MetaObject metaObject)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.metaObject = metaObject;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理集合：</span></span><br><span class="line"><span class="comment">   * 根据PropertyTokenizer获取对应属性的集合（Array、List、Map）对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop   PropertyTokenizer 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object 指定 Object 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">resolveCollection</span><span class="params">(PropertyTokenizer prop, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">""</span>.equals(prop.getName())) &#123;</span><br><span class="line">      <span class="keyword">return</span> object;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> metaObject.getValue(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据PropertyTokenizer获取集合（Array、List、Map）的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop       PropertyTokenizer 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> collection 集合（Array、List、Map）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 对应下标或key的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">getCollectionValue</span><span class="params">(PropertyTokenizer prop, Object collection)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="comment">// 如果是Map类型，则index为key</span></span><br><span class="line">      <span class="keyword">return</span> ((Map) collection).get(prop.getIndex());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是其他集合类型，则index为下标</span></span><br><span class="line">      <span class="keyword">int</span> i = Integer.parseInt(prop.getIndex());</span><br><span class="line">      <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((List) collection).get(i);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((Object[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">char</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">char</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">boolean</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">byte</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">double</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">double</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">float</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">float</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">int</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">int</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">long</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">long</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">short</span>[]) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((<span class="keyword">short</span>[]) collection)[i];</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是集合对象抛ReflectionException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"The '"</span> + prop.getName() + <span class="string">"' property of "</span> + collection + <span class="string">" is not a List or Array."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据PropertyTokenizer设置集合（Array、List、Map）的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop       PropertyTokenizer 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> collection 集合（Array、List、Map）</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value      值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setCollectionValue</span><span class="params">(PropertyTokenizer prop, Object collection, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> Map) &#123;</span><br><span class="line">      <span class="comment">// 如果是Map类型，则index为key</span></span><br><span class="line">      ((Map) collection).put(prop.getIndex(), value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是其他集合类型，则index为下标</span></span><br><span class="line">      <span class="keyword">int</span> i = Integer.parseInt(prop.getIndex());</span><br><span class="line">      <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> List) &#123;</span><br><span class="line">        ((List) collection).set(i, value);</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> Object[]) &#123;</span><br><span class="line">        ((Object[]) collection)[i] = value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">char</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">char</span>[]) collection)[i] = (Character) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">boolean</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">boolean</span>[]) collection)[i] = (Boolean) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">byte</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">byte</span>[]) collection)[i] = (Byte) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">double</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">double</span>[]) collection)[i] = (Double) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">float</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">float</span>[]) collection)[i] = (Float) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">int</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">int</span>[]) collection)[i] = (Integer) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">long</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">long</span>[]) collection)[i] = (Long) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (collection <span class="keyword">instanceof</span> <span class="keyword">short</span>[]) &#123;</span><br><span class="line">        ((<span class="keyword">short</span>[]) collection)[i] = (Short) value;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 不是集合对象抛ReflectionException异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"The '"</span> + prop.getName() + <span class="string">"' property of "</span> + collection + <span class="string">" is not a List or Array."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="BeanWrapper类"><a href="#BeanWrapper类" class="headerlink" title="BeanWrapper类"></a>BeanWrapper类</h4><blockquote><p>BeanWrapper普通对象包装器，继承BaseWrapper类，基于MetaClass实现对Object的属性操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承BaseWrapper，普通Bean包装器。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanWrapper</span> <span class="keyword">extends</span> <span class="title">BaseWrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 封装的对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Object object;</span><br><span class="line">  <span class="comment">// 封装的对象对应的MetaClass对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MetaClass metaClass;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BeanWrapper</span><span class="params">(MetaObject metaObject, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(metaObject);</span><br><span class="line">    <span class="keyword">this</span>.object = object;</span><br><span class="line">    <span class="keyword">this</span>.metaClass = MetaClass.forClass(object.getClass(), metaObject.getReflectorFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性获取对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop PropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在索引信息，则表示该属性表达式中的name部分为集合类型</span></span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过BaseWrapper中的公共方法获取集合对象和集合属性</span></span><br><span class="line">      Object collection = resolveCollection(prop, object);</span><br><span class="line">      <span class="keyword">return</span> getCollectionValue(prop, collection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在索引信息，则name部分为普通对象，查找并调用Invoker相关方法获取属性</span></span><br><span class="line">      <span class="keyword">return</span> getBeanProperty(prop, object);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数值属性的值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop  PropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 要设置的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在索引信息，则表示该属性表达式中的name部分为集合类型</span></span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      Object collection = resolveCollection(prop, object);</span><br><span class="line">      <span class="comment">// 通过BaseWrapper中的公共方法获取集合对象,然后设置集合属性</span></span><br><span class="line">      setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在索引信息，则name部分为普通对象，查找并调用Invoker相关方法设置属性</span></span><br><span class="line">      setBeanProperty(prop, object, value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据名称查找属性</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name                名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> useCamelCaseMapping 是否开启驼峰命名映射</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> metaClass.findProperty(name, useCamelCaseMapping);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取Get属性的数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> metaClass.getGetterNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取set属性的数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> metaClass.getSetterNames();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性名称获取set方法的type</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 属性类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 对应的属性值为null</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> metaClass.getSetterType(name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaValue.getSetterType(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaClass.getSetterType(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据属性获取get方法的type</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 对应的属性值为null</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> metaClass.getGetterType(name);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> metaValue.getGetterType(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaClass.getGetterType(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断属性是否包含set方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      <span class="keyword">if</span> (metaClass.hasSetter(prop.getIndexedName())) &#123;</span><br><span class="line">        MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="comment">//对应的属性值为null</span></span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">          <span class="keyword">return</span> metaClass.hasSetter(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> metaValue.hasSetter(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaClass.hasSetter(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断属性是否包含get方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      <span class="keyword">if</span> (metaClass.hasGetter(prop.getIndexedName())) &#123;</span><br><span class="line">        MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="comment">//对应的属性值为null</span></span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">          <span class="keyword">return</span> metaClass.hasGetter(name);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> metaValue.hasGetter(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> metaClass.hasGetter(name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 主要针对嵌套属性的场景</span></span><br><span class="line"><span class="comment">   * 即 address.street address.city时</span></span><br><span class="line"><span class="comment">   * address 也是一个对象，且未初始化</span></span><br><span class="line"><span class="comment">   * 首次设置address初始化相关对象并赋值到相关属性</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name          属性名</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">    MetaObject metaValue;</span><br><span class="line">    <span class="comment">// 获得 setter 方法的方法参数类型</span></span><br><span class="line">    Class&lt;?&gt; type = getSetterType(prop.getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建对象</span></span><br><span class="line">      Object newObject = objectFactory.create(type);</span><br><span class="line">      <span class="comment">// 创建 MetaObject 对象</span></span><br><span class="line">      metaValue = MetaObject.forObject(newObject, metaObject.getObjectFactory(), metaObject.getObjectWrapperFactory(), metaObject.getReflectorFactory());</span><br><span class="line">      <span class="comment">// 设置当前对象的值</span></span><br><span class="line">      set(prop, newObject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Cannot set value of property '"</span> + name + <span class="string">"' because '"</span> + name + <span class="string">"' is null and cannot be instantiated on instance of "</span> + type.getName() + <span class="string">". Cause:"</span> + e.toString(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> metaValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取Object对应PropertyTokenizer的属性值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop   PropertyTokenizer对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">getBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据属性名称，查找Reflector.getMethods集合中相应的GetFieldInvoker或MethodInvoker</span></span><br><span class="line">      Invoker method = metaClass.getGetInvoker(prop.getName());</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//反射 获取属性</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(object, NO_ARGUMENTS);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Could not get property '"</span> + prop.getName() + <span class="string">"' from "</span> + object.getClass() + <span class="string">".  Cause: "</span> + t.toString(), t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置Object对应PropertyTokenizer的属性值</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setBeanProperty</span><span class="params">(PropertyTokenizer prop, Object object, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 根据属性名称，查找Reflector.getMethods集合中相应的GetFieldInvoker或MethodInvoker</span></span><br><span class="line">      Invoker method = metaClass.getSetInvoker(prop.getName());</span><br><span class="line">      Object[] params = &#123;value&#125;;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//反射 设置属性</span></span><br><span class="line">        method.invoke(object, params);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Could not set property '"</span> + prop.getName() + <span class="string">"' of '"</span> + object.getClass() + <span class="string">"' with value '"</span> + value + <span class="string">"' Cause: "</span> + t.toString(), t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; list)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MapWrapper类"><a href="#MapWrapper类" class="headerlink" title="MapWrapper类"></a>MapWrapper类</h4><blockquote><p>MapWrapper是Map对象包装器，继承BaseWrapper类，基于<code>java.util.Map</code>接口方法实现对属性的操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Map 对象包装器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapWrapper</span> <span class="keyword">extends</span> <span class="title">BaseWrapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 封装的Map对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; map;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MapWrapper</span><span class="params">(MetaObject metaObject, Map&lt;String, Object&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(metaObject);</span><br><span class="line">    <span class="keyword">this</span>.map = map;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在索引信息，则表示该属性表达式中的name部分为集合类型</span></span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过BaseWrapper中的公共方法获取集合对象和集合属性</span></span><br><span class="line">      Object collection = resolveCollection(prop, map);</span><br><span class="line">      <span class="keyword">return</span> getCollectionValue(prop, collection);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在索引信息，则name部分为普通对象，直接从Map中获取值</span></span><br><span class="line">      <span class="keyword">return</span> map.get(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * set方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop  PropertyTokenizer分词器对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 要设置的值</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 存在索引信息，则表示该属性表达式中的name部分为集合类型</span></span><br><span class="line">    <span class="keyword">if</span> (prop.getIndex() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 通过BaseWrapper中的公共方法获取集合对象并设置集合属性</span></span><br><span class="line">      Object collection = resolveCollection(prop, map);</span><br><span class="line">      setCollectionValue(prop, collection, value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不存在索引信息，则name部分为普通对象，直接Map.put设置值</span></span><br><span class="line">      map.put(prop.getName(), value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 查找属性</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name                名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> useCamelCaseMapping 是否开启驼峰命名映射</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取key的数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().toArray(<span class="keyword">new</span> String[map.keySet().size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取key的数组</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">return</span> map.keySet().toArray(<span class="keyword">new</span> String[map.keySet().size()]);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取set方法的类型</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性名称</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 对应的属性值为null</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子表达式由MetaObject处理</span></span><br><span class="line">        <span class="keyword">return</span> metaValue.getSetterType(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">if</span> (map.get(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(name).getClass();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取getet方法的类型</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">      MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">      <span class="comment">// 对应的属性值为null</span></span><br><span class="line">      <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 子表达式由MetaObject处理</span></span><br><span class="line">        <span class="keyword">return</span> metaValue.getGetterType(prop.getChildren());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">if</span> (map.get(name) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> map.get(name).getClass();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Object.class;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包含get方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name 属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据属性表达式创建PropertyTokenizer对象</span></span><br><span class="line">    PropertyTokenizer prop = <span class="keyword">new</span> PropertyTokenizer(name);</span><br><span class="line">    <span class="keyword">if</span> (prop.hasNext()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (map.containsKey(prop.getIndexedName())) &#123;</span><br><span class="line">        <span class="comment">// 有子表达式，根据indexedName创建MetaObject对象</span></span><br><span class="line">        MetaObject metaValue = metaObject.metaObjectForProperty(prop.getIndexedName());</span><br><span class="line">        <span class="comment">// 对应的属性值为null</span></span><br><span class="line">        <span class="keyword">if</span> (metaValue == SystemMetaObject.NULL_META_OBJECT) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 子表达式由MetaObject处理</span></span><br><span class="line">          <span class="keyword">return</span> metaValue.hasGetter(prop.getChildren());</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 没有子表达式</span></span><br><span class="line">      <span class="keyword">return</span> map.containsKey(prop.getName());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 主要针对嵌套属性的场景</span></span><br><span class="line"><span class="comment">   * 即 address.street address.city时</span></span><br><span class="line"><span class="comment">   * 首次设置address会创建一个 key为address value为new HashMap&lt;&gt;()</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> prop</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objectFactory</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Map</span></span><br><span class="line">    HashMap&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 设置值</span></span><br><span class="line">    set(prop, map);</span><br><span class="line">    <span class="comment">// 返回封装map的MetaObject对象</span></span><br><span class="line">    <span class="keyword">return</span> MetaObject.forObject(map, metaObject.getObjectFactory(), metaObject.getObjectWrapperFactory(), metaObject.getReflectorFactory());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否是集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CollectionWrapper类"><a href="#CollectionWrapper类" class="headerlink" title="CollectionWrapper类"></a>CollectionWrapper类</h4><blockquote><p>CollectionWrapper是Collection对象包装器，直接实现ObjectWrapper接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 集合包装器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CollectionWrapper</span> <span class="keyword">implements</span> <span class="title">ObjectWrapper</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 封装的集合对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Collection&lt;Object&gt; object;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CollectionWrapper</span><span class="params">(MetaObject metaObject, Collection&lt;Object&gt; object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.object = object;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(PropertyTokenizer prop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(PropertyTokenizer prop, Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">findProperty</span><span class="params">(String name, <span class="keyword">boolean</span> useCamelCaseMapping)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getGetterNames() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> String[] getSetterNames() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getSetterType(String name) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getGetterType(String name) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MetaObject <span class="title">instantiatePropertyValue</span><span class="params">(String name, PropertyTokenizer prop, ObjectFactory objectFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否是集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加元素到集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Object element)</span> </span>&#123;</span><br><span class="line">    object.add(element);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 批量添加元素到集合</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> element</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;E&gt;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">addAll</span><span class="params">(List&lt;E&gt; element)</span> </span>&#123;</span><br><span class="line">    object.addAll(element);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ObjectWrapperFactory类"><a href="#ObjectWrapperFactory类" class="headerlink" title="ObjectWrapperFactory类"></a>ObjectWrapperFactory类</h4><blockquote><p>ObjectWrapperFactory对象包装器工厂接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对象包装器工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectWrapperFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包装了指定对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object 指定对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> 是否</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">hasWrapperFor</span><span class="params">(Object object)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获得指定对象的 ObjectWrapper 对象</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> metaObject MetaObject 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object     指定对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">ObjectWrapper <span class="title">getWrapperFor</span><span class="params">(MetaObject metaObject, Object object)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultObjectWrapperFactory类"><a href="#DefaultObjectWrapperFactory类" class="headerlink" title="DefaultObjectWrapperFactory类"></a>DefaultObjectWrapperFactory类</h4><blockquote><p>DefaultObjectWrapperFactory实现ObjectWrapperFactory接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> * 默认Object包装类工厂</span><br><span class="line"> * <span class="meta">@author</span> Clinton Begin</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultObjectWrapperFactory</span> <span class="keyword">implements</span> <span class="title">ObjectWrapperFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否包装了对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object 指定对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasWrapperFor</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 未实现的包装工厂</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> metaObject MetaObject 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object     指定对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ObjectWrapper <span class="title">getWrapperFor</span><span class="params">(MetaObject metaObject, Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"The DefaultObjectWrapperFactory should never be called to provide an ObjectWrapper."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="ObjectWrapperFactory扩展点"><a href="#ObjectWrapperFactory扩展点" class="headerlink" title="ObjectWrapperFactory扩展点"></a>ObjectWrapperFactory扩展点</h5><blockquote><p>可以看到DefaultObjectWrapperFactory并未做任何功能性的设计，但是Mybatis提供了基于mybatis-config配置的扩展。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">objectWrapperFactory</span> <span class="attr">type</span>=<span class="string">"org.apache.ibatis.builder.ExampleObjectWrapperFactory"</span>/&gt;</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis反射模块
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="反射模块" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="反射模块" scheme="http://www.baiyp.ren/tags/%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-反射模块02</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-04%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%9702.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-04反射模块02.html</id>
    <published>2019-09-16T08:58:57.000Z</published>
    <updated>2019-09-21T08:02:46.354Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS反射模块"><a href="#MYBATIS反射模块" class="headerlink" title="MYBATIS反射模块"></a>MYBATIS反射模块</h2><p><img src="../images/mybatis/reflect01.png" alt></p><h3 id="Invoker包"><a href="#Invoker包" class="headerlink" title="Invoker包"></a>Invoker包</h3><blockquote><p>这个包中对Java的反射调用进行了二次封装，定义了一个Invoker接口和三个具体实现。我们首先来看Invoker接口</p></blockquote><h4 id="Invoker接口"><a href="#Invoker接口" class="headerlink" title="Invoker接口"></a>Invoker接口</h4><blockquote><p>这个接口定义了两个函数，invoke用来执行具体的调用，getType用来返回调用对象的具体的类型。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Invoker接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调用接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  Class&lt;?&gt; getType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="GetFieldInvoker类"><a href="#GetFieldInvoker类" class="headerlink" title="GetFieldInvoker类"></a>GetFieldInvoker类</h4><blockquote><p>这两个类都实现了Invoker接口,都有一个类型为java.lang.reflect.Field的属性，这个属性在初始化时进行设置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字段中的值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GetFieldInvoker</span> <span class="keyword">implements</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="comment">//具体字段定义</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Field field;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">GetFieldInvoker</span><span class="params">(Field field)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.field = field;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调用方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取字段的值</span></span><br><span class="line">      <span class="keyword">return</span> field.get(target);</span><br><span class="line">      <span class="comment">//如果是私有的</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">        <span class="comment">//如果是私有的使用暴力反射</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(target);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取字段的类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getType() &#123;</span><br><span class="line">    <span class="keyword">return</span> field.getType();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="SetFieldInvoker和GetFieldInvoker类"><a href="#SetFieldInvoker和GetFieldInvoker类" class="headerlink" title="SetFieldInvoker和GetFieldInvoker类"></a>SetFieldInvoker和GetFieldInvoker类</h4><blockquote><p>这两个类都实现了Invoker接口,都有一个类型为java.lang.reflect.Field的属性，这个属性在初始化时进行设置。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">SetFieldInvoker</span><span class="params">(Field field)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.field = field;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 构造方法</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">GetFieldInvoker</span><span class="params">(Field field)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.field = field;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>getType函数返回的是Field的类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取字段的类型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Class&lt;?&gt; getType() &#123;</span><br><span class="line">  <span class="keyword">return</span> field.getType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两个类最大的不同在于对invoke函数的实现上，一个是调用fieldd的set方法，一个是调用Field的get方法。</p><h5 id="获取字段的值"><a href="#获取字段的值" class="headerlink" title="获取字段的值"></a>获取字段的值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 调用方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取字段的值</span></span><br><span class="line">      <span class="keyword">return</span> field.get(target);</span><br><span class="line">      <span class="comment">//如果是私有的</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">        <span class="comment">//如果是私有的使用暴力反射</span></span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> field.get(target);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="设置字段的值"><a href="#设置字段的值" class="headerlink" title="设置字段的值"></a>设置字段的值</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 具体调用</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> args 参数</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">     <span class="comment">//设置字段值</span></span><br><span class="line">     field.set(target, args[<span class="number">0</span>]);</span><br><span class="line">     <span class="comment">//如果是private</span></span><br><span class="line">   &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">     <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">       <span class="comment">//使用暴力反射</span></span><br><span class="line">       field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">       field.set(target, args[<span class="number">0</span>]);</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="keyword">throw</span> e;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h4 id="MethodInvoker类"><a href="#MethodInvoker类" class="headerlink" title="MethodInvoker类"></a>MethodInvoker类</h4><blockquote><p>这个类相对前面两个类要复杂些，主要复杂的地方在于type的确定，这个type的确定是在构造函数中进行的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 方法调用的封装</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MethodInvoker</span> <span class="keyword">implements</span> <span class="title">Invoker</span> </span>&#123;</span><br><span class="line">  <span class="comment">//参数类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">  <span class="comment">//基础属性 method</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Method method;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MethodInvoker</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.method = method;</span><br><span class="line">    <span class="comment">//method的类型不像Field的类型那样，如果这个method有参数，就取第一个参数的类型；如果没有参数就取这个method的返回值</span></span><br><span class="line">    <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line">      type = method.getParameterTypes()[<span class="number">0</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      type = method.getReturnType();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 具体方法的调用</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> target 目标对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args   参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> IllegalAccessException</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> InvocationTargetException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object target, Object[] args)</span> <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//通过反射进行调用</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">      <span class="comment">//如果是私有属性</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">        <span class="comment">//设置暴力反射</span></span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target, args);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取参数类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Class&lt;?&gt; getType() &#123;</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="property包"><a href="#property包" class="headerlink" title="property包"></a>property包</h3><blockquote><p>property包主要来操作对象的属性的</p></blockquote><h4 id="PropertyCopier类"><a href="#PropertyCopier类" class="headerlink" title="PropertyCopier类"></a>PropertyCopier类</h4><blockquote><p>属性复制器,这个类就是就是将一个对象的属性值赋给另一个对象中对应的属性。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 属性复制器</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyCopier</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PropertyCopier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将 sourceBean 的属性，复制到 destinationBean 中</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type            指定类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> sourceBean      来源 Bean 对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> destinationBean 目标 Bean 对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copyBeanProperties</span><span class="params">(Class&lt;?&gt; type, Object sourceBean, Object destinationBean)</span> </span>&#123;</span><br><span class="line">    Class&lt;?&gt; parent = type;</span><br><span class="line">    <span class="comment">// 循环，从当前类开始，不断复制到父类，直到父类不存在</span></span><br><span class="line">    <span class="keyword">while</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 获得当前 parent 类定义的属性</span></span><br><span class="line">      <span class="keyword">final</span> Field[] fields = parent.getDeclaredFields();</span><br><span class="line">      <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 从 sourceBean 中，复制到 destinationBean 去</span></span><br><span class="line">            field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">            <span class="comment">//如果是私有的</span></span><br><span class="line">          &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">              <span class="comment">// 设置属性可访问</span></span><br><span class="line">              field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">              <span class="comment">//属性复制</span></span><br><span class="line">              field.set(destinationBean, field.get(sourceBean));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="comment">// Nothing useful to do, will only fail on final fields, which will be ignored.</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置父类给parent</span></span><br><span class="line">      parent = parent.getSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PropertyNamer类"><a href="#PropertyNamer类" class="headerlink" title="PropertyNamer类"></a>PropertyNamer类</h4><blockquote><p>属性名工具类，主要用来处理getter和setter方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 属性名工具类，主要用来处理getter和setter方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyNamer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PropertyNamer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Prevent Instantiation of Static Class</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据getter或setter方法获取属性名</span></span><br><span class="line"><span class="comment">   * 规则：</span></span><br><span class="line"><span class="comment">   * 1.java bean getter/setter 方法命名规范截取属性名</span></span><br><span class="line"><span class="comment">   * 2.根据驼峰命名法 将第一个字符小写</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">methodToProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"is"</span>)) &#123;</span><br><span class="line">      name = name.substring(<span class="number">2</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (name.startsWith(<span class="string">"get"</span>) || name.startsWith(<span class="string">"set"</span>)) &#123;</span><br><span class="line">      name = name.substring(<span class="number">3</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Error parsing property name '"</span> + name + <span class="string">"'.  Didn't start with 'is', 'get' or 'set'."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果截取的属性名长度为1或长度大于1且第2位字符是小写</span></span><br><span class="line"><span class="comment">     * 例如：</span></span><br><span class="line"><span class="comment">     * getA -&gt; A -&gt; a</span></span><br><span class="line"><span class="comment">     * getAA -&gt; AA -&gt; AA</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (name.length() == <span class="number">1</span> || (name.length() &gt; <span class="number">1</span> &amp;&amp; !Character.isUpperCase(name.charAt(<span class="number">1</span>)))) &#123;</span><br><span class="line">      name = name.substring(<span class="number">0</span>, <span class="number">1</span>).toLowerCase(Locale.ENGLISH) + name.substring(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否为is、get、set方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isProperty</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> isGetter(name) || isSetter(name);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//判断是否为 is、get方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isGetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (name.startsWith(<span class="string">"get"</span>) &amp;&amp; name.length() &gt; <span class="number">3</span>) || (name.startsWith(<span class="string">"is"</span>) &amp;&amp; name.length() &gt; <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  判断是否为set方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSetter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name.startsWith(<span class="string">"set"</span>) &amp;&amp; name.length() &gt; <span class="number">3</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PropertyTokenizer类"><a href="#PropertyTokenizer类" class="headerlink" title="PropertyTokenizer类"></a>PropertyTokenizer类</h4><blockquote><p>这个类是property包中的重量级类，该类会被reflection包中其他的类频繁的引用到。这个类实现了Iterable和Iterator这两个接口，但在使用时经常被用到的是Iterator接口中的hasNext这个函数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 属性分词器</span></span><br><span class="line"><span class="comment"> * 实现 Iterator 接口，属性分词器，支持迭代器的访问方式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyTokenizer</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">PropertyTokenizer</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// 当前表达式的名称</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">// 当前表达式的索引名</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String indexedName;</span><br><span class="line">  <span class="comment">// 索引下标</span></span><br><span class="line">  <span class="keyword">private</span> String index;</span><br><span class="line">  <span class="comment">// 子表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String children;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对传入的表达式，并初始化上面的成员变量</span></span><br><span class="line"><span class="comment">   * 例： orders[0].item[0].name</span></span><br><span class="line"><span class="comment">   * name = orders</span></span><br><span class="line"><span class="comment">   * indexedName =</span></span><br><span class="line"><span class="comment">   * orders[0]</span></span><br><span class="line"><span class="comment">   * children = item[0].name</span></span><br><span class="line"><span class="comment">   * index = 0</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> fullname 待解析的表达式</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PropertyTokenizer</span><span class="params">(String fullname)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初始化 name、children 字符串，使用 '.'作为分隔</span></span><br><span class="line">    <span class="keyword">int</span> delim = fullname.indexOf(<span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      name = fullname.substring(<span class="number">0</span>, delim);</span><br><span class="line">      children = fullname.substring(delim + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      name = fullname;</span><br><span class="line">      children = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    indexedName = name;</span><br><span class="line">    <span class="comment">// 若存在 '[' ，则获得 index ，并修改 name 。</span></span><br><span class="line">    delim = name.indexOf(<span class="string">'['</span>);</span><br><span class="line">    <span class="keyword">if</span> (delim &gt; -<span class="number">1</span>) &#123;</span><br><span class="line">      <span class="comment">// 截取'['与']'中间的字符串</span></span><br><span class="line">      index = name.substring(delim + <span class="number">1</span>, name.length() - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">// 截取'['之前的字符串</span></span><br><span class="line">      name = name.substring(<span class="number">0</span>, delim);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getIndexedName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> indexedName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getChildren</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 经常使用的hasNext函数实现比较简单，就是判断children属性是不是为空</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> children != <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 迭代方法 创建一个以children为表达式的PropertyTokenizer对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PropertyTokenizer <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PropertyTokenizer(children);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"Remove is not supported, as it has no meaning in the context of properties."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis反射模块
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="反射模块" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="反射模块" scheme="http://www.baiyp.ren/tags/%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>JAVA动态追踪技术</title>
    <link href="http://www.baiyp.ren/JAVA%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA%E6%8A%80%E6%9C%AF.html"/>
    <id>http://www.baiyp.ren/JAVA动态追踪技术.html</id>
    <published>2019-09-15T12:37:11.000Z</published>
    <updated>2019-09-15T13:56:40.633Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="JAVA动态追踪技术"><a href="#JAVA动态追踪技术" class="headerlink" title="JAVA动态追踪技术"></a>JAVA动态追踪技术</h2><h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>在遥远的希艾斯星球爪哇国塞沃城中，两名年轻的程序员正在为一件事情苦恼，程序出问题了，一时看不出问题出在哪里，于是有了以下对话：</p><p>“Debug一下吧。”</p><p>“线上机器，没开Debug端口。”</p><p>“看日志，看看请求值和返回值分别是什么？”</p><p>“那段代码没打印日志。”</p><p>“改代码，加日志，重新发布一次。”</p><p>“怀疑是线程池的问题，重启会破坏现场。”</p><p>长达几十秒的沉默之后：“据说，排查问题的最高境界，就是只通过Review代码来发现问题。”</p><p>比几十秒长几十倍的沉默之后：“我轮询了那段代码一十七遍之后，终于得出一个结论。”</p><p>“结论是？”</p><p>“我还没到达只通过Review代码就能发现问题的至高境界。”</p><h3 id="从JSP说起"><a href="#从JSP说起" class="headerlink" title="从JSP说起"></a>从JSP说起</h3><p>​ 对于大多数Java程序员来说，早期的时候，都会接触到一个叫做JSP（Java Server Pages）的技术。虽然这种技术，在前后端代码分离、前后端逻辑分离、前后端组织架构分离的今天来看，已经过时了，但是其中还是有一些有意思的东西，值得拿出来说一说。</p><p>当时刚刚处于Java入门时期的我们，大多数精力似乎都放在了JSP的页面展示效果上了：</p><p>“这个表格显示的行数不对。”</p><p>“原来是for循环写的有问题，改一下，刷新页面再试一遍。”</p><p>“嗯，好了，表格显示没问题了，但是，登录人的姓名没取到啊，是不是Session获取有问题？”</p><p>“有可能，我再改一下，一会儿再刷新试试。”</p><p>……</p><p>​ 在一遍一遍修改代码刷新浏览器页面重试的时候，我们自己也许并没有注意到一件很酷的事情：我们修改完代码，居然只是简单地刷新一遍浏览器页面，修改就生效了，整个过程并没有重启JVM。按照我们的常识，Java程序一般都是在启动时加载类文件，如果都像JSP这样修改完代码，不用重启就生效的话，那文章开头的问题就可以解决了啊：Java文件中加一段日志打印的代码，不重启就生效，既不破坏现场，又可以定位问题。忍不住试一试：修改、编译、替换class文件。额，不行，新改的代码并没有生效。那为什么偏偏JSP可以呢？让我们先来看看JSP的运行原理。</p><p>当我们打开浏览器，请求访问一个JSP文件的时候，整个过程是这样的：</p><p><img src="../images/dynamictracing/jsp01.png" alt></p><p>​ JSP文件修改过后，之所以能及时生效，是因为Web容器（Tomcat）会检查请求的JSP文件是否被更改过。如果发生过更改，那么就将JSP文件重新解析翻译成一个新的Sevlet类，并加载到JVM中。之后的请求，都会由这个新的Servlet来处理。这里有个问题，根据Java的类加载机制，在同一个ClassLoader中，类是不允许重复的。为了绕开这个限制，Web容器每次都会创建一个新的ClassLoader实例，来加载新编译的Servlet类。之后的请求都会由这个新的Servlet来处理，这样就实现了新旧JSP的切换。</p><p>​ HTTP服务是无状态的，所以JSP的场景基本上都是一次性消费。这种通过创建新的ClassLoader来“替换”class的做法行得通，但是对于其他应用，比如Spring框架，即便这样做了，对象多数是单例。对于内存中已经创建好的对象，我们无法通过这种创建新的ClassLoader实例的方法来修改对象行为。</p><p>我就是想不重启应用加个日志打印，就这么难吗？</p><h3 id="Java对象行为"><a href="#Java对象行为" class="headerlink" title="Java对象行为"></a>Java对象行为</h3><p>​ 既然JSP的办法行不通，那我们来看看还有没有其他的办法。仔细想想，我们会发现，文章开头的问题本质上是动态改变内存中已存在对象的行为问题。所以，我们得先弄清楚JVM中和对象行为有关的地方在哪里，有没有更改的可能性。</p><p>我们都知道，对象使用两种东西来描述事物：行为和属性。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(<span class="keyword">int</span> age, String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 上面Person类中age和name是属性，speak是行为。对象是类的实例，每个对象的属性都属于对象本身，但是每个对象的行为却是公共的。举个例子，比如我们现在基于Person类创建了两个对象，personA和personB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person personA = <span class="keyword">new</span> Person(<span class="number">43</span>, <span class="string">"lixunhuan"</span>);</span><br><span class="line"></span><br><span class="line">personA.speak(<span class="string">"我是李寻欢"</span>);</span><br><span class="line"></span><br><span class="line">Person personB = <span class="keyword">new</span> Person(<span class="number">23</span>, <span class="string">"afei"</span>);</span><br><span class="line"></span><br><span class="line">personB.speak(<span class="string">"我是阿飞"</span>);</span><br></pre></td></tr></table></figure><p>personA和personB有各自的姓名和年龄，但是有共同的行为：speak。想象一下，如果我们是Java语言的设计者，我们会怎么存储对象的行为和属性呢？</p><p>“很简单，属性跟着对象走，每个对象都存一份。行为是公共的东西，抽离出来，单独放到一个地方。”</p><p>“咦？抽离出公共的部分，跟代码复用好像啊。”</p><p>“大道至简，很多东西本来都是殊途同归。”</p><p>也就是说，第一步我们首先得找到存储对象行为的这个公共的地方。一番搜索之后，我们发现这样一段描述：</p><blockquote><p>Method area is created on virtual machine startup, shared among all Java virtual machine threads and it is logically part of heap area. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors.</p></blockquote><p>Java的对象行为（方法、函数）是存储在方法区的。</p><p>“方法区中的数据从哪来？”</p><p>“方法区中的数据是类加载时从class文件中提取出来的。”</p><p>“class文件从哪来？”</p><p>“从Java或者其他符合JVM规范的源代码中编译而来。”</p><p>“源代码从哪来？”</p><p>“废话，当然是手写！”</p><p>“倒着推，手写没问题，编译没问题，至于加载……有没有办法加载一个已经加载过的类呢？如果有的话，我们就能修改字节码中目标方法所在的区域，然后重新加载这个类，这样方法区中的对象行为（方法）就被改变了，而且不改变对象的属性，也不影响已经存在对象的状态，那么就可以搞定这个问题了。可是，这岂不是违背了JVM的类加载原理？毕竟我们不想改变ClassLoader。”</p><p>“少年，可以去看看<code>java.lang.instrument.Instrumentation</code>。”</p><h3 id="java-lang-instrument-Instrumentation"><a href="#java-lang-instrument-Instrumentation" class="headerlink" title="java.lang.instrument.Instrumentation"></a>java.lang.instrument.Instrumentation</h3><p>看完文档之后，我们发现这么两个接口：<strong>redefineClasses</strong>和<strong>retransformClasses</strong>。一个是重新定义class，一个是修改class。这两个大同小异，看redefineClasses的说明：</p><blockquote><p>This method is used to replace the definition of a class without reference to the existing class file bytes, as one might do when recompiling from source for fix-and-continue debugging. Where the existing class file bytes are to be transformed (for example in bytecode instrumentation) retransformClasses should be used.</p></blockquote><p>都是替换已经存在的class文件，<strong>redefineClasses</strong>是自己提供字节码文件替换掉已存在的class文件，<strong>retransformClasses</strong>是在已存在的字节码文件上修改后再替换之。</p><p>当然，运行时直接替换类很不安全。比如新的class文件引用了一个不存在的类，或者把某个类的一个field给删除了等等，这些情况都会引发异常。所以如文档中所言，instrument存在诸多的限制：</p><blockquote><p>The redefinition may change method bodies, the constant pool and attributes. The redefinition must not add, remove or rename fields or methods, change the signatures of methods, or change inheritance. These restrictions maybe be lifted in future versions. The class file bytes are not checked, verified and installed until after the transformations have been applied, if the resultant bytes are in error this method will throw an exception.</p></blockquote><p>我们能做的基本上也就是简单修改方法内的一些行为，这对于我们开头的问题，打印一段日志来说，已经足够了。当然，我们除了通过retransform来打印日志，还能做很多其他非常有用的事情，这个下文会进行介绍。</p><p>那怎么得到我们需要的class文件呢？一个最简单的方法，是把修改后的Java文件重新编译一遍得到class文件，然后调用redefineClasses替换。但是对于没有（或者拿不到，或者不方便修改）源码的文件我们应该怎么办呢？其实对于JVM来说，不管是Java也好，Scala也好，任何一种符合JVM规范的语言的源代码，都可以编译成class文件。JVM的操作对象是class文件，而不是源码。所以，从这种意义上来讲，我们可以说“JVM跟语言无关”。既然如此，不管有没有源码，其实我们只需要修改class文件就行了。</p><h3 id="直接操作字节码"><a href="#直接操作字节码" class="headerlink" title="直接操作字节码"></a>直接操作字节码</h3><p>​ Java是软件开发人员能读懂的语言，class字节码是JVM能读懂的语言，class字节码最终会被JVM解释成机器能读懂的语言。无论哪种语言，都是人创造的。所以，理论上（实际上也确实如此）人能读懂上述任何一种语言，既然能读懂，自然能修改。只要我们愿意，我们完全可以跳过Java编译器，直接写字节码文件，只不过这并不符合时代的发展罢了，毕竟高级语言设计之始就是为我们人类所服务，其开发效率也比机器语言高很多。</p><p>​ 对于人类来说，字节码文件的可读性远远没有Java代码高。尽管如此，还是有一些杰出的程序员们创造出了可以用来直接编辑字节码的框架，提供接口可以让我们方便地操作字节码文件，进行注入修改类的方法，动态创造一个新的类等等操作。其中最著名的框架应该就是ASM了，cglib、Spring等框架中对于字节码的操作就建立在ASM之上。</p><p>​ 我们都知道，Spring的AOP是基于动态代理实现的，Spring会在运行时动态创建代理类，代理类中引用被代理类，在被代理的方法执行前后进行一些神秘的操作。那么，Spring是怎么在运行时创建代理类的呢？动态代理的美妙之处，就在于我们不必手动为每个需要被代理的类写代理类代码，Spring在运行时会根据需要动态地创造出一个类。这里创造的过程并非通过字符串写Java文件，然后编译成class文件，然后加载。Spring会直接“创造”一个class文件，然后加载，创造class文件的工具，就是ASM了。</p><p>到这里，我们知道了用ASM框架直接操作class文件，在类中加一段打印日志的代码，然后retransform就可以了。</p><h3 id="BTrace"><a href="#BTrace" class="headerlink" title="BTrace"></a>BTrace</h3><p>截止到目前，我们都是停留在理论描述的层面。那么如何进行实现呢？先来看几个问题：</p><ul><li><p>在我们的工程中，谁来做这个寻找字节码，修改字节码，然后retransform的动作呢？我们并非先知，不可能知道未来有没有可能遇到文章开头的这种问题。考虑到性价比，我们也不可能在每个工程中都开发一段专门做这些修改字节码、重新加载字节码的代码。</p></li><li><p>如果JVM不在本地，在远程呢？</p></li><li><p>如果连ASM都不会用呢？能不能更通用一些，更“傻瓜”一些。</p></li></ul><p>幸运的是，因为有BTrace的存在，我们不必自己写一套这样的工具了。什么是BTrace呢？<a href="https://github.com/btraceio/btrace" rel="external nofollow noopener noreferrer" target="_blank">BTrace</a>已经开源，项目描述极其简短：</p><blockquote><p>A safe, dynamic tracing tool for the Java platform.</p></blockquote><p>BTrace是基于Java语言的一个安全的、可提供动态追踪服务的工具。BTrace基于ASM、Java Attach API、Instrument开发，为用户提供了很多注解。依靠这些注解，我们可以编写BTrace脚本（简单的Java代码）达到我们想要的效果，而不必深陷于ASM对字节码的操作中不可自拔。</p><p>看BTrace官方提供的一个简单例子：拦截所有java.io包中所有类中以read开头的方法，打印类名、方法名和参数名。当程序IO负载比较高的时候，就可以从输出的信息中看到是哪些类所引起，是不是很方便？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.btrace.samples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.AnyType;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This sample demonstrates regular expression</span></span><br><span class="line"><span class="comment"> * probe matching and getting input arguments</span></span><br><span class="line"><span class="comment"> * as an array - so that any overload variant</span></span><br><span class="line"><span class="comment"> * can be traced in "one place". This example</span></span><br><span class="line"><span class="comment"> * traces any "readXX" method on any class in</span></span><br><span class="line"><span class="comment"> * java.io package. Probed class, method and arg</span></span><br><span class="line"><span class="comment"> * array is printed in the action.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@BTrace</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArgArray</span> </span>&#123;</span><br><span class="line">    <span class="meta">@OnMethod</span>(</span><br><span class="line">        clazz=<span class="string">"/java\\.io\\..*/"</span>,</span><br><span class="line">        method=<span class="string">"/read.*/"</span></span><br><span class="line">    )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">anyRead</span><span class="params">(@ProbeClassName String pcn, @ProbeMethodName String pmn, AnyType[] args)</span> </span>&#123;</span><br><span class="line">        println(pcn);</span><br><span class="line">        println(pmn);</span><br><span class="line">        printArray(args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再来看另一个例子：每隔2秒打印截止到当前创建过的线程数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.sun.btrace.samples;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.*;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> com.sun.btrace.BTraceUtils.*;</span><br><span class="line"><span class="keyword">import</span> com.sun.btrace.annotations.Export;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This sample creates a jvmstat counter and</span></span><br><span class="line"><span class="comment"> * increments it everytime Thread.start() is</span></span><br><span class="line"><span class="comment"> * called. This thread count may be accessed</span></span><br><span class="line"><span class="comment"> * from outside the process. The <span class="doctag">@Export</span> annotated</span></span><br><span class="line"><span class="comment"> * fields are mapped to jvmstat counters. The counter</span></span><br><span class="line"><span class="comment"> * name is "btrace." + &lt;className&gt; + "." + &lt;fieldName&gt;</span></span><br><span class="line"><span class="comment"> */</span> </span><br><span class="line"><span class="meta">@BTrace</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCounter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// create a jvmstat counter using @Export</span></span><br><span class="line">    <span class="meta">@Export</span> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnMethod</span>(</span><br><span class="line">        clazz=<span class="string">"java.lang.Thread"</span>,</span><br><span class="line">        method=<span class="string">"start"</span></span><br><span class="line">    ) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onnewThread</span><span class="params">(@Self Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// updating counter is easy. Just assign to</span></span><br><span class="line">        <span class="comment">// the static field!</span></span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@OnTimer</span>(<span class="number">2000</span>) </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">ontimer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// we can access counter as "count" as well</span></span><br><span class="line">        <span class="comment">// as from jvmstat counter directly.</span></span><br><span class="line">        println(count);</span><br><span class="line">        <span class="comment">// or equivalently ...</span></span><br><span class="line">        println(Counters.perfLong(<span class="string">"btrace.com.sun.btrace.samples.ThreadCounter.count"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了上面的用法是不是有所启发？忍不住冒出来许多想法。比如查看HashMap什么时候会触发rehash，以及此时容器中有多少元素等等。</p><p>有了BTrace，文章开头的问题可以得到完美的解决。至于BTrace具体有哪些功能，脚本怎么写，这些Git上BTrace工程中有大量的说明和举例，网上介绍BTrace用法的文章更是恒河沙数，这里就不再赘述了。</p><p>我们明白了原理，又有好用的工具支持，剩下的就是发挥我们的创造力了，只需在合适的场景下合理地进行使用即可。</p><p>既然BTrace能解决上面我们提到的所有问题，那么BTrace的架构是怎样的呢？</p><p>BTrace主要有下面几个模块：</p><ol><li>BTrace脚本：利用BTrace定义的注解，我们可以很方便地根据需要进行脚本的开发。</li><li>Compiler：将BTrace脚本编译成BTrace class文件。</li><li>Client：将class文件发送到Agent。</li><li>Agent：基于Java的Attach API，Agent可以动态附着到一个运行的JVM上，然后开启一个BTrace Server，接收client发过来的BTrace脚本；解析脚本，然后根据脚本中的规则找到要修改的类；修改字节码后，调用Java Instrument的retransform接口，完成对对象行为的修改并使之生效。</li></ol><p>整个BTrace的架构大致如下：</p><p><img src="../images/dynamictracing/btrace01.png" alt></p><p>BTrace最终借Instrument实现class的替换。如上文所说，出于安全考虑，Instrument在使用上存在诸多的限制，BTrace也不例外。BTrace对JVM来说是“只读的”，因此BTrace脚本的限制如下：</p><ol><li>不允许创建对象</li><li>不允许创建数组</li><li>不允许抛异常</li><li>不允许catch异常</li><li>不允许随意调用其他对象或者类的方法，只允许调用com.sun.btrace.BTraceUtils中提供的静态方法（一些数据处理和信息输出工具）</li><li>不允许改变类的属性</li><li>不允许有成员变量和方法，只允许存在<strong>static public void</strong>方法</li><li>不允许有内部类、嵌套类</li><li>不允许有同步方法和同步块</li><li>不允许有循环</li><li>不允许随意继承其他类（当然，java.lang.Object除外）</li><li>不允许实现接口</li><li>不允许使用assert</li><li>不允许使用Class对象</li></ol><p>如此多的限制，其实可以理解。BTrace要做的是，虽然修改了字节码，但是除了输出需要的信息外，对整个程序的正常运行并没有影响。</p><h3 id="Arthas"><a href="#Arthas" class="headerlink" title="Arthas"></a>Arthas</h3><p>​ BTrace脚本在使用上有一定的学习成本，如果能把一些常用的功能封装起来，对外直接提供简单的命令即可操作的话，那就再好不过了。阿里的工程师们早已想到这一点，就在去年（2018年9月份），阿里巴巴开源了自己的Java诊断工具——<a href="https://github.com/alibaba/arthas" rel="external nofollow noopener noreferrer" target="_blank">Arthas</a>。Arthas提供简单的命令行操作，功能强大。究其背后的技术原理，和本文中提到的大致无二。Arthas的文档很全面，想详细了解的话可以戳<a href="https://alibaba.github.io/arthas/" rel="external nofollow noopener noreferrer" target="_blank">这里</a>。</p><p>本文旨在说明Java动态追踪技术的来龙去脉，掌握技术背后的原理之后，只要愿意，各位读者也可以开发出自己的“冰封王座”出来。</p><h3 id="尾声"><a href="#尾声" class="headerlink" title="尾声"></a>尾声</h3><p>现在，让我们试着站在更高的地方“俯瞰”这些问题。</p><p>Java的Instrument给运行时的动态追踪留下了希望，Attach API则给运行时动态追踪提供了“出入口”，ASM则大大方便了“人类”操作Java字节码的操作。</p><p>基于Instrument和Attach API前辈们创造出了诸如JProfiler、Jvisualvm、BTrace这样的工具。以ASM为基础发展出了cglib、动态代理，继而是应用广泛的Spring AOP。</p><p>Java是静态语言，运行时不允许改变数据结构。然而，Java 5引入Instrument，Java 6引入Attach API之后，事情开始变得不一样了。虽然存在诸多限制，然而，在前辈们的努力下，仅仅是利用预留的近似于“只读”的这一点点狭小的空间，仍然创造出了各种大放异彩的技术，极大地提高了软件开发人员定位问题的效率。</p><p>计算机应该是人类有史以来最伟大的发明之一，从电磁感应磁生电，到高低电压模拟0和1的比特，再到二进制表示出几种基本类型，再到基本类型表示出无穷的对象，最后无穷的对象组合交互模拟现实生活乃至整个宇宙。</p><p>两千五百年前，《道德经》有言：“道生一，一生二，二生三，三生万物。”</p><p>两千五百年后，计算机的发展过程也大抵如此吧。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA动态追踪技术
    
    </summary>
    
      <category term="架构" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="动态追踪" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA/"/>
    
    
      <category term="架构" scheme="http://www.baiyp.ren/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="动态追踪" scheme="http://www.baiyp.ren/tags/%E5%8A%A8%E6%80%81%E8%BF%BD%E8%B8%AA/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-反射模块01</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-04%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%9701.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-04反射模块01.html</id>
    <published>2019-09-14T08:58:57.000Z</published>
    <updated>2019-09-21T08:02:38.255Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS反射模块"><a href="#MYBATIS反射模块" class="headerlink" title="MYBATIS反射模块"></a>MYBATIS反射模块</h2><p><img src="../images/mybatis/reflect01.png" alt></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​ MyBatis在进行参数处理、结果映射时等操作时，会涉及大量的反射操作。为了简化这些反射相关操作，MyBatis 在 org.apache.ibatis.reflection 包下提供了专门的反射模块，对反射操作做了近一步封装，提供了更为简洁的 API。</p><img src="../images/mybatis/reflect02.png" style="zoom:50%"><h3 id="Reflector相关类"><a href="#Reflector相关类" class="headerlink" title="Reflector相关类"></a>Reflector相关类</h3><blockquote><p>MyBatis 提供 Reflector 类来缓存类的字段名和 getter/setter 方法的元信息，使得反射时有更好的性能。使用方式是将原始类对象传入其构造方法，生成 Reflector 对象。</p></blockquote><h4 id="Reflector类"><a href="#Reflector类" class="headerlink" title="Reflector类"></a>Reflector类</h4><h5 id="属性和构造方法"><a href="#属性和构造方法" class="headerlink" title="属性和构造方法"></a>属性和构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对应class 的反射封装</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflector</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对应class 的类型</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">  <span class="comment">//可读属性数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line">  <span class="comment">//可写属性列表</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] writablePropertyNames;</span><br><span class="line">  <span class="comment">//setter方法列表</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//getter方法列表</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//set方法map</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//get方法map</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//默认构造器</span></span><br><span class="line">  <span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line">  <span class="comment">//大小写不敏感属性名称列表</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    type = clazz;</span><br><span class="line">    <span class="comment">// 如果存在，记录无参构造方法</span></span><br><span class="line">    addDefaultConstructor(clazz);</span><br><span class="line">    <span class="comment">// 记录字段名与get方法、get方法返回值的映射关系</span></span><br><span class="line">    addGetMethods(clazz);</span><br><span class="line">    <span class="comment">// 记录字段名与set方法、set方法参数的映射关系</span></span><br><span class="line">    addSetMethods(clazz);</span><br><span class="line">    <span class="comment">// 针对没有getter/setter方法的字段，通过Filed对象的反射来设置和读取字段值</span></span><br><span class="line">    addFields(clazz);</span><br><span class="line">    <span class="comment">// 可读的字段名</span></span><br><span class="line">    readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 可写的字段名</span></span><br><span class="line">    writablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">// 保存一份所有字段名大写与原始字段名的映射</span></span><br><span class="line">    <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String propName : writablePropertyNames) &#123;</span><br><span class="line">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加默认构造函数"><a href="#添加默认构造函数" class="headerlink" title="添加默认构造函数"></a>添加默认构造函数</h5><blockquote><p>对应属性defaultConstructor</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加默认的构造方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDefaultConstructor</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  Constructor&lt;?&gt;[] constructors = clazz.getDeclaredConstructors();</span><br><span class="line">  Arrays.stream(constructors).filter(constructor -&gt; constructor.getParameterTypes().length == <span class="number">0</span>)</span><br><span class="line">    .findAny().ifPresent(constructor -&gt; <span class="keyword">this</span>.defaultConstructor = constructor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="注册getter和setter方法"><a href="#注册getter和setter方法" class="headerlink" title="注册getter和setter方法"></a>注册getter和setter方法</h5><blockquote><p>addGetMethods 和 addSetMethods 分别获取类的所有方法，从符合 getter/setter 规范的方法中解析出字段名，并记录方法的参数类型、返回值类型等信息</p></blockquote><h6 id="addGetMethods方法"><a href="#addGetMethods方法" class="headerlink" title="addGetMethods方法"></a>addGetMethods方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加GetMethod</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addGetMethods</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//返回这个类及其父类的所以methods</span></span><br><span class="line">  Method[] methods = getClassMethods(clazz);</span><br><span class="line">  <span class="comment">//过滤为无参的method</span></span><br><span class="line">  Arrays.stream(methods).filter(m -&gt; m.getParameterTypes().length == <span class="number">0</span> &amp;&amp; PropertyNamer.isGetter(m.getName()))</span><br><span class="line">    .forEach(m -&gt; addMethodConflict(conflictingGetters, PropertyNamer.methodToProperty(m.getName()), m));</span><br><span class="line">  resolveGetterConflicts(conflictingGetters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​</p><h6 id="resolveGetterConflicts方法"><a href="#resolveGetterConflicts方法" class="headerlink" title="resolveGetterConflicts方法"></a>resolveGetterConflicts方法</h6><blockquote><p>​ 如果子类覆盖父类的gettter方法，并且返回值发生变化，就会生成2个签名。例如有类 A 及其子类 SubA, A 类中定 义了 getNames()方法，其返回值类型是 List<string>，而在其子类 SubA 中， 覆写了其 getNames()方法且将返回值修改成 ArrayList<string>类型，这种覆写在 Java语言中是合法的。最终得到 的两个方法签名分别是 java.util.List#getNames 和 java.util.ArrayList#getNames，在 Reflector.addUniqueMethods()方法中会被认为是两个不同的 方法并添加到 uniqueMethods 集合中。<br>Reflector.resolveGetterConflicts()方法对这种覆写 的情况进行处理，同时会将处理得到的 getter方法记录到 getMethods集合，并将其返回值类型填充到 getTypes集合 。 Reflector.resolveGetterConflicts()方法的具体实现如下:</string></string></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 去重 判断非法的get方法 并将可用的get方法加入到getMethods</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conflictingGetters</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resolveGetterConflicts</span><span class="params">(Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;Method&gt;&gt; entry : conflictingGetters.entrySet()) &#123;</span><br><span class="line">      Method winner = <span class="keyword">null</span>;</span><br><span class="line">      String propName = entry.getKey();</span><br><span class="line">      <span class="keyword">for</span> (Method candidate : entry.getValue()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (winner == <span class="keyword">null</span>) &#123;</span><br><span class="line">          winner = candidate;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; winnerType = winner.getReturnType();</span><br><span class="line">        Class&lt;?&gt; candidateType = candidate.getReturnType();</span><br><span class="line">        <span class="keyword">if</span> (candidateType.equals(winnerType)) &#123;</span><br><span class="line">          <span class="keyword">if</span> (!<span class="keyword">boolean</span>.class.equals(candidateType)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(</span><br><span class="line">              <span class="string">"Illegal overloaded getter method with ambiguous type for property "</span></span><br><span class="line">                + propName + <span class="string">" in class "</span> + winner.getDeclaringClass()</span><br><span class="line">                + <span class="string">". This breaks the JavaBeans specification and can cause unpredictable results."</span>);</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidate.getName().startsWith(<span class="string">"is"</span>)) &#123;</span><br><span class="line">            winner = candidate;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (candidateType.isAssignableFrom(winnerType)) &#123;</span><br><span class="line">          <span class="comment">// OK getter type is descendant</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (winnerType.isAssignableFrom(candidateType)) &#123;</span><br><span class="line">          winner = candidate;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(</span><br><span class="line">            <span class="string">"Illegal overloaded getter method with ambiguous type for property "</span></span><br><span class="line">              + propName + <span class="string">" in class "</span> + winner.getDeclaringClass()</span><br><span class="line">              + <span class="string">". This breaks the JavaBeans specification and can cause unpredictable results."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用 getMethod 添加getMethod</span></span><br><span class="line">      addGetMethod(propName, winner);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="getMethods方法"><a href="#getMethods方法" class="headerlink" title="getMethods方法"></a>getMethods方法</h6><blockquote><p>填充reflector属性 getMethods, getTypes</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加getMethod</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addGetMethod</span><span class="params">(String name, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isValidPropertyName(name)) &#123;</span><br><span class="line">    getMethods.put(name, <span class="keyword">new</span> MethodInvoker(method));</span><br><span class="line">    Type returnType = TypeParameterResolver.resolveReturnType(method, type);</span><br><span class="line">    getTypes.put(name, typeToClass(returnType));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="addFields方法"><a href="#addFields方法" class="headerlink" title="addFields方法"></a>addFields方法</h6><blockquote><p>Reflector.addFields()方法会处理类中定义的所有字段 ， 并且将处理后的字段信息添加到 setMethods 集合、 setTypes 集合、 getMethods 集合以及 getTypes 集合中，这一点与上述的 Reflector.addGetMethods()方法是一致 的 。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 添加字段列表</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> clazz</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFields</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">      <span class="comment">//如果set方法列表中没有属性</span></span><br><span class="line">      <span class="keyword">if</span> (!setMethods.containsKey(field.getName())) &#123;</span><br><span class="line">        <span class="comment">// issue #379 - removed the check for final because JDK 1.5 allows</span></span><br><span class="line">        <span class="comment">// modification of final fields through reflection (JSR-133). (JGB)</span></span><br><span class="line">        <span class="comment">// pr #16 - final static can only be set by the classloader</span></span><br><span class="line">        <span class="keyword">int</span> modifiers = field.getModifiers();</span><br><span class="line">        <span class="comment">//字段不是 final 类型的并且 不是 静态的</span></span><br><span class="line">        <span class="keyword">if</span> (!(Modifier.isFinal(modifiers) &amp;&amp; Modifier.isStatic(modifiers))) &#123;</span><br><span class="line">          <span class="comment">//添加setField构建的方法</span></span><br><span class="line">          addSetField(field);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果getMethod中没有对应的get方法</span></span><br><span class="line">      <span class="keyword">if</span> (!getMethods.containsKey(field.getName())) &#123;</span><br><span class="line">        <span class="comment">//添加getField构建的方法</span></span><br><span class="line">        addGetField(field);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//父类字段添加到Filed 列表</span></span><br><span class="line">    <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      addFields(clazz.getSuperclass());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h6 id="addSetField方法"><a href="#addSetField方法" class="headerlink" title="addSetField方法"></a>addSetField方法</h6><blockquote><p>对于某些字段没有些setter和getter的属性，mybatis会自动创建setter和getter方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个setMethod用于属性的获取</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> field</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addSetField</span><span class="params">(Field field)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isValidPropertyName(field.getName())) &#123;</span><br><span class="line">    setMethods.put(field.getName(), <span class="keyword">new</span> SetFieldInvoker(field));</span><br><span class="line">    Type fieldType = TypeParameterResolver.resolveFieldType(field, type);</span><br><span class="line">    setTypes.put(field.getName(), typeToClass(fieldType));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="isValidPropertyName-方法"><a href="#isValidPropertyName-方法" class="headerlink" title="isValidPropertyName 方法"></a>isValidPropertyName 方法</h6><blockquote><p>对于一些字段是不需要进行生成getter和setter方法的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 验证属性名称</span></span><br><span class="line"><span class="comment"> * 不嫩以$ 开头 不是代理的</span></span><br><span class="line"><span class="comment"> * 不是serialVersionUID 序列化字段</span></span><br><span class="line"><span class="comment"> * 并且不是class 属性</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPropertyName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !(name.startsWith(<span class="string">"$"</span>) || <span class="string">"serialVersionUID"</span>.equals(name) || <span class="string">"class"</span>.equals(name));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReflectorFactory接口"><a href="#ReflectorFactory接口" class="headerlink" title="ReflectorFactory接口"></a>ReflectorFactory接口</h4><blockquote><p>反射工厂接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 反射工厂接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReflectorFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * class 释放已经混村</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isClassCacheEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置class缓存状态</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> classCacheEnabled</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setClassCacheEnabled</span><span class="params">(<span class="keyword">boolean</span> classCacheEnabled)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取对应class的反射类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultReflectorFactory类"><a href="#DefaultReflectorFactory类" class="headerlink" title="DefaultReflectorFactory类"></a>DefaultReflectorFactory类</h4><blockquote><p>继承了ReflectorFactory接口增加了缓存等功能</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 默认反射工程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultReflectorFactory</span> <span class="keyword">implements</span> <span class="title">ReflectorFactory</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> classCacheEnabled = <span class="keyword">true</span>;</span><br><span class="line">  <span class="comment">//线程安全的hashMap</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Class&lt;?&gt;, Reflector&gt; reflectorMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">DefaultReflectorFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClassCacheEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> classCacheEnabled;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setClassCacheEnabled</span><span class="params">(<span class="keyword">boolean</span> classCacheEnabled)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.classCacheEnabled = classCacheEnabled;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果需要缓存</span></span><br><span class="line">    <span class="keyword">if</span> (classCacheEnabled) &#123;</span><br><span class="line">      <span class="comment">// synchronized (type) removed see issue #461</span></span><br><span class="line">      <span class="comment">//存在则则返回 否则创建</span></span><br><span class="line">      <span class="keyword">return</span> reflectorMap.computeIfAbsent(type, Reflector::<span class="keyword">new</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Reflector(type);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="factory包"><a href="#factory包" class="headerlink" title="factory包"></a>factory包</h3><blockquote><p>该包中包含的内容比较少，一个接口，一个实现类。</p></blockquote><h4 id="ObjectFactory接口"><a href="#ObjectFactory接口" class="headerlink" title="ObjectFactory接口"></a>ObjectFactory接口</h4><blockquote><p>POJO类在创建时通常也就两类操作：</p><ul><li>初始化：分带参数和不带参数两种</li><li>属性赋值。</li></ul></blockquote><p>​ 因而ObjectFactory接口也包含了这样的函数，同时考虑到mybatis配置时的特点，添加了一个额外的函数，具体如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Object 对象工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ObjectFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置一些配置书香</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// NOP</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 利用默认构造函数创建对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *     //利用带有参数的构造函数创建对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否是集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DefaultObjectFactory接口"><a href="#DefaultObjectFactory接口" class="headerlink" title="DefaultObjectFactory接口"></a>DefaultObjectFactory接口</h4><blockquote><p>默认的对象工厂的实现，是对ObjectFactory的具体实现</p><p>MyBatis每次创建结果对象的新实例时，使用ObjectFactory构建POJO</p></blockquote><h5 id="create函数合并"><a href="#create函数合并" class="headerlink" title="create函数合并"></a>create函数合并</h5><blockquote><p>上面我们提到初始化对象时可以调用默认构造函数和带有参数的构造函数，DefaultObjectFactory在实现时直接进行了二次包装，将两个函数的实现合二为一。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对默认创建构造方法进行包装</span></span><br><span class="line"><span class="comment"> * 进行调用create重载</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//调用具体的实现</span></span><br><span class="line">  <span class="keyword">return</span> create(type, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="根据接口获取实现类"><a href="#根据接口获取实现类" class="headerlink" title="根据接口获取实现类"></a>根据接口获取实现类</h5><blockquote><p>在面向对象的开发中我们会提倡面对接口而不是面向具体实现的编程原则，但是在创建对象时则必须指定一个具体的类，为了解决这个问题，mybatis对常用的集合超类指定了具体的实现类：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据接口获取具体的实现</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">protected</span> Class&lt;?&gt; resolveInterface(Class&lt;?&gt; type) &#123;</span><br><span class="line">    Class&lt;?&gt; classToCreate;</span><br><span class="line">    <span class="keyword">if</span> (type == List.class || type == Collection.class || type == Iterable.class) &#123;</span><br><span class="line">      classToCreate = ArrayList.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Map.class) &#123;</span><br><span class="line">      classToCreate = HashMap.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == SortedSet.class) &#123; <span class="comment">// issue #510 Collections Support</span></span><br><span class="line">      classToCreate = TreeSet.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == Set.class) &#123;</span><br><span class="line">      classToCreate = HashSet.class;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      classToCreate = type;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classToCreate;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="判断是否是集合"><a href="#判断是否是集合" class="headerlink" title="判断是否是集合"></a>判断是否是集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 判断是否是集合</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">isCollection</span><span class="params">(Class&lt;T&gt; type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Collection.class.isAssignableFrom(type);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="构造方法创建对象"><a href="#构造方法创建对象" class="headerlink" title="构造方法创建对象"></a>构造方法创建对象</h5><blockquote><p>准备工作完成了，下面我们来了解下具体的创建过程，虽然有些复杂，但是对于了解java的反射机制和类安全会有帮助：</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法创建对象的具体实现</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type                对象类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes 构造方法类型</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs     构造方法参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;                 返回具体的对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//判断类是不是集合类，如果是集合类指定具体的实现类</span></span><br><span class="line">    Class&lt;?&gt; classToCreate = resolveInterface(type);</span><br><span class="line">    <span class="comment">// we know types are assignable</span></span><br><span class="line">    <span class="keyword">return</span> (T) instantiateClass(classToCreate, constructorArgTypes, constructorArgs);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 实例化类</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> type</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgTypes</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> constructorArgs</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> &lt;T&gt;</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">instantiateClass</span><span class="params">(Class&lt;T&gt; type, List&lt;Class&lt;?&gt;&gt; constructorArgTypes, List&lt;Object&gt; constructorArgs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      Constructor&lt;T&gt; constructor;</span><br><span class="line">      <span class="comment">//通过无参构造函数创建对象</span></span><br><span class="line">      <span class="keyword">if</span> (constructorArgTypes == <span class="keyword">null</span> || constructorArgs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        constructor = type.getDeclaredConstructor();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">          <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">            <span class="comment">//必须设置为true,否则在下面的调用时会抛出IllegalAccessException</span></span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">return</span> constructor.newInstance();</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//根据指定的参数列表查找构造函数，并实例化对象</span></span><br><span class="line">      constructor = type.getDeclaredConstructor(constructorArgTypes.toArray(<span class="keyword">new</span> Class[constructorArgTypes.size()]));</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Reflector.canControlMemberAccessible()) &#123;</span><br><span class="line">          constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">          <span class="keyword">return</span> constructor.newInstance(constructorArgs.toArray(<span class="keyword">new</span> Object[constructorArgs.size()]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      String argTypes = Optional.ofNullable(constructorArgTypes).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(Class::getSimpleName).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">      String argValues = Optional.ofNullable(constructorArgs).orElseGet(Collections::emptyList)</span><br><span class="line">        .stream().map(String::valueOf).collect(Collectors.joining(<span class="string">","</span>));</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReflectionException(<span class="string">"Error instantiating "</span> + type + <span class="string">" with invalid types ("</span> + argTypes + <span class="string">") or values ("</span> + argValues + <span class="string">"). Cause: "</span> + e, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis反射模块
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="反射模块" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="反射模块" scheme="http://www.baiyp.ren/tags/%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>HashMap实现原理</title>
    <link href="http://www.baiyp.ren/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/HashMap实现原理.html</id>
    <published>2019-09-12T01:11:04.000Z</published>
    <updated>2019-09-15T08:47:34.396Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:36 GMT+0800 (GMT+08:00) --><h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><p><img src="../images/map/hashmap/hashmap01.png" alt></p><p>​ HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​ HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列号，序列化的时候使用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">/**默认容量，1向左移位4个，00000001变成00010000，也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。**/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//最大容量，2的30次方。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//负载因子，用于扩容使用。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">//当某个桶节点数量大于8时，会转换为红黑树。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">//存储元素的数组，transient关键字表示该属性不能被序列化</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">//将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">//元素数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//统计该map修改的次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">//临界值，也就是元素数量达到临界值时，会进行扩容。</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">//也是负载因子，只不过这个是变量。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里讲讲为什么默认容量大小为16，负载因子为0.75，主要原因是这两个常量的值都是经过大量的计算和统计得出来的最优解，仅仅是这样而已。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>HashMap提供了三个构造函数：</p><ul><li><p>HashMap()：构造一个具有默认初始容量 (16) 和默认负载因子 (0.75) 的空 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DEFAULT_LOAD_FACTOR = 0.75f</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashMap(int initialCapacity)：构造一个带指定初始容量和默负载因子 (0.75) 的空 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和负载因子的空 HashMap。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote><p>调用构造方法进行初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor      扩容因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//容量参数不合理 报错</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                   initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="comment">//扩容因子不合理报错</span></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                   loadFactor);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//初始化扩容因子</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="comment">//设置下次扩容阈值</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​ 在这里提到了两个参数：初始容量，负载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，负载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p><h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h4><blockquote><p>根据参数返回最近的2的n次幂的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//是返回大于输入参数且最近的2的整数次幂的数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//　让cap-1再赋值给n的目的是另找到的目标值大于或等于原值</span></span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种方法的效率非常高，可见Java8对容器优化了很多</p><h3 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><blockquote><p>Node是 HashMap的静态内部，HashMap主干是一个Node数组，Node是HashMap的最基本组成单位。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap 的Node 节点元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; 元素的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 元素的Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 这个节点所在位置的hash值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="comment">//这个节点的Key</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="comment">//这个节点的value</span></span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">//后继节点</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取HashCode</span></span><br><span class="line"><span class="comment">         * key和value 的hash做异或运算 防止hash冲突</span></span><br><span class="line"><span class="comment">          * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> newValue</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            <span class="comment">//替换当前node的value</span></span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="comment">//返回旧的value</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * equals 比较</span></span><br><span class="line"><span class="comment">         * 如果 key和value都一致 判断equals相等</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在jdk8之前HashMap是数组加链表的形式实现，但是在1.8之后为提高哈希冲突后链表的查询速度，当桶内链表长度超过<strong>树化阀值</strong>且总长度超过<strong>最小树化容量</strong>后会将链表转换为红黑树。</p><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><h5 id="查询与修改"><a href="#查询与修改" class="headerlink" title="查询与修改"></a>查询与修改</h5><p>先用散列函数对键进行散列，没有冲突的情况下查询是下标查询，时间复杂度是 O(1),速度很快。</p><p>存在哈希冲突的情况，需要对链表/红黑树进行遍历，equals比对查询。</p><p>性能上，考虑是链表/红黑树上的元素越是越好，越均匀越好；此外HashMap主干未必越长越好，会有用不到的桶浪费空间。</p><h5 id="增加与删除"><a href="#增加与删除" class="headerlink" title="增加与删除"></a>增加与删除</h5><p>​ 由于查询速度快，而桶里用链表/红黑树实现，所以添加和删除效率也很高。HashMap会在size超过阀值后进行调整大下(resize)，所以根据具体情况提前给HashMap一个合适的初始长度是个不错的习惯。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><blockquote><p>put方法是一个重点方法，这里有 HashMap初始化，数据在 HashMap中是如何储存的，什么情况下链表会转换为红黑树等内容，需要仔细研究。</p></blockquote><p><img src="../images/map/hashmap/hashmap03.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里继续调用putVal方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal 方法"></a>putVal 方法</h4><blockquote><p>putVal是final修饰的方法，子类 LinkedHashMap也是用的这各方法，evict（看下面的的第5个参数）就是给 LinkedHashMap使用的，HashMap中并没有什么用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * putVal 方法 真正进行插入操作的方法，</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash         传入key的哈希值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent 如果该值是true,如果存在值就不会进行修改操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict        LinekdHashMap尾操作使用，这里暂无用途</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K, V&gt;[] tab;</span><br><span class="line">       Node&lt;K, V&gt; p;</span><br><span class="line">       <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**********初始化********/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果table长度是0或table是null会调整一次大小</span></span><br><span class="line">       <span class="comment">// 这时tab会指向调整大下后的Node&lt;K,V&gt;[](主干数组)</span></span><br><span class="line">       <span class="comment">// n被赋值为新数组长度</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果没有调整大小，tab指向table</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/********开始查找键的位置，并存储value*******/</span></span><br><span class="line">       <span class="comment">// i = (n - 1) &amp; hash这个是获取key应该在哪个桶里,下面详说</span></span><br><span class="line">       <span class="comment">// 这里将p指向当前key所需要的那个桶</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果空桶，也就是无哈希冲突的情况，直接丢个Node进去。</span></span><br><span class="line">           <span class="comment">// 此时的tab就是table</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//存在冲突，开始寻找我们要找的节点</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">           Node&lt;K, V&gt; e;</span><br><span class="line">           K k;</span><br><span class="line">           <span class="comment">// 判断第一个节点是不是我们找的</span></span><br><span class="line">           <span class="comment">// 此时k储存了 p.key</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">               <span class="comment">// hash值相等，key值相等，定位完成,是修改操作</span></span><br><span class="line">               <span class="comment">// e来储存p这个节点，一会修改</span></span><br><span class="line">               e = p;</span><br><span class="line">               <span class="comment">// 判断是否是红黑树节点</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">               <span class="comment">// 是红黑树节点，存在就返回那个节点，不存在就返回null</span></span><br><span class="line">               e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">               <span class="comment">// 最终，是链表了，开始对链表遍历查找</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">// 上面知道第一个接点不是我们要的，直接获取下一个，并储存给e</span></span><br><span class="line">                   <span class="comment">// 下一个是空，直接丢个Node在这里，然后p.next指向这里</span></span><br><span class="line">                   <span class="comment">// 这里下一个节点地址给了e</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// ！大于树化阀值，开始树化</span></span><br><span class="line">                       <span class="comment">// 注意-1是因为binCount是索引而不是长度</span></span><br><span class="line">                       <span class="comment">// 其实此时链表长度已经是7+1（索引） + 1（新进来的Node）</span></span><br><span class="line">                       <span class="comment">// 已经大于树化阀值8，也就是说链表长度为8时是不会树化的</span></span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//树化</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="comment">//加进去就跳出循环了</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 下个节点有值，且是我们找的节点，跳出去</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//下一个节点不是我们找的节点继续编历</span></span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 上面说了，这有修改操作e才能不是null</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="comment">// 给e新值</span></span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 这个是LinkedHashMap用的，HashMap里是个空实现</span></span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="comment">// 修改就会把旧值返回去</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*********修改完成的后续操作**********/</span></span><br><span class="line">       <span class="comment">// 修改次数加1</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">// 如果size大于阀值，会执行resize()方法调整大小</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold) &#123;</span><br><span class="line">           resize();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 这个是给LinkedHashMap用的，HashMap里也是个空实现</span></span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="comment">// 添加成功返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash 运算</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  key是null就返回0，key不是null就先取hashCode（）</span></span><br><span class="line"><span class="comment">     *  然后与这个hashCode（）无符号右移进行亦或运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为什么要使用异或运算"><a href="#为什么要使用异或运算" class="headerlink" title="为什么要使用异或运算"></a>为什么要使用异或运算</h5><ul><li>这是因为找key的位置时，<code>(n - 1) &amp; hash</code>是table的索引，n的长度不够大时，只和hashCode()的低16位有关，这样发生冲突的概率就变高。</li><li>为减少这种影响，设计者权衡了speed, utility, and quality，将高16位与低16位异或来减少这种影响。设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，既减少了系统的开销，也不会造成的因为高16位没有参与下标的计算(table长度比较小时)而引起的碰撞。</li></ul><p><img src="../images/map/hashmap/hashmap04.jpg" alt></p><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><blockquote><p>这也是一个很重要的方法，主要包括两部分，第一部分是根据size是否超过阀值判断是否需要进行扩容，第二部分是扩容后将原Node[]中数据复制到扩容后的Node[]中</p></blockquote><p><img src="../images/map/hashmap/hashmap05.png" alt></p><h5 id="扩容的三种情况"><a href="#扩容的三种情况" class="headerlink" title="扩容的三种情况"></a>扩容的三种情况</h5><ul><li><p>使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12。</p></li><li><p>指定初始容量的构造方法初始化HashMap。那么从下面源码可以看到初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。</p></li><li><p>HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍</p></li></ul><p>这边也可以引申到一个问题就是HashMap是先插入数据再进行扩容的，但是如果是刚刚初始化容器的时候是先扩容再插入数据。</p><h5 id="扩容部分"><a href="#扩容部分" class="headerlink" title="扩容部分"></a>扩容部分</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 扩容方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">// 原容量，table为null返回0，否则返回table长度</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">//原始阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="comment">//新容量，新阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// table已经初始化，旧容量&gt;0</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 容量已经超过最大容量，直接返回去</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">               <span class="comment">// 2倍扩容后小于最大容量，并且原容量大于默认初始化容量(我还没想清楚为什么要大于默认初始容量)</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">               <span class="comment">// 阀值加倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 原数组容量为0，未初始化，但阀值不为0</span></span><br><span class="line">           <span class="comment">// 也就是构造方法里threshold = tableSizeFor(initialCapacity）这个步骤</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">           <span class="comment">// 啥都没有，默认构造</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 新数组阀值未被赋值</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 使用新的容量*负载因子计算阀值</span></span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">           <span class="comment">// 取计算后阀值和最大容量里较小的那个</span></span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br></pre></td></tr></table></figure><h5 id="复制数据部分"><a href="#复制数据部分" class="headerlink" title="复制数据部分"></a>复制数据部分</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的数组</span></span><br><span class="line">   Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">   table = newTab;</span><br><span class="line">   <span class="comment">//开始复制数据</span></span><br><span class="line">   <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//开始遍历</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">           Node&lt;K, V&gt; e;</span><br><span class="line">           <span class="comment">// 获取桶的第一个节点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//没有后继节点，说明为空，直接移过去</span></span><br><span class="line">               <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//如果是红黑树，分裂放入新数组</span></span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                   ((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">//链表操作在下面</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                   <span class="comment">// 不是直接进行计算元素在新数组中的位置，而是原位置加原数组长度</span></span><br><span class="line">                   Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K, V&gt; next;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="comment">// 把链表下一个节点放在 next里</span></span><br><span class="line">                       next = e.next;</span><br><span class="line">                       <span class="comment">// 该节点不需要移动</span></span><br><span class="line">                       <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">// 尾元素为空，说明链表为空，确定为首元素</span></span><br><span class="line">                           <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               loHead = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 尾元素有就将元素放进尾元素的后继节点</span></span><br><span class="line">                               loTail.next = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 确定尾元素</span></span><br><span class="line">                           loTail = e;</span><br><span class="line">                           <span class="comment">// 该节点需要移动</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">// 尾元素为空，说明链表为空，确定为首元素</span></span><br><span class="line">                           <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               hiHead = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 尾元素有就将元素放进尾元素的后继节点</span></span><br><span class="line">                               hiTail.next = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 确定尾元素</span></span><br><span class="line">                           hiTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//直到遍历完链表跳出</span></span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                   <span class="comment">// 把两个首元素放在两个桶里就可以了</span></span><br><span class="line">                   <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j] = loHead;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j + oldCap] = hiHead;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回新的数组</span></span><br><span class="line">   <span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure><p>复制过程，a过去，假设计算后位置不边，进到i,此时i为null，a进去后即是head，又是tail</p><p>然后循环，到b，假设计算后还是i，i中已经有a，所以b直接丢到a后面，a任是head,单tail已经变成了b</p><p>以此类推，a,b,c,d都会放在i,j中</p><p>其实是先拼完链表才装进桶里的，这里只是方便描述，说成是一个一个过去</p><p>至此，put方法已经说完了，重点是putVal,hash和resize三个方法。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p><img src="../images/map/hashmap/hashmap06.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定的key映射的value，如果value为null，则返回null</span></span><br><span class="line"><span class="comment">     * get可以分为三个步骤：</span></span><br><span class="line"><span class="comment">     * 1.通过hash(Object key)方法计算key的哈希值hash。</span></span><br><span class="line"><span class="comment">     * 2.通过getNode( int hash, Object key)方法获取node。</span></span><br><span class="line"><span class="comment">     * 3.如果node为null，返回null，否则返回node.value。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        <span class="comment">//根据key及其hash值查询node节点，如果存在，则返回该节点的value值</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其最终是调用了 <code>getNode</code> 函数。 其逻辑如下</p><h4 id="getNode方法"><a href="#getNode方法" class="headerlink" title="getNode方法"></a>getNode方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getNode 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 指定参数key的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  指定参数的 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回node，如果没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; first, e;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空，而且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点就和指定参数hash和key匹配上了</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">//返回第一个元素</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点没有匹配上，而且有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                <span class="comment">//如果当前的桶采用红黑树，则调用红黑树的get方法去获取节点</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前的桶不采用红黑树，即桶中节点结构为链式结构</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//匹配上key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    <span class="comment">//返回节点</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历元素直到 没有后继节点</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到 返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><blockquote><p>remove就是先找到节点位置，然后移除,核心方法是removeNode()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 所要删除元素的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除Node节点</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash       要删除元素的hash</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key        删除元素的key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value      remove方法重载时使用，只有同时匹配key-value时移除该节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> matchValue 为true时才会同时匹配key-value进行删除</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> movable    删除节点后是否改变红黑树的结构，般都为true只有在iterator的时候才为false</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*******查找节点的部分*******/</span></span><br><span class="line"></span><br><span class="line">     Node&lt;K, V&gt;[] tab;</span><br><span class="line">     Node&lt;K, V&gt; p;</span><br><span class="line">     <span class="keyword">int</span> n, index;</span><br><span class="line">     <span class="comment">// 1.原数组不为null</span></span><br><span class="line">     <span class="comment">// 2. 原数组长度大于0</span></span><br><span class="line">     <span class="comment">// 3.key数组中的位置不为空</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 声明两个节点node，e</span></span><br><span class="line">         Node&lt;K, V&gt; node = <span class="keyword">null</span>, e;</span><br><span class="line">         K k;</span><br><span class="line">         V v;</span><br><span class="line">         <span class="comment">// 第一个节点就我们要找的节点</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">             <span class="comment">// 先给node，在下面删掉</span></span><br><span class="line">             node = p;</span><br><span class="line">             <span class="comment">//如果第一个不是则向后查找</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果是红黑树，获取该接点并给node</span></span><br><span class="line">             <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">do</span> &#123;</span><br><span class="line">                     <span class="comment">// 如果是要找的节点就把这个节点给node</span></span><br><span class="line">                     <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                         node = e;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 不是把节点给p记录</span></span><br><span class="line">                     p = e;</span><br><span class="line">                     <span class="comment">//遍历节点一直到没有后继节点</span></span><br><span class="line">                 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/**********删除节点的部分*********/</span></span><br><span class="line">         <span class="comment">//节点不为空</span></span><br><span class="line">         <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">             <span class="comment">// 如果是红黑树节点，使用removeTreeNode移除</span></span><br><span class="line">             <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                 ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                 <span class="comment">// 这里执行的就是上面的第一种情况，桶里的第一个节点就是要移除的</span></span><br><span class="line">                 tab[index] = node.next;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 直接将移除的上个节点指向下一个节点</span></span><br><span class="line">                 p.next = node.next;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 修改次数再加1</span></span><br><span class="line">             ++modCount;</span><br><span class="line">             <span class="comment">// 长度 -1</span></span><br><span class="line">             --size;</span><br><span class="line">             <span class="comment">// 给LinkedList使用，这里没啥用</span></span><br><span class="line">             afterNodeRemoval(node);</span><br><span class="line">             <span class="comment">// 删除的值返回去</span></span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 根本没有这个</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p><p>1.什么时候会使用HashMap？他有什么特点？</p><blockquote><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p></blockquote><p>2.你知道HashMap的工作原理吗？</p><blockquote><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p></blockquote><p>3.你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</p><blockquote><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p></blockquote><p>4.你知道hash的实现吗？为什么要这样实现？</p><blockquote><p>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p></blockquote><p>5.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p><blockquote><p>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。<br>关于Java集合的小抄中是这样描述的：<br>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。<br>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。<br>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。<br>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。<br>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。<br>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p></blockquote><p>6.当两个对象的hashcode相同会发生什么？</p><blockquote><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p></blockquote><p>7.如果两个键的hashcode相同，你如何获取值对象？</p><blockquote><p>找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。因此，设计HashMap的key类型时，如果使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择</p></blockquote><p>8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p><blockquote><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置</p></blockquote><p>9.你了解重新调整HashMap大小存在什么问题吗？</p><blockquote><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。因此在并发环境下，我们使用CurrentHashMap来替代HashMap</p></blockquote><p>10.为什么String, Interger这样的wrapper类适合作为键？</p><blockquote><p>因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      HashMap实现原理
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="HashMap" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/HashMap/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="HashMap" scheme="http://www.baiyp.ren/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="http://www.baiyp.ren/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"/>
    <id>http://www.baiyp.ren/JVM垃圾回收机制.html</id>
    <published>2019-09-10T10:10:53.000Z</published>
    <updated>2019-09-15T04:53:30.007Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h2><p><img src="../images/jvm/jvm21.jpg" alt></p><h3 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h3><p>​ 由于程序计数器、虚拟机栈、本地方法栈的生命周期都跟随线程的生命周期，当线程销毁了，内存也就回收了，所以这几个区域不用过多地考虑内存回收。由于堆和方法区的内存都是动态分配的，而且是线程共享的，所以内存回收主要关注这部分区域。</p><p>​ 垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法</p><h3 id="如何判断对象是否存活"><a href="#如何判断对象是否存活" class="headerlink" title="如何判断对象是否存活"></a>如何判断对象是否存活</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>​ 引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li><p><strong>优点</strong>：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p></li><li><p><strong>缺点</strong>：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0</p></li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p><img src="../images/jvm/jvm22.jpg" alt></p><p>​ 可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（Native方法）引用的对象。</li></ul><h3 id="各种引用（Reference）"><a href="#各种引用（Reference）" class="headerlink" title="各种引用（Reference）"></a>各种引用（Reference）</h3><blockquote><p>传统定义：Reference中存储的数据代表的是另一块内存的起始地址。</p></blockquote><p>​ 无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用4种，这四种引用强度依次逐渐减弱。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>​ 在程序代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><h4 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h4><p>​ 用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p><p>​ 软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的，一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM，这些对象就会被回收。</p><h4 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h4><p>​ 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><h4 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用 (PhantomReference)"></a>虚引用 (PhantomReference)</h4><p>​ 也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。</p><h3 id="对象死亡前的最后一次挣扎"><a href="#对象死亡前的最后一次挣扎" class="headerlink" title="对象死亡前的最后一次挣扎"></a>对象死亡前的最后一次挣扎</h3><blockquote><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p></blockquote><h4 id="第一次标记"><a href="#第一次标记" class="headerlink" title="第一次标记"></a>第一次标记</h4><p>​ 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。</p><h4 id="第二次标记"><a href="#第二次标记" class="headerlink" title="第二次标记"></a>第二次标记</h4><p>​ 第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。在<code>finalize()</code>方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</p><p>第二次标记成功的对象将真的会被回收，如果对象在<code>finalize()</code>方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p><h4 id="请忘记-finalize"><a href="#请忘记-finalize" class="headerlink" title="请忘记 finalize"></a>请忘记 finalize</h4><p>finalize可以完成对象的拯救，但是JVM不保证一定能执行，所以请忘记这个“坑”。</p><h3 id="方法区如何判断是否需要回收"><a href="#方法区如何判断是否需要回收" class="headerlink" title="方法区如何判断是否需要回收"></a>方法区如何判断是否需要回收</h3><blockquote><p>方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：</p></blockquote><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>加载该类的<code>ClassLoader</code>已经被回收；</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h3 id="常用的垃圾收集算法"><a href="#常用的垃圾收集算法" class="headerlink" title="常用的垃圾收集算法"></a>常用的垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p><img src="../images/jvm/jvm23.png" alt></p><p>​ <strong>标记-清除算</strong>法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p><p><img src="../images/jvm/jvm24.jpg" alt></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><img src="../images/jvm/jvm25.png" style="zoom:60%"><p>​ <strong>复制算法</strong>的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p><p><img src="../images/jvm/jvm26.jpg" alt></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><img src="../images/jvm/jvm27.jpg" style="zoom:60%"><p>​ <strong>标记-整理算</strong>法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。具体流程见下图：</p><p><img src="../images/jvm/jvm28.jpg" alt></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>​ 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p><p><img src="../images/jvm/jvm30.jpg" alt></p><h5 id="年轻代（Young-Generation）的回收算法"><a href="#年轻代（Young-Generation）的回收算法" class="headerlink" title="年轻代（Young Generation）的回收算法"></a>年轻代（Young Generation）的回收算法</h5><ul><li><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p></li><li><p>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p></li><li><p>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</p></li><li><p>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</p></li></ul><h4 id="老年代（Old-Generation）的回收算法"><a href="#老年代（Old-Generation）的回收算法" class="headerlink" title="老年代（Old Generation）的回收算法"></a>老年代（Old Generation）的回收算法</h4><ul><li><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p></li><li><p>内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高</p></li></ul><h4 id="持久代（Permanent-Generation）的回收算法"><a href="#持久代（Permanent-Generation）的回收算法" class="headerlink" title="持久代（Permanent Generation）的回收算法"></a>持久代（Permanent Generation）的回收算法</h4><p>​  用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM垃圾回收机制
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="垃圾回收" scheme="http://www.baiyp.ren/categories/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="垃圾回收" scheme="http://www.baiyp.ren/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="http://www.baiyp.ren/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html"/>
    <id>http://www.baiyp.ren/JVM垃圾收集器.html</id>
    <published>2019-09-10T10:10:53.000Z</published>
    <updated>2019-09-15T04:54:37.921Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h2><p><img src="../images/jvm/jvm21.jpg" alt></p><h3 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h3><p><img src="../images/jvm/jvm31.png" alt></p><h4 id="Serial收集器（复制算法"><a href="#Serial收集器（复制算法" class="headerlink" title="Serial收集器（复制算法)"></a>Serial收集器（复制算法)</h4><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过<code>-XX:+UseSerialGC</code>来强制指定。</p><h4 id="Serial-Old收集器-标记-整理算法"><a href="#Serial-Old收集器-标记-整理算法" class="headerlink" title="Serial Old收集器(标记-整理算法)"></a>Serial Old收集器(标记-整理算法)</h4><p>老年代单线程收集器，Serial收集器的老年代版本。</p><h4 id="ParNew收集器-停止-复制算法"><a href="#ParNew收集器-停止-复制算法" class="headerlink" title="ParNew收集器(停止-复制算法)　"></a>ParNew收集器(停止-复制算法)</h4><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p><h4 id="Parallel-Old-Scavenge收集器-停止-复制算法"><a href="#Parallel-Old-Scavenge收集器-停止-复制算法" class="headerlink" title="Parallel Old/Scavenge收集器(停止-复制算法)"></a>Parallel Old/Scavenge收集器(停止-复制算法)</h4><p>​ 关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>​ 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><h4 id="CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）"><a href="#CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）" class="headerlink" title="CMS(Concurrent Mark Sweep)收集器（标记-清理算法）"></a>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</h4><p>​ 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>-XX:+UseConcMarkSweepGC ，一般新生代使用ParNew，老年代的用CMS</p><p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，</p><h3 id="GC是什么时候触发的"><a href="#GC是什么时候触发的" class="headerlink" title="GC是什么时候触发的"></a>GC是什么时候触发的</h3><blockquote><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p></blockquote><h4 id="Scavenge-GC"><a href="#Scavenge-GC" class="headerlink" title="Scavenge GC"></a>Scavenge GC</h4><p>​ 一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>​ 对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：</p><ul><li><p>年老代（Tenured）被写满；</p></li><li><p>持久代（Perm）被写满；</p></li><li><p>System.gc()被显示调用；</p></li><li><p>上一次GC之后Heap的各域分配策略动态变化</p></li></ul><h3 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h3><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><blockquote><p>整个过程分为4个步骤</p></blockquote><h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><p>​ 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿（STW -Stop the world）。</p><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p>​ 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。</p><h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><p>​ 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿(STW)。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><h5 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h5><p>不需要停顿。</p><p><img src="../images/jvm/jvm32.png" alt></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>​ 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p><strong>CPU资源敏感</strong>：因为并发阶段多线程占据CPU资源，如果CPU资源不足，效率会明显降低。</p></li><li><p><strong>浮动垃圾：</strong>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p><p>​ 由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。</p><p>​ 在1.6的版本中老年代空间使用率阈值(92%)</p><p>​ 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</p></li><li><p><strong>会产生空间碎片：</strong>标记 - 清除算法会导致产生不连续的空间碎片</p></li></ul><h4 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h4><blockquote><p>G1中重要的参数：-XX:+UseG1GC 使用G1垃圾回收器</p></blockquote><h5 id="内部布局改变"><a href="#内部布局改变" class="headerlink" title="内部布局改变"></a>内部布局改变</h5><blockquote><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p></blockquote><p><img src="../images/jvm/jvm33.png" alt></p><p><strong>算法</strong>：标记—整理 （humongous） 和复制回收算法(survivor)。</p><h5 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h5><h6 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h6><p>​ 选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。（复制回收算法）</p><h6 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h6><p>​ 选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</p><p>​ Mixed GC不是full GC，它只能回收部分老年代的Region。如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。</p><h6 id="全局并发标记（global-concurrent-marking）"><a href="#全局并发标记（global-concurrent-marking）" class="headerlink" title="全局并发标记（global concurrent marking）"></a>全局并发标记（global concurrent marking）</h6><ul><li><strong>初始标记：</strong>仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程(STW)，但耗时很短。</li></ul><ul><li><strong>并发标记：</strong>从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</li></ul><ul><li><strong>最终标记：</strong>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程(STW)，但是可并行执行。</li></ul><ul><li><strong>筛选回收：</strong>首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p><img src="../images/jvm/jvm34.png" alt></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><h6 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h6><p>​ 不会产生内存碎片</p><p>​ 算法：标记—整理 （humongous） 和复制回收算法(survivor)。</p><h6 id="可预测的停顿"><a href="#可预测的停顿" class="headerlink" title="可预测的停顿"></a>可预测的停顿</h6><p>​ G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>G1把内存“化整为零”的思路，理解起来似</p><h5 id="G1GC主要的参数"><a href="#G1GC主要的参数" class="headerlink" title="G1GC主要的参数"></a><strong>G1GC</strong>主要的参数</h5><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-XX:G1HeapRegionSize=n</td><td>设置Region大小，并非最终值</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>设置G1收集过程目标时间，默认值200ms，不是硬性条件</td></tr><tr><td>-XX:G1NewSizePercent</td><td>新生代最小值，默认值5%</td></tr><tr><td>-XX:G1MaxNewSizePercent</td><td>新生代最大值，默认值60%</td></tr><tr><td>-XX:ParallelGCThreads</td><td>STW期间，并行GC线程数</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>并发标记阶段，并行执行的线程数</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent</td><td>设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous</td></tr></tbody></table><h3 id="Stop-The-World现象"><a href="#Stop-The-World现象" class="headerlink" title="Stop The World现象"></a>Stop The World现象</h3><blockquote><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p></blockquote><p><img src="../images/jvm/jvm35.jpg" alt></p><p>​ JVM里有一条特殊的线程－－VM Threads，专门用来执行一些特殊的VM Operation，比如分派GC，thread dump等，这些任务，都需要整个Heap，以及所有线程的状态是静止的，一致的才能进行。所以JVM引入了安全点(Safe Point)的概念，想办法在需要进行VM Operation时，通知所有的线程进入一个静止的安全点。</p><p>​ GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数。</p><p><img src="../images/jvm/jvm36.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM垃圾收集器
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="垃圾回收" scheme="http://www.baiyp.ren/categories/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="垃圾回收" scheme="http://www.baiyp.ren/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM对象分配</title>
    <link href="http://www.baiyp.ren/JVM%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D.html"/>
    <id>http://www.baiyp.ren/JVM对象分配.html</id>
    <published>2019-09-10T06:10:53.000Z</published>
    <updated>2019-09-15T03:16:18.072Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="JVM对象分配"><a href="#JVM对象分配" class="headerlink" title="JVM对象分配"></a>JVM对象分配</h2><p><img src="../images/jvm/jvm14.png" alt></p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><blockquote><p>这里的对象限于普通Java对象，不包括数组和Class对象。</p><p>虚拟机遇到一条new指令时：根据new的参数是否能在常量池中定位到一个类的符号引用,如果没有，说明还未定义该类，抛出ClassNotFoundException；</p></blockquote><p><img src="../images/jvm/jvm15.png" alt></p><p>​</p><h4 id="检查加载"><a href="#检查加载" class="headerlink" title="检查加载"></a>检查加载</h4><p>​ 虚拟机遇到一条new指令时，首先检查指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先执行相应的类加载过程。</p><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><blockquote><p>对象所需要的内存在类加载完成后可以被完全确定，所以只需要把一块确定大小的内存区域从堆中划分出来给这个对象即可。</p></blockquote><h5 id="指针碰撞（Bump-the-Pointer）"><a href="#指针碰撞（Bump-the-Pointer）" class="headerlink" title="指针碰撞（Bump the Pointer）"></a>指针碰撞（Bump the Pointer）</h5><blockquote><p>java堆内存空间规整的情况下使用</p></blockquote><p>​ 如果堆的内存是规整的，所有使用的内存在一边，未使用的内存在另一边，中间是一个作为分界点的指针，那分配空间只需要移动作为分界点的指针（移动距离等于该对象需要的空间）。</p><h5 id="空闲列表（Free-List）"><a href="#空闲列表（Free-List）" class="headerlink" title="空闲列表（Free List）"></a>空闲列表（Free List）</h5><blockquote><p>java堆空间不规整的情况下使用</p></blockquote><p>​ 如果堆的内存是不规整的，那么虚拟机需要维护一个列表，记录那些内存块是可用的，在分配的时候划分一个足够大的内存块给该对象，并且更新列表的记录。Java堆内存是否规整取决于所采用的垃圾收集器是否带有压缩整理的功能。</p><h4 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h4><p>​ 除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p><h5 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h5><p>​ 对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</p><h5 id="分配缓冲"><a href="#分配缓冲" class="headerlink" title="分配缓冲"></a>分配缓冲</h5><p>​ 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:+UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。</p><p>​ TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间（Eden区，默认Eden的1%），减少同步开销。</p><p>​ TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</p><p>分配内存后，虚拟机设置对象的一些必要信息，这些信息存在在对象的对象头中。一般来说，执行new指令后，会接着执行<init>方法，将对象初始化。这样一个真正可用的对象才算完全产生出来。</init></p><p>​ 编译器为每个类生成至少一个实例初始化方法，即<init>()方法。此方法与源程序里的每个<strong>构造方法</strong>对应。如果类没有声明构造方法，则生成一个默认构造方法，该方法仅调用父类的默认构造方法，同时生成与该默认构造方法对应的<init>()方法。<init>()方法内容大概为</init></init></init></p><ul><li>调用另一个<init>()方法（本类的另外一个<init>()方法或父类的<init>()方法）;</init></init></init></li><li>初始化实例变量;</li><li>与其对应的构造方法内的字节码</li></ul><h4 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h4><p>​ （<strong>注意不是构造方法</strong>）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>​ 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</p><h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>​ 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><blockquote><p>对象在内存中的布局可以分为3块区域：</p><ul><li>对象头（header);</li><li>实例数据(Instance Data);</li><li>对齐填充(Padding);</li></ul></blockquote><p><img src="../images/jvm/jvm16.png" alt></p><h4 id="对象头（header"><a href="#对象头（header" class="headerlink" title="对象头（header)"></a>对象头（header)</h4><blockquote><p>对象头包括两部分信息</p></blockquote><ul><li>第一部分用于存储对象自身的运行时数据。如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳等。考虑到虚拟机的空间效率，此部分在32位和64位虚拟机中只占32位或者64位的大小。</li><li>第二部分是类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（并不是所有的虚拟机实现都保留类型指针，查找对象 的元数据信息不一定要通过对象本身）</li></ul><p><strong>如果该对象是数组，那么对象头还会保留一块数据，用于记录数组长度。</strong></p><h4 id="实例数据-Instance-Data"><a href="#实例数据-Instance-Data" class="headerlink" title="实例数据(Instance Data)"></a>实例数据(Instance Data)</h4><p>​ 实例数据是对象真正存储的有效信息，也是在代码中定义的各种类型的字段内容。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。Hotspot虚拟机默认策略是longs/doubles，ints，shorts/chars，bytes/booleans，oops（Ordinary Object Pointers），相同宽度的字段总是分配到一起。在这个去前提下，父类中定义的变量会出现在子类之前。</p><h4 id="对齐填充-Padding"><a href="#对齐填充-Padding" class="headerlink" title="对齐填充(Padding)"></a>对齐填充(Padding)</h4><p>​ 对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。对象正好是9字节的整数，所以当对象其他数据部分（对象实例数据）没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>​ Java程序通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机中的规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机的实现而定的。目前主流的访问方式有试用句柄和直接指针两种：</p><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><blockquote><p>句柄是一种特殊的<a href="https://baike.baidu.com/item/智能指针/10784135" rel="external nofollow noopener noreferrer" target="_blank">智能指针</a> 。句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。</p></blockquote><p><img src="../images/jvm/jvm17.jpg" alt></p><p>​ Java堆划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息</p><h4 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h4><blockquote><p>如果使用直接指针访问， reference中存储的直接就是对象地址。</p></blockquote><p><img src="../images/jvm/jvm18.jpg" alt></p><p>​ 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>使 用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><p>​ 对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。</p><h3 id="堆内存分配策略"><a href="#堆内存分配策略" class="headerlink" title="堆内存分配策略"></a>堆内存分配策略</h3><blockquote><p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from（S1）和to（S2））</p></blockquote><p><img src="../images/jvm/jvm19.png" alt></p><p>​ Eden和Survival的默认分配比例为<strong>8：1</strong>。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理，后面会说到)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>​ 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>​ 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><p>​ 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p>​ 永久代主要用于存放静态文件，Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持永久代空间来存放这些运行过程中新增的类。永久代大小通过-XX: MaxPermSize =<n>进行设置。</n></p><h4 id="优先使用Eden区域"><a href="#优先使用Eden区域" class="headerlink" title="优先使用Eden区域"></a>优先使用Eden区域</h4><p>​ 大多数新生代对象都在Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><h4 id="大对象直接放入老年代"><a href="#大对象直接放入老年代" class="headerlink" title="大对象直接放入老年代"></a>大对象直接放入老年代</h4><p>​ 大对象是指需要大量内存空间的Java对象，最典型的大对象就是那种很长的字符串和数组（byte[ ]就是典型的大对象）。出现大对象很容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><p>​ 虚拟机提供了一个-XX: PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>​ Java虚拟机采用分代收集的思想来管理虚拟机内存。虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并且经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄增加到一定程度（默认15岁），就会被晋升到老年代。对晋升到老年代的对象的阈值可以通过-XX:MaxTenuringThreshold设置。</p><h4 id="动态判断对象年龄"><a href="#动态判断对象年龄" class="headerlink" title="动态判断对象年龄"></a>动态判断对象年龄</h4><p>​ 虚拟并不是永远都要求对象年龄必须达到MaxTenuringThreshold才能晋升为老年代的，如果在Survivor的空间相同年龄的所有对象大小总和大于Survivor空间的一半时，年龄大于或者等于该年龄的对象直接进入老年代，无需要等到MaxTenuringThreshold中要求的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><img src="../images/jvm/jvm20.png" alt></p><p>​ 在发生Minor GC之前，虚拟机会先检查老年代可用的连续空间是否大于所有新生代的总空间，如果大于的话，那么这个GC就可以保证安全，如果不成立的，那么可能会造成晋升老年代的时候内存不足。在这样的情况下，虚拟机会先检查HandlePromotionFailure设置值是否允许担保失败，如果是允许的，那么说明虚拟机允许这样的风险存在并坚持运行，然后检查老年代的最大连续可用空间是否大于历次晋升老年代对象的平均大小，如果大于的话，就执行Minor GC,如果小于，或者HandlePromotionFailure设置不允许冒险，那么就会先进行一次Full GC将老年代的内存清理出来，然后再判断。</p><p>​ 上面提到的风险，是由于新生代因为存活对象采用复制算法，但为了内存利用率，只使用其中的一个Survivor空间，将存活的对象备份到Survivor空间上，一旦出现大量对象在一次Minor GC以后依然存活（最坏的计划就是没有发现有对象死亡需要清理），那么就需要老年代来分担一部分内存，把在Survivor上分配不下的对象直接进入老年代，因为我们不知道实际上具体需要多大内存，我们只能估算一个合理值，这个值采用的方法就是计算出每次晋升老年代的平均内存大小作为参考，如果需要的话，那就提前进行一次Full GC.</p><p>​ 取平均值在大多数情况下是可行的，但是因为内存分配的不确定性太多，保不定哪次运行突然出现某些大对象或者Minor GC以后多数对象依然存活，导致内存远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。这样的情况下，担保失败是要付出代价的，大部分情况下都还是会将HandlePromotionFailure开关打开，毕竟失败的几率比较小，这样的担保可以避免Full GC过于频繁，垃圾收集器频繁的启动肯定是不好的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM对象分配
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="对象分配" scheme="http://www.baiyp.ren/categories/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="对象分配" scheme="http://www.baiyp.ren/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM整体介绍</title>
    <link href="http://www.baiyp.ren/JVM%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://www.baiyp.ren/JVM整体介绍.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T14:17:20.473Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="JVM整体介绍"><a href="#JVM整体介绍" class="headerlink" title="JVM整体介绍"></a>JVM整体介绍</h2><h3 id="JAVA技术体系结构"><a href="#JAVA技术体系结构" class="headerlink" title="JAVA技术体系结构"></a>JAVA技术体系结构</h3><blockquote><p>Java虚拟机（Java Virtual Machine 简称 JVM）是<strong>运行所有Java程序</strong>的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。</p></blockquote><p><img src="../images/jvm/jvm01.png" alt></p><p>Java虚拟机是整个Java技术体系最重要的基础。</p><h3 id="为什么要了解虚拟机"><a href="#为什么要了解虚拟机" class="headerlink" title="为什么要了解虚拟机"></a>为什么要了解虚拟机</h3><ul><li><p>首先，Java 虚拟机提供了许多配置参数，用于满足不同应用场景下，对程序性能的需求。学习Java 虚拟机，你可以针对自己的应用，最优化匹配运行参数。</p></li><li><p>其次，Java 虚拟机本身是一种工程产品，在实现过程中自然存在不少局限性。学习 Java 虚拟机，可以更好地规避它在使用中的 Bug，也可以更快地识别出 Java 虚拟机中的错误</p></li><li><p>再次，Java 虚拟机拥有当前最前沿、最成熟的垃圾回收算法实现，以及即时编译器实现。学习Java 虚拟机，我们可以了解背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。</p></li><li><p>最后，Java 虚拟机发展到了今天，已经脱离 Java 语言，形成了一套相对独立的、高性能的执行方案。除了 Java 外，Scala、Clojure、Groovy，以及时下热门的 Kotlin，这些语言都可以运行在 Java 虚拟机之上。学习 Java 虚拟机，便可以了解这些语言的通用机制，甚至于让这些语言共享生态系统。</p></li></ul><h3 id="未来的Java技术"><a href="#未来的Java技术" class="headerlink" title="未来的Java技术"></a>未来的Java技术</h3><ul><li><p><strong>模块化</strong>:OSGI（动态化、模块化），应用层面就是微服务，互联网的发展方向</p></li><li><p><strong>混合语言</strong>：多个语言都可以运行在JVM中，google的Kotlin 成为了 Android 的官方语言。Scala(Kafka)</p></li><li><p><strong>多核并行</strong>：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)</p></li><li><p><strong>丰富语法：</strong>JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource</p></li><li><p><strong>64**</strong>位：**虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位，32位的JVM有4G的堆大小限制。</p></li><li><p><strong>更强的垃圾回收器（现在主流CMS、G1）：</strong>JDK11 –ZGC（暂停时间不超过10毫秒，且不会随着堆的增加而增加，TB级别的堆回收））：有色指针、加载屏障。JDK12支持并发类卸载，进一步缩短暂停时间 JDK13(计划于2019年9月)将最大堆大小从4TB增加到16TB</p></li></ul><h3 id="JVM的整体介绍"><a href="#JVM的整体介绍" class="headerlink" title="JVM的整体介绍"></a>JVM的整体介绍</h3><p><img src="../images/jvm/jvm02.jpg" alt></p><h4 id="JVM是如何工作的"><a href="#JVM是如何工作的" class="headerlink" title="JVM是如何工作的"></a>JVM是如何工作的</h4><blockquote><p>JVM分成3个主要的子系统</p><ul><li><p>类加载器子系统</p></li><li><p>运行时数据区</p></li><li><p>执行引擎</p></li></ul></blockquote><h5 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h5><blockquote><p>Java的动态类加载功能是通过类加载子系统去处理的。</p><p>它并不是在编译时候，而是在首次运行时加载引用类时、连接并初始化类文件。</p></blockquote><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><blockquote><p>类通过该组件加载。通过引导类加载器，扩展类加载器，应用类加载器这三个类加载器帮助完成加载。</p></blockquote><ol><li><p><strong>引导类加载器</strong></p><p>负责从引导类路径去加载类，除了rt.jar之外，没其他别的jar。给予该加载器最高的优先级。</p></li><li><p><strong>扩展类加载器</strong></p><p>负责加载ext目录（jre\lib）的类</p></li><li><p><strong>应用加载器</strong></p><p>负责加载类路径中应用级别的类，path提到的环境变量，等等。</p></li></ol><p>以上的类加载器在加载类文件的时候遵循委托层次算法。</p><h6 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h6><ol><li><strong>验证</strong>-字节码验证器验证生成的字节码是否正确，如果验证失败，我们将收到验证的错误信息。</li><li><strong>准备</strong>-为所有的静态变量分配内存和默认值</li><li><strong>解析</strong>-用方法区的原始引用代替所有符号内存引用。</li></ol><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><blockquote><p>这是类加载的最后一个阶段，此时所有的静态变量都用原始值去赋值，并且将运行静态代码块。</p></blockquote><h5 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h5><blockquote><p>运行时数据区域分成5个主要的组件</p></blockquote><h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><blockquote><p>所有类级的数据都存储在这里，包括静态变量。</p><p>每个JVM只有一个方法区，它是一个共享资源。</p></blockquote><h6 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h6><blockquote><p>所有的对象和对应的实例变量以及数组都存储在这里。</p><p>每个JVM只有一个堆区，由于方法区和堆区为多个线程共享内存，所以存储的数据不是线程安全的。</p></blockquote><h6 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h6><blockquote><p>为每个线程，创建一个单独的运行时栈。为每个方法调用，在栈内存创建一个条目，称之为栈帧。所有本地变量都会在栈内存中创建。由于它不是共享的资源，所有是线程安全的。</p><p>栈帧被分成3子实体</p></blockquote><ol><li>本地变量数组-涉及跟方法有关的本地变量和对应的值都存储在这里。</li><li>操作数栈-如果需要执行中间操作，操作数堆栈作为运行时工作区来执行操作。</li><li>帧数据-所有和对应方法的标记都存储在里面。在发生异常的情况下，捕捉块信息在这里维护。</li></ol><h6 id="程序计数器寄存器"><a href="#程序计数器寄存器" class="headerlink" title="程序计数器寄存器"></a>程序计数器寄存器</h6><blockquote><p>每个线程都有自己的程序计数器寄存器，持有当前执行指令的地址，一旦当前指令执行被运行，下一个指令将会更新到程序计数器寄存器。</p></blockquote><h5 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h5><blockquote><p>字节码被分配到执行引擎执行的运行时数据区。执行引擎一块一块的读取字节码并执行。</p></blockquote><h6 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h6><blockquote><p>解释器解释字节码很快，但是执行的很慢。解释器的缺点是当一个方法被调用多次，每次都需要一个新的解释。</p></blockquote><h6 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h6><blockquote><p>JIT弥补了解释器的缺点。执行引擎将利用解释器转换字节码，但是当他找到重复的编码，它就使用编译器。编译器编译全部的字节码并变成本地代码</p><p>这些本地码将直接被方法调用重复地使用，这就改善了系统的性能。</p></blockquote><ol><li><strong>中间代码生成器</strong>-生成中间代码。</li><li><strong>代码优化器</strong>-负责优化上面生成的代码</li><li><strong>目标代码生成器</strong>-负责生成机器码或者本地代码</li><li><strong>分析器</strong>-一个特殊的组件，负责寻找hotspots,即是否方法被调用多次。</li></ol><h6 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h6><blockquote><p>收集和清除未被引用的对象，可以通过System.gc()触发垃圾回收，但是不保证一定执行。创建收集对象的JVM垃圾收集。</p></blockquote><p><strong>Java Native Interface (JNI)：</strong>JNI和本地方法库互动，特供本地库所需的执行引擎。</p><p><strong>Native Method Libraries:</strong> 这是执行引擎所需的本地方法的一个集合</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM整体介绍
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="内存结构" scheme="http://www.baiyp.ren/categories/jvm/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="整体介绍" scheme="http://www.baiyp.ren/tags/%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM永久代与元空间</title>
    <link href="http://www.baiyp.ren/JVM%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%8E%E5%85%83%E7%A9%BA%E9%97%B4.html"/>
    <id>http://www.baiyp.ren/JVM永久代与元空间.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T14:16:49.803Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="JVM永久代与元空间"><a href="#JVM永久代与元空间" class="headerlink" title="JVM永久代与元空间"></a>JVM永久代与元空间</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="方法区与永久代"><a href="#方法区与永久代" class="headerlink" title="方法区与永久代"></a>方法区与永久代</h3><blockquote><p>方法区和永久代又有着本质的区别。<strong>前者是 JVM 的规范</strong>，<strong>而后者则是 JVM 规范的一种实现</strong>，并且只有 HotSpot 才有永久代，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出</p></blockquote><p>​ 在Java虚拟机规范中，方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择不在方法区实现垃圾回收与压缩。这个版本的虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。所以不同的JVM厂商，针对自己的JVM可能有不同的方法区实现方式。</p><p>​ 在HotSpot中，设计者将方法区纳入GC分代收集。HotSpot虚拟机堆内存被分为新生代和老年代，对堆内存进行分代管理，所以HotSpot虚拟机使用者更愿意将方法区称为老年代。</p><p>​ 方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。</p><p>​ 我们知道在HotSpot虚拟机中存在三种垃圾回收现象，minor GC、major GC和full GC。对新生代进行垃圾回收叫做minor GC，对老年代进行垃圾回收叫做major GC，同时对新生代、老年代和永久代进行垃圾回收叫做full GC。许多major GC是由minor GC触发的，所以很难将这两种垃圾回收区分开。major GC和full GC通常是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是major GC。</p><h4 id="大小调节"><a href="#大小调节" class="headerlink" title="大小调节"></a>大小调节</h4><blockquote><p>在1.7之前，可以使用如下参数来调节方法区的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法区初始大小</span></span><br><span class="line">-XX:PermSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法区最大大小, 超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen</span></span><br><span class="line">-XX:MaxPermSize</span><br></pre></td></tr></table></figure><h3 id="jdk8中的方法区"><a href="#jdk8中的方法区" class="headerlink" title="jdk8中的方法区"></a>jdk8中的方法区</h3><p>​ 在jdk8中已经将永久带移除了。也就是说-XX:PermSize这些参数在jdk8中将是无效的。<br>移除了，肯定有人来代替他。就是新出现的元空间(Metaspace)来代替原来的永久带。</p><p>方法区中主要存放的是一些描述性信息，即元数据。</p><p>​ 方法区是堆的逻辑组成部分。实际上JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，但是并没完全移除。</p><h4 id="大小调整"><a href="#大小调整" class="headerlink" title="大小调整"></a>大小调整</h4><blockquote><p>在1.8中，使用如下参数来调节方法区的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元空间初始大小</span></span><br><span class="line">-XX: MetaspaceSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元空间最大大小, 超过这个值将会抛出OutOfMemoryError异常：java.lang.OutOfMemoryError: Metadata space</span></span><br><span class="line">-XX: MaxMetaspaceSize</span><br></pre></td></tr></table></figure><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>​ 永久代中包含了虚拟机中所有可通过反射获取到的数据，比如Class和Method对象。不同的Java虚拟机之间可能会进行类共享，因此永久代又分为只读区和读写区。</p><p>​ JVM用于描述应用程序中用到的类和方法的元数据也存储在永久代中。JVM运行时会用到多少永久代的空间取决于应用程序用到了多少类。除此之外，Java SE库中的类和方法也都存储在这里。</p><p>​ 如果JVM发现有的类已经不再需要了，它会去回收（卸载）这些类，将它们的空间释放出来给其它类使用。Full GC会进行持久代的回收。</p><ul><li>JVM中类的元数据在Java堆中的存储区域。</li><li>Java类对应的HotSpot虚拟机中的内部表示也存储在这里。</li><li>类的层级信息，字段，名字。</li><li>方法的编译信息及字节码。</li><li>变量</li><li>常量池和符号解析</li></ul><h4 id="永久代大小"><a href="#永久代大小" class="headerlink" title="永久代大小"></a>永久代大小</h4><ul><li>它的上限是MaxPermSize，默认是64M</li><li>Java堆中的连续区域 : 如果存储在非连续的堆空间中的话，要定位出持久代到新对象的引用非常复杂并且耗时。卡表（card table），是一种记忆集（Remembered Set），它用来记录某个内存代中普通对象指针（oops）的修改。</li><li>持久代用完后，会抛出OutOfMemoryError “PermGen space”异常。解决方案：应用程序清理引用来触发类卸载；增加MaxPermSize的大小。</li><li>需要多大的持久代空间取决于类的数量，方法的大小，以及常量池的大小。</li></ul><h4 id="为什么移除持久代"><a href="#为什么移除持久代" class="headerlink" title="为什么移除持久代"></a>为什么移除持久代</h4><ul><li>它的大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？</li><li>HotSpot的内部类型也是Java对象：它可能会在Full GC中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。</li><li>简化Full GC：每一个回收器有专门的元数据迭代器。</li><li>可以在GC不进行暂停的情况下并发地释放类数据。</li><li>使得原来受限于持久代的一些改进未来有可能实现</li></ul><h3 id="元空间-metaspace"><a href="#元空间-metaspace" class="headerlink" title="元空间(metaspace)"></a>元空间(metaspace)</h3><blockquote><p>JDK 8的HotSpot JVM现在使用的是本地内存来表示类的元数据，这个区域就叫做元空间。</p></blockquote><p>​ 持久代的空间被彻底地删除了，它被一个叫元空间的区域所替代了。持久代删除了之后，很明显，JVM会忽略PermSize和MaxPermSize这两个参数，还有就是你再也看不到java.lang.OutOfMemoryError: PermGen error的异常了。原来类的静态变量和Interned Strings 都被转移到了java堆区，只有class元数据才在元空间。</p><h4 id="元空间的特点"><a href="#元空间的特点" class="headerlink" title="元空间的特点"></a>元空间的特点</h4><ul><li>充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。</li><li>每个加载器有专门的存储空间</li><li>只进行线性分配</li><li>不会单独回收某个类</li><li>省掉了GC扫描及压缩的时间</li><li>元空间里的对象的位置是固定的</li><li>如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉</li></ul><h4 id="元空间的内存分配模型"><a href="#元空间的内存分配模型" class="headerlink" title="元空间的内存分配模型"></a>元空间的内存分配模型</h4><ul><li>绝大多数的类元数据的空间都从本地内存中分配</li><li>用来描述类元数据的类也被删除了</li><li>分元数据分配了多个虚拟内存空间</li><li>给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些</li><li>归还内存块，释放内存块列表</li><li>一旦元空间的数据被清空了，虚拟内存的空间会被回收掉</li><li>减少碎片的策略</li></ul><h4 id="元空间内存管理"><a href="#元空间内存管理" class="headerlink" title="元空间内存管理"></a>元空间内存管理</h4><p>​ <strong>元空间的内存管理由元空间虚拟机来完成</strong>。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，<strong>类和其元数据的生命周期和其对应的类加载器是相同的</strong>。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。</p><p>​ 准确的来说，<strong>每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间</strong>。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p><p>​ <strong>元空间虚拟机负责元空间的分配</strong>，其采用的形式为<strong>组块分配</strong>。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个<strong>全局的空闲组块列表</strong>。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。<strong>组块中的块是线性分配（指针碰撞分配形式）</strong>。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p><p>​ 运行时常量池在<strong>JDK1.6及之前版本的JVM中是方法区的一部分</strong>，而在HotSpot虚拟机中方法区放在了”永久代(Permanent Generation)”。所以运行时常量池也是在永久代的，但是<strong>JDK1.7及之后版本的JVM已经将字符串常量池从方法区中移了出来，在Java 堆（Heap）中开辟了一块区域存放运行时常量池</strong>。</p><p>​ String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的<strong>引用</strong>。</p><h3 id="永久代与元空间"><a href="#永久代与元空间" class="headerlink" title="永久代与元空间"></a>永久代与元空间</h3><blockquote><p>JDK8 HotSpot JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）</p></blockquote><p>以下是JVM内存模型中方法区的变动</p><p><img src="../images/jvm/jvm11.jpg" alt></p><p>1.新生代：Eden+From Survivor+To Survivor</p><p>2.老年代：OldGen</p><p>3.永久代（方法区的实现） : PermGen—–&gt;替换为Metaspace(本地内存中)</p><p>​ 元空间的本质和永久代类似，<strong>都是对JVM规范中方法区的实现</strong>。不过元空间与永久代之间<strong>最大的区别在于：元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><p>​ 《Java虚拟机规范(JavaSE7)》中也说了<strong>方法区是堆的逻辑组成部分</strong>。<br>实际上JDK1.7中，存储在永久代的部分数据就已经转移到了<code>Java Heap</code>或者是 <code>Native Heap</code>。但永久代在JDK1.8才被移除</p><h4 id="移除永久代的影响"><a href="#移除永久代的影响" class="headerlink" title="移除永久代的影响"></a>移除永久代的影响</h4><p>​ 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，<strong>我们就不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情</strong>。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM会<strong>自动</strong>根据类的元数据大小动态增加元空间的容量。</p><p><strong>注意</strong>：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM永久代与元空间
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="永久代" scheme="http://www.baiyp.ren/tags/%E6%B0%B8%E4%B9%85%E4%BB%A3/"/>
    
      <category term="元空间" scheme="http://www.baiyp.ren/tags/%E5%85%83%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区-线程私有</title>
    <link href="http://www.baiyp.ren/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB.html"/>
    <id>http://www.baiyp.ren/JVM运行时数据区-线程共享.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T14:17:05.305Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="JVM运行时数据区-线程共享"><a href="#JVM运行时数据区-线程共享" class="headerlink" title="JVM运行时数据区-线程共享"></a>JVM运行时数据区-线程共享</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="方法区-永久代"><a href="#方法区-永久代" class="headerlink" title="方法区(永久代)"></a>方法区(永久代)</h3><blockquote><p>方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p><p><strong>方法区（method area）</strong>只是<strong>JVM规范</strong>中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而<strong>永久代</strong>是<strong>Hotspot</strong>虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西</p></blockquote><p>​ 主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。</p><h4 id="方法区结构"><a href="#方法区结构" class="headerlink" title="方法区结构"></a>方法区结构</h4><h5 id="classLoader是如何加载class文件和存储文件信息的"><a href="#classLoader是如何加载class文件和存储文件信息的" class="headerlink" title="classLoader是如何加载class文件和存储文件信息的"></a>classLoader是如何加载class文件和存储文件信息的</h5><p>​ 当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader。那么方法区中的字节码内存块，除了记录一个class自己的class对象引用和一个加载自己的ClassLoader引用之外，还记录了什么信息呢？？</p><p><img src="../images/jvm/jvm09.png" alt></p><h4 id="方法区关键信息介绍"><a href="#方法区关键信息介绍" class="headerlink" title="方法区关键信息介绍"></a>方法区关键信息介绍</h4><h5 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h5><ul><li>类型的全限定名</li><li>超类的全限定名</li><li>直接超接口的全限定名</li><li>类型标志（该类是类类型还是接口类型）</li><li>类的访问描述符（public、private、default、abstract、final、static）</li></ul><h5 id="类型的常量池"><a href="#类型的常量池" class="headerlink" title="类型的常量池"></a>类型的常量池</h5><pre><code>存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的常量）和对其他类型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为常量池中保存中所有类型使用到的类型、字段、方法的字符引用，所以它也是动态连接的主要对象（在动态链接中起到核心作用）。</code></pre><h5 id="字段信息（该类声明的所有字段）"><a href="#字段信息（该类声明的所有字段）" class="headerlink" title="字段信息（该类声明的所有字段）"></a>字段信息（该类声明的所有字段）</h5><ul><li>字段修饰符（public、protect、private、default）</li><li>字段的类型</li><li>字段名称</li></ul><h5 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h5><blockquote><p>方法信息中包含类的所有方法，每个方法包含以下信息</p></blockquote><ul><li>方法修饰符</li><li>方法返回类型</li><li>方法名</li><li>方法参数个数、类型、顺序等</li><li>方法字节码</li><li>操作数栈和该方法在栈帧中的局部变量区大小</li><li>异常表</li></ul><h5 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h5><p>​ 指该类所有对象共享的变量，即使没有任何实例对象时，也可以访问的类变量。它们与类进行绑定。</p><h5 id="指向类加载器的引用"><a href="#指向类加载器的引用" class="headerlink" title="指向类加载器的引用"></a>指向类加载器的引用</h5><p>​ 每一个被JVM加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到。</p><h5 id="指向Class实例的引用"><a href="#指向Class实例的引用" class="headerlink" title="指向Class实例的引用"></a>指向Class实例的引用</h5><p>​ 类加载的过程中，虚拟机会创建该类型的Class实例，方法区中必须保存对该对象的引用。通过Class.forName(String className)来查找获得该实例的引用，然后创建该类的对象。</p><h5 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h5><p>​ 为了提高访问效率，JVM可能会对每个装载的非抽象类，都创建一个数组，数组的每个元素是实例可能调用的方法的直接引用，包括父类中继承过来的方法。这个表在抽象类或者接口中是没有的，类似C++虚函数表vtbl。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><h5 id="Class文件中的常量池"><a href="#Class文件中的常量池" class="headerlink" title="Class文件中的常量池"></a>Class文件中的常量池</h5><p>​ 在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p><p>​ 常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>​ Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>​ 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h5 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h5><p>​ 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>​ 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><ul><li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li></ul><h6 id="双等号-的含义"><a href="#双等号-的含义" class="headerlink" title="双等号==的含义"></a>双等号==的含义</h6><ul><li>基本数据类型之间应用双等号，比较的是他们的数值。</li><li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li></ul><h5 id="基本类型的包装类和常量池"><a href="#基本类型的包装类和常量池" class="headerlink" title="基本类型的包装类和常量池"></a>基本类型的包装类和常量池</h5><p>​ java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean。</p><p>​ 这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float,Double并没有实现常量池技术。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><blockquote><p>堆是需要重点关注的一块区域，因为涉及到内存的分配(new关键字，反射等)与回收(回收算法，收集器等)</p><p>几乎所有的对象都是在堆中分配。</p></blockquote><p>​ 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，<strong>在虚拟机启动时创建</strong>。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存</strong>。这一点在Java虚拟机规范中的描述是：<strong>所有的对象实例以及数组都要在堆上分配</strong>。但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得没那么绝对了。</p><p>​ Java堆是垃圾收集器管理的主要区域，因此很多时候也被称“GC堆”（Garbage Collected Heap）。从内存回收的角度看，现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、F rom Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer ,TLAB）。无论如何划分，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>​ 根据虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，可以是固定大小的，也可以是扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx -Xms 控制）。如果在堆中没有内存完成 实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>存储的全部是对象，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。</p></li><li><p>jvm只有一个堆区（heap）被所有线程共享，堆区中不存放基本类型和对象引用，只存放对象本身。</p></li><li><p>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。</p></li><li><p>缺点是，由于要在运行时动态分配内存，存取速度较慢。</p></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><img src="../images/jvm/jvm13.png" style="zoom:48%"><p>​ 直接内存不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK1.4中新加入了<strong>NIO（New Input/Output）</strong>类，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓冲区（Buffer）</strong>的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的<strong>DirectByteBuffer</strong>对象作为这块内存的引用 进行操作。<strong>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="../images/jvm/jvm12.png" style="zoom:75%"><h4 id="堆栈方法区的区别"><a href="#堆栈方法区的区别" class="headerlink" title="堆栈方法区的区别"></a>堆栈方法区的区别</h4><h5 id="存储内容的区别"><a href="#存储内容的区别" class="headerlink" title="存储内容的区别"></a>存储内容的区别</h5><p><strong>栈：</strong>为即时调用的方法开辟空间，<strong>存储局部变量值(基本数据类型)</strong>，<strong>局部变量引用</strong>,<strong>对象属性的引用</strong>。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放；注意：局部变量必须手动初始化。</p><p><strong>堆</strong>：<strong>存放引用类型的对象</strong>，即new出来的<strong>对象、数组值、类的非静态成员变量值(基本数据类型)、非静态成员变量引用</strong>。其中非静态成员变量在实例化时开辟空间初始化值。（类中属于全局变量的基本数据类型也存放在堆中）。一个java对象占用的内存空间,除了一个固定大小的空间用于描述这个对象属于哪个类,其它的就用于保存它的字段的值;堆比栈要大。</p><p><strong>方法区</strong>：<strong>存放class二进制文件</strong>。包含<strong>类信息、静态变量，常量池（String字符串和final修饰的常量值等），类的版本号等基本信息</strong>。静态成员变量是在方法区的静态域里面，而静态成员方法是在方法区的class二进制信息里面(.class文件和方法区里面的二进制信息不一样，读取.class文件按照虚拟机需要的格式存储在方法区，这种格式包括数据结构方面。）因为是共享的区域，所以如果静态成员变量的值或者常量值(String类型的值能够非修改)被修改了直接就会反应到其它类的对象中。</p><p><strong>基本类型的地址和值都存在栈中，但是两个相同值的基本类型的地址不同，其中的==比较被重写</strong></p><p><strong>成员变量存放在堆中，就算是int a[]=new int[10]，也都是存放在堆中，包括a[2]=1.而局部变量存放于栈中</strong></p><h5 id="定义的区别"><a href="#定义的区别" class="headerlink" title="定义的区别"></a>定义的区别</h5><p><strong>堆</strong>：FIFO队列优先，先进先出。jvm只有一个堆区被所有线程所共享！堆存放在二级缓存中，调用对象的速度相对慢一些，生命周期由虚拟机的垃圾回收机制定。</p><p><strong>栈</strong>：FILO先进后出，暂存数据的地方。每个线程都包含一个栈区！栈存放在一级缓存中，存取速度较快，“栈是限定仅在表头进行插入和删除操作的线性表”。</p><p><strong>方法区</strong>：用来存放方法和static变量。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>堆的优点-可以动态的分配内存大小，生命周期不确定。缺点-速度略慢</p><p>栈的优点-速度快，缺点-存在栈中的数据大小和生命周期必须是明确的，缺少灵活性。</p><h5 id="直接内存（堆外内存）与堆内存比较"><a href="#直接内存（堆外内存）与堆内存比较" class="headerlink" title="直接内存（堆外内存）与堆内存比较"></a>直接内存（堆外内存）与堆内存比较</h5><ul><li><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显</p></li><li><p>直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM运行时数据区-线程私有
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
      <category term="线程私有" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区-线程私有</title>
    <link href="http://www.baiyp.ren/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89.html"/>
    <id>http://www.baiyp.ren/JVM运行时数据区-线程私有.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T14:17:13.110Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="JVM运行时数据区-线程私有"><a href="#JVM运行时数据区-线程私有" class="headerlink" title="JVM运行时数据区-线程私有"></a>JVM运行时数据区-线程私有</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="什么是运行时数据区"><a href="#什么是运行时数据区" class="headerlink" title="什么是运行时数据区"></a>什么是运行时数据区</h3><blockquote><p>JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域！</p><p>这个是抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）</p><p>计算机的运行=指令+数据，指令用于执行方法的，数据用于存放数据和对象的。</p></blockquote><p>​ Java虚拟机在执行Java程序的过程中会把它管理的内存分为若干个不同的数据区域。这些区域有着各自的用途，一级创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》中规定，jvm所管理的内存大致包括以下几个运行时数据区域。</p><ul><li><strong>线程私有</strong>:程序计数器、虚拟机栈、本地方法栈</li><li><strong>线程共享</strong>：堆、方法区</li></ul><p><img src="../images/jvm/jvm04.png" alt></p><p>与线程之间的关系：</p><table><thead><tr><th>区域</th><th>是否线程共享</th><th>是否会内存溢出</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>不会</td></tr><tr><td>虚拟机栈</td><td>否</td><td>会</td></tr><tr><td>本地方法栈</td><td>否</td><td>会</td></tr><tr><td>堆</td><td>是</td><td>会</td></tr><tr><td>方法区</td><td>是</td><td>会</td></tr></tbody></table><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote><p>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></blockquote><h4 id="特-点"><a href="#特-点" class="headerlink" title="特 点"></a>特 点</h4><ul><li><p>如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址</p></li><li><p>如果正在执行的是Native 方法，则这个技术器值为空（Undefined）</p></li><li><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p></li></ul><h4 id="为什么需要程序计数器"><a href="#为什么需要程序计数器" class="headerlink" title="为什么需要程序计数器"></a>为什么需要程序计数器</h4><ul><li><p>Java是多线程的，意味着线程切换</p></li><li><p>确保多线程情况下的程序正常执行</p></li></ul><h4 id="存储那些内容"><a href="#存储那些内容" class="headerlink" title="存储那些内容"></a>存储那些内容</h4><p>看一个代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的计算代码，我们先编译成Class 文件再使用 javap 反汇编工具看下class 文件中数据格式，如下图</p><img src="../images/jvm/jvm05.jpg" style="zoom:50%"><p>当执行到方法<strong>test()</strong>时在当前的线程中会创建相应的程序计数器，在计数器中为存放执行地址 （红框中的）0 2 3…等等。</p><p>这也说明在我们程序运行过程中计数器中改变的只是值，而不会随着程序的运行需要更大的空间，也就不会发生溢出情况。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h4><blockquote><p>虚拟机栈是用于描述java方法执行的内存模型。</p></blockquote><p>​ 每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“<strong>局部变量表、操作数栈、动态链接、方法出口</strong>”几个部分。我们常说的“堆内存、栈内存”中的“栈内存”指的便是虚拟机栈，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。</p><p>方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：</p><img src="../images/jvm/jvm06.png" style="zoom:75%"><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><blockquote><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p></blockquote><img src="../images/jvm/jvm07.png" style="zoom:75%"><h5 id="栈帧中的元素"><a href="#栈帧中的元素" class="headerlink" title="栈帧中的元素"></a>栈帧中的元素</h5><h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><p>​ 局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><img src="../images/jvm/jvm08.jpg" style="zoom:50%"><h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h6><p>​ 操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。</p><blockquote><p>操作数是运算符作用于的实体，是表达式中的一个组成部分，它规定了指令中进行数字运算的量 。<br>表达式是操作数与操作符的组合。</p></blockquote><h6 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h6><p>​ 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class文文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p><h6 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h6><p>​ 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><blockquote><p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p></blockquote><p>​ 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。</p><h4 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h4><ul><li>虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。</li><li>栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</li><li>在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</li></ul><h4 id="虚拟机栈的StackOverflowError"><a href="#虚拟机栈的StackOverflowError" class="headerlink" title="虚拟机栈的StackOverflowError"></a>虚拟机栈的StackOverflowError</h4><p>若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。</p><p>JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用。</p><h4 id="虚拟机栈的OutOfMemoryError"><a href="#虚拟机栈的OutOfMemoryError" class="headerlink" title="虚拟机栈的OutOfMemoryError"></a>虚拟机栈的OutOfMemoryError</h4><p>​ 不同于StackOverflowError，OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。</p><p>JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​ 本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。</p><p>不同的是，本地方法栈服务的对象是JVM执行的<strong>native</strong>方法，而虚拟机栈服务的是JVM执行的java方法。如何去服务native方法？native方法使用什么语言实现？怎么组织像栈帧这种为了服务方法的数据结构？虚拟机规范并未给出强制规定，因此不同的虚拟机实可以进行自由实现，我们常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM运行时数据区-线程私有
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
      <category term="线程私有" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>并发面试题总结</title>
    <link href="http://www.baiyp.ren/%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.baiyp.ren/并发面试题总结.html</id>
    <published>2019-09-07T09:12:30.000Z</published>
    <updated>2019-09-07T09:56:25.851Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:36 GMT+0800 (GMT+08:00) --><h2 id="并发面试题总结"><a href="#并发面试题总结" class="headerlink" title="并发面试题总结"></a>并发面试题总结</h2><h3 id="谈面试"><a href="#谈面试" class="headerlink" title="谈面试"></a>谈面试</h3><ol><li><p>面试主要分为两块：</p><ul><li>一块是考查工程师对基础知识（包括了技术广度、深度、对技术的热情度等）的掌握程度，因为<strong>基础知识决定了一个技术人员发展的上限</strong>；</li><li>另一块是考察工程师的工程能力，比如：做过哪些项目？遇到最难的问题怎样解决的？说说最有成就感的一项任务？<strong>工程能力是考察工程师当下能为公司带来的利益</strong>。当然还有其它考核方面：抗压性、合作能力。</li></ul></li><li><p>Java只是一门语言，即使是Java工程师也不能局限于Java，要从面向对象语言本身，甚至从整个计算机体系，从工程实际出发看Java。</p></li><li><p>很多知识在一般公司的开发中是用不到的，常有人戏称：“面试造火箭，工作拧螺丝”，但这只是通常情况下公司对程序员的标准——迅速产出，完成任务。所以，工程师为了自己职业的发展不能局限于公司对自己的要求，不能停留在应用层面，要能够很好地掌握基础知识，要多看源码，自己多实践，学成记得产出，比如多为开源社区贡献代码，帮助初学者指路等。</p></li></ol><p>其实“面试造火箭，工作拧螺丝”的背后其实是大家都普遍认可基础知识的重要性。</p><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="1-在java中守护线程和用户线程的区别？"><a href="#1-在java中守护线程和用户线程的区别？" class="headerlink" title="1.在java中守护线程和用户线程的区别？"></a>1.在java中守护线程和用户线程的区别？</h4><p>java中的线程分为两种：</p><ul><li>守护线程（Daemon）</li><li>用户线程（User）。</li></ul><p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。</p><p><strong>两者的区别：</strong></p><p>唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经结束，Daemon 没有可服务的线程，JVM关闭。</p><p>扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程</p><h4 id="2-线程与进程的区别"><a href="#2-线程与进程的区别" class="headerlink" title="2.线程与进程的区别"></a>2.线程与进程的区别</h4><p>​ 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p><p>​ 一个程序至少有一个进程,一个进程至少有一个线程。</p><h4 id="3-什么是多线程中的上下文切换"><a href="#3-什么是多线程中的上下文切换" class="headerlink" title="3.什么是多线程中的上下文切换"></a>3.什么是多线程中的上下文切换</h4><p>多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。</p><h4 id="4-死锁与活锁的区别，死锁与饥饿的区别？"><a href="#4-死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="4.死锁与活锁的区别，死锁与饥饿的区别？"></a>4.死锁与活锁的区别，死锁与饥饿的区别？</h4><p><strong>死锁</strong>：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><p><strong>产生死锁的必要条件：</strong></p><ul><li><p>互斥条件：所谓互斥就是进程在某一时间内独占资源。</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p></li><li><p>不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。</p></li><li><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p></li></ul><p><strong>活锁</strong>：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p><strong>饥饿</strong>：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><h4 id="5-synchronized底层实现原理"><a href="#5-synchronized底层实现原理" class="headerlink" title="5.synchronized底层实现原理"></a>5.synchronized底层实现原理</h4><p>​ synchronized (this)原理：涉及两条指令：<strong>monitorenter</strong>，<strong>monitorexit</strong>；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</p><p>​ JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><p>注意，这个问题可能会接着追问，java对象头信息，偏向锁，轻量锁，重量级锁及其他们相互间转化。</p><h4 id="6-什么是线程组，为什么在Java中不推荐使用？"><a href="#6-什么是线程组，为什么在Java中不推荐使用？" class="headerlink" title="6.什么是线程组，为什么在Java中不推荐使用？"></a>6.什么是线程组，为什么在Java中不推荐使用？</h4><p>ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p><ul><li><p>线程组ThreadGroup对象中比较有用的方法是stop、resume、suspend等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。</p></li><li><p>线程组ThreadGroup不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。</p></li></ul><h4 id="7-什么是Executors框架？为什么使用Executor框架？"><a href="#7-什么是Executors框架？为什么使用Executor框架？" class="headerlink" title="7.什么是Executors框架？为什么使用Executor框架？"></a>7.什么是Executors框架？为什么使用Executor框架？</h4><ul><li><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p></li><li><p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。</p></li><li><p>调用 new Thread()创建的线程缺乏管理，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</p></li><li><p>直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p></li></ul><h4 id="8-在Java中Executor和Executors的区别？"><a href="#8-在Java中Executor和Executors的区别？" class="headerlink" title="8.在Java中Executor和Executors的区别？"></a>8.在Java中Executor和Executors的区别？</h4><ul><li><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p></li><li><p>Executor 接口对象能执行我们的线程任务。</p></li><li><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</p></li><li><p>使用ThreadPoolExecutor 可以创建自定义线程池。</p></li></ul><h4 id="9-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#9-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="9.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>9.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h4><blockquote><p><strong>原子操作（atomic operation）</strong>意为”不可被中断的一个或一系列操作” 。</p></blockquote><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。</p><p>CAS操作——Compare And Set，或是 Compare And Swap，现在几乎所有的CPU指令都支持CAS的原子操作。java.util.concurrent.atomic下提供了大量的原子操作类，比如原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference ，原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray ，原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</p><h4 id="10-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比synchronized它有什么优势？"><a href="#10-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比synchronized它有什么优势？" class="headerlink" title="10.Java Concurrency API中的Lock接口(Lock interface)是什么？对比synchronized它有什么优势？"></a>10.Java Concurrency API中的Lock接口(Lock interface)是什么？对比synchronized它有什么优势？</h4><ul><li><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。</p></li><li><p>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p></li></ul><p><strong>它的优势有</strong>：可以使锁更公平，可以使线程在等待锁的时候响应中断，可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间，可以在不同的范围，以不同的顺序获取和释放锁。</p><p>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p><h4 id="11-什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#11-什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="11.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>11.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h4><blockquote><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p></blockquote><p>这两个附加的操作是：</p><ul><li>在队列为空时，获取元素的线程会等待队列变为非空。</li><li>当队列满时，存储元素的线程会等待队列可用。</li></ul><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7提供了7个阻塞队列。在实现上，主要是利用了Condition和Lock的等待通知模式。</p><h4 id="12-什么是Callable和Future"><a href="#12-什么是Callable和Future" class="headerlink" title="12.什么是Callable和Future?"></a>12.什么是Callable和Future?</h4><p>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。</p><p>可以认为是带有回调的Runnable。</p><p>Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p><h4 id="13-什么是FutureTask"><a href="#13-什么是FutureTask" class="headerlink" title="13.什么是FutureTask?"></a>13.什么是FutureTask?</h4><p>​ 在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p><h4 id="14-什么是并发容器的实现？"><a href="#14-什么是并发容器的实现？" class="headerlink" title="14.什么是并发容器的实现？"></a>14.什么是并发容器的实现？</h4><p><strong>何为同步容器</strong>：可以简单地理解为通过<strong>synchronized</strong>来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。</p><p>比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。</p><p>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。</p><h4 id="15-多线程同步和互斥有几种实现方法，都是什么？"><a href="#15-多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="15.多线程同步和互斥有几种实现方法，都是什么？"></a>15.多线程同步和互斥有几种实现方法，都是什么？</h4><p><strong>线程同步</strong>：是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p><p><strong>线程互斥</strong>：是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>线程间的同步方法大体可分为两类：</p><p>用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p><p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p><h4 id="16-什么是竞争条件？"><a href="#16-什么是竞争条件？" class="headerlink" title="16.什么是竞争条件？"></a>16.什么是竞争条件？</h4><p>​ 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。</p><h4 id="17-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#17-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="17.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>17.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h4><p>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。</p><p>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。</p><h4 id="18-在Java中CycliBarriar和CountdownLatch有什么区别？"><a href="#18-在Java中CycliBarriar和CountdownLatch有什么区别？" class="headerlink" title="18.在Java中CycliBarriar和CountdownLatch有什么区别？"></a>18.在Java中CycliBarriar和CountdownLatch有什么区别？</h4><p>CyclicBarrier可以重复使用，而CountdownLatch不能重复使用。</p><h4 id="19-什么是不可变对象，它对写并发应用有什么帮助？"><a href="#19-什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="19.什么是不可变对象，它对写并发应用有什么帮助？"></a>19.什么是不可变对象，它对写并发应用有什么帮助？</h4><blockquote><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p></blockquote><p>不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。</p><p>不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。</p><p><strong>不可变对象永远是线程安全的。</strong></p><p>只有满足如下状态，一个对象才是不可变的：</p><ul><li><p>它的状态不能在创建后再被修改；</p></li><li><p>所有域都是final类型；并且， 它被正确创建</p></li></ul><h4 id="20-notify-和notifyAll-有什么区别？"><a href="#20-notify-和notifyAll-有什么区别？" class="headerlink" title="20.notify()和notifyAll()有什么区别？"></a>20.notify()和notifyAll()有什么区别？</h4><p>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</p><p>如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。</p><h4 id="21-什么是可重入锁（ReentrantLock）？谈谈它的实现。"><a href="#21-什么是可重入锁（ReentrantLock）？谈谈它的实现。" class="headerlink" title="21.什么是可重入锁（ReentrantLock）？谈谈它的实现。"></a>21.什么是可重入锁（ReentrantLock）？谈谈它的实现。</h4><p>​ 线程可以重复进入任何一个它已经拥有的锁所同步着的代码块，synchronized、ReentrantLock都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每 释放一次锁，进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。</p><h4 id="22-当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#22-当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="22.当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"></a>22.当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</h4><p>如果其他方法没有synchronized的话，其他线程是可以进入的。</p><p>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p><h4 id="23-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#23-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="23.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>23.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p><strong>悲观锁：</strong>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java里面的同步原语synchronized关键字的实现是悲观锁。</p><p><strong>乐观锁：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。在Java中j原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>乐观锁的实现方式：</p><ul><li><p>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p></li><li><p>java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p></li></ul><h4 id="24-什么是CAS操作，缺点是什么？"><a href="#24-什么是CAS操作，缺点是什么？" class="headerlink" title="24.什么是CAS操作，缺点是什么？"></a>24.什么是CAS操作，缺点是什么？</h4><p>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p><p><strong>CAS缺点：</strong></p><ul><li><p>ABA问题：</p><p>​ 比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p></li><li><p>循环时间长开销大：</p><p>​ 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p></li><li><p>只能保证一个共享变量的原子操作：</p><p>​ 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p></li></ul><h4 id="25-SynchronizedMap和ConcurrentHashMap有什么区别？"><a href="#25-SynchronizedMap和ConcurrentHashMap有什么区别？" class="headerlink" title="25.SynchronizedMap和ConcurrentHashMap有什么区别？"></a>25.SynchronizedMap和ConcurrentHashMap有什么区别？</h4><ul><li><p>SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。</p></li><li><p>ConcurrentHashMap使用分段锁来保证在多线程下的性能。</p></li></ul><h4 id="26-写时复制容器可以用于什么应用场景？"><a href="#26-写时复制容器可以用于什么应用场景？" class="headerlink" title="26.写时复制容器可以用于什么应用场景？"></a>26.写时复制容器可以用于什么应用场景？</h4><p>CopyOnWrite并发容器用于对于绝大部分访问都是读，且<strong>只是偶尔写</strong>的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><p>透露的思想：</p><ul><li><p>读写分离，读和写分开</p></li><li><p>最终一致性</p></li><li><p>使用另外开辟空间的思路，来解决并发冲突</p></li></ul><h4 id="27-volatile有什么用？能否用一句话说明下volatile的应用场景？"><a href="#27-volatile有什么用？能否用一句话说明下volatile的应用场景？" class="headerlink" title="27.volatile有什么用？能否用一句话说明下volatile的应用场景？"></a>27.volatile有什么用？能否用一句话说明下volatile的应用场景？</h4><ul><li><p>volatile保证内存可见性和禁止指令重排。</p></li><li><p>volatile用于多线程环境下的一写多读，或者无关联的多写。</p></li></ul><h4 id="28-为什么代码会重排序？"><a href="#28-为什么代码会重排序？" class="headerlink" title="28.为什么代码会重排序？"></a>28.为什么代码会重排序？</h4><p>​ 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p><ul><li><p>在单线程环境下不能改变程序运行的结果；</p></li><li><p>存在数据依赖关系的不允许重排序</p></li></ul><h4 id="29-在java中wait和sleep方法的不同？"><a href="#29-在java中wait和sleep方法的不同？" class="headerlink" title="29.在java中wait和sleep方法的不同？"></a>29.在java中wait和sleep方法的不同？</h4><p>​ 最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p><h4 id="30-一个线程运行时发生异常会怎样？"><a href="#30-一个线程运行时发生异常会怎样？" class="headerlink" title="30.一个线程运行时发生异常会怎样？"></a>30.一个线程运行时发生异常会怎样？</h4><p>​ 如果异常没有被捕获该线程将会停止执行。hread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p><h4 id="31-为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#31-为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="31.为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>31.为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p>​ JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h4 id="32-什么是ThreadLocal变量？"><a href="#32-什么是ThreadLocal变量？" class="headerlink" title="32.什么是ThreadLocal变量？"></a>32.什么是ThreadLocal变量？</h4><p>​ ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p><h4 id="33-Java中interrupted-和-isInterrupted方法的区别？"><a href="#33-Java中interrupted-和-isInterrupted方法的区别？" class="headerlink" title="33.Java中interrupted 和 isInterrupted方法的区别？"></a>33.Java中interrupted 和 isInterrupted方法的区别？</h4><p>​ <strong>interrupted()</strong> 和 <strong>isInterrupted()</strong>的主要区别是前者会将中断状态清除而后者不会。</p><p>​ Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。</p><h4 id="34-为什么wait和notify方法要在同步块中调用？"><a href="#34-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="34.为什么wait和notify方法要在同步块中调用？"></a>34.为什么wait和notify方法要在同步块中调用？</h4><p>​ 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。</p><h4 id="35-为什么你应该在循环中检查等待条件"><a href="#35-为什么你应该在循环中检查等待条件" class="headerlink" title="35.为什么你应该在循环中检查等待条件?"></a>35.为什么你应该在循环中检查等待条件?</h4><p>​ 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因</p><h4 id="36-怎么检测一个线程是否拥有锁？"><a href="#36-怎么检测一个线程是否拥有锁？" class="headerlink" title="36.怎么检测一个线程是否拥有锁？"></a>36.怎么检测一个线程是否拥有锁？</h4><p>​ 在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p><h4 id="37-你如何在Java中获取线程堆栈？"><a href="#37-你如何在Java中获取线程堆栈？" class="headerlink" title="37.你如何在Java中获取线程堆栈？"></a>37.你如何在Java中获取线程堆栈？</h4><p><strong>kill -3 [java pid]</strong></p><p>不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，kill -3 tomcat pid, 输出堆栈到log目录下。</p><p><strong>Jstack [java pid]</strong></p><p>这个比较简单，在当前终端显示，也可以重定向到指定文件中。</p><p>或者使用Java提供的拟机线程系统的管理接口ManagementFactory.getThreadMXBean()。</p><h4 id="38-Java线程池中submit-和-execute-方法有什么区别？"><a href="#38-Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="38.Java线程池中submit() 和 execute()方法有什么区别？"></a>38.Java线程池中submit() 和 execute()方法有什么区别？</h4><p>​ 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。</p><p>而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口</p><h4 id="39-你对线程优先级的理解是什么？"><a href="#39-你对线程优先级的理解是什么？" class="headerlink" title="39.你对线程优先级的理解是什么？"></a>39.你对线程优先级的理解是什么？</h4><p>​ 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p><p>​ java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><h4 id="40-你如何确保main-方法所在的线程是Java-程序最后结束的线程？"><a href="#40-你如何确保main-方法所在的线程是Java-程序最后结束的线程？" class="headerlink" title="40.你如何确保main()方法所在的线程是Java 程序最后结束的线程？"></a>40.你如何确保main()方法所在的线程是Java 程序最后结束的线程？</h4><p>​ 可以使用Thread类的join()方法（或者CountDownLatch工具类）来确保所有程序创建的线程在main()方法退出前结束。</p><h4 id="41-为什么Thread类的sleep-和yield-方法是静态的？"><a href="#41-为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="41.为什么Thread类的sleep()和yield ()方法是静态的？"></a>41.为什么Thread类的sleep()和yield ()方法是静态的？</h4><p>​ Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><p>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</p><p>​ 可以用join方法实现。</p><h4 id="42-你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"><a href="#42-你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？" class="headerlink" title="42.你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"></a>42.你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</h4><p>​ volatile关键字，读写锁，写时复制等等都可以实现。</p><h4 id="43-用Java实现阻塞队列"><a href="#43-用Java实现阻塞队列" class="headerlink" title="43.用Java实现阻塞队列"></a>43.用Java实现阻塞队列</h4><p>​ 适用Lock或者synchronize，队列空的时候进行阻塞，有新的入队的时候唤醒阻塞。</p><h4 id="44-用Java写代码来解决生产者——消费者问题。"><a href="#44-用Java写代码来解决生产者——消费者问题。" class="headerlink" title="44.用Java写代码来解决生产者——消费者问题。"></a>44.用Java写代码来解决生产者——消费者问题。</h4><p>​ 阻塞队列实现即可，也可以用wait和notify来解决这个问题，或者用Semaphore</p><h4 id="45-用Java编程一个会导致死锁的程序，你将怎么解决？"><a href="#45-用Java编程一个会导致死锁的程序，你将怎么解决？" class="headerlink" title="45.用Java编程一个会导致死锁的程序，你将怎么解决？"></a>45.用Java编程一个会导致死锁的程序，你将怎么解决？</h4><blockquote><p>参照 JAVA中的死锁一章</p></blockquote><h4 id="46-Java中如何停止一个线程？"><a href="#46-Java中如何停止一个线程？" class="headerlink" title="46.Java中如何停止一个线程？"></a>46.Java中如何停止一个线程？</h4><ul><li><p>使用共享变量的方式</p><p>​ 在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p></li><li><p>使用interrupt方法终止线程</p><p>​ 如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。所以应该尽量使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态。</p></li></ul><h4 id="47-JVM中哪个参数是用来控制线程的栈堆栈大小的"><a href="#47-JVM中哪个参数是用来控制线程的栈堆栈大小的" class="headerlink" title="47.JVM中哪个参数是用来控制线程的栈堆栈大小的"></a>47.JVM中哪个参数是用来控制线程的栈堆栈大小的</h4><p><strong>-Xss</strong></p><h4 id="48-如果同步块内的线程抛出异常锁会释放吗？"><a href="#48-如果同步块内的线程抛出异常锁会释放吗？" class="headerlink" title="48.如果同步块内的线程抛出异常锁会释放吗？"></a>48.如果同步块内的线程抛出异常锁会释放吗？</h4><p><strong>会</strong></p><h4 id="49-单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？"><a href="#49-单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？" class="headerlink" title="49.单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？"></a>49.单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？</h4><p>​ 不安全的根本原因是重排序会导致未初始化完成的对象可以被其他线程看见而导致错误。创建安全的单例模式有：延迟占位模式、在声明的时候就new这个类的实例、枚举</p><h4 id="50-写出3条你遵循的多线程最佳实践"><a href="#50-写出3条你遵循的多线程最佳实践" class="headerlink" title="50.写出3条你遵循的多线程最佳实践"></a>50.写出3条你遵循的多线程最佳实践</h4><ul><li>给你的线程起个有意义的名字。 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</li><li>避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</li><li>多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li><li>多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。</li><li>比如并发编程的黄金原则，尽量无锁化编程等等……..</li></ul><h4 id="51-合理地配置线程池"><a href="#51-合理地配置线程池" class="headerlink" title="51.合理地配置线程池"></a>51.合理地配置线程池</h4><ul><li><p>CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。</p></li><li><p>IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。</p></li><li><p>混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>对于IO型的任务的最佳线程数，有个公式可以计算 Nthreads = NCPU * UCPU * (1 + W/C)</p></li></ul><h4 id="52-请概述锁的公平和非公平，JDK内部是如何实现的。"><a href="#52-请概述锁的公平和非公平，JDK内部是如何实现的。" class="headerlink" title="52.请概述锁的公平和非公平，JDK内部是如何实现的。"></a>52.请概述锁的公平和非公平，JDK内部是如何实现的。</h4><ul><li><p><strong>公平锁</strong>：是指所有试图获得锁的线程按照获取锁的顺序依次获得锁，而非公平锁则是当前的锁状态没有被占用时,当前线程可以直接占用,而不需要等待。在实现上，非公平锁逻辑基本跟公平锁一致，唯一的区别是，当前线程不需要判断同步队列中是否有等待线程。</p></li><li><p><strong>非公平锁</strong>：性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。</p></li></ul><p>​ 使用场景的话呢，其实还是和他们的属性一一相关，比如：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平锁其实效率并不明显，但是用公平锁可以保证不会有线程被饿死。</p><h4 id="53-请概述AQS"><a href="#53-请概述AQS" class="headerlink" title="53.请概述AQS"></a>53.请概述AQS</h4><p>​ 是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock和CountDownLatch就是基于AQS实现的。它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。它是CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。</p><p>​ AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如tryAcquire、tryReleaseShared等等。</p><p>​ 这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。</p><p>​ 在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。</p><p>同时与Condition相关的等待队列，节点类型也是Node，构成一个单向链表。</p><h4 id="54-请概述volatile"><a href="#54-请概述volatile" class="headerlink" title="54.请概述volatile"></a>54.请概述volatile</h4><p>volatile关键字的作用主要有两点：</p><p>​ 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。但是volatile不能保证操作的原子，对任意单个volatile变量的读/写具有原子性，但类似于++这种复合操作不具有原子性。。</p><p>​ 代码底层在执行时为了获取更好的性能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止重排序，当然这也一定程度上降低了代码执行效率。</p><p>​ 同时在内存语义上，当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存，当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>​ 在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序问题、强制刷新和读取。</p><p>​ 在具体实现上，volatile关键字修饰的变量会存在一个“lock:”的前缀。它不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。</p><p>​ 同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      并发面试题总结
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="面试题" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="面试题" scheme="http://www.baiyp.ren/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized锁优化</title>
    <link href="http://www.baiyp.ren/Synchronized%E9%94%81%E4%BC%98%E5%8C%96.html"/>
    <id>http://www.baiyp.ren/Synchronized锁优化.html</id>
    <published>2019-09-07T01:11:04.000Z</published>
    <updated>2019-09-08T14:18:08.409Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="Synchronized锁优化"><a href="#Synchronized锁优化" class="headerlink" title="Synchronized锁优化"></a>Synchronized锁优化</h2><blockquote><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。<br>锁主要存在四中状态，依次是：<strong>无锁</strong>-&gt; <strong>偏向锁</strong> -&gt; <strong>轻量级锁</strong> -&gt; <strong>重量级锁</strong>，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p></blockquote><p><img src="../images/thread/synchronized/synchronized010.png" alt></p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>​ 线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p><strong>何谓自旋锁？</strong><br>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋），和CAS类似。<br>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。<br>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；<br>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h4 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h4><p>​ JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>​ 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>​ 为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。<br>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">           vector.add(i + <span class="string">""</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(vector);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p><h6 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h6><p>如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行优化：</p><p>同步消除synchronization Elimination，如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>​ 我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。<br>​ 在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。<br>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如下面的例子，一个方法由两个加锁,因为num = x + y;耗时较短，对比两次锁短的多，就会锁粗化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 因为一个方法需要两个加锁解锁耗费资源</span></span><br><span class="line"><span class="comment">    * 对于  num = x + y; 耗费时间很短 就会将</span></span><br><span class="line"><span class="comment">    * 代码包裹进去组成一个锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lockCoarsening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           x++;</span><br><span class="line">           <span class="comment">//todo 处理部分业务</span></span><br><span class="line">       &#125;</span><br><span class="line">       num = x + y;</span><br><span class="line">       <span class="comment">//对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           y++;</span><br><span class="line">           <span class="comment">//todo 处理部分业务</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>粗化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用一个锁</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lockCoarsening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//只进行一次加锁解锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          x++;</span><br><span class="line">          <span class="comment">//todo 处理部分业务</span></span><br><span class="line">          num = x + y;</span><br><span class="line">          y++;</span><br><span class="line">          <span class="comment">//todo 处理部分业务</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>​ 引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p></blockquote><p><img src="../images/thread/synchronized/synchronized02.png" alt></p><h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h5><ol><li><p>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</p></li><li><p>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</p></li><li><p>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</p></li></ol><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><blockquote><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p></blockquote><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可</p></blockquote><p><img src="../images/thread/synchronized/synchronized03.png" alt></p><p>获取锁</p><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><p>释放锁<br>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>​ 重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p><blockquote><p>为什么重量级锁的开销比较大呢</p></blockquote><p>​ 原因是当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现，也就是相当于从用户态转化到内核态，而转化状态是需要消耗时间的</p><h4 id="三种锁的区别"><a href="#三种锁的区别" class="headerlink" title="三种锁的区别"></a>三种锁的区别</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要CAS，没有额外的性能消耗，和执行非同步方法相比，仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>只有一个线程访问同步块或者同步方法的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞提高响应速度</td><td>若线程长时间抢不到锁，自旋会消耗CPU性能</td><td>线程交替执行同步块或者同步方法的场景</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不消耗CPU</td><td>线程阻塞，响应时间缓慢,在多线程下,频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步块或者同步方法执行时间较长的场景</td></tr></tbody></table><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p><strong>偏向锁升级轻量级锁</strong>：当一个对象持有偏向锁，一旦第二个线程访问这个对象，如果产生竞争，偏向锁升级为轻量级锁。</p><p><strong>轻量级锁升级重量级锁</strong>：一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p><h3 id="wait和notify的原理"><a href="#wait和notify的原理" class="headerlink" title="wait和notify的原理"></a>wait和notify的原理</h3><blockquote><p>调用wait方法，首先会获取监视器锁，获得成功以后，会让当前线程进入等待状态进入等待队列并且释放锁。</p><p>当其他线程调用notify后，会选择从等待队列中唤醒任意一个线程，而执行完notify方法以后，并不会立马唤醒线程，原因是当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁。必须要等到当前的线程执行完按monitorexit指令以后，也就是锁被释放以后，处于等待队列中的线程就可以开始竞争锁了。</p></blockquote><p><strong>wait和notify为什么需要在synchronized里面？</strong></p><p>wait方法的语义有两个，<strong>一个是释放当前的对象锁、另一个是使得当前线程进入阻塞队列</strong>，而这些操作都和监视器是相关的，所以wait必须要获得一个监视器锁。</p><p>而对于notify来说也是一样，它是唤醒一个线程，既然要去唤醒，首先得知道它在哪里，所以就必须要找到这个对象获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Synchronized锁优化
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/synchronized/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://www.baiyp.ren/tags/synchronized/"/>
    
      <category term="锁优化" scheme="http://www.baiyp.ren/tags/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized实现原理</title>
    <link href="http://www.baiyp.ren/Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/Synchronized实现原理.html</id>
    <published>2019-09-07T01:11:04.000Z</published>
    <updated>2019-09-08T14:18:00.858Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="Synchronized实现原理"><a href="#Synchronized实现原理" class="headerlink" title="Synchronized实现原理"></a>Synchronized实现原理</h2><p><img src="../images/thread/synchronized/synchronized01.png" alt></p><h3 id="三种应用方式"><a href="#三种应用方式" class="headerlink" title="三种应用方式"></a>三种应用方式</h3><ol><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象。</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>被 synchronized 修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在 Java 中可以使用 synchronized 来保证方法和代码块内的操作是原子性的。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>synchronized 本身是无法禁止指令重排和处理器优化的，</p><p>as-if-serial 语义：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。</p><p>编译器和处理器无论如何优化，都必须遵守 as-if-serial 语义。</p><p>synchronized 修饰的代码，同一时间只能被同一线程执行。所以，可以保证其有序性。</p><h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p>​ 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性</p></blockquote><h4 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h4><p>​ synchronized同步块使用了monitorenter和monitorexit指令实现同步，这两个指令，本质上都是对一个对象的监视器(monitor)进行获取，这个过程是排他的，也就是说同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。</p><p>​ 线程执行到monitorenter指令时，会尝试获取对象所对应的monitor所有权，也就是尝试获取对象的锁，而执行monitorexit，就是释放monitor的所有权。</p><h4 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h4><p><strong>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</strong></p><p><strong>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量</strong></p><p><strong>所以锁的释放-获取和volatile的写-读具有相同的内存语义。volatile可以看过轻量级的锁，</strong></p><p>小结下：</p><ul><li>A释放锁 ，即 A向后来将拿锁的线程B发送一个消息</li><li>B拿锁，即B接收了之前释放锁的线程A的一个消息</li><li>A释放锁、B拿锁，其实就是A向B发送个消息。</li></ul><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ol><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ol><p>当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用javap工具查看生成的class文件信息来分析Synchronize的实现</p><p><img src="../images/thread/synchronized/synchronized09.jpg" alt></p><p>从上面可以看出，同步代码块是使用<strong>monitorenter</strong>和<strong>monitorexit</strong>指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。<br><strong>同步代码块</strong>：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；<br><strong>同步方法</strong>：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象</p><p>下面我们来继续分析，但是在深入之前我们需要了解两个重要的概念：Java对象头，Monitor。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><blockquote><p>在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头（Mark Word、Class Metadata Address）、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础。一般而言，synchronized使用的锁对象是存储在Java对象头里。它是轻量级锁和偏向锁的关键。</p></blockquote><p><img src="../images/thread/synchronized/synchronized05.jpg" alt></p><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><blockquote><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit）。</p></blockquote><p><img src="../images/thread/synchronized/synchronized04.png" alt></p><h5 id="Class-Metadata-Address"><a href="#Class-Metadata-Address" class="headerlink" title="Class Metadata Address"></a>Class Metadata Address</h5><blockquote><p>类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></blockquote><h5 id="Array-length"><a href="#Array-length" class="headerlink" title="Array length"></a>Array length</h5><blockquote><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p></blockquote><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><blockquote><p>我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：</p></blockquote><p><img src="../images/thread/synchronized/synchronized06.png" alt></p><ul><li><strong>Owner</strong>：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li><li><strong>EntryQ</strong>:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li><li><strong>RcThis</strong>:表示blocked或waiting在该monitor record上的所有线程的个数。</li><li><strong>Nest</strong>:用来实现重入锁的计数。</li><li><strong>HashCode</strong>:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li><li><strong>Candidate</strong>:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li></ul><p>在hotspot虚拟机中，通过ObjectMonitor类来实现monitor。</p><p><img src="../images/thread/synchronized/synchronized07.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Synchronized实现原理
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/synchronized/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://www.baiyp.ren/tags/synchronized/"/>
    
      <category term="实现原理" scheme="http://www.baiyp.ren/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-缓存模块</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-03%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-03缓存模块.html</id>
    <published>2019-09-04T08:58:57.000Z</published>
    <updated>2019-09-21T08:04:34.257Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:35 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS缓存模块"><a href="#MYBATIS缓存模块" class="headerlink" title="MYBATIS缓存模块"></a>MYBATIS缓存模块</h2><p><img src="../images/mybatis/cache02.png" alt></p><h3 id="mybatis缓存"><a href="#mybatis缓存" class="headerlink" title="mybatis缓存"></a>mybatis缓存</h3><p>​ MyBatis作为一个强大的持久层框架，缓存是其必不可少的功能之一，MyBatis中的缓存是两层结构的，分为一级缓存，二级缓存，但本质上市相同的，它们使用的都是Cache接口的实现。</p><p>​ MyBatis缓存的实现是基于Map的，从缓存里面读写数据是缓存模块的核心基础功能</p><p>​ 除核心功能之外，有很多额外的附加功能，如：防止缓存击穿，添加缓存情况策略（fifo、LRU），序列化功能，日志能力和定时清空能力等</p><p>​ 附加功能可以以任意的组合附加到核心基础功能之上</p><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><blockquote><p>mybatis 缓存模块使用了装饰器模式</p></blockquote><p>​ Mybatis缓存的核心模块就是在缓存中读写数据，但是除了在缓存中读写数据wait，还有其他的附加功能，这些附加功能可以任意的加在缓存这个核心功能上。</p><p>​ 加载附加功能可以有很多种方法，动态代理或者继承都可以实现，但是附加功能存在多种组合，用这两种方法，会导致生成大量的子类，所以mybatis选择使用装饰器模式.(灵活性、扩展性)</p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>Mybatis 数据源的实现主要是在 cache包：</p><img src="../images/mybatis/cache01.jpg" style="zoom:50%"><p>​</p><h3 id="Cache-接口"><a href="#Cache-接口" class="headerlink" title="Cache 接口"></a>Cache 接口</h3><blockquote><p>一级缓存和二级缓存都是通过cache接口来实现的</p><p>Cache 接口是缓存模块的核心接口，定义了缓存的基本操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存核心接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存ID</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据Key获取缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 删除缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取读写锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> A ReadWriteLock</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存实现类PerpetualCache"><a href="#缓存实现类PerpetualCache" class="headerlink" title="缓存实现类PerpetualCache"></a>缓存实现类PerpetualCache</h3><blockquote><p>在缓存模块使用了装饰器模式PerpetualCache在其中扮演ConcreteComponent 角色，使用 HashMap来实现 cache 的相关操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存的核心实现类</span></span><br><span class="line"><span class="comment"> * 在装饰者模式中扮演了 ConcreteComponent(具体组件) 角色</span></span><br><span class="line"><span class="comment"> * 使用HashMao实现了缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓存的ID</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓存的主体对象 hashMap</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 涉资缓存</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key 缓存key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 缓存的Value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除缓存</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cache)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cache otherCache = (Cache) o;</span><br><span class="line">    <span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getId().hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存项CacheKey"><a href="#缓存项CacheKey" class="headerlink" title="缓存项CacheKey"></a>缓存项CacheKey</h3><blockquote><p>为什么需要一个复杂的对象表示缓存项的key？通常来说表示一个对象的key可以用一个String对象，为什么不可以吗？</p></blockquote><p>​ 在cache中唯一确定一个缓存项需要使用缓存项的key，Mybatis中因为涉及到动态SQL等多方面因素，其缓存项的key不等仅仅通过一个String表示，所以MyBatis 提供了CacheKey类来表示缓存项的key，在一个CacheKey对象中可以封装多个影响缓存项的因素。</p><p>​ 怎么样的查询条件算和上一次查询是一样的查询，从而返回同样的结果回去？这个问题，得从CacheKey说起。<br>我们先看一下CacheKey的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存项cacheKey</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1146682552656046210L</span>;</span><br><span class="line">  <span class="comment">//定义为Null的缓存key</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheKey NULL_CACHE_KEY = <span class="keyword">new</span> NullCacheKey();</span><br><span class="line">  <span class="comment">//默认的乘数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line">  <span class="comment">//默认的hashCode</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line">  <span class="comment">//定义乘数变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier;</span><br><span class="line">  <span class="comment">//hashCode</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line">  <span class="comment">//校验码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="comment">//统计</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="comment">//更新列表</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置hashCode</span></span><br><span class="line">    <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">    <span class="comment">//设置乘数</span></span><br><span class="line">    <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//更新列表 为空的list</span></span><br><span class="line">    <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objects 需要缓存的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用空的构造方法初始化缓存key</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">//更新所有数据</span></span><br><span class="line">    updateAll(objects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><blockquote><p>其中最重要的是<strong>第41行</strong>的updateList这个属性，为什么这么说，因为HashMap的Key是CacheKey，而HashMap的get方法是先判断hashCode，在hashCode冲突的情况下再进行equals判断，因此最终无论如何都会进行一次equals的判断。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成的equals方法</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * 如果是CacheKey</span></span><br><span class="line"><span class="comment">   * 先比较CacheKey的hashCode</span></span><br><span class="line"><span class="comment">   * 一样在比较 校验码</span></span><br><span class="line"><span class="comment">   * 还一样比较更新次数</span></span><br><span class="line"><span class="comment">   * 还是一样比较更新的每个值的hashCode</span></span><br><span class="line"><span class="comment">   * 保证每一个比较的一致性</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line">    <span class="comment">//比较cachekey的hashCode</span></span><br><span class="line">    <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较校验码</span></span><br><span class="line">    <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较更新次数</span></span><br><span class="line">    <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较每个值的hashCode</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject = updateList.get(i);</span><br><span class="line">      Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进行equals的时候经过了几次比较</p><ul><li>对象不为空</li><li>对象是CacheKey类型</li><li>cacheKey的hashcode一致</li><li>cacheKey的校验码checksum一致</li><li>cacheKey的更新次数count一致</li><li>updateList列表中每一个数据的hashCode一致</li></ul><p>经过这样负责的比较，保证每一个cacheKey是完全一致才会计算equals一致。</p><h4 id="更新方法update"><a href="#更新方法update" class="headerlink" title="更新方法update"></a>更新方法update</h4><h5 id="如何生产hashcode"><a href="#如何生产hashcode" class="headerlink" title="如何生产hashcode"></a>如何生产hashcode</h5><p>17是质子数中一个“不大不小”的存在，如果你使用的是一个如2的较小质数，<br>那么得出的乘积会在一个很小的范围，很容易造成哈希值的冲突。<br>而如果选择一个100以上的质数，得出的哈希值会超出int的最大范围，这两种都不合适。<br>而如果对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，<br>并使用常数 31, 33, 37, 39 和 41 作为乘子（cachekey使用37），每个常数算出的哈希值冲突数都小于7个（国外大神做的测试），<br>那么这几个数就被作为生成hashCode值得备选乘数了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取hashCode 为null 则hashCode是1 否则是计算出来的hash值</span></span><br><span class="line">  <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line">  <span class="comment">//统计更新次数</span></span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">//校验码更新</span></span><br><span class="line">  checksum += baseHashCode;</span><br><span class="line">  <span class="comment">//计算对象初始的hashCode 防止hash冲突</span></span><br><span class="line">  baseHashCode *= count;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * hashCode更新方法</span></span><br><span class="line"><span class="comment">   * newHashCode = oldHashCode*乘数(31,33,37,39,41)中选择一个+ObjectHashCode</span></span><br><span class="line"><span class="comment">   * 每次迭代乘以 乘数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line">  <span class="comment">//将缓存对象添加到更新列表</span></span><br><span class="line">  updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存增强"><a href="#缓存增强" class="headerlink" title="缓存增强"></a>缓存增强</h3><blockquote><p>PerpetualCache是基类，其它实现的Cache的类都是对基类的扩<br>展，也就是装饰来包裹真实的对象。扩展了类的功能，也可以说是附加了一些方法。使得具有很好的灵活性</p></blockquote><p><img src="../images/mybatis/cache03.png" alt></p><p>用于装饰PerpetualCache的标准装饰器共有8个（全部在 org.apache.ibatis.cache.decorators包中）：</p><ul><li><p>BlockingCache：是阻塞版本的缓存装饰器，它保证只有一个线程到数据库中查找指定key对应的数据。</p></li><li><p>FifoCache：先进先出算法，缓存回收策略</p></li><li><p>LoggingCache：输出缓存命中的日志信息</p></li><li><p>LruCache：最近最少使用算法，缓存回收策略</p></li><li><p>ScheduledCache：调度缓存，负责定时清空缓存</p></li><li><p>SerializedCache：缓存序列化和反序列化存储</p></li><li><p>SoftCache：基于软引用实现的缓存管理策略</p></li><li><p>SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问</p></li><li><p>WeakCache：基于弱引用实现的缓存管理策略</p></li><li><p>TransactionalCache：事务性的缓存</p></li></ul><h3 id="一级缓存和二级缓存"><a href="#一级缓存和二级缓存" class="headerlink" title="一级缓存和二级缓存"></a>一级缓存和二级缓存</h3><ul><li>一级缓存，又叫本地缓存，是PerpetualCache类型的永久缓存，保存在执行器中<br>(BaseExecutor)，而执行器又在SqlSession(DefaultSqlSession)中，所以<br>一级缓存的生命周期与SqlSession是相同的。</li><li>二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，所以可配<br>置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保<br>存在Configuration核心配置对象中</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>二级缓存对象的默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis<br>会根据配置自动追加一系列装饰器。</p></blockquote><h5 id="Cache对象之间的引用顺序"><a href="#Cache对象之间的引用顺序" class="headerlink" title="Cache对象之间的引用顺序"></a>Cache对象之间的引用顺序</h5><blockquote><p>SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis缓存模块
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="缓存模块" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="缓存模块" scheme="http://www.baiyp.ren/tags/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-数据库连接池</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-02数据库连接池.html</id>
    <published>2019-09-04T08:58:57.000Z</published>
    <updated>2019-09-21T08:04:28.889Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sat Sep 21 2019 18:22:36 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS数据库连接池"><a href="#MYBATIS数据库连接池" class="headerlink" title="MYBATIS数据库连接池"></a>MYBATIS数据库连接池</h2><h3 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h3><p>​ 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><p>​ 在使用 Mybatis 的时候，数据库的连接一般都会使用第三方的数据源组件，如 C3P0，DBCP 和 Druid 等，其实 Mybatis 也有自己的数据源实现，可以连接数据库，还有连接池的功能，下面就来看看 Mybatis 自己实现的数据源头和连接池的一个实现原理。</p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>Mybatis 数据源的实现主要是在 datasource 包：</p><p><img src="../images/mybatis/pool01.jpg" alt></p><p>​ 我们常见的数据库连接池都需要实现javax.sql.DataSource接口mybatis提供了UnpooledDataSource和PooledDataSource的实现， 一个使用连接池，一个不使用连接池此外，对于这两个类，Mybatis 还提供了两个工厂类进行创建对象，是工厂方法模式的一个应用，首先来看下它们的一个类图：</p><p><img src="../images/mybatis/pool02.jpg" alt></p><p>我们先看下工厂类</p><h3 id="DataSourceFactory"><a href="#DataSourceFactory" class="headerlink" title="DataSourceFactory"></a>DataSourceFactory</h3><blockquote><p>数据源连接池工厂类接口</p></blockquote><p>该类是 JndiDataSourceFactory 和 UnpooledDataSourceFactory 两个工厂类的顶层接口，只定义了两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据源连接池 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数据源连接池</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnpooledDataSourceFactory"><a href="#UnpooledDataSourceFactory" class="headerlink" title="UnpooledDataSourceFactory"></a>UnpooledDataSourceFactory</h3><blockquote><p>UnpooledDataSourceFactory 主要用来创建 UnpooledDataSource 对象，它会在构造方法中初始化 UnpooledDataSource 对象，并在 setProperties 方法中完成对 UnpooledDataSource 对象的配置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnpooledDataSource 连接工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSourceFactory</span> <span class="keyword">implements</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数据库驱动前缀</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_PROPERTY_PREFIX = <span class="string">"driver."</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DRIVER_PROPERTY_PREFIX_LENGTH = DRIVER_PROPERTY_PREFIX.length();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应的数据源，即 UnpooledDataSource</span></span><br><span class="line">  <span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对数据源 UnpooledDataSource 进行配置</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据源属性文件</span></span><br><span class="line">    Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 创建 DataSource 相应的 MetaObject</span></span><br><span class="line">    MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">    <span class="comment">// 遍历 properties 集合，该集合中存放了数据源需要的信息</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : properties.keySet()) &#123;</span><br><span class="line">      String propertyName = (String) key;</span><br><span class="line">      <span class="comment">// 以 "driver." 开头的配置项是对 DataSource 的配置，记录到 driverProperties  中</span></span><br><span class="line">      <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">        String value = properties.getProperty(propertyName);</span><br><span class="line">        <span class="comment">//设置连接的属性和值</span></span><br><span class="line">        driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">        <span class="comment">// 该属性是否有 set 方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">        <span class="comment">// 获取对应的属性值</span></span><br><span class="line">        String value = (String) properties.get(propertyName);</span><br><span class="line">        <span class="comment">// 根据属性类型进行类型的转换，主要是 Integer, Long, Boolean 三种类型的转换</span></span><br><span class="line">        Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">        <span class="comment">// 设置DataSource 的相关属性值</span></span><br><span class="line">        metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">"Unknown DataSource property: "</span> + propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 DataSource.driverProerties 属性值</span></span><br><span class="line">    <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      metaDataSource.setValue(<span class="string">"driverProperties"</span>, driverProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回数据源</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型转</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">convertValue</span><span class="params">(MetaObject metaDataSource, String propertyName, String value)</span> </span>&#123;</span><br><span class="line">    Object convertedValue = value;</span><br><span class="line">    Class&lt;?&gt; targetType = metaDataSource.getSetterType(propertyName);</span><br><span class="line">    <span class="keyword">if</span> (targetType == Integer.class || targetType == <span class="keyword">int</span>.class) &#123;</span><br><span class="line">      convertedValue = Integer.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Long.class || targetType == <span class="keyword">long</span>.class) &#123;</span><br><span class="line">      convertedValue = Long.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Boolean.class || targetType == <span class="keyword">boolean</span>.class) &#123;</span><br><span class="line">      convertedValue = Boolean.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> convertedValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JndiDataSourceFactory 依赖 JNDI 服务器中获取用户配置的 DataSource，这里可以不看。</p></blockquote><p>UnpooledDataSourceFactory工厂类主要的作用是对数据源进行配置。</p><h3 id="PooledDataSourceFactory"><a href="#PooledDataSourceFactory" class="headerlink" title="PooledDataSourceFactory"></a>PooledDataSourceFactory</h3><blockquote><p>PooledDataSourceFactory 主要用来创建 PooledDataSource 对象，它继承了 UnpooledDataSource 类，设置 DataSource 参数的方法复用UnpooledDataSource 中的 setProperties 方法，只是数据源返回的是 PooledDataSource 对象而已。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceFactory</span> <span class="keyword">extends</span> <span class="title">UnpooledDataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建连接池对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上这些就是 Mybatis 用来创建数据源的工厂类，下面就来看下数据源的主要实现。</p></blockquote><h3 id="UnpooledDataSource"><a href="#UnpooledDataSource" class="headerlink" title="UnpooledDataSource"></a>UnpooledDataSource</h3><blockquote><p>UnpooledDataSource 不使用连接池来创建数据库连接，每次获取数据库连接时都会创建一个新的连接进行返回；</p></blockquote><h4 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h4><blockquote><p>在static静态块中进行驱动注册</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未使用连接池的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 加载 Driver 类的类加载器</span></span><br><span class="line">  <span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line">  <span class="comment">// 数据库连接驱动的相关配置</span></span><br><span class="line">  <span class="keyword">private</span> Properties driverProperties;</span><br><span class="line">  <span class="comment">// 缓存所有已注册的数据库连接驱动</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//数据源配置相关</span></span><br><span class="line">  <span class="keyword">private</span> String driver;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="comment">// 是否自动提交</span></span><br><span class="line">  <span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line">  <span class="comment">//默认事务隔离级别</span></span><br><span class="line">  <span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line">  <span class="comment">//默认超时时间</span></span><br><span class="line">  <span class="keyword">private</span> Integer defaultNetworkTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  静态块，在初始化的时候，从 DriverManager 中获取所有的已注册的驱动信息，并缓存到该类的 registeredDrivers集合中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//获取驱动信息</span></span><br><span class="line">    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();</span><br><span class="line">    <span class="keyword">while</span> (drivers.hasMoreElements()) &#123;</span><br><span class="line">      Driver driver = drivers.nextElement();</span><br><span class="line">      <span class="comment">//注册进集合中</span></span><br><span class="line">      registeredDrivers.put(driver.getClass().getName(), driver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 无参构造</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, Properties driverProperties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.driverProperties = driverProperties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取一个连接"><a href="#获取一个连接" class="headerlink" title="获取一个连接"></a>获取一个连接</h4><blockquote><p>这里面没有提供连接销毁的方法，在连接池中有销毁连接的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 获取一个连接</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@return</span> 连接对象</span><br><span class="line"> * <span class="meta">@throws</span> SQLException</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个数据库连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">if</span> (driverProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.putAll(driverProperties);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置用户</span></span><br><span class="line">  <span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置密码</span></span><br><span class="line">  <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个连接对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> properties 数据库属性文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数据库连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//初始化驱动信息</span></span><br><span class="line">  initializeDriver();</span><br><span class="line">  <span class="comment">// 通过 DriverManager 来获取一个数据库连接</span></span><br><span class="line">  Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">  <span class="comment">//配置连接信息</span></span><br><span class="line">  configureConnection(connection);</span><br><span class="line">  <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化驱动信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前的驱动还没有注册，则进行注册</span></span><br><span class="line">  <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">    Class&lt;?&gt; driverType;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//驱动的类加载器不为空</span></span><br><span class="line">      <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取驱动类型</span></span><br><span class="line">        driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driverType = Resources.classForName(driver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// DriverManager requires the driver to be loaded via the system ClassLoader.</span></span><br><span class="line">      <span class="comment">// http://www.kfu.com/~nsayer/Java/dyn-jdbc.html</span></span><br><span class="line">      <span class="comment">//创建驱动</span></span><br><span class="line">      Driver driverInstance = (Driver) driverType.newInstance();</span><br><span class="line">      <span class="comment">//向JDBC注册驱动</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">      <span class="comment">//向registeredDrivers注册驱动</span></span><br><span class="line">      registeredDrivers.put(driver, driverInstance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error setting driver on UnpooledDataSource. Cause: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置数据库连接信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureConnection</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//设置超时时间</span></span><br><span class="line">  <span class="keyword">if</span> (defaultNetworkTimeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conn.setNetworkTimeout(Executors.newSingleThreadExecutor(), defaultNetworkTimeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置是否自动提交</span></span><br><span class="line">  <span class="keyword">if</span> (autoCommit != <span class="keyword">null</span> &amp;&amp; autoCommit != conn.getAutoCommit()) &#123;</span><br><span class="line">    conn.setAutoCommit(autoCommit);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置事务隔离等级</span></span><br><span class="line">  <span class="keyword">if</span> (defaultTransactionIsolationLevel != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conn.setTransactionIsolation(defaultTransactionIsolationLevel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 以上代码就是 UnpooledDataSource 类的主要实现逻辑，每次获取连接都是从数据库新创建一个连接进行返回，又因为，数据库连接的创建是一个耗时的操作，且数据库连接是非常珍贵的资源，如果每次获取连接都创建一个，则可能会造成系统的瓶颈，拖垮响应速度等，这时就需要数据库连接池了，Mybatis 也提供了自己数据库连接池的实现，就是 PooledDataSource 类。</p><h3 id="PooledDataSource"><a href="#PooledDataSource" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><blockquote><p>PooledDataSource 是一个比较复杂的类，PooledDataSource 新创建数据库连接是使用 UnpooledDataSource 来实现的，且 PooledDataSource 并不会管理 java.sql.Connection 对象，而是管理 PooledConnection 对象，在 PooledConnection 中封装了真正的数据库连接对象和其代理对象；此外，由于它是一个连接池，所以还需要管理连接池的状态，比如有多少连接是空闲的，还可以创建多少连接，此时，就需要一个类来管理连接池的对象，即 PoolState 对象；先来看下 PooledDataSource 的一个 UML 图：</p></blockquote><p><img src="../images/mybatis/pool03.jpg" alt></p><h3 id="PooledConnection"><a href="#PooledConnection" class="headerlink" title="PooledConnection"></a>PooledConnection</h3><blockquote><p>它主要是用来管理数据库连接的，它是一个代理类，实现了 InvocationHandler 接口</p></blockquote><h4 id="主体方法"><a href="#主体方法" class="headerlink" title="主体方法"></a>主体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis 连接池对象 使用的是 动态代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledConnection</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//关闭方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOSE = <span class="string">"close"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IFACES = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Connection.class&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">  <span class="comment">// 记录当前的 PooledConnection 对象所在的 PooledDataSource 对象，该 PooledConnection 对象是从 PooledDataSource 对象中获取的，当调用 close 方法时会将 PooledConnection 放回该 PooledDataSource 中去</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PooledDataSource dataSource;</span><br><span class="line">  <span class="comment">//真实连接</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection realConnection;</span><br><span class="line">  <span class="comment">// 数据库连接的代理对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line">  <span class="comment">// 从连接池中取出该连接的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp;</span><br><span class="line">  <span class="comment">// 该连接创建的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp;</span><br><span class="line">  <span class="comment">// 该连接最后一次被使用的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp;</span><br><span class="line">  <span class="comment">// 用于标识该连接所在的连接池，由URL+username+password 计算出来的hash值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> connectionTypeCode;</span><br><span class="line">  <span class="comment">// 该连接是否有效</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in.</span></span><br><span class="line"><span class="comment">   * 创建连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> connection - the connection that is to be presented as a pooled connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource - the dataSource that the connection is from</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledConnection</span><span class="params">(Connection connection, PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashCode = connection.hashCode();</span><br><span class="line">    <span class="keyword">this</span>.realConnection = connection;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.createdTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.lastUsedTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invalidates the connection.</span></span><br><span class="line"><span class="comment">   *   废弃该连接 设置连接未不可用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    valid = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Method to see if the connection is usable.</span></span><br><span class="line"><span class="comment">   * 检查连接是否可用 连接可用并且能够被ping，</span></span><br><span class="line"><span class="comment">   *   1.判断 valid 字段</span></span><br><span class="line"><span class="comment">   *   2.向数据库中发送检测测试的SQL，查看真正的连接还是否有效</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> True if the connection is usable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> valid &amp;&amp; realConnection != <span class="keyword">null</span> &amp;&amp; dataSource.pingConnection(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error accessing PooledConnection. Connection is invalid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invok代理方法"><a href="#invok代理方法" class="headerlink" title="invok代理方法"></a>invok代理方法</h4><blockquote><p>该方法是 proxyConnection 这个连接代理对象的真正代理逻辑，它会对 close 方法进行代理，并且在调用真正的连接之前对连接进行检测。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Required for InvocationHandler implementation.</span></span><br><span class="line"><span class="comment">   * 动态代理的入口方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy  - not used</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method - the method to be executed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args   - the parameters to be passed to the method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="comment">//如果关闭连接 将当前连接放回连接池 资源复用</span></span><br><span class="line">    <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">      dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//不是Object对象的一些方法例如 toString等方法</span></span><br><span class="line">      <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">        <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">        <span class="comment">// 执行之前，需要进行连接的检测</span></span><br><span class="line">        checkConnection();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用数据库真正的连接进行执行</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="PoolState"><a href="#PoolState" class="headerlink" title="PoolState"></a>PoolState</h3><blockquote><p>PoolState 类主要是用来管理连接池的状态，比如哪些连接是空闲的，哪些是活动的，还可以创建多少连接等。该类中只是定义了一些属性来进行控制连接池的状态，并没有任何的方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolState</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 该 PoolState 属于哪个 PooledDataSource</span></span><br><span class="line">  <span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line">  <span class="comment">// 来用存放空闲的 pooledConnection 连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 用来存放活跃的 PooledConnection 连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 请求数据库连接的次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 请求数据库连接的次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// checkoutTime 表示从连接池中获取连接到归还连接的时间</span></span><br><span class="line">  <span class="comment">// accumulatedCheckoutTime 记录了所有连接的累计 checkoutTime 时长</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 连接超时的连接个数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 累计超时时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 累计等待时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 等待次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 无效的连接数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PoolState</span><span class="params">(PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PooledDataSource-1"><a href="#PooledDataSource-1" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><blockquote><p>终于等来了我们的主角，PooledDataSource 它是一个简单的，同步的，线程安全的数据库连接池</p></blockquote><p>​ 知道了 UnpooledDataSource 用来创建数据库新的连接，PooledConnection 用来管理连接池中的连接，PoolState 用来管理连接池的状态之后，来看下 PooledDataSource 的一个逻辑，该类中主要有以下几个方法：获取数据库连接的方法 popConnection，把连接放回连接池的方法 pushConnection，检测数据库连接是否有效的方法 pingConnection ，还有 关闭连接池中所有连接的方法 forceCloseAll</p><h4 id="主体方法-1"><a href="#主体方法-1" class="headerlink" title="主体方法"></a>主体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a simple, synchronous, thread-safe database connection pool.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 简单的 带有锁的 线程安全的 数据库连接池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(PooledDataSource.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据库连接池状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来创建真正的数据库连接对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OPTIONAL CONFIGURATION FIELDS</span></span><br><span class="line">  <span class="comment">// 最大活跃的连接数，默认为 10</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 最大空闲连接数，默认为 5</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// 最大获取连接的时长</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line">  <span class="comment">// 在无法获取到连接时，最大等待的时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line">  <span class="comment">//脸是失败重试次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 在检测一个连接是否可用时，会向数据库发送一个测试 SQL</span></span><br><span class="line">  <span class="keyword">protected</span> String poolPingQuery = <span class="string">"NO PING QUERY SET"</span>;</span><br><span class="line">  <span class="comment">//是否启动连接池ping</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line">  <span class="comment">// 当连接超过 poolPingConnectionsNotUsedFor 毫秒未使用时，会发送一次测试 SQL 语句，测试连接是否正常</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line">  <span class="comment">// 标志着当前的连接池，是 url+username+password 的 hash 值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建连接池</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(UnpooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  生成 连接的hash 值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">assembleConnectionTypeCode</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">""</span> + url + username + password).hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h4><blockquote><p>从 连接池中获取连接的方法主要是在 popConnection 中实现的，先来看下它的一个流程图：</p></blockquote><p><img src="../images/mybatis/pool04.jpg" alt></p><p>代码逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> popConnection(username, password).getProxyConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从连接池中获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待个数</span></span><br><span class="line">    <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// PooledConnection 对象</span></span><br><span class="line">    PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//耗时计算</span></span><br><span class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 无效的连接个数</span></span><br><span class="line">    <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        <span class="comment">// 检测是否还有空闲的连接</span></span><br><span class="line">        <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// Pool has available connection</span></span><br><span class="line">          <span class="comment">// 连接池中还有空闲的连接，则直接获取连接返回</span></span><br><span class="line">          conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Checked out connection "</span> + conn.getRealHashCode() + <span class="string">" from pool."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 连接池中已经没有空闲连接了</span></span><br><span class="line">          <span class="comment">// Pool does not have available connection</span></span><br><span class="line">          <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">            <span class="comment">// Can create new connection</span></span><br><span class="line">            <span class="comment">// 活跃的连接数没有达到最大值，则创建一个新的数据库连接</span></span><br><span class="line">            conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">"Created connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Cannot create new connection</span></span><br><span class="line">            <span class="comment">// 如果活跃的连接数已经达到允许的最大值了，则不能创建新的数据库连接</span></span><br><span class="line">            <span class="comment">// 获取最先创建的那个活跃的连接</span></span><br><span class="line">            PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">            <span class="comment">// 检测该连接是否超时</span></span><br><span class="line">            <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">              <span class="comment">// 如果该连接超时，则进行相应的统计</span></span><br><span class="line">              <span class="comment">// Can claim overdue connection</span></span><br><span class="line">              <span class="comment">//超时连接个数统计</span></span><br><span class="line">              state.claimedOverdueConnectionCount++;</span><br><span class="line">              <span class="comment">//统计过期的连接超时时间</span></span><br><span class="line">              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">              <span class="comment">//统计超时时间</span></span><br><span class="line">              state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">              <span class="comment">// 将超时连接移出 activeConnections 集合</span></span><br><span class="line">              state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">              <span class="comment">//如果没有设置自动提交</span></span><br><span class="line">              <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果超时未提交，则自动回滚</span></span><br><span class="line">                  oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     Just log a message for debug and continue to execute the following</span></span><br><span class="line"><span class="comment">                     statement like nothing happened.</span></span><br><span class="line"><span class="comment">                     Wrap the bad connection with a new PooledConnection, this will help</span></span><br><span class="line"><span class="comment">                     to not interrupt current executing thread and give current thread a</span></span><br><span class="line"><span class="comment">                     chance to join the next competition for another valid/good database</span></span><br><span class="line"><span class="comment">                     connection. At the end of this loop, bad &#123;@link @conn&#125; will be set as null.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  log.debug(<span class="string">"Bad connection. Could not roll back"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 创建新的 PooledConnection 对象，但是真正的数据库连接并没有创建</span></span><br><span class="line">              <span class="comment">//刚刚获取的真实连接 新瓶装旧酒</span></span><br><span class="line">              conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">//设置创建时间</span></span><br><span class="line">              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">              <span class="comment">//设置最后使用时间</span></span><br><span class="line">              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">              <span class="comment">// 设置该超时的旧的连接为无效</span></span><br><span class="line">              oldestActiveConnection.invalidate();</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"Claimed overdue connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果第一个连接还没有超时，说明其他的都没有超时，只能等待了</span></span><br><span class="line">              <span class="comment">// Must wait</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等待个数统计</span></span><br><span class="line">                <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                  <span class="comment">//等待计数</span></span><br><span class="line">                  state.hadToWaitCount++;</span><br><span class="line">                  <span class="comment">//下次不进行计数</span></span><br><span class="line">                  countedWait = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                  log.debug(<span class="string">"Waiting as long as "</span> + poolTimeToWait + <span class="string">" milliseconds for connection."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//超时等待 阻塞等待</span></span><br><span class="line">                state.wait(poolTimeToWait);</span><br><span class="line">                <span class="comment">//统计等待的时长</span></span><br><span class="line">                state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//异常退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经获取到连接，如果连接不为空</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// ping to server and check the connection is valid or not</span></span><br><span class="line">          <span class="comment">//连接状态可用</span></span><br><span class="line">          <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">            <span class="comment">// 如果连连接有效，事务未提交则回滚</span></span><br><span class="line">            <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">              <span class="comment">//进行回滚 恢复到最初状态</span></span><br><span class="line">              conn.getRealConnection().rollback();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置连接类型</span></span><br><span class="line">            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">            <span class="comment">//设置检查超时的时间</span></span><br><span class="line">            conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">//设置最后使用时间</span></span><br><span class="line">            conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">// 把连接加入到活跃集合中去</span></span><br><span class="line">            state.activeConnections.add(conn);</span><br><span class="line">            <span class="comment">//统计请求计数</span></span><br><span class="line">            state.requestCount++;</span><br><span class="line">            <span class="comment">//统计请求时长</span></span><br><span class="line">            state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果验证连接失败</span></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") was returned from the pool, getting another connection."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//统计错误连接个数</span></span><br><span class="line">            state.badConnectionCount++;</span><br><span class="line">            localBadConnectionCount++;</span><br><span class="line">            <span class="comment">//连接置为null 进行GC</span></span><br><span class="line">            conn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//无效连接个数 &gt; 最大空闲连接数 + 失败尝试次数</span></span><br><span class="line">            <span class="comment">//大部分无效连接，可以停止服务了</span></span><br><span class="line">            <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//抛异常 因为获取的都是不可用的连接</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果连接还未空</span></span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回连接</span></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上就是从连接池获取连接的主要逻辑。</p><h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><blockquote><p>把连接放入的连接池中以供下次重新使用，把连接放入到连接池中的方法为 pushConnection 方法,它也是 PooledDataSource 类的一个主要方法。</p></blockquote><p><img src="../images/mybatis/pool05.jpg" alt></p><p>代码逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  把不用的连接放入到连接池中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 首先从活跃的集合中移除掉该连接</span></span><br><span class="line">    state.activeConnections.remove(conn);</span><br><span class="line">    <span class="comment">//验证连接是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">      <span class="comment">// 如果空闲连接数没有达到最大值，且 PooledConnection 为该连接池的连接</span></span><br><span class="line">      <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">        <span class="comment">//验证超时时间汇总</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">//如果没有自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//进行回滚</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据真实连接创建一个新的池化的连接 真是链接还用当前的连接</span></span><br><span class="line">        PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//添加到空闲连接</span></span><br><span class="line">        state.idleConnections.add(newConn);</span><br><span class="line">        <span class="comment">//设置创建时间</span></span><br><span class="line">        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">        <span class="comment">//设置最后使用时间</span></span><br><span class="line">        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">        <span class="comment">//设置原来的连接为无效</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">"Returned connection "</span> + newConn.getRealHashCode() + <span class="string">" to pool."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒阻塞等待的线程</span></span><br><span class="line">        state.notifyAll();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空闲连接数已经达到最大值</span></span><br><span class="line">        <span class="comment">//计算超时时间汇总</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">//未设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//回滚</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真正的数据库连接</span></span><br><span class="line">        conn.getRealConnection().close();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">"Closed connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置该连接为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果连接状态失败</span></span><br><span class="line">      <span class="comment">//打印日志</span></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") attempted to return to the pool, discarding connection."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无效连接个数加1</span></span><br><span class="line">      state.badConnectionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是把不用的连接放入到连接池中以供下次使用，</p><p>在上面两个方法中，都调用了 isValid 方法来检测连接是否可用。</p><h4 id="检查连接"><a href="#检查连接" class="headerlink" title="检查连接"></a>检查连接</h4><blockquote><p>该方法除了检测 valid 字段外，还会调用 pingConnection 方法来尝试让数据库执行测试 SQL 语句，从而检测真正的数据库连接对象是否依然正常可用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method to check to see if a connection is still usable</span></span><br><span class="line"><span class="comment"> *   向数据库发送测试 SQL 来检测真正的数据库连接是否可用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn - the connection to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the connection is still usable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">pingConnection</span><span class="params">(PooledConnection conn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 结果</span></span><br><span class="line">  <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 检测真正的数据库连接是否已经关闭</span></span><br><span class="line">    result = !conn.getRealConnection().isClosed();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果真正的数据库连接还没关闭</span></span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 是否执行测试 SQL 语句</span></span><br><span class="line">    <span class="keyword">if</span> (poolPingEnabled) &#123;</span><br><span class="line">      <span class="comment">// 长时间（poolPingConnectionsNotUsedFor 指定的时长）未使用的连接，才需要ping操作来检测连接是否正常</span></span><br><span class="line">      <span class="keyword">if</span> (poolPingConnectionsNotUsedFor &gt;= <span class="number">0</span> &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Testing connection "</span> + conn.getRealHashCode() + <span class="string">" ..."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 发送测试 SQL 语句执行</span></span><br><span class="line">          Connection realConn = conn.getRealConnection();</span><br><span class="line">          <span class="keyword">try</span> (Statement statement = realConn.createStatement()) &#123;</span><br><span class="line">            statement.executeQuery(poolPingQuery).close();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//回滚</span></span><br><span class="line">          <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">            realConn.rollback();</span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is GOOD!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(<span class="string">"Execution of ping query '"</span> + poolPingQuery + <span class="string">"' failed: "</span> + e.getMessage());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//关闭真实连接</span></span><br><span class="line">            conn.getRealConnection().close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">            <span class="comment">//ignore</span></span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭所有连接"><a href="#关闭所有连接" class="headerlink" title="关闭所有连接"></a>关闭所有连接</h4><blockquote><p>当修改 PooledDataSource 相应的字段，如 数据库的 URL，用户名或密码等，需要将连接池中连接全部关闭，之后获取连接的时候从重新初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes all active and idle connections in the pool.</span></span><br><span class="line"><span class="comment"> * 关闭所有的活动以及空闲连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">    <span class="comment">//遍历关闭活动的连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置连接为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="comment">//获取真实连接</span></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="comment">//是否设置了自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//否则进行回滚，保证数据一致性</span></span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真实连接</span></span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历关闭空闲的连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="comment">//获取真实连接</span></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="comment">//如果没有设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//进行数据回滚</span></span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真实的链接</span></span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">"PooledDataSource forcefully closed/removed all connections."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在连接池中提到了 连接池中的最大连接数和最大空闲数，在 获取连接和把连接放入连接池中都有判断，</p><ol><li><p>获取连接：首先从连接池中进行获取，如果连接池中已经没有空闲的连接了，则会判断当前的活跃连接数是否已经达到允许的最大值了，如果没有，则还可以创建新的连接，之后把它放到活跃的集合中进行使用，如果当前活跃的已达到最大值，则阻塞。</p></li><li><p>返还连接到连接池，在返还连接的时候，进行判断，如果空闲连接数已达到允许的最大值，则直接关闭真正的数据库连接，否则把该连接放入到空闲集合中以供下次使用。</p></li></ol><p>Mybatis 数据源中，主要的代码逻辑还是在连接池类 PooledDataSource 中，对于获取连接的方法 popConnection，返还连接的方法 pushConnection ，需要结合上图来看，才能看得清楚。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis数据库连接池
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据库连接池" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据库连接池" scheme="http://www.baiyp.ren/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
</feed>
