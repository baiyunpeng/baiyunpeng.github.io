<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓风残月的博客</title>
  
  <subtitle>晓风残月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baiyp.ren/"/>
  <updated>2019-09-04T10:04:19.385Z</updated>
  <id>http://www.baiyp.ren/</id>
  
  <author>
    <name>晓风残月</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MYBATIS源码解析-02数据库连接池</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-02数据库连接池.html</id>
    <published>2019-09-04T08:58:57.000Z</published>
    <updated>2019-09-04T10:04:19.385Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:43 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS数据库连接池"><a href="#MYBATIS数据库连接池" class="headerlink" title="MYBATIS数据库连接池"></a>MYBATIS数据库连接池</h2><h3 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h3><p>​ 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><p>​ 在使用 Mybatis 的时候，数据库的连接一般都会使用第三方的数据源组件，如 C3P0，DBCP 和 Druid 等，其实 Mybatis 也有自己的数据源实现，可以连接数据库，还有连接池的功能，下面就来看看 Mybatis 自己实现的数据源头和连接池的一个实现原理。</p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>Mybatis 数据源的实现主要是在 datasource 包：</p><p><img src="../images/mybatis/pool01.jpg" alt></p><p>​ 我们常见的数据库连接池都需要实现javax.sql.DataSource接口mybatis提供了UnpooledDataSource和PooledDataSource的实现， 一个使用连接池，一个不使用连接池此外，对于这两个类，Mybatis 还提供了两个工厂类进行创建对象，是工厂方法模式的一个应用，首先来看下它们的一个类图：</p><p><img src="../images/mybatis/pool02.jpg" alt></p><p>我们先看下工厂类</p><h3 id="DataSourceFactory"><a href="#DataSourceFactory" class="headerlink" title="DataSourceFactory"></a>DataSourceFactory</h3><blockquote><p>数据源连接池工厂类接口</p></blockquote><p>该类是 JndiDataSourceFactory 和 UnpooledDataSourceFactory 两个工厂类的顶层接口，只定义了两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据源连接池 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数据源连接池</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnpooledDataSourceFactory"><a href="#UnpooledDataSourceFactory" class="headerlink" title="UnpooledDataSourceFactory"></a>UnpooledDataSourceFactory</h3><blockquote><p>UnpooledDataSourceFactory 主要用来创建 UnpooledDataSource 对象，它会在构造方法中初始化 UnpooledDataSource 对象，并在 setProperties 方法中完成对 UnpooledDataSource 对象的配置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnpooledDataSource 连接工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSourceFactory</span> <span class="keyword">implements</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数据库驱动前缀</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_PROPERTY_PREFIX = <span class="string">"driver."</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DRIVER_PROPERTY_PREFIX_LENGTH = DRIVER_PROPERTY_PREFIX.length();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应的数据源，即 UnpooledDataSource</span></span><br><span class="line">  <span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对数据源 UnpooledDataSource 进行配置</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据源属性文件</span></span><br><span class="line">    Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 创建 DataSource 相应的 MetaObject</span></span><br><span class="line">    MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">    <span class="comment">// 遍历 properties 集合，该集合中存放了数据源需要的信息</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : properties.keySet()) &#123;</span><br><span class="line">      String propertyName = (String) key;</span><br><span class="line">      <span class="comment">// 以 "driver." 开头的配置项是对 DataSource 的配置，记录到 driverProperties  中</span></span><br><span class="line">      <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">        String value = properties.getProperty(propertyName);</span><br><span class="line">        <span class="comment">//设置连接的属性和值</span></span><br><span class="line">        driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">        <span class="comment">// 该属性是否有 set 方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">        <span class="comment">// 获取对应的属性值</span></span><br><span class="line">        String value = (String) properties.get(propertyName);</span><br><span class="line">        <span class="comment">// 根据属性类型进行类型的转换，主要是 Integer, Long, Boolean 三种类型的转换</span></span><br><span class="line">        Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">        <span class="comment">// 设置DataSource 的相关属性值</span></span><br><span class="line">        metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">"Unknown DataSource property: "</span> + propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 DataSource.driverProerties 属性值</span></span><br><span class="line">    <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      metaDataSource.setValue(<span class="string">"driverProperties"</span>, driverProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回数据源</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型转</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">convertValue</span><span class="params">(MetaObject metaDataSource, String propertyName, String value)</span> </span>&#123;</span><br><span class="line">    Object convertedValue = value;</span><br><span class="line">    Class&lt;?&gt; targetType = metaDataSource.getSetterType(propertyName);</span><br><span class="line">    <span class="keyword">if</span> (targetType == Integer.class || targetType == <span class="keyword">int</span>.class) &#123;</span><br><span class="line">      convertedValue = Integer.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Long.class || targetType == <span class="keyword">long</span>.class) &#123;</span><br><span class="line">      convertedValue = Long.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Boolean.class || targetType == <span class="keyword">boolean</span>.class) &#123;</span><br><span class="line">      convertedValue = Boolean.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> convertedValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JndiDataSourceFactory 依赖 JNDI 服务器中获取用户配置的 DataSource，这里可以不看。</p></blockquote><p>UnpooledDataSourceFactory工厂类主要的作用是对数据源进行配置。</p><h3 id="PooledDataSourceFactory"><a href="#PooledDataSourceFactory" class="headerlink" title="PooledDataSourceFactory"></a>PooledDataSourceFactory</h3><blockquote><p>PooledDataSourceFactory 主要用来创建 PooledDataSource 对象，它继承了 UnpooledDataSource 类，设置 DataSource 参数的方法复用UnpooledDataSource 中的 setProperties 方法，只是数据源返回的是 PooledDataSource 对象而已。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceFactory</span> <span class="keyword">extends</span> <span class="title">UnpooledDataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建连接池对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上这些就是 Mybatis 用来创建数据源的工厂类，下面就来看下数据源的主要实现。</p></blockquote><h3 id="UnpooledDataSource"><a href="#UnpooledDataSource" class="headerlink" title="UnpooledDataSource"></a>UnpooledDataSource</h3><blockquote><p>UnpooledDataSource 不使用连接池来创建数据库连接，每次获取数据库连接时都会创建一个新的连接进行返回；</p></blockquote><h4 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h4><blockquote><p>在static静态块中进行驱动注册</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未使用连接池的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 加载 Driver 类的类加载器</span></span><br><span class="line">  <span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line">  <span class="comment">// 数据库连接驱动的相关配置</span></span><br><span class="line">  <span class="keyword">private</span> Properties driverProperties;</span><br><span class="line">  <span class="comment">// 缓存所有已注册的数据库连接驱动</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//数据源配置相关</span></span><br><span class="line">  <span class="keyword">private</span> String driver;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="comment">// 是否自动提交</span></span><br><span class="line">  <span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line">  <span class="comment">//默认事务隔离级别</span></span><br><span class="line">  <span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line">  <span class="comment">//默认超时时间</span></span><br><span class="line">  <span class="keyword">private</span> Integer defaultNetworkTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  静态块，在初始化的时候，从 DriverManager 中获取所有的已注册的驱动信息，并缓存到该类的 registeredDrivers集合中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//获取驱动信息</span></span><br><span class="line">    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();</span><br><span class="line">    <span class="keyword">while</span> (drivers.hasMoreElements()) &#123;</span><br><span class="line">      Driver driver = drivers.nextElement();</span><br><span class="line">      <span class="comment">//注册进集合中</span></span><br><span class="line">      registeredDrivers.put(driver.getClass().getName(), driver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 无参构造</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, Properties driverProperties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.driverProperties = driverProperties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取一个连接"><a href="#获取一个连接" class="headerlink" title="获取一个连接"></a>获取一个连接</h4><blockquote><p>这里面没有提供连接销毁的方法，在连接池中有销毁连接的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 获取一个连接</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@return</span> 连接对象</span><br><span class="line"> * <span class="meta">@throws</span> SQLException</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个数据库连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">if</span> (driverProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.putAll(driverProperties);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置用户</span></span><br><span class="line">  <span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置密码</span></span><br><span class="line">  <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个连接对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> properties 数据库属性文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数据库连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//初始化驱动信息</span></span><br><span class="line">  initializeDriver();</span><br><span class="line">  <span class="comment">// 通过 DriverManager 来获取一个数据库连接</span></span><br><span class="line">  Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">  <span class="comment">//配置连接信息</span></span><br><span class="line">  configureConnection(connection);</span><br><span class="line">  <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化驱动信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前的驱动还没有注册，则进行注册</span></span><br><span class="line">  <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">    Class&lt;?&gt; driverType;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//驱动的类加载器不为空</span></span><br><span class="line">      <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取驱动类型</span></span><br><span class="line">        driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driverType = Resources.classForName(driver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// DriverManager requires the driver to be loaded via the system ClassLoader.</span></span><br><span class="line">      <span class="comment">// http://www.kfu.com/~nsayer/Java/dyn-jdbc.html</span></span><br><span class="line">      <span class="comment">//创建驱动</span></span><br><span class="line">      Driver driverInstance = (Driver) driverType.newInstance();</span><br><span class="line">      <span class="comment">//向JDBC注册驱动</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">      <span class="comment">//向registeredDrivers注册驱动</span></span><br><span class="line">      registeredDrivers.put(driver, driverInstance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error setting driver on UnpooledDataSource. Cause: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置数据库连接信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureConnection</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//设置超时时间</span></span><br><span class="line">  <span class="keyword">if</span> (defaultNetworkTimeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conn.setNetworkTimeout(Executors.newSingleThreadExecutor(), defaultNetworkTimeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置是否自动提交</span></span><br><span class="line">  <span class="keyword">if</span> (autoCommit != <span class="keyword">null</span> &amp;&amp; autoCommit != conn.getAutoCommit()) &#123;</span><br><span class="line">    conn.setAutoCommit(autoCommit);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置事务隔离等级</span></span><br><span class="line">  <span class="keyword">if</span> (defaultTransactionIsolationLevel != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conn.setTransactionIsolation(defaultTransactionIsolationLevel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 以上代码就是 UnpooledDataSource 类的主要实现逻辑，每次获取连接都是从数据库新创建一个连接进行返回，又因为，数据库连接的创建是一个耗时的操作，且数据库连接是非常珍贵的资源，如果每次获取连接都创建一个，则可能会造成系统的瓶颈，拖垮响应速度等，这时就需要数据库连接池了，Mybatis 也提供了自己数据库连接池的实现，就是 PooledDataSource 类。</p><h3 id="PooledDataSource"><a href="#PooledDataSource" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><blockquote><p>PooledDataSource 是一个比较复杂的类，PooledDataSource 新创建数据库连接是使用 UnpooledDataSource 来实现的，且 PooledDataSource 并不会管理 java.sql.Connection 对象，而是管理 PooledConnection 对象，在 PooledConnection 中封装了真正的数据库连接对象和其代理对象；此外，由于它是一个连接池，所以还需要管理连接池的状态，比如有多少连接是空闲的，还可以创建多少连接，此时，就需要一个类来管理连接池的对象，即 PoolState 对象；先来看下 PooledDataSource 的一个 UML 图：</p></blockquote><p><img src="../images/mybatis/pool03.jpg" alt></p><h3 id="PooledConnection"><a href="#PooledConnection" class="headerlink" title="PooledConnection"></a>PooledConnection</h3><blockquote><p>它主要是用来管理数据库连接的，它是一个代理类，实现了 InvocationHandler 接口</p></blockquote><h4 id="主体方法"><a href="#主体方法" class="headerlink" title="主体方法"></a>主体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis 连接池对象 使用的是 动态代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledConnection</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//关闭方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOSE = <span class="string">"close"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IFACES = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Connection.class&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">  <span class="comment">// 记录当前的 PooledConnection 对象所在的 PooledDataSource 对象，该 PooledConnection 对象是从 PooledDataSource 对象中获取的，当调用 close 方法时会将 PooledConnection 放回该 PooledDataSource 中去</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PooledDataSource dataSource;</span><br><span class="line">  <span class="comment">//真实连接</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection realConnection;</span><br><span class="line">  <span class="comment">// 数据库连接的代理对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line">  <span class="comment">// 从连接池中取出该连接的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp;</span><br><span class="line">  <span class="comment">// 该连接创建的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp;</span><br><span class="line">  <span class="comment">// 该连接最后一次被使用的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp;</span><br><span class="line">  <span class="comment">// 用于标识该连接所在的连接池，由URL+username+password 计算出来的hash值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> connectionTypeCode;</span><br><span class="line">  <span class="comment">// 该连接是否有效</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in.</span></span><br><span class="line"><span class="comment">   * 创建连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> connection - the connection that is to be presented as a pooled connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource - the dataSource that the connection is from</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledConnection</span><span class="params">(Connection connection, PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashCode = connection.hashCode();</span><br><span class="line">    <span class="keyword">this</span>.realConnection = connection;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.createdTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.lastUsedTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invalidates the connection.</span></span><br><span class="line"><span class="comment">   *   废弃该连接 设置连接未不可用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    valid = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Method to see if the connection is usable.</span></span><br><span class="line"><span class="comment">   * 检查连接是否可用 连接可用并且能够被ping，</span></span><br><span class="line"><span class="comment">   *   1.判断 valid 字段</span></span><br><span class="line"><span class="comment">   *   2.向数据库中发送检测测试的SQL，查看真正的连接还是否有效</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> True if the connection is usable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> valid &amp;&amp; realConnection != <span class="keyword">null</span> &amp;&amp; dataSource.pingConnection(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error accessing PooledConnection. Connection is invalid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invok代理方法"><a href="#invok代理方法" class="headerlink" title="invok代理方法"></a>invok代理方法</h4><blockquote><p>该方法是 proxyConnection 这个连接代理对象的真正代理逻辑，它会对 close 方法进行代理，并且在调用真正的连接之前对连接进行检测。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Required for InvocationHandler implementation.</span></span><br><span class="line"><span class="comment">   * 动态代理的入口方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy  - not used</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method - the method to be executed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args   - the parameters to be passed to the method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="comment">//如果关闭连接 将当前连接放回连接池 资源复用</span></span><br><span class="line">    <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">      dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//不是Object对象的一些方法例如 toString等方法</span></span><br><span class="line">      <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">        <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">        <span class="comment">// 执行之前，需要进行连接的检测</span></span><br><span class="line">        checkConnection();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用数据库真正的连接进行执行</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="PoolState"><a href="#PoolState" class="headerlink" title="PoolState"></a>PoolState</h3><blockquote><p>PoolState 类主要是用来管理连接池的状态，比如哪些连接是空闲的，哪些是活动的，还可以创建多少连接等。该类中只是定义了一些属性来进行控制连接池的状态，并没有任何的方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolState</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 该 PoolState 属于哪个 PooledDataSource</span></span><br><span class="line">  <span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line">  <span class="comment">// 来用存放空闲的 pooledConnection 连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 用来存放活跃的 PooledConnection 连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 请求数据库连接的次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 请求数据库连接的次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// checkoutTime 表示从连接池中获取连接到归还连接的时间</span></span><br><span class="line">  <span class="comment">// accumulatedCheckoutTime 记录了所有连接的累计 checkoutTime 时长</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 连接超时的连接个数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 累计超时时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 累计等待时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 等待次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 无效的连接数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PoolState</span><span class="params">(PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PooledDataSource-1"><a href="#PooledDataSource-1" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><blockquote><p>终于等来了我们的主角，PooledDataSource 它是一个简单的，同步的，线程安全的数据库连接池</p></blockquote><p>​ 知道了 UnpooledDataSource 用来创建数据库新的连接，PooledConnection 用来管理连接池中的连接，PoolState 用来管理连接池的状态之后，来看下 PooledDataSource 的一个逻辑，该类中主要有以下几个方法：获取数据库连接的方法 popConnection，把连接放回连接池的方法 pushConnection，检测数据库连接是否有效的方法 pingConnection ，还有 关闭连接池中所有连接的方法 forceCloseAll</p><h4 id="主体方法-1"><a href="#主体方法-1" class="headerlink" title="主体方法"></a>主体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a simple, synchronous, thread-safe database connection pool.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 简单的 带有锁的 线程安全的 数据库连接池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(PooledDataSource.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据库连接池状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来创建真正的数据库连接对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OPTIONAL CONFIGURATION FIELDS</span></span><br><span class="line">  <span class="comment">// 最大活跃的连接数，默认为 10</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 最大空闲连接数，默认为 5</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// 最大获取连接的时长</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line">  <span class="comment">// 在无法获取到连接时，最大等待的时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line">  <span class="comment">//脸是失败重试次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 在检测一个连接是否可用时，会向数据库发送一个测试 SQL</span></span><br><span class="line">  <span class="keyword">protected</span> String poolPingQuery = <span class="string">"NO PING QUERY SET"</span>;</span><br><span class="line">  <span class="comment">//是否启动连接池ping</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line">  <span class="comment">// 当连接超过 poolPingConnectionsNotUsedFor 毫秒未使用时，会发送一次测试 SQL 语句，测试连接是否正常</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line">  <span class="comment">// 标志着当前的连接池，是 url+username+password 的 hash 值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建连接池</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(UnpooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  生成 连接的hash 值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">assembleConnectionTypeCode</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">""</span> + url + username + password).hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h4><blockquote><p>从 连接池中获取连接的方法主要是在 popConnection 中实现的，先来看下它的一个流程图：</p></blockquote><p><img src="../images/mybatis/pool04.jpg" alt></p><p>代码逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> popConnection(username, password).getProxyConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从连接池中获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待个数</span></span><br><span class="line">    <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// PooledConnection 对象</span></span><br><span class="line">    PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//耗时计算</span></span><br><span class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 无效的连接个数</span></span><br><span class="line">    <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        <span class="comment">// 检测是否还有空闲的连接</span></span><br><span class="line">        <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// Pool has available connection</span></span><br><span class="line">          <span class="comment">// 连接池中还有空闲的连接，则直接获取连接返回</span></span><br><span class="line">          conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Checked out connection "</span> + conn.getRealHashCode() + <span class="string">" from pool."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 连接池中已经没有空闲连接了</span></span><br><span class="line">          <span class="comment">// Pool does not have available connection</span></span><br><span class="line">          <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">            <span class="comment">// Can create new connection</span></span><br><span class="line">            <span class="comment">// 活跃的连接数没有达到最大值，则创建一个新的数据库连接</span></span><br><span class="line">            conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">"Created connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Cannot create new connection</span></span><br><span class="line">            <span class="comment">// 如果活跃的连接数已经达到允许的最大值了，则不能创建新的数据库连接</span></span><br><span class="line">            <span class="comment">// 获取最先创建的那个活跃的连接</span></span><br><span class="line">            PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">            <span class="comment">// 检测该连接是否超时</span></span><br><span class="line">            <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">              <span class="comment">// 如果该连接超时，则进行相应的统计</span></span><br><span class="line">              <span class="comment">// Can claim overdue connection</span></span><br><span class="line">              <span class="comment">//超时连接个数统计</span></span><br><span class="line">              state.claimedOverdueConnectionCount++;</span><br><span class="line">              <span class="comment">//统计过期的连接超时时间</span></span><br><span class="line">              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">              <span class="comment">//统计超时时间</span></span><br><span class="line">              state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">              <span class="comment">// 将超时连接移出 activeConnections 集合</span></span><br><span class="line">              state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">              <span class="comment">//如果没有设置自动提交</span></span><br><span class="line">              <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果超时未提交，则自动回滚</span></span><br><span class="line">                  oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     Just log a message for debug and continue to execute the following</span></span><br><span class="line"><span class="comment">                     statement like nothing happened.</span></span><br><span class="line"><span class="comment">                     Wrap the bad connection with a new PooledConnection, this will help</span></span><br><span class="line"><span class="comment">                     to not interrupt current executing thread and give current thread a</span></span><br><span class="line"><span class="comment">                     chance to join the next competition for another valid/good database</span></span><br><span class="line"><span class="comment">                     connection. At the end of this loop, bad &#123;@link @conn&#125; will be set as null.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  log.debug(<span class="string">"Bad connection. Could not roll back"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 创建新的 PooledConnection 对象，但是真正的数据库连接并没有创建</span></span><br><span class="line">              <span class="comment">//刚刚获取的真实连接 新瓶装旧酒</span></span><br><span class="line">              conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">//设置创建时间</span></span><br><span class="line">              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">              <span class="comment">//设置最后使用时间</span></span><br><span class="line">              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">              <span class="comment">// 设置该超时的旧的连接为无效</span></span><br><span class="line">              oldestActiveConnection.invalidate();</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"Claimed overdue connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果第一个连接还没有超时，说明其他的都没有超时，只能等待了</span></span><br><span class="line">              <span class="comment">// Must wait</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等待个数统计</span></span><br><span class="line">                <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                  <span class="comment">//等待计数</span></span><br><span class="line">                  state.hadToWaitCount++;</span><br><span class="line">                  <span class="comment">//下次不进行计数</span></span><br><span class="line">                  countedWait = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                  log.debug(<span class="string">"Waiting as long as "</span> + poolTimeToWait + <span class="string">" milliseconds for connection."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//超时等待 阻塞等待</span></span><br><span class="line">                state.wait(poolTimeToWait);</span><br><span class="line">                <span class="comment">//统计等待的时长</span></span><br><span class="line">                state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//异常退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经获取到连接，如果连接不为空</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// ping to server and check the connection is valid or not</span></span><br><span class="line">          <span class="comment">//连接状态可用</span></span><br><span class="line">          <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">            <span class="comment">// 如果连连接有效，事务未提交则回滚</span></span><br><span class="line">            <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">              <span class="comment">//进行回滚 恢复到最初状态</span></span><br><span class="line">              conn.getRealConnection().rollback();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置连接类型</span></span><br><span class="line">            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">            <span class="comment">//设置检查超时的时间</span></span><br><span class="line">            conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">//设置最后使用时间</span></span><br><span class="line">            conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">// 把连接加入到活跃集合中去</span></span><br><span class="line">            state.activeConnections.add(conn);</span><br><span class="line">            <span class="comment">//统计请求计数</span></span><br><span class="line">            state.requestCount++;</span><br><span class="line">            <span class="comment">//统计请求时长</span></span><br><span class="line">            state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果验证连接失败</span></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") was returned from the pool, getting another connection."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//统计错误连接个数</span></span><br><span class="line">            state.badConnectionCount++;</span><br><span class="line">            localBadConnectionCount++;</span><br><span class="line">            <span class="comment">//连接置为null 进行GC</span></span><br><span class="line">            conn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//无效连接个数 &gt; 最大空闲连接数 + 失败尝试次数</span></span><br><span class="line">            <span class="comment">//大部分无效连接，可以停止服务了</span></span><br><span class="line">            <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//抛异常 因为获取的都是不可用的连接</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果连接还未空</span></span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回连接</span></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上就是从连接池获取连接的主要逻辑。</p><h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><blockquote><p>把连接放入的连接池中以供下次重新使用，把连接放入到连接池中的方法为 pushConnection 方法,它也是 PooledDataSource 类的一个主要方法。</p></blockquote><p><img src="../images/mybatis/pool05.jpg" alt></p><p>代码逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  把不用的连接放入到连接池中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 首先从活跃的集合中移除掉该连接</span></span><br><span class="line">    state.activeConnections.remove(conn);</span><br><span class="line">    <span class="comment">//验证连接是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">      <span class="comment">// 如果空闲连接数没有达到最大值，且 PooledConnection 为该连接池的连接</span></span><br><span class="line">      <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">        <span class="comment">//验证超时时间汇总</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">//如果没有自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//进行回滚</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据真实连接创建一个新的池化的连接 真是链接还用当前的连接</span></span><br><span class="line">        PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//添加到空闲连接</span></span><br><span class="line">        state.idleConnections.add(newConn);</span><br><span class="line">        <span class="comment">//设置创建时间</span></span><br><span class="line">        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">        <span class="comment">//设置最后使用时间</span></span><br><span class="line">        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">        <span class="comment">//设置原来的连接为无效</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">"Returned connection "</span> + newConn.getRealHashCode() + <span class="string">" to pool."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒阻塞等待的线程</span></span><br><span class="line">        state.notifyAll();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空闲连接数已经达到最大值</span></span><br><span class="line">        <span class="comment">//计算超时时间汇总</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">//未设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//回滚</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真正的数据库连接</span></span><br><span class="line">        conn.getRealConnection().close();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">"Closed connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置该连接为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果连接状态失败</span></span><br><span class="line">      <span class="comment">//打印日志</span></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") attempted to return to the pool, discarding connection."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无效连接个数加1</span></span><br><span class="line">      state.badConnectionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是把不用的连接放入到连接池中以供下次使用，</p><p>在上面两个方法中，都调用了 isValid 方法来检测连接是否可用。</p><h4 id="检查连接"><a href="#检查连接" class="headerlink" title="检查连接"></a>检查连接</h4><blockquote><p>该方法除了检测 valid 字段外，还会调用 pingConnection 方法来尝试让数据库执行测试 SQL 语句，从而检测真正的数据库连接对象是否依然正常可用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method to check to see if a connection is still usable</span></span><br><span class="line"><span class="comment"> *   向数据库发送测试 SQL 来检测真正的数据库连接是否可用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn - the connection to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the connection is still usable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">pingConnection</span><span class="params">(PooledConnection conn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 结果</span></span><br><span class="line">  <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 检测真正的数据库连接是否已经关闭</span></span><br><span class="line">    result = !conn.getRealConnection().isClosed();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果真正的数据库连接还没关闭</span></span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 是否执行测试 SQL 语句</span></span><br><span class="line">    <span class="keyword">if</span> (poolPingEnabled) &#123;</span><br><span class="line">      <span class="comment">// 长时间（poolPingConnectionsNotUsedFor 指定的时长）未使用的连接，才需要ping操作来检测连接是否正常</span></span><br><span class="line">      <span class="keyword">if</span> (poolPingConnectionsNotUsedFor &gt;= <span class="number">0</span> &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Testing connection "</span> + conn.getRealHashCode() + <span class="string">" ..."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 发送测试 SQL 语句执行</span></span><br><span class="line">          Connection realConn = conn.getRealConnection();</span><br><span class="line">          <span class="keyword">try</span> (Statement statement = realConn.createStatement()) &#123;</span><br><span class="line">            statement.executeQuery(poolPingQuery).close();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//回滚</span></span><br><span class="line">          <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">            realConn.rollback();</span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is GOOD!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(<span class="string">"Execution of ping query '"</span> + poolPingQuery + <span class="string">"' failed: "</span> + e.getMessage());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//关闭真实连接</span></span><br><span class="line">            conn.getRealConnection().close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">            <span class="comment">//ignore</span></span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭所有连接"><a href="#关闭所有连接" class="headerlink" title="关闭所有连接"></a>关闭所有连接</h4><blockquote><p>当修改 PooledDataSource 相应的字段，如 数据库的 URL，用户名或密码等，需要将连接池中连接全部关闭，之后获取连接的时候从重新初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes all active and idle connections in the pool.</span></span><br><span class="line"><span class="comment"> * 关闭所有的活动以及空闲连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">    <span class="comment">//遍历关闭活动的连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置连接为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="comment">//获取真实连接</span></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="comment">//是否设置了自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//否则进行回滚，保证数据一致性</span></span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真实连接</span></span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历关闭空闲的连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="comment">//获取真实连接</span></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="comment">//如果没有设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//进行数据回滚</span></span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真实的链接</span></span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">"PooledDataSource forcefully closed/removed all connections."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在连接池中提到了 连接池中的最大连接数和最大空闲数，在 获取连接和把连接放入连接池中都有判断，</p><ol><li><p>获取连接：首先从连接池中进行获取，如果连接池中已经没有空闲的连接了，则会判断当前的活跃连接数是否已经达到允许的最大值了，如果没有，则还可以创建新的连接，之后把它放到活跃的集合中进行使用，如果当前活跃的已达到最大值，则阻塞。</p></li><li><p>返还连接到连接池，在返还连接的时候，进行判断，如果空闲连接数已达到允许的最大值，则直接关闭真正的数据库连接，否则把该连接放入到空闲集合中以供下次使用。</p></li></ol><p>Mybatis 数据源中，主要的代码逻辑还是在连接池类 PooledDataSource 中，对于获取连接的方法 popConnection，返还连接的方法 pushConnection ，需要结合上图来看，才能看得清楚。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis数据库连接池
    
    </summary>
    
      <category term="MYBATIS" scheme="http://www.baiyp.ren/categories/MYBATIS/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/MYBATIS/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据库连接池" scheme="http://www.baiyp.ren/categories/MYBATIS/%E6%BA%90%E7%A0%81/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="MYBATIS" scheme="http://www.baiyp.ren/tags/MYBATIS/"/>
    
      <category term="数据库连接池" scheme="http://www.baiyp.ren/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-01日志模块</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-01日志模块.html</id>
    <published>2019-09-04T06:58:57.000Z</published>
    <updated>2019-09-04T08:28:04.960Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:43 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS日志模块解析"><a href="#MYBATIS日志模块解析" class="headerlink" title="MYBATIS日志模块解析"></a>MYBATIS日志模块解析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​ mybatis 没有提供日志的实现类，需要接入第三方的日志组件，但第三方日志组件都有各自的Log级别，且各不相同。而Mybatis统一提供了trace/ debug/ warn/ error四个级别，mybatis使用适配器模式进行日志加载，我们来欣赏下mybatis源码的魅力。</p><h3 id="日志接口Log"><a href="#日志接口Log" class="headerlink" title="日志接口Log"></a>日志接口Log</h3><blockquote><p>mybatis 封装了统一的日志接口，其他日志接口接入需要实现该日志接口。</p><p>该接口只提供了trace/ debug/ warn/ error四个级别的日志输出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * mybatis log日志接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="comment">//是否启动debug</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否启动Trace</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//error日志级别</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志工厂LogFactory"><a href="#日志工厂LogFactory" class="headerlink" title="日志工厂LogFactory"></a>日志工厂LogFactory</h3><blockquote><p>在这里定义了日志框架的加载顺序</p><p>slf4j -&gt; commonsLoging -&gt; Log4J2 -&gt; Log4J -&gt; JdkLog</p><p>使得日志框架优雅的嵌入到mybatis中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis log 工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Marker to be used by logging implementations that support markers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MARKER = <span class="string">"MYBATIS"</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 记录正在使用的是那个日志框架的构造方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 顺序尝试找到一个可用的日志框架</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * :: 双冒号运算符就是java中的方法引用 方法引用的格式是 类名::方法名。</span></span><br><span class="line"><span class="comment">   * person -&gt;person.getAge(); 可以替换为 Person::getAge</span></span><br><span class="line"><span class="comment">   * （）-&gt; new HashMap&lt;&gt;(); 可以替换为 HashMap::new</span></span><br><span class="line"><span class="comment">   * 双冒号操作符返回的是一个接口的匿名实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="comment">//尝试使用某一种日志框架 第一个不成功到第二个 一直找到一个合适的</span></span><br><span class="line">    tryImplementation(LogFactory::useSlf4jLogging);</span><br><span class="line">    tryImplementation(LogFactory::useCommonsLogging);</span><br><span class="line">    tryImplementation(LogFactory::useLog4J2Logging);</span><br><span class="line">    tryImplementation(LogFactory::useLog4JLogging);</span><br><span class="line">    tryImplementation(LogFactory::useJdkLogging);</span><br><span class="line">    tryImplementation(LogFactory::useNoLogging);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// disable construction</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回具体实现的实现类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> aClass</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回具体实现的接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> logger 具体需要日志的 类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(String logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//使用当前可用的构造方法进行创建对象</span></span><br><span class="line">      <span class="keyword">return</span> logConstructor.newInstance(logger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">"Error creating logger for logger "</span> + logger + <span class="string">".  Cause: "</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useCustomLogging</span><span class="params">(Class&lt;? extends Log&gt; clazz)</span> </span>&#123;</span><br><span class="line">    setImplementation(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useSlf4jLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useCommonsLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useLog4JLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.log4j.Log4jImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useLog4J2Logging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.log4j2.Log4j2Impl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useJdkLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useStdOutLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.stdout.StdOutImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useNoLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.nologging.NoLoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 咋一看好像是多线程</span></span><br><span class="line"><span class="comment">   * 其实不然，只用用了下Runnable接口的钩子方法</span></span><br><span class="line"><span class="comment">   * 不用再自定义接口内部类实现了，用现成的Runnable接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryImplementation</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果构造方法为空就调用匿名内部类</span></span><br><span class="line">    <span class="keyword">if</span> (logConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用具体接口的方法</span></span><br><span class="line">        runnable.run();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置日志实现类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> implClass</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImplementation</span><span class="params">(Class&lt;? extends Log&gt; implClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取具体实现类的构造方法</span></span><br><span class="line">      Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);</span><br><span class="line">      <span class="comment">//创建一个实现类 并打印日志</span></span><br><span class="line">      Log log = candidate.newInstance(LogFactory.class.getName());</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"Logging initialized using '"</span> + implClass + <span class="string">"' adapter."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置否则方法为当前可用构造方法</span></span><br><span class="line">      logConstructor = candidate;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">"Error setting Log implementation.  Cause: "</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里是整个日志的加载顺序，尝试找到一个可用的构造方法，找到后返回该日志框架的实例。</p><p>这里面用到了Runable接口的钩子方法，也可以叫做接口回调，并没有使用多线程编程。</p><h3 id="日志系统转换"><a href="#日志系统转换" class="headerlink" title="日志系统转换"></a>日志系统转换</h3><blockquote><p>这里采用了很多日志框架，使用了适配器模式进行日志的转换，装饰着模式可以查看我的设计模式一节</p><p>这里我们就拿比较负责的sl4j来查看源码</p></blockquote><p><img src="../images/mybatis%5Cmybatis_log01.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式 Sl4j 实现类</span></span><br><span class="line"><span class="comment"> * 实现Log 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前类的实现类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Log log;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法 初始化 log</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> clazz 需要打印日志的类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Slf4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//logger的方式创建日志类</span></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(clazz);</span><br><span class="line">    <span class="comment">//如果返回的是 LocationAwareLogger 对象</span></span><br><span class="line">    <span class="keyword">if</span> (logger <span class="keyword">instanceof</span> LocationAwareLogger) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check for slf4j &gt;= 1.6 method signature</span></span><br><span class="line">        <span class="comment">//检查sl4j 版本是否&gt;=1.6</span></span><br><span class="line">        logger.getClass().getMethod(<span class="string">"log"</span>, Marker.class, String.class, <span class="keyword">int</span>.class, String.class, Object[].class, Throwable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 Slf4jLocationAwareLoggerImpl 实例</span></span><br><span class="line">        log = <span class="keyword">new</span> Slf4jLocationAwareLoggerImpl((LocationAwareLogger) logger);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SecurityException | NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="comment">// fail-back to Slf4jLoggerImpl</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Logger is not LocationAwareLogger or slf4j version &lt; 1.6</span></span><br><span class="line">    <span class="comment">//sl4j 版本小于1.6 使用Slf4jLoggerImpl</span></span><br><span class="line">    log = <span class="keyword">new</span> Slf4jLoggerImpl(logger);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.error(s, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.error(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.trace(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.warn(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意下Slf4j版本控制，如果Slf4j版本&gt;=1.6 使用 Slf4jLocationAwareLoggerImpl 否则使用Slf4jLoggerImpl</p><p>我们再拿Slf4jLoggerImpl看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slf4jLoggerImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Slf4jLoggerImpl</span><span class="params">(Logger logger)</span> </span>&#123;</span><br><span class="line">    log = logger;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.error(s, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.error(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.trace(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.warn(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就是mybatis日志框架的优雅封装实现，通过依次尝试加载，使用适配器模式进行日志接口的统一</p><h3 id="JDBC日志增强"><a href="#JDBC日志增强" class="headerlink" title="JDBC日志增强"></a>JDBC日志增强</h3><h4 id="JDBC模板类BaseJdbcLogger"><a href="#JDBC模板类BaseJdbcLogger" class="headerlink" title="JDBC模板类BaseJdbcLogger"></a>JDBC模板类BaseJdbcLogger</h4><blockquote><p>BaseJdbcLogger初始化了日志框架Log，SET_METHODS和jdbc执行方法列表EXECUTE_METHODS</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for proxies to do logging.</span></span><br><span class="line"><span class="comment"> * 基类 JDBC操作日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJdbcLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; SET_METHODS;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; EXECUTE_METHODS = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; columnMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; columnNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; columnValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Log statementLog;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> queryStack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Default constructor</span></span><br><span class="line"><span class="comment">   * 默认构造方法，将日志接口以及查询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BaseJdbcLogger</span><span class="params">(Log log, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.statementLog = log;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.queryStack = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.queryStack = queryStack;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Set方法设置进SET_METHODS</span></span><br><span class="line">    SET_METHODS = Arrays.stream(PreparedStatement.class.getDeclaredMethods())</span><br><span class="line">            .filter(method -&gt; method.getName().startsWith(<span class="string">"set"</span>))</span><br><span class="line">            .filter(method -&gt; method.getParameterCount() &gt; <span class="number">1</span>)</span><br><span class="line">            .map(Method::getName)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">//添加执行方法</span></span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"execute"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"executeUpdate"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"executeQuery"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"addBatch"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setColumn</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    columnMap.put(key, value);</span><br><span class="line">    columnNames.add(key);</span><br><span class="line">    columnValues.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">getColumn</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> columnMap.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取参数值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getParameterValueString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(columnValues.size());</span><br><span class="line">    <span class="keyword">for</span> (Object value : columnValues) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        typeList.add(<span class="string">"null"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        typeList.add(objectValueString(value) + <span class="string">"("</span> + value.getClass().getSimpleName() + <span class="string">")"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String parameters = typeList.toString();</span><br><span class="line">    <span class="keyword">return</span> parameters.substring(<span class="number">1</span>, parameters.length() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将Object转换为String</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">objectValueString</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Array) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ArrayUtil.toString(((Array) value).getArray());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取参数名称列表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getColumnString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> columnNames.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空参数map</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearColumnInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    columnMap.clear();</span><br><span class="line">    columnNames.clear();</span><br><span class="line">    columnValues.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清除换行符以及制表符</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> original</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">removeBreakingWhitespace</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    StringTokenizer whitespaceStripper = <span class="keyword">new</span> StringTokenizer(original);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (whitespaceStripper.hasMoreTokens()) &#123;</span><br><span class="line">      builder.append(whitespaceStripper.nextToken());</span><br><span class="line">      builder.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否启用debug</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementLog.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否启用Trace</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementLog.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 日志打印</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> input</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String text, <span class="keyword">boolean</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (statementLog.isDebugEnabled()) &#123;</span><br><span class="line">      statementLog.debug(prefix(input) + text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String text, <span class="keyword">boolean</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (statementLog.isTraceEnabled()) &#123;</span><br><span class="line">      statementLog.trace(prefix(input) + text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取输出的前缀</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> isInput</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">prefix</span><span class="params">(<span class="keyword">boolean</span> isInput)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[queryStack * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">    Arrays.fill(buffer, <span class="string">'='</span>);</span><br><span class="line">    buffer[queryStack * <span class="number">2</span> + <span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">if</span> (isInput) &#123;</span><br><span class="line">      buffer[queryStack * <span class="number">2</span>] = <span class="string">'&gt;'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer[<span class="number">0</span>] = <span class="string">'&lt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Connection日志增强"><a href="#Connection日志增强" class="headerlink" title="Connection日志增强"></a>Connection日志增强</h4><blockquote><p>Connection日志增加是基于动态代理实现的，具有很高的参考价值，他创建预处理等对象的时候并返回预处理对象的代理方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Connection proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 基于动态代理的日志增强</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据库连接</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn 连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ConnectionLogger</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.connection = conn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理的核心处理类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果是预处理方法 打印debug信息</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"prepareStatement"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">" Preparing: "</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用prepareStatement方法</span></span><br><span class="line">        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">        <span class="comment">//如果是调用存储过程</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"prepareCall"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">" Preparing: "</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用prepareCall 方法</span></span><br><span class="line">        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">        <span class="comment">//如果创建createStatement 方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"createStatement"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用 createStatement 方法</span></span><br><span class="line">        Statement stmt = (Statement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其他方法直接调用</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(connection, params);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a connection.</span></span><br><span class="line"><span class="comment">   * 创建 连接的代理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn - the original connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the connection with logging</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">newInstance</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> ConnectionLogger(conn, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = Connection.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;Connection.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * return the wrapped connection.</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the connection</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PreparedStatementLogger预处理日志增强"><a href="#PreparedStatementLogger预处理日志增强" class="headerlink" title="PreparedStatementLogger预处理日志增强"></a>PreparedStatementLogger预处理日志增强</h4><blockquote><p>预处理日志增强，对其中一些方法进行增强，对于查询以及获取结果集，返回结果集的日志动态代理增强。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PreparedStatement proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 基于动态代理的预处理日志增强</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 原始的预处理对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 私有的构造方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stmt         预处理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PreparedStatementLogger</span><span class="params">(PreparedStatement stmt, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.statement = stmt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理和核心方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//如果是Object对象直接调用</span></span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果包含定义的可执行方法 则打印日志 以及值列表</span></span><br><span class="line">      <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">"Parameters: "</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空 参数</span></span><br><span class="line">        clearColumnInfo();</span><br><span class="line">        <span class="comment">//如果是查询方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"executeQuery"</span>.equals(method.getName())) &#123;</span><br><span class="line">          <span class="comment">//调用 executeQuery 方法 并返回结果集</span></span><br><span class="line">          ResultSet rs = (ResultSet) method.invoke(statement, params);</span><br><span class="line">          <span class="comment">//返回结果集的 动态代理日志增强</span></span><br><span class="line">          <span class="keyword">return</span> rs == <span class="keyword">null</span> ? <span class="keyword">null</span> : ResultSetLogger.newInstance(rs, statementLog, queryStack);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其他方法直接调用不进行日志增强</span></span><br><span class="line">          <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果方法在SET_METHODS列表中</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SET_METHODS.contains(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//如果是 setNull 的方法 则设置为null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"setNull"</span>.equals(method.getName())) &#123;</span><br><span class="line">          setColumn(params[<span class="number">0</span>], <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其他设置具体参数的值</span></span><br><span class="line">          setColumn(params[<span class="number">0</span>], params[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用set方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//如果是getResultSet方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"getResultSet"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用具体的getResultSet方法</span></span><br><span class="line">        ResultSet rs = (ResultSet) method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//返回结果集日志曾倩</span></span><br><span class="line">        <span class="keyword">return</span> rs == <span class="keyword">null</span> ? <span class="keyword">null</span> : ResultSetLogger.newInstance(rs, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//如果是获取更新条数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"getUpdateCount"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用具体方法获取条数</span></span><br><span class="line">        <span class="keyword">int</span> updateCount = (Integer) method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//如果是不等于-1 打印结果日志</span></span><br><span class="line">        <span class="keyword">if</span> (updateCount != -<span class="number">1</span>) &#123;</span><br><span class="line">          debug(<span class="string">"   Updates: "</span> + updateCount, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回更新条数</span></span><br><span class="line">        <span class="keyword">return</span> updateCount;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不进行增加的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a PreparedStatement.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 创建动态代理的实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stmt         - the statement</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog - the statement log</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack   - the query stack</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the proxy</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PreparedStatement <span class="title">newInstance</span><span class="params">(PreparedStatement stmt, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> PreparedStatementLogger(stmt, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = PreparedStatement.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (PreparedStatement) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;PreparedStatement.class, CallableStatement.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the wrapped prepared statement.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the PreparedStatement</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">getPreparedStatement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatementLogger日志增加和PreparedStatementLogger这个类基本上一样，大家可以看一下。</p><h4 id="ResultSetLogger结果集日志增强"><a href="#ResultSetLogger结果集日志增强" class="headerlink" title="ResultSetLogger结果集日志增强"></a>ResultSetLogger结果集日志增强</h4><blockquote><p>结果集打印没有什么可说的了，基本上就是判断是否是blob类型，特殊处理，其他情况进行字符串拼接</p><p>这里使用了JDK1.8的StringJoiner 进行字符串拼接，可以简单的方式进行包含有分隔符的字符串拼接</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResultSet proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 结果集处理日志动态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSetLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Bolb 字段类型列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Integer&gt; BLOB_TYPES = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">  <span class="comment">//结果集原始对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultSet rs;</span><br><span class="line">  <span class="comment">//blob参数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; blobColumns = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//设置blob数据类型</span></span><br><span class="line">    BLOB_TYPES.add(Types.BINARY);</span><br><span class="line">    BLOB_TYPES.add(Types.BLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.CLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGNVARCHAR);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGVARBINARY);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGVARCHAR);</span><br><span class="line">    BLOB_TYPES.add(Types.NCLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.VARBINARY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 私有构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rs 结果集</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ResultSetLogger</span><span class="params">(ResultSet rs, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.rs = rs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理的核心方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//方法是Object类型 直接调用</span></span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用原始的方法</span></span><br><span class="line">      Object o = method.invoke(rs, params);</span><br><span class="line">      <span class="comment">//如果调用next方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"next"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//如果有下一行</span></span><br><span class="line">        <span class="keyword">if</span> ((Boolean) o) &#123;</span><br><span class="line">          <span class="comment">//行数++</span></span><br><span class="line">          rows++;</span><br><span class="line">          <span class="comment">//日志打印</span></span><br><span class="line">          <span class="keyword">if</span> (isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">//获取元数据</span></span><br><span class="line">            ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">            <span class="comment">//获取列数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">//如果是第一行 用来判断是否是第一行</span></span><br><span class="line">            <span class="keyword">if</span> (first) &#123;</span><br><span class="line">              <span class="comment">//设置第一行不显示</span></span><br><span class="line">              first = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//打印列标题</span></span><br><span class="line">              printColumnHeaders(rsmd, columnCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印参数结果集数据</span></span><br><span class="line">            printColumnValues(columnCount);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          debug(<span class="string">"     Total: "</span> + rows, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      clearColumnInfo();</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打印结果集日志</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rsmd 结果集元数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> columnCount 列行数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printColumnHeaders</span><span class="params">(ResultSetMetaData rsmd, <span class="keyword">int</span> columnCount)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    StringJoiner row = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>, <span class="string">"   Columns: "</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (BLOB_TYPES.contains(rsmd.getColumnType(i))) &#123;</span><br><span class="line">        blobColumns.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      row.add(rsmd.getColumnLabel(i));</span><br><span class="line">    &#125;</span><br><span class="line">    trace(row.toString(), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打印结果集数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> columnCount</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printColumnValues</span><span class="params">(<span class="keyword">int</span> columnCount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//StringJoiner 进行字符串拼接</span></span><br><span class="line">    StringJoiner row = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>, <span class="string">"       Row: "</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果包是blob类型 添加BLOB 标识</span></span><br><span class="line">        <span class="keyword">if</span> (blobColumns.contains(i)) &#123;</span><br><span class="line">          row.add(<span class="string">"&lt;&lt;BLOB&gt;&gt;"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//将值添加到字符串中</span></span><br><span class="line">          row.add(rs.getString(i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// generally can't call getString() on a BLOB column</span></span><br><span class="line">        row.add(<span class="string">"&lt;&lt;Cannot Display&gt;&gt;"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trace(row.toString(), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a ResultSet.</span></span><br><span class="line"><span class="comment">   * 创建结果集代理类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rs - the ResultSet to proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the ResultSet with logging</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title">newInstance</span><span class="params">(ResultSet rs, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> ResultSetLogger(rs, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = ResultSet.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (ResultSet) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;ResultSet.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the wrapped result set.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the resultSet</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSet <span class="title">getRs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ mybatis 日志模块使用适配器模式进行不同类型的日志框架的统一，使用动态代理对连接执行sql，结果集进行日志的增强，使其无缝的与mybatis结合起来，你们的日志是怎么打印的呢？</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis日志模块解析
    
    </summary>
    
      <category term="MYBATIS" scheme="http://www.baiyp.ren/categories/MYBATIS/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/MYBATIS/%E6%BA%90%E7%A0%81/"/>
    
      <category term="日志" scheme="http://www.baiyp.ren/categories/MYBATIS/%E6%BA%90%E7%A0%81/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="MYBATIS" scheme="http://www.baiyp.ren/tags/MYBATIS/"/>
    
      <category term="日志" scheme="http://www.baiyp.ren/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式08--建造者模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式08.html</id>
    <published>2019-08-31T01:42:30.000Z</published>
    <updated>2019-09-05T10:26:56.839Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-建造者模式（Builder-Pattern）"><a href="#JAVA设计模式-建造者模式（Builder-Pattern）" class="headerlink" title="JAVA设计模式-建造者模式（Builder Pattern）"></a>JAVA设计模式-建造者模式（Builder Pattern）</h2><p><img src="../images/design-patterns/builderpattern01.png" alt></p><h3 id="什么是建造者模式"><a href="#什么是建造者模式" class="headerlink" title="什么是建造者模式"></a>什么是建造者模式</h3><p>​ 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的</p><p>​ 创建者模式又叫建造者模式，是将一个复杂的对象的<strong>构建</strong>与它的<strong>表示</strong>分离，使<br>得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><strong>Product（产品角色）：</strong> 一个具体的产品对象。</li><li><strong>Builder（抽象建造者）：</strong>创建一个Product对象的各个部件指定的抽象接口。</li><li><strong>ConcreteBuilder（具体建造者）：</strong>实现抽象接口，构建和装配各个部件。</li><li><strong>Director（指挥者）：</strong>构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li><li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li><li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li><li>初始化一个对象时，参数过多，或者很多参数具有默认值</li><li>Builder模式不适合创建差异性很大的产品类</li><li>产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li><li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ul><h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3><blockquote><p>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</p></blockquote><ul><li>用户只需要给出指定复杂对象的类型和内容；</li><li>建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)</li></ul><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul><li>方便用户创建复杂的对象（不需要知道实现过程）</li><li>代码复用性 &amp; 封装性（将对象构建过程和细节进行封装 &amp; 复用）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><blockquote><p>需要进行构建的原始的产品类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要进行构建的产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单价</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">", num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Builder-接口"><a href="#Builder-接口" class="headerlink" title="Builder 接口"></a>Builder 接口</h4><blockquote><p>Builder 可以是接口也可以是抽象类，定义需要实现的构建模板</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建产品名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建单价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取构建的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体建造者（ConcreteBuilder）"><a href="#具体建造者（ConcreteBuilder）" class="headerlink" title="具体建造者（ConcreteBuilder）"></a>具体建造者（ConcreteBuilder）</h4><h5 id="构建苹果手机"><a href="#构建苹果手机" class="headerlink" title="构建苹果手机"></a>构建苹果手机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建苹果手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">"iphone手机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPrice(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setNum(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构建手表"><a href="#构建手表" class="headerlink" title="构建手表"></a>构建手表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建手表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">"手表"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPrice(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setNum(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指挥者-Director"><a href="#指挥者-Director" class="headerlink" title="指挥者(Director)"></a>指挥者(Director)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建造者接口</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建具体的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 构建出来的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildName();</span><br><span class="line">        builder.buildPrice();</span><br><span class="line">        builder.buildNum();</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印手机</span></span><br><span class="line">        printBuild(<span class="keyword">new</span> MobileBuilder());</span><br><span class="line">        <span class="comment">//打印手表</span></span><br><span class="line">        printBuild(<span class="keyword">new</span> WatchBuilder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印建造后的对象数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuild</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.getProduct();</span><br><span class="line">        System.out.println(product.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Product&#123;name=<span class="string">'iphone手机'</span>, price=<span class="number">8000.0</span>, num=<span class="number">1000</span>&#125;</span><br><span class="line">Product&#123;name=<span class="string">'手表'</span>, price=<span class="number">10000.0</span>, num=<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="通过链式调用优化-非常推荐"><a href="#通过链式调用优化-非常推荐" class="headerlink" title="通过链式调用优化(非常推荐)"></a>通过链式调用优化(非常推荐)</h3><blockquote><p>链式写法是在原型写法的基础上做优化，有些时候<code>Builder</code>的创建部分有默认值，或者不需要的情况下，而产生不同的<code>Product</code>，通过以上方式，就需要修改<code>Director</code>类和<code>Builder</code>类，再或者根据不同的创建顺序，生成不同的结果，也需要修改<code>Director</code>类。<code>Director</code>似乎显得很不稳定和多余。可以通过<code>Builder</code>自身的调用逻辑来生成<code>Product</code>，即链式调用</p></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链式的建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamProductBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单价</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamProductBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamProductBuilder</span><span class="params">(String name, <span class="keyword">float</span> price, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态类 Builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 产品名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单价</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//空的构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进行建造</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">price</span><span class="params">(<span class="keyword">float</span> prie)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.price = price;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">num</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回建造的对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> StreamProductBuilder <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StreamProductBuilder(name, price, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端使用-1"><a href="#客户端使用-1" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StreamProductBuilder builder = <span class="keyword">new</span> StreamProductBuilder.Builder().name(<span class="string">"iphone手机"</span>).price(<span class="number">8000</span>).num(<span class="number">100</span>).build();</span><br><span class="line">        System.out.println(builder.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码只是传入三个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性，代码更加简洁。</p><h4 id="相比于普通JavaBean的好处"><a href="#相比于普通JavaBean的好处" class="headerlink" title="相比于普通JavaBean的好处"></a>相比于普通JavaBean的好处</h4><p>​ 在建造者模式中,提供一个辅助的静态建造器<code>Builder</code>(静态内部类),可以在里面<code>set</code>实体类的属性,与<code>JavaBean</code>不同的是,建造者是先<code>set</code>,在通过<code>build</code>实例化实体类,这样既可以提高代码的阅读性,也可以防止对象没有实例化,就被调用;不会造成不一致性,同时解决了<code>Javabean</code>模式的线程安全问题</p><h3 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ <strong>Director角色并非多余，能把复杂的Product创建过程对外隐藏，使Builder部件和创建过程分离，各方易于扩展，降低了耦合度。当需要对一个对象设置很多属性，此时就能方便的使用链式调用来提高编码速度和代码可读性。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之建造者模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="-建造者模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="-建造者模式" scheme="http://www.baiyp.ren/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式07-代理模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式07.html</id>
    <published>2019-08-30T01:42:30.000Z</published>
    <updated>2019-09-05T09:23:26.677Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-代理模式（Proxy-Pattern）"><a href="#JAVA设计模式-代理模式（Proxy-Pattern）" class="headerlink" title="JAVA设计模式-代理模式（Proxy Pattern）"></a>JAVA设计模式-代理模式（Proxy Pattern）</h2><p><img src="../images/design-patterns/proxyparrern01.png" alt></p><h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3><p>​ 在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。</p><p>​ 代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，后面将学习这些不同的代理形式。</p><p>​ 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p><p>​ 代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。</p><h4 id="为什么要用代理模式"><a href="#为什么要用代理模式" class="headerlink" title="为什么要用代理模式"></a>为什么要用代理模式</h4><ul><li><strong>中介隔离作用：</strong>在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。</li><li><strong>开闭原则，增加功能：</strong>代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</li></ul><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><strong>Subject（抽象主题角色）：</strong> 它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li><li><strong>Proxy（代理主题角色）：</strong> 它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</li><li><strong>RealSubject（真实主题角色）：</strong> 它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>职责清晰。</li><li>高扩展性。</li><li>智能化。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>远程代理。</li><li>虚拟代理。</li><li>Copy-on-Write 代理。</li><li>保护（Protect or Access）代理。</li><li>Cache代理。</li><li>防火墙（Firewall）代理。</li><li>同步化（Synchronization）代理。</li><li>智能引用（Smart Reference）代理。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>其实代理的一般模式就是静态代理的实现模式：首先创建一个接口（JDK代理都是面向接口的），然后创建具体实现类来实现这个接口，在创建一个代理类同样实现这个接口，不同之处在于，具体实现类的方法中需要将接口中定义的方法的业务逻辑功能实现，而代理类中的方法只要调用具体类中的对应方法即可，这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可，将具体的实现类隐藏在底层。</p></blockquote><p><img src="../images/design-patterns/proxyparrern02.png" alt></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="公用接口"><a href="#公用接口" class="headerlink" title="公用接口"></a>公用接口</h5><blockquote><p>代理类和真实类的公用接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="真实类的请求"><a href="#真实类的请求" class="headerlink" title="真实类的请求"></a>真实类的请求</h5><blockquote><p>实现公有的接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"真实请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建代理类"><a href="#创建代理类" class="headerlink" title="创建代理类"></a>创建代理类</h5><blockquote><p>代理请求，引入了真实类对象，对方法进行了增强。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"><span class="comment">//真实请求接口</span></span><br><span class="line">    <span class="keyword">private</span> Subject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//转发真实请求</span></span><br><span class="line">        realSubject.request();</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态代理总结"><a href="#静态代理总结" class="headerlink" title="静态代理总结"></a>静态代理总结</h4><p>优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。</p><p>缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。</p></blockquote><h4 id="编写动态处理器"><a href="#编写动态处理器" class="headerlink" title="编写动态处理器"></a>编写动态处理器</h4><blockquote><p>动态代理需要实现InvocationHandler接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类只能代理接口（不支持抽象类），代理类都需要实现InvocationHandler类，实现invoke方法。</span></span><br><span class="line"><span class="comment"> * 该invoke方法就是调用被代理接口的所有方法时需要调用的，该invoke方法返回的值是被代理接口的一个实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定关系，也就是关联到哪个接口（与具体的实现类绑定）的哪些方法将被调用时，执行invoke方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object targetObject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetObject=targetObject;</span><br><span class="line">        <span class="comment">//该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span><br><span class="line">        <span class="comment">//第一个参数指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器</span></span><br><span class="line">        <span class="comment">//第二个参数要实现和目标对象一样的接口，所以只需要拿到目标对象的实现接口</span></span><br><span class="line">        <span class="comment">//第三个参数表明这些被拦截的方法在被拦截时需要执行哪个InvocationHandler的invoke方法</span></span><br><span class="line">        <span class="comment">//根据传入的目标返回一个代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),</span><br><span class="line">                targetObject.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联的这个实现类的方法被调用时将被执行</span></span><br><span class="line"><span class="comment">     * InvocationHandler接口的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 原对象被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 表示方法的参数*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//调用目标方法</span></span><br><span class="line">        Object result = method.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DynamicProxyHandler dynamicProxyHandler=<span class="keyword">new</span> DynamicProxyHandler();</span><br><span class="line">        UserManager userManager=(UserManager)dynamicProxyHandler.newProxyInstance(<span class="keyword">new</span> UserManagerImpl());</span><br><span class="line">        UserManager userManager=<span class="keyword">new</span> UserManagerImpl();</span><br><span class="line">        userManager.addUser(<span class="string">"1111"</span>, <span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理总结"><a href="#动态代理总结" class="headerlink" title="动态代理总结"></a>动态代理总结</h4><p>​ 虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。</p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><blockquote><p>JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。</p></blockquote><h4 id="创建CGLIB代理类"><a href="#创建CGLIB代理类" class="headerlink" title="创建CGLIB代理类"></a>创建CGLIB代理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//CGLIB enhancer增强类对象</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置代理类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.targetObject.getClass());</span><br><span class="line">        <span class="comment">//定义代理逻辑对象为当前对象   ，对象要继承MethodInterceptor。并实现逻辑方法intercept</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理逻辑方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//真的是代理对象，不像JDk代理，还是真实对象</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了CGLIB的加强者Enhancer,通过设置超类的方法setSuperclass，然后通过setCallback方法设置哪个类为它的代理类。其中，参数为this就意味着是当前对象，那就要求用this这个对象实现接口Methodlnterceptor的方法intercept，然后返回代理对象。那么此时当前类的intercept方法就是其代理逻辑方法，其参数内容见代码注解，我们在反射真实对象方法前后进行了打印，CGLIB是通过如下代码完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object result=methodProxy.invokeSuper(proxy,args);</span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        CglibProxy cglib = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        Dog dog = (Dog) cglib.getInstance(Dog.class);</span><br><span class="line">        <span class="comment">//调用代理对象的isAnimal()方法</span></span><br><span class="line">        dog.isAnimal(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CGLIB代理总结"><a href="#CGLIB代理总结" class="headerlink" title="CGLIB代理总结"></a>CGLIB代理总结</h4><p>​ CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之代理模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://www.baiyp.ren/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA字节码指令</title>
    <link href="http://www.baiyp.ren/JAVA%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.html"/>
    <id>http://www.baiyp.ren/JAVA字节码指令.html</id>
    <published>2019-08-29T06:20:57.000Z</published>
    <updated>2019-08-29T07:21:09.418Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA字节码指令"><a href="#JAVA字节码指令" class="headerlink" title="JAVA字节码指令"></a>JAVA字节码指令</h2><p>​ Java程序是运行在Java虚拟机上的，而这里的“虚拟”是对什么东西进行虚拟呢？答案当然就是对“实体”机进行虚拟啦，虚拟机可以看做是对实体机进行了进一步的封装和抽象，隐藏了不同实体机之间的差别，从而达成“Write Once,Run AnyWhere”的目标。既然虚拟机是对实体机的虚拟，所以我认为虚拟机和实体机在结构和功能上必然存在某种程度上的对应与关联。因此我们在学习时应该注意发掘和类比两者之间的关系。<br>​ 本着这样的思想，我们进行Java字节码指令的学习。JAVA字节码在JAVA虚拟机中的地位相当于实体机的机器码，一切在Java虚拟机上运行的程序都要被解释或编译成字节码，一切在实体机上运行的程序最后也都要编译成机器码。Java字节码指令可以对字节码进行操作，在实体机中对机器码进行操作的是汇编语言。所以Java字节码指令对应汇编语言，Java字节码指令集对应汇编指令集。</p><h3 id="字节码简介"><a href="#字节码简介" class="headerlink" title="字节码简介"></a>字节码简介</h3><blockquote><p>Java汇编指令就是Java虚拟机能够听得懂、可执行的指令，也可以说是Java代码的最小执行单元。</p></blockquote><p>​ Java字节码指令由<em>一个</em>字节长度的，代表某种特定操作含义的数字（操作码）以及其后的零至多个代表此操作所需参数（操作数）。此外字节码指令是面向操作数栈的，这里操作数栈在功能上对应实体机的寄存器但是结构上有所区别。</p><h3 id="java字节码指令集"><a href="#java字节码指令集" class="headerlink" title="java字节码指令集"></a>java字节码指令集</h3><h4 id="常用指令集"><a href="#常用指令集" class="headerlink" title="常用指令集"></a>常用指令集</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x01</td><td>aconst_null</td><td></td><td>null值入栈。</td></tr><tr><td>0x02</td><td>iconst_m1</td><td></td><td>-1(int)值入栈。</td></tr><tr><td>0x03</td><td>iconst_0</td><td></td><td>0(int)值入栈。</td></tr><tr><td>0x04</td><td>iconst_1</td><td></td><td>1(int)值入栈。</td></tr><tr><td>0x05</td><td>iconst_2</td><td></td><td>2(int)值入栈。</td></tr><tr><td>0x06</td><td>iconst_3</td><td></td><td>3(int)值入栈。</td></tr><tr><td>0x07</td><td>iconst_4</td><td></td><td>4(int)值入栈。</td></tr><tr><td>0x08</td><td>iconst_5</td><td></td><td>5(int)值入栈。</td></tr><tr><td>0x09</td><td>lconst_0</td><td></td><td>0(long)值入栈。</td></tr><tr><td>0x0a</td><td>lconst_1</td><td></td><td>1(long)值入栈。</td></tr><tr><td>0x0b</td><td>fconst_0</td><td></td><td>0(float)值入栈。</td></tr><tr><td>0x0c</td><td>fconst_1</td><td></td><td>1(float)值入栈。</td></tr><tr><td>0x0d</td><td>fconst_2</td><td></td><td>2(float)值入栈。</td></tr><tr><td>0x0e</td><td>dconst_0</td><td></td><td>0(double)值入栈。</td></tr><tr><td>0x0f</td><td>dconst_1</td><td></td><td>1(double)值入栈。</td></tr><tr><td>0x10</td><td>bipush</td><td>valuebyte</td><td>valuebyte值带符号扩展成int值入栈。</td></tr><tr><td>0x11</td><td>sipush</td><td>valuebyte1，valuebyte2</td><td>(valuebyte1 &lt;&lt; 8) | valuebyte2 值带符号扩展成int值入栈。</td></tr><tr><td>0x12</td><td>ldc</td><td>indexbyte1</td><td>常量池中的常量值（int, float, string reference, object reference）入栈。</td></tr><tr><td>0x13</td><td>ldc_w</td><td>indexbyte1，indexbyte2</td><td>常量池中常量（int, float, string reference, object reference）入栈。</td></tr><tr><td>0x14</td><td>ldc2_w</td><td>indexbyte1，indexbyte2</td><td>常量池+A1:D24中常量（long, double）入栈。</td></tr></tbody></table><h4 id="局部变量值转载到栈中指令"><a href="#局部变量值转载到栈中指令" class="headerlink" title="局部变量值转载到栈中指令"></a>局部变量值转载到栈中指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x19</td><td>(wide)aload</td><td>indexbyte</td><td>从局部变量indexbyte中装载引用类型值入栈。</td></tr><tr><td>0x2a</td><td>aload_0</td><td></td><td>从局部变量0中装载引用类型值入栈。</td></tr><tr><td>0x2b</td><td>aload_1</td><td></td><td>从局部变量1中装载引用类型值入栈。</td></tr><tr><td>0x2c</td><td>aload_2</td><td></td><td>从局部变量2中装载引用类型值入栈。</td></tr><tr><td>0x2d</td><td>aload_3</td><td></td><td>从局部变量3中装载引用类型值入栈。</td></tr><tr><td>0x15</td><td>(wide)iload</td><td>indexbyte</td><td>从局部变量indexbyte中装载int类型值入栈。</td></tr><tr><td>0x1a</td><td>iload_0</td><td></td><td>从局部变量0中装载int类型值入栈。</td></tr><tr><td>0x1b</td><td>iload_1</td><td></td><td>从局部变量1中装载int类型值入栈。</td></tr><tr><td>0x1c</td><td>iload_2</td><td></td><td>从局部变量2中装载int类型值入栈。</td></tr><tr><td>0x1d</td><td>iload_3</td><td></td><td>从局部变量3中装载int类型值入栈。</td></tr><tr><td>0x16</td><td>(wide)lload</td><td>indexbyte</td><td>从局部变量indexbyte中装载long类型值入栈。</td></tr><tr><td>0x1e</td><td>lload_0</td><td></td><td>从局部变量0中装载int类型值入栈。</td></tr><tr><td>0x1f</td><td>lload_1</td><td></td><td>从局部变量1中装载int类型值入栈。</td></tr><tr><td>0x20</td><td>lload_2</td><td></td><td>从局部变量2中装载int类型值入栈。</td></tr><tr><td>0x21</td><td>lload_3</td><td></td><td>从局部变量3中装载int类型值入栈。</td></tr><tr><td>0x17</td><td>(wide)fload</td><td>indexbyte</td><td>从局部变量indexbyte中装载float类型值入栈。</td></tr><tr><td>0x22</td><td>fload_0</td><td></td><td>从局部变量0中装载float类型值入栈。</td></tr><tr><td>0x23</td><td>fload_1</td><td></td><td>从局部变量1中装载float类型值入栈。</td></tr><tr><td>0x24</td><td>fload_2</td><td></td><td>从局部变量2中装载float类型值入栈。</td></tr><tr><td>0x25</td><td>fload_3</td><td></td><td>从局部变量3中装载float类型值入栈。</td></tr><tr><td>0x18</td><td>(wide)dload</td><td>indexbyte</td><td>从局部变量indexbyte中装载double类型值入栈。</td></tr><tr><td>0x26</td><td>dload_0</td><td></td><td>从局部变量0中装载double类型值入栈。</td></tr><tr><td>0x27</td><td>dload_1</td><td></td><td>从局部变量1中装载double类型值入栈。</td></tr><tr><td>0x28</td><td>dload_2</td><td></td><td>从局部变量2中装载double类型值入栈。</td></tr><tr><td>0x29</td><td>dload_3</td><td></td><td>从局部变量3中装载double类型值入栈。</td></tr><tr><td>0x32</td><td>aaload</td><td></td><td>从引用类型数组中装载指定项的值。</td></tr><tr><td>0x2e</td><td>iaload</td><td></td><td>从int类型数组中装载指定项的值。</td></tr><tr><td>0x2f</td><td>laload</td><td></td><td>从long类型数组中装载指定项的值。</td></tr><tr><td>0x30</td><td>faload</td><td></td><td>从float类型数组中装载指定项的值。</td></tr><tr><td>0x31</td><td>daload</td><td></td><td>从double类型数组中装载指定项的值。</td></tr><tr><td>0x33</td><td>baload</td><td></td><td>从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td>0x34</td><td>caload</td><td></td><td>从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td>0x35</td><td>saload</td><td></td><td>从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr></tbody></table><h4 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xc4</td><td>wide</td><td></td><td>使用附加字节扩展局部变量索引（iinc指令特殊）。</td></tr></tbody></table><h4 id="将栈顶值保存到局部变量中指令"><a href="#将栈顶值保存到局部变量中指令" class="headerlink" title="将栈顶值保存到局部变量中指令"></a>将栈顶值保存到局部变量中指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x3a</td><td>(wide)astore</td><td>indexbyte</td><td>将栈顶引用类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x4b</td><td>astroe_0</td><td></td><td>将栈顶引用类型值保存到局部变量0中。</td></tr><tr><td>0x4c</td><td>astore_1</td><td></td><td>将栈顶引用类型值保存到局部变量1中。</td></tr><tr><td>0x4d</td><td>astore_2</td><td></td><td>将栈顶引用类型值保存到局部变量2中。</td></tr><tr><td>0x4e</td><td>astore_3</td><td></td><td>将栈顶引用类型值保存到局部变量3中。</td></tr><tr><td>0x36</td><td>(wide)istore</td><td>indexbyte</td><td>将栈顶int类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x3b</td><td>istore_0</td><td></td><td>将栈顶int类型值保存到局部变量0中。</td></tr><tr><td>0x3c</td><td>istore_1</td><td></td><td>将栈顶int类型值保存到局部变量1中。</td></tr><tr><td>0x3d</td><td>istore_2</td><td></td><td>将栈顶int类型值保存到局部变量2中。</td></tr><tr><td>0x3e</td><td>istore_3</td><td></td><td>将栈顶int类型值保存到局部变量3中。</td></tr><tr><td>0x37</td><td>(wide)lstore</td><td>indexbyte</td><td>将栈顶long类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x3f</td><td>lstore_0</td><td></td><td>将栈顶long类型值保存到局部变量0中。</td></tr><tr><td>0x40</td><td>lstore_1</td><td></td><td>将栈顶long类型值保存到局部变量1中。</td></tr><tr><td>0x41</td><td>lstore_2</td><td></td><td>将栈顶long类型值保存到局部变量2中。</td></tr><tr><td>0x42</td><td>lstroe_3</td><td></td><td>将栈顶long类型值保存到局部变量3中。</td></tr><tr><td>0x38</td><td>(wide)fstore</td><td>indexbyte</td><td>将栈顶float类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x43</td><td>fstore_0</td><td></td><td>将栈顶float类型值保存到局部变量0中。</td></tr><tr><td>0x44</td><td>fstore_1</td><td></td><td>将栈顶float类型值保存到局部变量1中。</td></tr><tr><td>0x45</td><td>fstore_2</td><td></td><td>将栈顶float类型值保存到局部变量2中。</td></tr><tr><td>0x46</td><td>fstore_3</td><td></td><td>将栈顶float类型值保存到局部变量3中。</td></tr><tr><td>0x39</td><td>(wide)dstore</td><td>indexbyte</td><td>将栈顶double类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x47</td><td>dstore_0</td><td></td><td>将栈顶double类型值保存到局部变量0中。</td></tr><tr><td>0x48</td><td>dstore_1</td><td></td><td>将栈顶double类型值保存到局部变量1中。</td></tr><tr><td>0x49</td><td>dstore_2</td><td></td><td>将栈顶double类型值保存到局部变量2中。</td></tr><tr><td>0x4a</td><td>dstore_3</td><td></td><td>将栈顶double类型值保存到局部变量3中。</td></tr><tr><td>0x53</td><td>aastore</td><td></td><td>将栈顶引用类型值保存到指定引用类型数组的指定项。</td></tr><tr><td>0x4f</td><td>iastore</td><td></td><td>将栈顶int类型值保存到指定int类型数组的指定项。</td></tr><tr><td>0x50</td><td>lastore</td><td></td><td>将栈顶long类型值保存到指定long类型数组的指定项。</td></tr><tr><td>0x51</td><td>fastore</td><td></td><td>将栈顶float类型值保存到指定float类型数组的指定项。</td></tr><tr><td>0x52</td><td>dastore</td><td></td><td>将栈顶double类型值保存到指定double类型数组的指定项。</td></tr><tr><td>0x54</td><td>bastroe</td><td></td><td>将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。</td></tr><tr><td>0x55</td><td>castore</td><td></td><td>将栈顶char类型值保存到指定char类型数组的指定项。</td></tr><tr><td>0x56</td><td>sastore</td><td></td><td>将栈顶short类型值保存到指定short类型数组的指定项。</td></tr></tbody></table><h4 id="通用（无类型）栈操作指令"><a href="#通用（无类型）栈操作指令" class="headerlink" title="通用（无类型）栈操作指令"></a>通用（无类型）栈操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x00</td><td>nop</td><td></td><td>空操作。</td></tr><tr><td>0x57</td><td>pop</td><td></td><td>从栈顶弹出一个字长的数据。</td></tr><tr><td>0x58</td><td>pop2</td><td></td><td>从栈顶弹出两个字长的数据。</td></tr><tr><td>0x59</td><td>dup</td><td></td><td>复制栈顶一个字长的数据，将复制后的数据压栈。</td></tr><tr><td>0x5a</td><td>dup_x1</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。</td></tr><tr><td>0x5b</td><td>dup_x2</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5c</td><td>dup2</td><td></td><td>复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。</td></tr><tr><td>0x5d</td><td>dup2_x1</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5e</td><td>dup2_x2</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。</td></tr><tr><td>0x5f</td><td>swap</td><td></td><td>交换栈顶两个字长的数据的位置。Java指令中没有提供以两个字长为单位的交换指令。</td></tr></tbody></table><h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x86</td><td>i2f</td><td></td><td>将栈顶int类型值转换为float类型值。</td></tr><tr><td>0x85</td><td>i2l</td><td></td><td>将栈顶int类型值转换为long类型值。</td></tr><tr><td>0x87</td><td>i2d</td><td></td><td>将栈顶int类型值转换为double类型值。</td></tr><tr><td>0x8b</td><td>f2i</td><td></td><td>将栈顶float类型值转换为int类型值。</td></tr><tr><td>0x8c</td><td>f2l</td><td></td><td>将栈顶float类型值转换为long类型值。</td></tr><tr><td>0x8d</td><td>f2d</td><td></td><td>将栈顶float类型值转换为double类型值。</td></tr><tr><td>0x88</td><td>l2i</td><td></td><td>将栈顶long类型值转换为int类型值。</td></tr><tr><td>0x89</td><td>l2f</td><td></td><td>将栈顶long类型值转换为float类型值。</td></tr><tr><td>0x8a</td><td>l2d</td><td></td><td>将栈顶long类型值转换double类型值。</td></tr><tr><td>0x8e</td><td>d2i</td><td></td><td>将栈顶double类型值转换为int类型值。</td></tr><tr><td>0x90</td><td>d2f</td><td></td><td>将栈顶double类型值转换为float类型值。</td></tr><tr><td>0x8f</td><td>d2l</td><td></td><td>将栈顶double类型值转换为long类型值。</td></tr><tr><td>0x91</td><td>i2b</td><td></td><td>将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x92</td><td>i2c</td><td></td><td>将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x93</td><td>i2s</td><td></td><td>将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。</td></tr></tbody></table><h4 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x60</td><td>iadd</td><td></td><td>将栈顶两int类型数相加，结果入栈。</td></tr><tr><td>0x64</td><td>isub</td><td></td><td>将栈顶两int类型数相减，结果入栈。</td></tr><tr><td>0x68</td><td>imul</td><td></td><td>将栈顶两int类型数相乘，结果入栈。</td></tr><tr><td>0x6c</td><td>idiv</td><td></td><td>将栈顶两int类型数相除，结果入栈。</td></tr><tr><td>0x70</td><td>irem</td><td></td><td>将栈顶两int类型数取模，结果入栈。</td></tr><tr><td>0x74</td><td>ineg</td><td></td><td>将栈顶int类型值取负，结果入栈。</td></tr><tr><td>0x61</td><td>ladd</td><td></td><td>将栈顶两long类型数相加，结果入栈。</td></tr><tr><td>0x65</td><td>lsub</td><td></td><td>将栈顶两long类型数相减，结果入栈。</td></tr><tr><td>0x69</td><td>lmul</td><td></td><td>将栈顶两long类型数相乘，结果入栈。</td></tr><tr><td>0x6d</td><td>ldiv</td><td></td><td>将栈顶两long类型数相除，结果入栈。</td></tr><tr><td>0x71</td><td>lrem</td><td></td><td>将栈顶两long类型数取模，结果入栈。</td></tr><tr><td>0x75</td><td>lneg</td><td></td><td>将栈顶long类型值取负，结果入栈。</td></tr><tr><td>0x84</td><td>(wide)iinc</td><td>indexbyte，constbyte</td><td>将整数值constbyte加到indexbyte指定的int类型的局部变量中。</td></tr></tbody></table><h4 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x62</td><td>fadd</td><td></td><td>将栈顶两float类型数相加，结果入栈。</td></tr><tr><td>0x66</td><td>fsub</td><td></td><td>将栈顶两float类型数相减，结果入栈。</td></tr><tr><td>0x6a</td><td>fmul</td><td></td><td>将栈顶两float类型数相乘，结果入栈。</td></tr><tr><td>0x6e</td><td>fdiv</td><td></td><td>将栈顶两float类型数相除，结果入栈。</td></tr><tr><td>0x72</td><td>frem</td><td></td><td>将栈顶两float类型数取模，结果入栈。</td></tr><tr><td>0x76</td><td>fneg</td><td></td><td>将栈顶float类型值取反，结果入栈。</td></tr><tr><td>0x63</td><td>dadd</td><td></td><td>将栈顶两double类型数相加，结果入栈。</td></tr><tr><td>0x67</td><td>dsub</td><td></td><td>将栈顶两double类型数相减，结果入栈。</td></tr><tr><td>0x6b</td><td>dmul</td><td></td><td>将栈顶两double类型数相乘，结果入栈。</td></tr><tr><td>0x6f</td><td>ddiv</td><td></td><td>将栈顶两double类型数相除，结果入栈。</td></tr><tr><td>0x73</td><td>drem</td><td></td><td>将栈顶两double类型数取模，结果入栈。</td></tr><tr><td>0x77</td><td>dneg</td><td></td><td>将栈顶double类型值取负，结果入栈。</td></tr></tbody></table><h4 id="逻辑运算——移位运算"><a href="#逻辑运算——移位运算" class="headerlink" title="逻辑运算——移位运算"></a>逻辑运算——移位运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x78</td><td>ishl</td><td></td><td>左移int类型值。</td></tr><tr><td>0x79</td><td>lshl</td><td></td><td>左移long类型值。</td></tr><tr><td>0x7a</td><td>ishr</td><td></td><td>算术右移int类型值。</td></tr><tr><td>0x7b</td><td>lshr</td><td></td><td>算术右移long类型值。</td></tr><tr><td>0x7c</td><td>iushr</td><td></td><td>逻辑右移int类型值。</td></tr><tr><td>0x7d</td><td>lushr</td><td></td><td>逻辑右移long类型值。</td></tr></tbody></table><h4 id="逻辑运算——按位布尔运算"><a href="#逻辑运算——按位布尔运算" class="headerlink" title="逻辑运算——按位布尔运算"></a>逻辑运算——按位布尔运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x73</td><td>iand</td><td></td><td>对int类型按位与运算。</td></tr><tr><td>0x7f</td><td>land</td><td></td><td>对long类型的按位与运算。</td></tr><tr><td>0x80</td><td>ior</td><td></td><td>对int类型的按位或运算。</td></tr><tr><td>0x81</td><td>lor</td><td></td><td>对long类型的按位或运算。</td></tr><tr><td>0x82</td><td>ixor</td><td></td><td>对int类型的按位异或运算。</td></tr><tr><td>0x83</td><td>lxor</td><td></td><td>对long类型的按位异或运算。</td></tr></tbody></table><h4 id="控制流指令——条件跳转指令"><a href="#控制流指令——条件跳转指令" class="headerlink" title="控制流指令——条件跳转指令"></a>控制流指令——条件跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x99</td><td>ifeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值为0则跳转。</td></tr><tr><td>0x9a</td><td>ifne</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值不为0则跳转。</td></tr><tr><td>0x9b</td><td>iflt</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值小于0则跳转。</td></tr><tr><td>0x9e</td><td>ifle</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值小于等于0则跳转。</td></tr><tr><td>0x9d</td><td>ifgt</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值大于0则跳转。</td></tr><tr><td>0x9c</td><td>ifge</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值大于等于0则跳转。</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值相等则跳转。</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值不相等则跳转。</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前小于后则跳转。</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前小于等于后则跳转。</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前大于后则跳转。</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前大于等于后则跳转。</td></tr><tr><td>0xc6</td><td>ifnull</td><td>branchbyte1，branchbyte2</td><td>若栈顶引用值为null则跳转。</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>branchbyte1，branchbyte2</td><td>若栈顶引用值不为null则跳转。</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶两引用类型值相等则跳转。</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>branchbyte1，branchbyte2</td><td>若栈顶两引用类型值不相等则跳转。</td></tr></tbody></table><h4 id="控制流指令——比较指令"><a href="#控制流指令——比较指令" class="headerlink" title="控制流指令——比较指令"></a>控制流指令——比较指令</h4><table><thead><tr><th>0x94</th><th>lcmp</th><th></th><th>比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。</th></tr></thead><tbody><tr><td>0x95</td><td>fcmpl</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x96</td><td>fcmpg</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x97</td><td>dcmpl</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x98</td><td>dcmpg</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr></tbody></table><h4 id="控制流指令——无条件跳转指令"><a href="#控制流指令——无条件跳转指令" class="headerlink" title="控制流指令——无条件跳转指令"></a>控制流指令——无条件跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xa7</td><td>goto</td><td>branchbyte1，branchbyte2</td><td>无条件跳转到指定位置。</td></tr><tr><td>0xc8</td><td>goto_w</td><td>branchbyte1，branchbyte2，branchbyte3，branchbyte4</td><td>无条件跳转到指定位置（宽索引）。</td></tr></tbody></table><h4 id="控制流指令——表跳转指令"><a href="#控制流指令——表跳转指令" class="headerlink" title="控制流指令——表跳转指令"></a>控制流指令——表跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xaa</td><td>tableswitch</td><td>&lt;0-3bytepad&gt;,<br>defaultbyte1,<br>defaultbyte2,<br>defaultbyte3,<br>defaultbyte4,<br>lowbyte1,<br>lowbyte2,<br>lowbyte3,<br>lowbyte4,<br>highbyte1,<br>highbyte2,<br>highbyte3,<br>highbyte4,<br>jump offsets…</td><td>通过索引访问跳转表，并跳转。</td></tr><tr><td>0xab</td><td>lookupswitch</td><td>&lt;0-3bytepad&gt;,<br>defaultbyte1,<br>defaultbyte2,<br>defaultbyte3,<br>defaultbyte4,<br>npairs1,<br>npairs2,<br>npairs3,<br>npairs4,<br>match offsets</td><td>通过键值访问跳转表，并跳转。</td></tr></tbody></table><h4 id="控制流指令——异常和finally"><a href="#控制流指令——异常和finally" class="headerlink" title="控制流指令——异常和finally"></a>控制流指令——异常和finally</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbf</td><td>athrow</td><td></td><td>抛出异常。</td></tr><tr><td>0xa8</td><td>jsr</td><td>branchbyte1,<br>branchbyte2</td><td>跳转到子例程序。</td></tr><tr><td>0xc9</td><td>jsr_w</td><td>branchbyte1,<br>branchbyte2,<br>branchbyte3,<br>branchbyte4</td><td>跳转到子例程序（宽索引）。</td></tr><tr><td>0xa9</td><td>(wide)ret</td><td>indexbyte</td><td>返回子例程序。</td></tr></tbody></table><h4 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbb</td><td>new</td><td>indexbyte1,indexbyte2</td><td>创建新的对象实例。</td></tr><tr><td>0xc0</td><td>checkcast</td><td>indexbyte1,indexbyte2</td><td>类型强转。</td></tr><tr><td>0xc1</td><td>instanceof</td><td>indexbyte1,indexbyte2</td><td>判断类型。</td></tr><tr><td>0xb4</td><td>getfield</td><td>indexbyte1,indexbyte2</td><td>获取对象字段的值。</td></tr><tr><td>0xb5</td><td>putfield</td><td>indexbyte1,indexbyte2</td><td>给对象字段赋值。</td></tr><tr><td>0xb2</td><td>getstatic</td><td>indexbyte1,indexbyte2</td><td>获取静态字段的值。</td></tr><tr><td>0xb3</td><td>putstatic</td><td>indexbyte1,indexbyte2</td><td>给静态字段赋值。</td></tr></tbody></table><h4 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbc</td><td>newarray</td><td>atype</td><td>创建type类型的数组。</td></tr><tr><td>0xbd</td><td>anewarray</td><td>indexbyte1,indexbyte2</td><td>创建引用类型的数组。</td></tr><tr><td>0xbe</td><td>arraylength</td><td></td><td>获取一维数组的长度。</td></tr><tr><td>0xc5</td><td>multianewarray</td><td>indexbyte1,indexbyte2,dimension</td><td>创建dimension维度的数组。</td></tr></tbody></table><h4 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xb7</td><td>invokespecial</td><td>indexbyte1,indexbyte2</td><td>编译时方法绑定调用方法。</td></tr><tr><td>0xb6</td><td>invokevirtual</td><td>indexbyte1,indexbyte2</td><td>运行时方法绑定调用方法。</td></tr><tr><td>0xb8</td><td>invokestatic</td><td>indexbyte1,indexbyte2</td><td>调用静态方法。</td></tr><tr><td>0xb9</td><td>invokeinterface</td><td>indexbyte1,indexbyte2,count,0</td><td>调用接口方法。</td></tr></tbody></table><h4 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xac</td><td>ireturn</td><td></td><td>返回int类型值。</td></tr><tr><td>0xad</td><td>lreturn</td><td></td><td>返回long类型值。</td></tr><tr><td>0xae</td><td>freturn</td><td></td><td>返回float类型值。</td></tr><tr><td>0xaf</td><td>dreturn</td><td></td><td>返回double类型值。</td></tr><tr><td>0xb0</td><td>areturn</td><td></td><td>返回引用类型值。</td></tr><tr><td>0xb1</td><td>return</td><td></td><td>void函数返回。</td></tr></tbody></table><h4 id="线程同步指令"><a href="#线程同步指令" class="headerlink" title="线程同步指令"></a>线程同步指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xc2</td><td>monitorenter</td><td></td><td>进入并获得对象监视器。</td></tr><tr><td>0xc3</td><td>monitorexit</td><td></td><td>释放并退出对象监视器。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      AVA字节码指令
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="指令" scheme="http://www.baiyp.ren/categories/jvm/%E6%8C%87%E4%BB%A4/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="指令" scheme="http://www.baiyp.ren/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式的六大原则</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式的六大原则.html</id>
    <published>2019-08-29T01:42:30.000Z</published>
    <updated>2019-08-30T03:18:19.015Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式的六大原则"><a href="#JAVA设计模式的六大原则" class="headerlink" title="JAVA设计模式的六大原则"></a>JAVA设计模式的六大原则</h2><p><img src="../images/design-patterns/designpatterns01.png" alt></p><h3 id="开闭原则（Open-Close-Principle）"><a href="#开闭原则（Open-Close-Principle）" class="headerlink" title="开闭原则（Open Close Principle）"></a>开闭原则（Open Close Principle）</h3><blockquote><p><strong>开闭原则，对于扩展是开放的，对于修改是关闭。</strong></p></blockquote><p><img src="../images/design-patterns/designpatterns02.png" alt></p><p>​ 当应用的需求改变时，在不修改软件实体的源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p><p>​ 可以通过“<strong>抽象约束、封装变化</strong>”来实现开闭原则，即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，而将相同的可变因素封装在相同的具体实现类中。</p><p>​ 开闭原则无非就是想表达这样一层意思：<strong>用抽象构建框架，用实现扩展细节</strong>。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。</p><p>开闭原则的好处是：</p><ul><li>由于对于软件原来的模块不需要修改，因此不担心软件的稳定性。</li><li>对软件进行扩展，加入新的功能，这样，这个软件就可以通过不断地增加新模块满足不断变化的新需求。</li></ul><h4 id="和其他原则的关系"><a href="#和其他原则的关系" class="headerlink" title="和其他原则的关系"></a>和其他原则的关系</h4><blockquote><p>开闭原则具有理想主义的色彩，它是面向对象设计的终极目标</p></blockquote><p>​ 因此，针对开闭原则的实现方法，一直都有面向对象设计的大师费尽心机，研究开闭原则的实现方式。后面要提到的里氏替换原则（LSP）、依赖倒转原则（DIP）、接口隔离原则（ISP）以及抽象类（Abstract Class）、接口(Interface)等等，都可以看作是开闭原则的实现方法。</p><h3 id="单一职责原则（Single-Responsibility-Principle）"><a href="#单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="单一职责原则（Single Responsibility Principle）"></a>单一职责原则（Single Responsibility Principle）</h3><blockquote><p>就一个类而言，应该仅有一个引起它变化的原因（一个类只负责一项职责）</p></blockquote><p><img src="../images/design-patterns/designpatterns07.png" alt></p><p>为什么要使用单一职责原则：</p><p>​ 如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计。</p><p>优点：</p><ul><li>可以降低类的复杂度，一个类只负责一项职责，其逻辑肯定要比负责多项职责简单的多；</li><li>提高类的可读性，提高系统的可维护性；</li><li>变更引起的风险降低，变更是必然的，如果单一职责原则遵守的好，当修改一个功能时，可以显著降低对其他功能的影响。</li></ul><h3 id="里氏代换原则（Liskov-Substitution-Principle）"><a href="#里氏代换原则（Liskov-Substitution-Principle）" class="headerlink" title="里氏代换原则（Liskov Substitution Principle）"></a>里氏代换原则（Liskov Substitution Principle）</h3><blockquote><ul><li><p>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</p></li><li><p>子类中可以增加自己特有的方法。</p></li><li><p>当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松。</p></li><li><p>当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格。</p></li></ul></blockquote><p><img src="../images/design-patterns/designpatterns06.png" alt></p><p>​ 里氏代换原则是对“<strong>开闭</strong>”原则的补充。实现“开闭”原则的关键步骤就是抽象化。而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p>​ 简单的理解为一个软件实体如果使用的是一个父类，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，软件里面，把父类都替换成它的子类，程序的行为没有变化。</p><p>但是反过来的代换却不成立，一个软件实体如果使用的是一个子类的话，那么它不能适用于其父类。</p><p>例如：</p><p>​ 在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅却不能继承鸟。在面向对象设计时，子类拥有父类所有非private的行为和属性，鸟会飞，但企鹅不会飞，所以企鹅不能继承鸟类。</p><p><strong>里氏替换原则通俗的来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。</strong></p><h3 id="依赖倒转原则（Dependence-Inversion-Principle）"><a href="#依赖倒转原则（Dependence-Inversion-Principle）" class="headerlink" title="依赖倒转原则（Dependence Inversion Principle）"></a>依赖倒转原则（Dependence Inversion Principle）</h3><blockquote><ul><li>高层模块不应该依赖低层模块，两者都应该依赖其抽象</li><li>抽象不应该依赖细节</li><li>细节应该依赖抽象</li></ul></blockquote><p><img src="../images/design-patterns/designpatterns05.jpg" alt></p><p><strong>也可以说高层模块，低层模块，细节都应该依赖抽象</strong></p><p>​ 依赖倒转其实就是谁也不要依靠谁，除了约定的接口，大家都可以灵活自如。依赖倒转可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。如果设计的各个部件或类相互依赖，这样就是耦合度高，难以维护和扩展，这也就体现不出面向对象的好处了。</p><p>​ 赖倒置原则基于这样一个事实：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建起来的架构比以细节为基础搭建起来的架构要稳定的多。在java中，抽象指的是接口或者抽象类，细节就是具体的实现类，使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给他们的实现类去完成。</p><p>​ <strong>依赖倒置原则的中心思想是面向接口编程</strong>，传递依赖关系有三种方式，以上的说的是是接口传递，另外还有两种传递方式：构造方法传递和setter方法传递，相信用过Spring框架的，对依赖的传递方式一定不会陌生。</p><p><strong>DIP的好处：</strong> 采用依赖倒置原则可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性。</p><p>在实际编程中，我们一般需要做到如下3点：</p><ul><li><p><strong>低层模块尽量都要有抽象类或接口，或者两者都有。</strong></p></li><li><p><strong>变量的声明类型尽量是抽象类或接口。</strong></p></li><li><p><strong>使用继承时遵循里氏替换原则。</strong></p></li></ul><h3 id="接口隔离原则（Interface-Segregation-Principle）"><a href="#接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="接口隔离原则（Interface Segregation Principle）"></a>接口隔离原则（Interface Segregation Principle）</h3><blockquote><ul><li>客户端不应该依赖它不需要的接口</li><li>类间的依赖关系应该建立在最小的接口上</li></ul></blockquote><p><img src="../images/design-patterns/designpatterns04.jpg" alt></p><p>​ 接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</p><p>​ 说到这里，很多人会觉的接口隔离原则跟单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。</p><p>采用接口隔离原则对接口进行约束时，要注意以下几点：</p><ol><li><p>接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。</p></li><li><p>为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。</p></li><li><p>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</p><p>运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。</p></li></ol><p><strong>好处:</strong></p><p>​ 现在我们知道，接口隔离原则的要点，就是要细化我们的接口。那么这样做具体有什么好处呢？主要有四个好处，分别是：</p><ol><li>避免接口污染；</li><li>提高灵活性；</li><li>提供定制服务；</li><li>实现高内聚。</li></ol><h3 id="迪米特法则（Law-Of-Demeter）"><a href="#迪米特法则（Law-Of-Demeter）" class="headerlink" title="迪米特法则（Law Of Demeter）"></a>迪米特法则（Law Of Demeter）</h3><blockquote><p>一个对象应该对其他对象保持最少的了解</p></blockquote><p><img src="../images/design-patterns/designpatterns03.jpg" alt></p><p>​ <strong>迪米特法则的意义在于降低类之间的耦合</strong>。由于每个对象尽量减少对其他对象的了解，因此，很容易使得系统的功能模块功能独立，相互之间不存在（或很少有）依赖关系。</p><p>​ 迪米特法则其根本思想，是强调了类之间的松耦合，类之间的耦合越弱,越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成影响，也就是说，信息的隐藏促进了软件的复用。</p><p>​ 自从我们接触编程开始，就知道了软件编程的总的原则：低耦合，高内聚。无论是面向过程编程还是面向对象编程，只有使各个模块之间的耦合尽量的低，才能提高代码的复用率。低耦合的优点不言而喻，但是怎么样编程才能做到低耦合呢？那正是迪米特法则要去完成的。</p><p>模式中的<strong>外观模式</strong>和<strong>中介模式</strong>就是迪米特法则的实现</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式的六大原则
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="设计原则" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式06-模板模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F06.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式06.html</id>
    <published>2019-08-29T01:42:30.000Z</published>
    <updated>2019-09-05T10:28:05.539Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-模板模式（Template-Pattern）"><a href="#JAVA设计模式-模板模式（Template-Pattern）" class="headerlink" title="JAVA设计模式-模板模式（Template Pattern）"></a>JAVA设计模式-模板模式（Template Pattern）</h2><p><img src="../images/design-patterns/templatepattern01.jpg" alt></p><h3 id="什么是模板模式"><a href="#什么是模板模式" class="headerlink" title="什么是模板模式"></a>什么是模板模式</h3><p>​ 定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><p>​ 使用了JAVA的继承机制，在抽象类中定义一个模板方法，该方法引用了若干个抽象方法（由子类实现）或具体方法（子类可以覆盖重写）；</p><p>​ 其实就是JAVA的继承以及抽象方法、重写覆盖的使用；</p><p>​ <strong>注意</strong>：为防止恶意操作，一般模板方法都加上 final 关键词</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><p>AbstractClass（抽象模板）：定义了一个模板方法和若干抽象方法和具体方法，</p></li><li><p>ConcreteClass（具体模板）：继承抽象模板类并实现抽象方法</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>封装不变部分，扩展可变部分。</li><li>提取公共代码，便于维护。</li><li>行为由父类控制，子类实现。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>多个子类有公有的方法,而且逻辑基本相同时.</p></li><li><p>重要,复杂的算法,可以把核心算法设计为模板方法,周边的相关细节功能由各个子类实现.</p></li><li><p>重构时,模板方法模式是一个经常使用的模式,把相同的代码抽取到父类中,庵后通过函数约束其行为。</p></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>我们将创建一个定义操作的 <em>Game</em> 抽象类，其中，模板方法设置为 final，这样它就不会被重写。<em>Cricket</em> 和 <em>Football</em> 是扩展了 <em>Game</em> 的实体类，它们重写了抽象类的方法。</p><p><em>TemplatePatternDemo*，我们的演示类使用 *Game</em> 来演示模板模式的用法。</p></blockquote><h4 id="创建一个抽象类"><a href="#创建一个抽象类" class="headerlink" title="创建一个抽象类"></a>创建一个抽象类</h4><blockquote><p>它的模板方法被设置为 final。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span></span>;</span><br><span class="line">   <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">   <span class="comment">//模板</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>&#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//初始化游戏</span></span><br><span class="line">      initialize();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//开始游戏</span></span><br><span class="line">      startPlay();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//结束游戏</span></span><br><span class="line">      endPlay();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建扩展的子类"><a href="#创建扩展的子类" class="headerlink" title="创建扩展的子类"></a>创建扩展的子类</h4><h5 id="Cricket-类"><a href="#Cricket-类" class="headerlink" title="Cricket 类"></a>Cricket 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cricket</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Initialized! Start playing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Cricket Game Started. Enjoy the game!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Football-类"><a href="#Football-类" class="headerlink" title="Football 类"></a>Football 类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Football</span> <span class="keyword">extends</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">endPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Finished!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Initialized! Start playing."</span>);</span><br><span class="line">   &#125;</span><br><span class="line"> </span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">startPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      System.out.println(<span class="string">"Football Game Started. Enjoy the game!"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TemplatePatternDemo</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">      Game game = <span class="keyword">new</span> Cricket();</span><br><span class="line">      game.play();</span><br><span class="line">      System.out.println();</span><br><span class="line">      game = <span class="keyword">new</span> Football();</span><br><span class="line">      game.play();      </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之模板模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="模板模式" scheme="http://www.baiyp.ren/tags/%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>伪共享与缓存行</title>
    <link href="http://www.baiyp.ren/%E4%BC%AA%E5%85%B1%E4%BA%AB%E4%B8%8E%E7%BC%93%E5%AD%98%E8%A1%8C.html"/>
    <id>http://www.baiyp.ren/伪共享与缓存行.html</id>
    <published>2019-08-28T07:33:17.000Z</published>
    <updated>2019-09-05T09:19:26.528Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="伪共享与缓存行"><a href="#伪共享与缓存行" class="headerlink" title="伪共享与缓存行"></a>伪共享与缓存行</h2><h3 id="CPU缓存架构"><a href="#CPU缓存架构" class="headerlink" title="CPU缓存架构"></a>CPU缓存架构</h3><p>CPU 是计算机的心脏，所有运算和程序最终都要由它来执行。</p><p>主内存（RAM）是数据存放的地方，CPU 和主内存之间有好几级缓存，因为即使直接访问主内存也是非常慢的。</p><p>CPU的速度要远远大于内存的速度，为了解决这个问题，CPU引入了三级缓存：L1，L2和L3三个级别，L1最靠近CPU，L2次之，L3离CPU最远，L3之后才是主存。速度是L1&gt;L2&gt;L3&gt;主存。越靠近CPU的容量越小。CPU获取数据会依次从三级缓存中查找。</p><p><img src="../images/cpu01.jpg" alt></p><p>当CPU要读取一个数据时，首先从一级缓存中查找，如果没有找到再从二级缓存中查找，如果还是没有就从三级缓存或内存中查找。一般来说，每级缓存的命中率大概都在80%左右，也就是说全部数据量的80%都可以在一级缓存中找到，只剩下20%的总数据量才需要从二级缓存、三级缓存或内存中读取，由此可见一级缓存是整个CPU缓存架构中最为重要的部分。<br><img src="../images/cpu02.jpg" alt></p><p>下表是一些缓存未命中的消耗数据：</p><table><thead><tr><th>从CPU到</th><th>大约需要的CPU周期</th><th>大约需要的时间</th></tr></thead><tbody><tr><td>主存</td><td></td><td>约60-80ns</td></tr><tr><td>QPI总线</td><td></td><td>约20ns</td></tr><tr><td>L3 cache</td><td>约40-45cycles</td><td>约15ns</td></tr><tr><td>L2 cache</td><td>约10cycles</td><td>约3ns</td></tr><tr><td>L1 cache</td><td>约3-4cycles</td><td>约1ns</td></tr><tr><td>寄存器</td><td>1cycle</td><td></td></tr></tbody></table><h3 id="MESI协议"><a href="#MESI协议" class="headerlink" title="MESI协议"></a>MESI协议</h3><h4 id="缓存行状态"><a href="#缓存行状态" class="headerlink" title="缓存行状态"></a>缓存行状态</h4><p>CPU的缓存是以缓存行(cache line)为单位的，MESI协议描述了多核处理器中一个缓存行的状态。在MESI协议中，每个缓存行有4个状态，分别是：</p><ul><li>M（修改，Modified）：本地处理器已经修改缓存行，即是脏行，它的内容与内存中的内容不一样，并且此 cache 只有本地一个拷贝(专有)；</li><li>E（专有，Exclusive）：缓存行内容和内存中的一样，而且其它处理器都没有这行数据；</li><li>S（共享，Shared）：缓存行内容和内存中的一样, 有可能其它处理器也存在此缓存行的拷贝；</li><li>I（无效，Invalid）：缓存行失效, 不能使用。</li></ul><p>缓存行的E状态如下图：</p><p><img src="../images/cacheline01.png" alt></p><p>此时只有core1访问缓存行，它的缓存行的状态为E，表示core1独占。</p><p>缓存行的S状态如下图：</p><p><img src="../images/cacheline02.png" alt></p><p>此时core1和core2都会访问缓存行，他们的缓存行状态为S，表示缓存行处于共享状态。</p><p>缓存行的M和I状态如下图：</p><p><img src="../images/cacheline03.png" alt></p><p>此时core1修改了缓存行，因此core1的缓存行状态为M，代表已经修改，而core2的缓存行状态为I，代表已经失效，需要从主存中读取。</p><h3 id="缓存行状态转换"><a href="#缓存行状态转换" class="headerlink" title="缓存行状态转换"></a>缓存行状态转换</h3><p>​ 在MESI协议中，每个Cache的Cache控制器不仅知道自己的读写操作，而且也监听(snoop)其它Cache的读写操作。每个Cache line所处的状态根据本核和其它核的读写操作在4个状态间进行迁移。MESI协议状态迁移图如下：</p><p><img src="../images/cacheline04.png" alt></p><p>初始：一开始时，缓存行没有加载任何数据，所以它处于 I 状态。</p><p>本地写（Local Write）：如果本地处理器写数据至处于 I 状态的缓存行，则缓存行的状态变成 M。</p><p>本地读（Local Read）：如果本地处理器读取处于 I 状态的缓存行，很明显此缓存没有数据给它。此时分两种情况：(1)其它处理器的缓存里也没有此行数据，则从内存加载数据到此缓存行后，再将它设成 E 状态，表示只有我一家有这条数据，其它处理器都没有；(2)其它处理器的缓存有此行数据，则将此缓存行的状态设为 S 状态。（备注：如果处于M状态的缓存行，再由本地处理器写入/读出，状态是不会改变的）</p><p>远程读（Remote Read）：假设我们有两个处理器 c1 和 c2，如果 c2 需要读另外一个处理器 c1 的缓存行内容，c1 需要把它缓存行的内容通过内存控制器 (Memory Controller) 发送给 c2，c2 接到后将相应的缓存行状态设为 S。在设置之前，内存也得从总线上得到这份数据并保存。</p><p>远程写（Remote Write）：其实确切地说不是远程写，而是 c2 得到 c1 的数据后，不是为了读，而是为了写。也算是本地写，只是 c1 也拥有这份数据的拷贝，这该怎么办呢？c2 将发出一个 RFO (Request For Owner) 请求，它需要拥有这行数据的权限，其它处理器的相应缓存行设为 I，除了它自已，谁不能动这行数据。这保证了数据的安全，同时处理 RFO 请求以及设置I的过程将给写操作带来很大的性能消耗。</p><h3 id="缓存行"><a href="#缓存行" class="headerlink" title="缓存行"></a>缓存行</h3><p>​ CPU缓存是以缓存行（cache line）为单位存储的。缓存行通常是 64 字节，并且它有效地引用主内存中的一块地址。一个 Java 的 long 类型是 8 字节，因此在一个缓存行中可以存 8 个 long 类型的变量。所以，如果你访问一个 long 数组，当数组中的一个值被加载到缓存中，它会额外加载另外 7 个，以致你能非常快地遍历这个数组。事实上，你可以非常快速的遍历在连续的内存块中分配的任意数据结构。而如果你在数据结构中的项在内存中不是彼此相邻的（如链表），你将得不到免费缓存加载所带来的优势，并且在这些数据结构中的每一个项都可能会出现缓存未命中。下图是一个CPU缓存行的示意图：</p><p><img src="../images/cacheline07.png" alt></p><p>上图中，一个运行在处理器 core1上的线程想要更新变量 X 的值，同时另外一个运行在处理器 core2 上的线程想要更新变量 Y 的值。但是，这两个频繁改动的变量都处于同一条缓存行。两个线程就会轮番发送 RFO 消息，占得此缓存行的拥有权。当 core1 取得了拥有权开始更新 X，则 core2 对应的缓存行需要设为 I 状态。当 core2 取得了拥有权开始更新 Y，则 core1 对应的缓存行需要设为 I 状态(失效态)。轮番夺取拥有权不但带来大量的 RFO 消息，而且如果某个线程需要读此行数据时，L1 和 L2 缓存上都是失效数据，只有 L3 缓存上是同步好的数据。从前一篇我们知道，读 L3 的数据非常影响性能。更坏的情况是跨槽读取，L3 都要 miss，只能从内存上加载。</p><p>表面上 X 和 Y 都是被独立线程操作的，而且两操作之间也没有任何关系。只不过它们共享了一个缓存行，但所有竞争冲突都是来源于共享。</p><h3 id="什么是伪共享"><a href="#什么是伪共享" class="headerlink" title="什么是伪共享"></a>什么是伪共享</h3><p>​ 计算机系统中为了解决主内存与CPU运行速度的差距，在CPU与主内存之间添加了一级或者多级高速缓冲存储器（Cache），这个Cache一般是集成到CPU内部的，所以也叫 CPU Cache，如下图是两级cache结构：</p><p><img src="../images/cpu03.jpg" alt></p><p>Cache内部是按行存储的，其中每一行称为一个cache行，cache行是Cache与主内存进行数据交换的单位，cache行的大小一般为2的幂次数字节。</p><p><img src="../images/cacheline05.png" alt></p><p>​ 当CPU访问某一个变量时候，首先会去看CPU Cache内是否有该变量，如果有则直接从中获取，否者就去主内存里面获取该变量，然后把该变量所在内存区域的一个Cache行大小的内存拷贝到Cache（cache行是Cache与主内存进行数据交换的单位）。由于存放到Cache行的的是内存块而不是单个变量，所以可能会把多个变量存放到了一个cache行。当多个线程同时修改一个缓存行里面的多个变量时候，由于同时只能有一个线程操作缓存行，所以相比每个变量放到一个缓存行性能会有所下降，这就是伪共享。</p><p><img src="../images/cacheline06.png" alt></p><p>​ 如上图变量x,y同时被放到了CPU的一级和二级缓存，当线程1使用CPU1对变量x进行更新时候，首先会修改cpu1的一级缓存变量x所在缓存行，这时候缓存一致性协议会导致cpu2中变量x对应的缓存行失效，那么线程2写入变量x的时候就只能去二级缓存去查找，这就破坏了一级缓存，而一级缓存比二级缓存更快。更坏的情况下如果cpu只有一级缓存，那么会导致频繁的直接访问主内存。</p><h4 id="为何会出现伪共享"><a href="#为何会出现伪共享" class="headerlink" title="为何会出现伪共享"></a>为何会出现伪共享</h4><p>​ 伪共享的产生是因为多个变量被放入了一个缓存行，并且多个线程同时去写入缓存行中不同变量。那么为何多个变量会被放入一个缓存行那。其实是因为Cache与内存交换数据的单位就是Cache，当CPU要访问的变量没有在Cache命中时候，根据程序运行的局部性原理会把该变量在内存中大小为Cache行的内存放如缓存行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure><p>​ 如上代码，声明了四个long变量，假设cache行的大小为32个字节，那么当cpu访问变量a时候发现该变量没有在cache命中，那么就会去主内存把变量a以及内存地址附近的b,c,d放入缓存行。也就是地址连续的多个变量才有可能会被放到一个缓存行中，当创建数组时候，数组里面的多个元素就会被放入到同一个缓存行。那么单线程下多个变量放入缓存行对性能有影响？其实正常情况下单线程访问时候由于数组元素被放入到了一个或者多个cache行对代码执行是有利的，因为数据都在缓存中，代码执行会更快。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      伪共享与缓存行
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="伪共享" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="伪共享" scheme="http://www.baiyp.ren/tags/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的伪共享与缓存行</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E4%BC%AA%E5%85%B1%E4%BA%AB.html"/>
    <id>http://www.baiyp.ren/JAVA中的伪共享.html</id>
    <published>2019-08-28T07:33:17.000Z</published>
    <updated>2019-09-05T09:18:36.316Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的伪共享"><a href="#JAVA中的伪共享" class="headerlink" title="JAVA中的伪共享"></a>JAVA中的伪共享</h2><h3 id="Java中的伪共享"><a href="#Java中的伪共享" class="headerlink" title="Java中的伪共享"></a>Java中的伪共享</h3><p>​ 解决伪共享最直接的方法就是填充（padding），例如下面的VolatileLong，一个long占8个字节，Java的对象头占用8个字节（32位系统）或者12字节（64位系统，默认开启对象头压缩，不开启占16字节）。一个缓存行64字节，那么我们可以填充6个long（6 * 8 = 48 个字节）。</p><p>​ 现在，我们学习JVM对象的内存模型。所有的Java对象都有8字节的对象头，前四个字节用来保存对象的哈希码和锁的状态，前3个字节用来存储哈希码，最后一个字节用来存储锁状态，一旦对象上锁，这4个字节都会被拿出对象外，并用指针进行链接。剩下4个字节用来存储对象所属类的引用。对于数组来讲，还有一个保存数组大小的变量，为4字节。每一个对象的大小都会对齐到8字节的倍数，不够8字节部分需要填充。为了保证效率，Java编译器在编译Java对象的时候，通过字段类型对Java对象的字段进行排序，如下表所示。</p><table><thead><tr><th>顺序</th><th>类型</th><th>字节数量</th></tr></thead><tbody><tr><td>1</td><td>double</td><td>8字节</td></tr><tr><td>2</td><td>long</td><td>8字节</td></tr><tr><td>3</td><td>int</td><td>4字节</td></tr><tr><td>4</td><td>float</td><td>4字节</td></tr><tr><td>5</td><td>short</td><td>2字节</td></tr><tr><td>6</td><td>char</td><td>2字节</td></tr><tr><td>7</td><td>boolean</td><td>1字节</td></tr><tr><td>8</td><td>byte</td><td>1字节</td></tr><tr><td>9</td><td>对象引用</td><td>4字节或者8字节</td></tr><tr><td>10</td><td>子类字段</td><td>重新排序</td></tr></tbody></table><p>​ 因此，我们可以在任何字段之间通过填充长整型的变量把热点变量隔离在不同的缓存行中，通过减少伪同步，在多核心CPU中能够极大的提高效率。</p><h4 id="最简单的方式"><a href="#最简单的方式" class="headerlink" title="最简单的方式"></a>最简单的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存行填充父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataPadding</span> </span>&#123;</span><br><span class="line">    <span class="comment">//填充 6个long类型字段 8*4 = 48 个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">    <span class="comment">//需要操作的数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为JDK1.7以后就自动优化代码会删除无用的代码，在JDK1.7以后的版本这些不生效了。</p><h4 id="继承的方式"><a href="#继承的方式" class="headerlink" title="继承的方式"></a>继承的方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存行填充父类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataPadding</span> </span>&#123;</span><br><span class="line">    <span class="comment">//填充 6个long类型字段 8*4 = 48 个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承缓存填充类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 继承DataPadding</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileData</span> <span class="keyword">extends</span> <span class="title">DataPadding</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 占用 8个字节 +48 + 对象头 = 64字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> data = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolatileData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VolatileData</span><span class="params">(<span class="keyword">long</span> defValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = defValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">accumulationAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          <span class="comment">//因为单线程操作不需要加锁</span></span><br><span class="line">         data++;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样在JDK1.8中是可以使用的</p><h4 id="Contended注解"><a href="#Contended注解" class="headerlink" title="@Contended注解"></a>@Contended注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(&#123;ElementType.FIELD, ElementType.TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Contended &#123;</span><br><span class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ Contended注解可以用于类型上和属性上，加上这个注解之后虚拟机会自动进行填充，从而避免伪共享。这个注解在Java8 ConcurrentHashMap、ForkJoinPool和Thread等类中都有应用。我们来看一下Java8中ConcurrentHashMap中如何运用Contended这个注解来解决伪共享问题。以下说的ConcurrentHashMap都是Java8版本。</p><p><strong>注意</strong>：在Java8中提供了<strong>@sun.misc.Contended</strong>来避免伪共享时，在运行时需要设置JVM启动参数<strong>-XX:-RestrictContended</strong>否则可能不生效。</p><h3 id="缓存行填充的威力"><a href="#缓存行填充的威力" class="headerlink" title="缓存行填充的威力"></a>缓存行填充的威力</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存行测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheLineTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 是否启用缓存行填充</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDataPadding = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 正常定义的变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> x = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> z = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过缓存行填充的变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataX = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataY = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> VolatileData volatileDataZ = <span class="keyword">new</span> VolatileData(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 循环次数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> size = <span class="number">100000000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计算耗时</span></span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//循环累加</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//使用缓存行填充的方式</span></span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataX.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不使用缓存行填充的方式 因为时单线程操作不需要加锁</span></span><br><span class="line">                value = (++x);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//打印</span></span><br><span class="line">        System.out.println(value);</span><br><span class="line">        <span class="comment">//打印耗时</span></span><br><span class="line">        System.out.println(<span class="string">"耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataY.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = ++y;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(<span class="string">"耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行累加操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulationZ</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> currentTime = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDataPadding) &#123;</span><br><span class="line">                value = volatileDataZ.accumulationAdd();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                value = ++z;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(<span class="string">"耗时："</span> + (System.currentTimeMillis() - currentTime));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象</span></span><br><span class="line">        CacheLineTest cacheRowTest = <span class="keyword">new</span> CacheLineTest();</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        <span class="comment">//启动三个线程个调用他们各自的方法</span></span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationX());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationY());</span><br><span class="line">        executorService.execute(() -&gt; cacheRowTest.accumulationZ());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="不使用缓存行填充测试"><a href="#不使用缓存行填充测试" class="headerlink" title="不使用缓存行填充测试"></a>不使用缓存行填充测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否启用缓存行填充</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDataPadding = <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">7960</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">7984</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">7989</span></span><br></pre></td></tr></table></figure><h4 id="使用缓存行填充测试"><a href="#使用缓存行填充测试" class="headerlink" title="使用缓存行填充测试"></a>使用缓存行填充测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 是否启用缓存行填充</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDataPadding = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">176</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">178</span></span><br><span class="line"><span class="number">100000000</span></span><br><span class="line">耗时：<span class="number">182</span></span><br></pre></td></tr></table></figure><p>同样的结构他们之间差了 将近 50倍的速度差距</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ 当多个线程同时对共享的缓存行进行写操作的时候，因为缓存系统自身的缓存一致性原则，会引发伪共享问题，解决的常用办法是将共享变量根据缓存行大小进行补充对齐，使其加载到缓存时能够独享缓存行，避免与其他共享变量存储在同一个缓存行。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的伪共享与缓存行
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="伪共享" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="伪共享" scheme="http://www.baiyp.ren/tags/%E4%BC%AA%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式05-装饰器模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F05.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式05.html</id>
    <published>2019-08-27T01:42:30.000Z</published>
    <updated>2019-09-05T10:28:13.423Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-装饰器模式（Decorator-Pattern）"><a href="#JAVA设计模式-装饰器模式（Decorator-Pattern）" class="headerlink" title="JAVA设计模式-装饰器模式（Decorator Pattern）"></a>JAVA设计模式-装饰器模式（Decorator Pattern）</h2><blockquote><p><strong>装饰器模式(Decorator Pattern)，动态地给一个对象添加一些额外的职责，就增加功能来说，装饰器模式比生成子类更灵活。 —-《大话设计模式》</strong></p></blockquote><p><img src="../images/design-patterns/decoratorpattern01.jpg" alt></p><h3 id="什么是装饰器模式"><a href="#什么是装饰器模式" class="headerlink" title="什么是装饰器模式"></a>什么是装饰器模式</h3><p>​ 允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。</p><p>​ 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p><p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li>Component（抽象构件）：给出一个抽象接口，装饰器模式中公共方法的类，在装饰器模式结构图的顶层，以规范准备接收附加责任的对象。</li><li>ConcreteComponent（具体构件）：是要动态扩展的对象，转换器模式中具体的被装饰的类，它继承自Component。</li><li>Decorator（装饰器）：持有一个构件(Component)对象的实例，它是装饰器模式中的核心对象，所有具体装饰器对象的父类，完成装饰器的部分职能。可以只对被装饰的对象进行一些简单的包裹，也可包含对Component中方法的实现。</li><li>ConcreteDecorator（具体装饰）：完成具体的装饰功能。装饰功能的实现是通过调用被装饰对象对应的方法，加上装饰对象自身的方法。这是装饰器模式动机中的添加额外功能的关键。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</li><li>装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。装饰模式允许系统动态决定“贴上”或者除掉一个“装饰”，继承关系是静态的，它在系统运行前就决定了；</li><li>通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合；</li><li>装饰者类可以在被装饰者的行为前面或后面加上自己的行为，甚至取代被装饰者的行为，达到特定的目的；</li><li>装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>多层装饰比较复杂。</li><li>由于使用装饰模式，可以比使用继承关系需要较少数目的类。使用较少的类，当然使设计比较易于进行。但是，在另一方面，使用装饰模式会产生比使用继承关系更多的对象。更多的对象会使得查错变得困难，特别是这些对象看上去都很相像。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>运行时，你需要动态地为对象增加额外职责时；</li><li>当你需要一个能够代替子类的类，借助它提供额外方法时。</li><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；</li><li>处理那些可以撤销的职责；</li><li>当不能采用生成子类的方式进行扩充时。</li></ul><h3 id="装饰器模式与适配器模式的比较"><a href="#装饰器模式与适配器模式的比较" class="headerlink" title="装饰器模式与适配器模式的比较"></a>装饰器模式与适配器模式的比较</h3><p>共同点：都拥有一个目标对象。装饰器通过包装一个装饰对象来扩展其功能，而又不改变其接口，这实际上是基于对象的适配器模式的一种变种。<br>不同点：适配器模式需要实现另外一个接口，而装饰器模式必须实现该对象的接口。适配器模式主要是为了接口的转换，而装饰者模式关注的是通过组合来动态的为被装饰者注入新的功能或行为(即所谓的责任)。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>假设我去买咖啡，首先服务员给我冲了一杯原味咖啡，我希望服务员给我加些牛奶和白糖混合入原味咖啡中。使用装饰器模式就可以解决这个问题。</p></blockquote><h4 id="咖啡接口"><a href="#咖啡接口" class="headerlink" title="咖啡接口"></a>咖啡接口</h4><blockquote><p>定义了获取花费和配料的接口。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取咖啡</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="原味咖啡"><a href="#原味咖啡" class="headerlink" title="原味咖啡"></a>原味咖啡</h4><blockquote><p>实现Coffe接口，花费1元，配料中，只有咖啡</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原味咖啡类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OriginalCoffee</span> <span class="keyword">implements</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"原味咖啡"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h4><blockquote><p>咖啡对象的装饰器类，同样实现Coffee接口，定义一个Coffe对象的引用，在构造器中进行初始化。并且将getPrice（）和getCoffee()方法转发给被装饰对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 咖啡的"装饰器"，可以给咖啡添加各种"配料"</span></span><br><span class="line"><span class="comment"> * 该类是一个抽象类需要具体子类来实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorAbstractCoffee</span> <span class="keyword">implements</span> <span class="title">Coffee</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体咖啡的接口</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span>  Coffee coffee;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法，初始化咖啡对象的引用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coffee</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DecoratorAbstractCoffee</span><span class="params">(Coffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.coffee = coffee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取价格，装饰器父类中直接转发"请求"至引用对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取咖啡，装饰器父类中直接转发"请求"至引用对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCoffee();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体的装饰器类"><a href="#具体的装饰器类" class="headerlink" title="具体的装饰器类"></a>具体的装饰器类</h4><h5 id="添加牛奶"><a href="#添加牛奶" class="headerlink" title="添加牛奶"></a>添加牛奶</h5><blockquote><p>具体的装饰器类，负责往咖啡中“添加”牛奶，注意看getPrice（）方法和getCoffee()方法，可以在转发请求之前或者之后，增加功能。如果是代理模式，这里的结构就有所不同，通常代理模式根据运行时的条件来判断是否转发请求。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 混合牛奶到蜂蜜中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CreamCoffee</span> <span class="keyword">extends</span> <span class="title">DecoratorAbstractCoffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = (<span class="keyword">float</span>) <span class="number">0.5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调用父类的构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coffee</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CreamCoffee</span><span class="params">(Coffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 增加配料需要加钱</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getPrice()+price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对咖啡进行加工</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCoffee()+<span class="string">"；添加牛奶"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="添加糖"><a href="#添加糖" class="headerlink" title="添加糖"></a>添加糖</h5><blockquote><p>另一个具体装饰器类，用来给咖啡加蜂蜜，一样的逻辑。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HoneyCoffee</span> <span class="keyword">extends</span> <span class="title">DecoratorAbstractCoffee</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price = (<span class="keyword">float</span>) <span class="number">1.4</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HoneyCoffee</span><span class="params">(Coffee coffee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(coffee);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getPrice()+price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCoffee</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> coffee.getCoffee()+<span class="string">"；添加蜂蜜"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DecoratorMain</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//是不是很像 javaIO中的 stream流</span></span><br><span class="line">        Coffee coffee = <span class="keyword">new</span> CreamCoffee(<span class="keyword">new</span> HoneyCoffee(<span class="keyword">new</span> OriginalCoffee()));</span><br><span class="line">        System.out.println(coffee.getCoffee());</span><br><span class="line">        System.out.println(coffee.getPrice());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ 装饰器模式是代替增加子类的一种解决方案，体现了聚合/合成复用原则的思想，尽量使用组合的方式来扩展功能，这样就把基本功能和扩展功能解耦了，使得代码可复用，可维护，灵活。关键点在于装饰器模式可以动态地为对象增加扩展功能。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之装饰器模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰器模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="装饰器模式" scheme="http://www.baiyp.ren/tags/%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的线程安全</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8.html"/>
    <id>http://www.baiyp.ren/JAVA中的线程安全.html</id>
    <published>2019-08-26T07:33:17.000Z</published>
    <updated>2019-09-05T09:21:10.078Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的线程安全"><a href="#JAVA中的线程安全" class="headerlink" title="JAVA中的线程安全"></a>JAVA中的线程安全</h2><p><img src="../images/threadsafety01.jpg" alt></p><h3 id="什么是线程安全"><a href="#什么是线程安全" class="headerlink" title="什么是线程安全"></a>什么是线程安全</h3><p>​ 指多个线程在执行同一段代码的时候采用加锁机制，使每次的执行结果和单线程执行的结果都是一样的，不存在执行程序时出现意外结果。</p><p>线程不安全：是指不提供加锁机制保护，有可能出现多个线程先后更改数据造成所得到的数据是脏数据。</p><h3 id="线程安全的解决方案"><a href="#线程安全的解决方案" class="headerlink" title="线程安全的解决方案"></a>线程安全的解决方案</h3><h4 id="栈封闭（局部变量）"><a href="#栈封闭（局部变量）" class="headerlink" title="栈封闭（局部变量）"></a>栈封闭（局部变量）</h4><p>​ 栈限制是线程封闭的一种特例，只能通过局部变量才可以访问对象，局部使对象限制在执行线程中，存在于执行线程栈，其他线程无法访问这个栈，从而确保线程安全。（每一个线程都有一个工作内存，工作内存中班包括有栈，局部的基本类型变量是处于栈中，引用类型的引用处于栈中，而引用指向的对象处于堆中）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//x,y 传递进来，因为x，y都是基本数据类型作为变量副本传递过来</span></span><br><span class="line">        <span class="comment">//z变量被封闭在了方法内部</span></span><br><span class="line">        <span class="keyword">int</span> z = x + y;</span><br><span class="line">        <span class="keyword">return</span> z;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="无状态（No-State）"><a href="#无状态（No-State）" class="headerlink" title="无状态（No State）"></a>无状态（No State）</h4><blockquote><p>如果一个类的同一个实例被多个线程共享并不会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为<strong>无状态对象</strong>；反之，如果一个类的同一个实例被多个线程共享，会使这些线程存在共享状态，那么这个类及其任意一个实例就被称为<strong>有状态对象</strong></p></blockquote><p>无状态对象不包含任何实例变量，且不包含任何静态变量或者其包含的静态变量都是只读的（常量）</p><p>​ 即使一个类不包含任何实例变量或者静态变量，执行该类方法的多个线程也仍然可能存在共享状态；因为类方法中可能存在的实例对象中包含有静态变量或实例变量。此时就需要在方法中加锁来保障</p><p>​ 当多个线程访问相同的实例或静态变量时，必须以某种方式来协调对此变量的访问。最简单的方法就是避免使用实例或静态变量。对于没有实例变量的类，它的方法只使用局部变量和方法参数</p><p>以下示例显示了java.lang.Math类的其中一部分:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">subtractExact</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = x - y;</span><br><span class="line">    <span class="comment">// HD 2-12 Overflow iff the arguments have different signs and</span></span><br><span class="line">    <span class="comment">// the sign of the result is different than the sign of x</span></span><br><span class="line">    <span class="keyword">if</span> (((x ^ y) &amp; (x ^ r)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ArithmeticException(<span class="string">"integer overflow"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><p>​ 使用volatile可以保证变量的可见性与有序性，但是volatile不能保证线程的安全性，适合于一写多读的场景。</p><h4 id="加锁与CAS"><a href="#加锁与CAS" class="headerlink" title="加锁与CAS"></a>加锁与CAS</h4><p>​ 通过加内置锁 synchronize或者 显示锁Lock可以解决线程同步问题，但是线程比较多的情况下会产生上下文切花问题，对于变量的同步可以使用CAS原子操作。</p><h4 id="安全的发布"><a href="#安全的发布" class="headerlink" title="安全的发布"></a>安全的发布</h4><h4 id="TheadLocal"><a href="#TheadLocal" class="headerlink" title="TheadLocal"></a>TheadLocal</h4><p>使用ThreadLocal 来进行线程的隔离，因为TheadLocal都保存这线程对象的副本，所以可以避免线程安全问题。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的线程安全
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="线程安全" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="并发安全" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="线程安全" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JAVA线程池实现03-其余方法</title>
    <link href="http://www.baiyp.ren/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B003.html"/>
    <id>http://www.baiyp.ren/JAVA线程池实现03.html</id>
    <published>2019-08-25T02:55:59.000Z</published>
    <updated>2019-08-27T06:10:17.903Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA线程池实现03-其余方法"><a href="#JAVA线程池实现03-其余方法" class="headerlink" title="JAVA线程池实现03-其余方法"></a>JAVA线程池实现03-其余方法</h2><p><img src="../images/threadpoolexecutor03.png" alt></p><h3 id="shutdown安全停止任务"><a href="#shutdown安全停止任务" class="headerlink" title="shutdown安全停止任务"></a>shutdown安全停止任务</h3><blockquote><p>注意该方法不会马上停止线程池，会先将线程池置于shutdown状态然后发起中断请求，等待任务自己结束，线程内部要实现中断请求的响应处理，否则就不会终止。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安全的中断任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查权限</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//更改运行状态</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">//中断任务</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            <span class="comment">//模板方法，不继承实现则是一个空方法</span></span><br><span class="line">            onShutdown();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试中断任务</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="检查权限-checkShutdownAccess"><a href="#检查权限-checkShutdownAccess" class="headerlink" title="检查权限 checkShutdownAccess"></a>检查权限 checkShutdownAccess</h4><blockquote><p>这主要的目的是为了在系统层面对线程池进行保护，防止其发生意外。比如中断系统进程等，获取了安全管理器之后接下来再对其进行权限检查。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//检查线程池个任务权限</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkShutdownAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取安全管理器</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//检查任务权限</span></span><br><span class="line">        security.checkPermission(shutdownPerm);</span><br><span class="line">        <span class="comment">//获取重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查个任务的权限</span></span><br><span class="line">            <span class="keyword">for</span> (ThreadPoolExecutor.Worker w : workers) &#123;</span><br><span class="line">                security.checkAccess(w.thread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更改运行状态-advanceRunState"><a href="#更改运行状态-advanceRunState" class="headerlink" title="更改运行状态 advanceRunState"></a>更改运行状态 advanceRunState</h4><blockquote><p>更改线程池的状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置运行状态</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="comment">//非运行状态 当前状态&gt; targetState 或者 设置运行状态为 targetState状态成功</span></span><br><span class="line">           <span class="keyword">if</span> (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="中断工作任务-interruptIdleWorkers"><a href="#中断工作任务-interruptIdleWorkers" class="headerlink" title="中断工作任务 interruptIdleWorkers"></a>中断工作任务 interruptIdleWorkers</h4><blockquote><p>中断任务，但是只是发起中断请求，不会强制中断任务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 中断任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 中断任务</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyOne 是否只中断一次</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取重入锁</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">      <span class="comment">//加锁</span></span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">              Thread t = w.thread;</span><br><span class="line">              <span class="comment">//任务未中断 并且尝试获取锁成功</span></span><br><span class="line">              <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//发起中断请求</span></span><br><span class="line">                      t.interrupt();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">//解锁</span></span><br><span class="line">                      w.unlock();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//解锁</span></span><br><span class="line">          mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="尝试终止任务"><a href="#尝试终止任务" class="headerlink" title="尝试终止任务"></a>尝试终止任务</h4><blockquote><p>尝试终止任务如果有正在运行的任务或者任务队列不为空且运行状态是SHUTDOWN就返回，不进行前置终止。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试终止任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * isRunning 线程正在运行</span></span><br><span class="line"><span class="comment">         * runStateAtLeast 线程池已经中断</span></span><br><span class="line"><span class="comment">         * 或者 线程池停止并且任务队列不为空 返回</span></span><br><span class="line"><span class="comment">         * 不进行强制终止</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//正在运行或者</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||  runStateAtLeast(c, TIDYING) ||  (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前工作线程不为0</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">//发起中断请求 只终止一次</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="comment">//返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置运行状态为真理状态</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//空方法，用于终止线程后的自定义任务</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//设置线程池为终止状态</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">//通知所有线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdownNow马上终止线程"><a href="#shutdownNow马上终止线程" class="headerlink" title="shutdownNow马上终止线程"></a>shutdownNow马上终止线程</h3><blockquote><p>该方法是马上中断线程池，如果有未完成的任务先发起中断请求，然后将线程池中的任务删除，并将删除的数据放进一个临时的队列并且返回。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 马上终止线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 未完成的任务列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="comment">//获取重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//设置状态为终止</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//发起中断请求</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//将线程池任务队列清空，并返回未完成的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终止任务</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="drainQueue-清空队列"><a href="#drainQueue-清空队列" class="headerlink" title="drainQueue 清空队列"></a>drainQueue 清空队列</h4><blockquote><p>清理队列并且返回未完成任务的列表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空队列，并返回清除的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    <span class="comment">//批量获取任务</span></span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="comment">//为防止还有剩余数据，做一次查询</span></span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="comment">//删除队列中的元素</span></span><br><span class="line">            <span class="keyword">if</span> (q.remove(r)) &#123;</span><br><span class="line">                <span class="comment">//添加到队列</span></span><br><span class="line">                taskList.add(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdown与shutdownNow"><a href="#shutdown与shutdownNow" class="headerlink" title="shutdown与shutdownNow"></a>shutdown与shutdownNow</h3><blockquote><p>到这里我们发现shutdown和 shutdownNow很像，但是有差别，shutdownNow就强制在调用后会清空任务列表，强制终止任务，但是shutdown不会，shutdown会等待任务完成然后才会进行终止。</p></blockquote><h3 id="isShutdown-线程池是否关闭"><a href="#isShutdown-线程池是否关闭" class="headerlink" title="isShutdown 线程池是否关闭"></a>isShutdown 线程池是否关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="isTerminating-线程池是否正在终止"><a href="#isTerminating-线程池是否正在终止" class="headerlink" title="isTerminating 线程池是否正在终止"></a>isTerminating 线程池是否正在终止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">return</span> ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="线程池是否终止"><a href="#线程池是否终止" class="headerlink" title="线程池是否终止"></a>线程池是否终止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA线程池实现-ThreadPoolExecutor
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://www.baiyp.ren/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式04-适配器模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F04.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式04.html</id>
    <published>2019-08-25T01:42:30.000Z</published>
    <updated>2019-09-05T10:28:22.242Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-适配器模式（Adapter-Pattern）"><a href="#JAVA设计模式-适配器模式（Adapter-Pattern）" class="headerlink" title="JAVA设计模式-适配器模式（Adapter Pattern）"></a>JAVA设计模式-适配器模式（Adapter Pattern）</h2><p><img src="../images/design-patterns/adapterpattern01.png" alt></p><h3 id="什么是适配器模式"><a href="#什么是适配器模式" class="headerlink" title="什么是适配器模式"></a>什么是适配器模式</h3><p>​ 将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</p><p>​ 在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。</p><p>​ 根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</p><p>​ 缺省适配器模式(Default Adapter Pattern)：当不需要实现一个接口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可以选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。在JDK类库的事件处理包java.awt.event中广泛使用了缺省适配器模式，如WindowAdapter、KeyAdapter、MouseAdapter等。</p><p>适配器模式实现的方式有三种：<strong>类适配器</strong>，<strong>对象适配器</strong>，<strong>接口适配器</strong>。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><p>Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</p></li><li><p>Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。</p></li><li><p>Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>可以让任何两个没有关联的类一起运行。</li><li>提高了类的复用。</li><li>增加了类的透明度。</li><li>灵活性好。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>过多地使用适配器，会让系统非常零乱，不易整体进行把握。比如，明明看到调用的是 A 接口，其实内部被适配成了 B 接口的实现，一个系统如果太多出现这种情况，无异于一场灾难。因此如果不是很有必要，可以不使用适配器，而是直接对系统进行重构。</li><li>由于 JAVA 至多继承一个类，所以至多只能适配一个适配者类，而且目标类必须是抽象类。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li><p>想要使用一个已经存在的类，但是它却不符合现有的接口规范，导致无法直接去访问，这时创建一个适配器就能间接去访问这个类中的方法。</p></li><li><p>我们有一个类，想将其设计为可重用的类（可已经被多处访问了），我们可以创建适配器来将这个类来适配其他没有提供合适接口的类。</p></li><li><p>想要使用接口中的某个或者某些方法，但是接口中有太多不是自己需要的方法了，接口在实现时必须实现其中的所有方法，这个时候就要使用抽象类来实现接口，并不对所有方法进行实现（进置空），然后我们再继承这个抽象类来重写想要的方法。这个抽象类就是适配器</p></li></ul><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><blockquote><p>Adapter 类继承Adaptee （被适配类），同时实现Target 接口（因为 Java 不支持多继承，所以只能通过接口的方法来实现多继承），在 Client 类中我们可以根据需要选择并创建任一种符合需求的子类，来实现具体功能。</p></blockquote><p><img src="../images/design-patterns/adapterpattern02.png" alt></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="创建被适配的类"><a href="#创建被适配的类" class="headerlink" title="创建被适配的类"></a>创建被适配的类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">adapteeRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"被适配者的方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="定义一个目标接口"><a href="#定义一个目标接口" class="headerlink" title="定义一个目标接口"></a>定义一个目标接口</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建适配器类"><a href="#创建适配器类" class="headerlink" title="创建适配器类"></a>创建适配器类</h5><blockquote><p>实现 <strong>Target</strong> 接口，同时继承了 <strong>Adaptee</strong> 类，然后在实现的 <strong>request()</strong>方法中调用父类的 <strong>adapteeRequest()</strong></p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">        <span class="keyword">super</span>.adapteeRequest();</span><br><span class="line">        <span class="comment">//...一些操作...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><blockquote><p>对象适配器与类适配器不同之处在于，类适配器通过继承来完成适配，对象适配器则是通过关联来完成，这里稍微修改一下 <code>Adapter</code> 类即可将转变为对象适配器</p></blockquote><p><img src="../images/design-patterns/adapterpattern03.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span></span>&#123;</span><br><span class="line">    <span class="comment">// 适配者是对象适配器的一个属性</span></span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee = <span class="keyword">new</span> Adaptee();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        adaptee.adapteeRequest();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的 <strong>Adapter</strong> 是将 <strong>Adaptee</strong> 作为一个成员属性，而不是继承它</p><h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><blockquote><p>当不需要<strong>全部实现</strong>接口提供的方法时，可先设计一个<strong>抽象类</strong>实现接口，并为该接口中每个方法提供一个<strong>默认实现</strong>（空方法），那么该抽象类的子类可<strong>有选择</strong>地覆盖父类的某些方法来实现需求，它适用于<strong>一个接口不想使用其所有的方法</strong>的情况。</p></blockquote><p><img src="../images/design-patterns/adapterpattern04.png" alt></p><h4 id="手机品牌接口"><a href="#手机品牌接口" class="headerlink" title="手机品牌接口"></a>手机品牌接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MobilePhoneBrand</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">xiaomi</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">huawei</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">apple</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">vivo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">oppo</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">samsung</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建抽象类"><a href="#创建抽象类" class="headerlink" title="创建抽象类"></a>创建抽象类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MobilePhoneDefault</span> <span class="keyword">implements</span> <span class="title">MobilePhoneBrand</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">xiaomi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">huawei</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">apple</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">vivo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">oppo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">samsung</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建具体实现类"><a href="#创建具体实现类" class="headerlink" title="创建具体实现类"></a>创建具体实现类</h4><h5 id="中国手机品牌"><a href="#中国手机品牌" class="headerlink" title="中国手机品牌"></a>中国手机品牌</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChinaMobilePhone</span> <span class="keyword">extends</span> <span class="title">MobilePhoneDefault</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">xiaomi</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"小米"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">huawei</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"华为"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">vivo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"VIVO"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">oppo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"OPPO"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="美国手机品牌"><a href="#美国手机品牌" class="headerlink" title="美国手机品牌"></a>美国手机品牌</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">USAMobilePhone</span> <span class="keyword">extends</span> <span class="title">MobilePhoneDefault</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">apple</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"苹果"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="韩国手机品牌"><a href="#韩国手机品牌" class="headerlink" title="韩国手机品牌"></a>韩国手机品牌</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KoreaMobilePhone</span> <span class="keyword">extends</span> <span class="title">MobilePhoneDefault</span> </span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> String <span class="title">samsung</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"三星"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之适配器模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="适配器模式" scheme="http://www.baiyp.ren/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的死锁</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81.html"/>
    <id>http://www.baiyp.ren/JAVA中的死锁.html</id>
    <published>2019-08-24T07:33:17.000Z</published>
    <updated>2019-09-05T09:20:55.494Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的死锁"><a href="#JAVA中的死锁" class="headerlink" title="JAVA中的死锁"></a>JAVA中的死锁</h2><p><img src="../images/deadlock01.png" alt></p><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>​ 在多线程环境中，多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为<strong>死锁</strong></p><p>​ 在Java中使用多线程，就会<strong>有可能导致死锁</strong>问题。死锁会让程序一直<strong>卡</strong>住，不再程序往下执行。我们只能通过<strong>中止并重启</strong>的方式来让程序重新执行。</p><h3 id="造成死锁的原因"><a href="#造成死锁的原因" class="headerlink" title="造成死锁的原因"></a>造成死锁的原因</h3><ul><li>当前线程<strong>拥有其他线程需要的</strong>资源</li><li>当前线程<strong>等待其他线程已拥有</strong>的资源</li><li><strong>都不放弃</strong>自己拥有的资源</li></ul><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>​ 进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><h4 id="不可剥夺"><a href="#不可剥夺" class="headerlink" title="不可剥夺"></a>不可剥夺</h4><p>​ 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p><h4 id="请求与保持"><a href="#请求与保持" class="headerlink" title="请求与保持"></a>请求与保持</h4><p>​ 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><h4 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h4><p>​ 是指进程发生死锁后，必然存在一个进程–资源之间的环形链，通俗讲就是你等我的资源，我等你的资源，大家一直等。</p><h3 id="死锁的分类"><a href="#死锁的分类" class="headerlink" title="死锁的分类"></a>死锁的分类</h3><h4 id="静态顺序型死锁"><a href="#静态顺序型死锁" class="headerlink" title="静态顺序型死锁"></a>静态顺序型死锁</h4><blockquote><p>线程之间形成相互等待资源的环时，就会形成顺序死锁lock-ordering deadlock，多个线程试图以不同的顺序来获取相同的锁时，容易形成顺序死锁，如果所有线程以固定的顺序来获取锁，就不会出现顺序死锁问题</p></blockquote><p>​ 经典案例是LeftRightDeadlock，两个方法，分别是leftRigth、rightLeft。如果一个线程调用leftRight，另一个线程调用rightLeft，且两个线程是交替执行的，就会发生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左边锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object left = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//右边锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object right = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 现持有左边的锁，然后获取右边的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftRigth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">            System.out.println(<span class="string">"leftRigth: left lock，threadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                System.out.println(<span class="string">"leftRigth: right lock，threadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 现持有右边的锁，然后获取左边的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            System.out.println(<span class="string">"rightLeft: right lock，threadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                System.out.println(<span class="string">"rightLeft: left lock，threadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 休眠</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.execute(() -&gt; leftRigth());</span><br><span class="line">        executorService.execute(() -&gt; rightLeft());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftRigth: left lock，threadId:<span class="number">12</span></span><br><span class="line">rightLeft: right lock，threadId:<span class="number">13</span></span><br></pre></td></tr></table></figure><p>我们发现，12号线程锁住了左边要向右边获取锁，13号锁住了右边，要向左边获取锁，因为两边都不释放自己的锁，互不相让，就产生了死锁。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><blockquote><p><strong>固定加锁的顺序</strong>(针对锁顺序死锁)</p></blockquote><p>只要交换下锁的顺序，让线程来了之后先获取同一把锁，获取不到就等待，等待上一个线程释放锁再获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftRigth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">         ...</span><br><span class="line">           <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">         ...</span><br><span class="line">           <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="动态锁顺序型死锁"><a href="#动态锁顺序型死锁" class="headerlink" title="动态锁顺序型死锁"></a>动态锁顺序型死锁</h4><blockquote><p>由于方法入参由外部传递而来，方法内部虽然对两个参数按照固定顺序进行加锁，但是由于外部传递时顺序的不可控，而产生锁顺序造成的死锁，即动态锁顺序死锁。</p></blockquote><p>​ 上例告诉我们，交替的获取锁会导致死锁，且锁是固定的。有时候并锁的执行顺序并不那么清晰，参数导致不同的执行顺序。经典案例是银行账户转账，from账户向to账户转账，在转账之前先获取两个账户的锁，然后开始转账，如果这是to账户向from账户转账，角色互换，也会导致锁顺序死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态顺序型死锁</span></span><br><span class="line"><span class="comment"> * 转账业务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoneyDeadlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先锁住转账的账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">            <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">//在锁住目标账户</span></span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    from.debit(amount);</span><br><span class="line">                    to.credit(amount);</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name, <span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">debit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance - amount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">credit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance + amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 休眠</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//创建账户A</span></span><br><span class="line">        Account A = <span class="keyword">new</span> Account(<span class="string">"A"</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建账户B</span></span><br><span class="line">        Account B = <span class="keyword">new</span> Account(<span class="string">"B"</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//A -&gt; B 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(A, B, <span class="number">5</span>));</span><br><span class="line">        <span class="comment">//B -&gt; A 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(B, A, <span class="number">10</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程【<span class="number">12</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【B】账户锁成功</span><br></pre></td></tr></table></figure><p>然后就没有然后了，产生了死锁，我们发现 因为对象的调用关系，产生了互相锁住资源的问题。</p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>​ 根据传入对象的hashCode硬性确定加锁顺序，消除可变性，避免死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.thread.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态顺序型死锁解决方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoneyDeadlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监视器，第三把锁，为了方式HASH冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们经过上一次得失败，明白了不能依赖参数名称简单的确定锁的顺序，因为参数是</span></span><br><span class="line"><span class="comment">     * 具有动态性的，所以，我们改变一下思路，直接根据传入对象的hashCode()大小来</span></span><br><span class="line"><span class="comment">     * 对锁定顺序进行排序(这里要明白的是如何排序不是关键，有序才是关键)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里需要说明一下为什么不使用HashCode()因为HashCode方法可以被重写，</span></span><br><span class="line"><span class="comment">         * 所以，我们无法简单的使用父类或者当前类提供的简单的hashCode()方法，</span></span><br><span class="line"><span class="comment">         * 所以，我们就使用系统提供的identityHashCode()方法，该方法保证无论</span></span><br><span class="line"><span class="comment">         * 你是否重写了hashCode方法，都会在虚拟机层面上调用一个名为JVM_IHashCode</span></span><br><span class="line"><span class="comment">         * 的方法来根据对象的存储地址来获取该对象的hashCode(),HashCode如果不重写</span></span><br><span class="line"><span class="comment">         * 的话，其实也是通过这个虚拟机层面上的方法，JVM_IHashCode()方法实现的</span></span><br><span class="line"><span class="comment">         * 这个方法是用C++实现的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> fromHash = System.identityHashCode(from);</span><br><span class="line">        <span class="keyword">int</span> toHash = System.identityHashCode(to);</span><br><span class="line">        <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">            <span class="comment">//先锁住转账的账户</span></span><br><span class="line">            <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">//在锁住目标账户</span></span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        from.debit(amount);</span><br><span class="line">                        to.credit(amount);</span><br><span class="line">                        System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">            <span class="comment">//先锁住转账的账户</span></span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">//在锁住目标账户</span></span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        from.debit(amount);</span><br><span class="line">                        to.credit(amount);</span><br><span class="line">                        System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果传入对象的Hash值相同，那就加让加第三层锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">//先锁住转账的账户</span></span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                    <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">                    sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">//在锁住目标账户</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            from.debit(amount);</span><br><span class="line">                            to.credit(amount);</span><br><span class="line">                            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name, <span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">debit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance - amount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">credit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance + amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 休眠</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//创建账户A</span></span><br><span class="line">        Account A = <span class="keyword">new</span> Account(<span class="string">"A"</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建账户B</span></span><br><span class="line">        Account B = <span class="keyword">new</span> Account(<span class="string">"B"</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//A -&gt; B 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(A, B, <span class="number">5</span>));</span><br><span class="line">        <span class="comment">//B -&gt; A 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(B, A, <span class="number">10</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程【<span class="number">12</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">12</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">12</span>】从【A】账户转账到【B】账户【<span class="number">5</span>】元钱成功</span><br><span class="line">线程【<span class="number">13</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】从【B】账户转账到【A】账户【<span class="number">10</span>】元钱成功</span><br></pre></td></tr></table></figure><h4 id="协作对象间的死锁"><a href="#协作对象间的死锁" class="headerlink" title="协作对象间的死锁"></a>协作对象间的死锁</h4><blockquote><p>在协作对象之间可能存在多个锁获取的情况，但是这些获取多个锁的操作并不像在LeftRightDeadLock或transferMoney中那么明显，这两个锁并不一定必须在同一个方法中被获取。如果在持有锁时调用某个外部方法，那么这就需要警惕死锁问题，因为在这个外部方法中可能会获取其他锁，或者阻塞时间过长，导致其他线程无法及时获取当前被持有的锁。</p></blockquote><p>​ 上述两例中，在同一个方法中获取两个锁。实际上，锁并不一定在同一方法中被获取。经典案例，如出租车调度系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协作对象间的死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinateDeadlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Taxi 类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String location;</span><br><span class="line">        <span class="keyword">private</span> String destination;</span><br><span class="line">        <span class="keyword">private</span> Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher, String destination)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">            <span class="keyword">this</span>.destination = destination;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.location;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法先获取Taxi的this对象锁后，然后调用Dispatcher类的方法时，又需要获取</span></span><br><span class="line"><span class="comment">         * Dispatcher类的this方法。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> location</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.location = location;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" taxi set location:"</span> + location);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.location.equals(destination)) &#123;</span><br><span class="line">                dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">        <span class="keyword">private</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">            availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" notifyAvailable."</span>);</span><br><span class="line">            availableTaxis.add(taxi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印当前位置：有死锁风险</span></span><br><span class="line"><span class="comment">         * 持有当前锁的时候，同时调用Taxi的getLocation这个外部方法；而这个外部方法也是需要加锁的</span></span><br><span class="line"><span class="comment">         * reportLocation的锁的顺序与Taxi的setLocation锁的顺序完全相反</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reportLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" report location."</span>);</span><br><span class="line">            <span class="keyword">for</span> (Taxi t : taxis) &#123;</span><br><span class="line">                t.getLocation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTaxi</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">            taxis.add(taxi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">        <span class="keyword">final</span> Taxi taxi = <span class="keyword">new</span> Taxi(dispatcher, <span class="string">"软件园"</span>);</span><br><span class="line">        dispatcher.addTaxi(taxi);</span><br><span class="line">        <span class="comment">//先获取dispatcher锁，然后是taxi的锁</span></span><br><span class="line">        executorService.execute(() -&gt; dispatcher.reportLocation());</span><br><span class="line">        <span class="comment">//先获取taxi锁，然后是dispatcher的锁</span></span><br><span class="line">        executorService.execute(() -&gt; taxi.setLocation(<span class="string">"软件园"</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><blockquote><p>使用开放调用，开放调用指调用该方法不需要持有锁。</p></blockquote><p>​ 开放调用，是指在调用某个方法时不需要持有锁。开放调用可以避免死锁，这种代码更容易编写。上述调度算法完全可以修改为开发调用，修改同步代码块的范围，使其仅用于保护那些涉及共享状态的操作，避免在同步代码块中执行方法调用。修改Dispatcher的reportLocation方法：</p><h6 id="setLocation方法"><a href="#setLocation方法" class="headerlink" title="setLocation方法"></a>setLocation方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 开放调用，不持有锁期间进行外部方法调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> location</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.location = location;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">" taxi set location:"</span> + location);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.location.equals(destination)) &#123;</span><br><span class="line">           dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="reportLocation-方法"><a href="#reportLocation-方法" class="headerlink" title="reportLocation 方法"></a>reportLocation 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 同步块只包含对共享状态的操作代码</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reportLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">" report location."</span>);</span><br><span class="line">          Set&lt;Taxi&gt; taxisCopy;</span><br><span class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">              taxisCopy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (Taxi t : taxisCopy) &#123;</span><br><span class="line">              t.getLocation();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="死锁问题排查"><a href="#死锁问题排查" class="headerlink" title="死锁问题排查"></a>死锁问题排查</h3><p>​ 拿动态顺序型死锁举例，其他的都一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Account A = <span class="keyword">new</span> Account(<span class="string">"A"</span>, <span class="number">100</span>);</span><br><span class="line">        Account B = <span class="keyword">new</span> Account(<span class="string">"B"</span>, <span class="number">200</span>);</span><br><span class="line">        executorService.execute(() -&gt; transfer(A, B, <span class="number">5</span>));</span><br><span class="line">        executorService.execute(() -&gt; transfer(B, A, <span class="number">10</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="死锁的现象"><a href="#死锁的现象" class="headerlink" title="死锁的现象"></a>死锁的现象</h4><blockquote><p>系统越来越卡，没有任何报错信息，随机性比较高</p></blockquote><h4 id="排查死锁"><a href="#排查死锁" class="headerlink" title="排查死锁"></a>排查死锁</h4><h5 id="使用-jps-jstack"><a href="#使用-jps-jstack" class="headerlink" title="使用 jps + jstack"></a>使用 jps + jstack</h5><ol><li>在 window或linux中使用jps + jstack命令</li></ol><p><img src="../images/deadlock02.jpg" alt></p><ol start="2"><li><p>找到可能发生死锁的类对应的PID</p><blockquote><p>我们对应的类是TransferMoneyDeadlock PID是 13964</p></blockquote></li></ol><h5 id="使用jstack-l-PID"><a href="#使用jstack-l-PID" class="headerlink" title="使用jstack -l PID"></a>使用jstack -l PID</h5><blockquote><p>执行 jstack -l 13964 命令</p></blockquote><p><img src="../images/deadlock03.jpg" alt></p><p>我们观察BLOCKED 就表示阻塞状态</p><ul><li>pool-1-thread-2 等待锁 &lt;0x00000000d673baa8&gt;并且已经获取了锁 &lt;0x00000000d673baf0&gt;</li><li>pool-1-thread-1 等待锁 &lt;0x00000000d673baf0&gt; 并且已经获取了锁&lt;0x00000000d673baa8&gt;</li></ul><p>我们发现他们互相持有各自的锁，并且想获取对方的锁，这就是明显的死锁。</p><h5 id="使用jconsole"><a href="#使用jconsole" class="headerlink" title="使用jconsole"></a>使用jconsole</h5><blockquote><p>使用命令打开jconsole</p></blockquote><p><img src="../images/deadlock04.jpg" alt></p><blockquote><p>打开jconsole界面工具选择我们需要检测的类</p></blockquote><p><img src="../images/deadlock05.jpg" alt></p><blockquote><p>选择检查死锁</p></blockquote><p><img src="../images/deadlock06.jpg" alt></p><blockquote><p>点击检查死锁</p></blockquote><p><img src="../images/deadlock07.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的死锁
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="死锁" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E6%AD%BB%E9%94%81/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="并发安全" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="死锁" scheme="http://www.baiyp.ren/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的活锁</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E6%B4%BB%E9%94%81.html"/>
    <id>http://www.baiyp.ren/JAVA中的活锁.html</id>
    <published>2019-08-22T09:33:17.000Z</published>
    <updated>2019-09-05T09:20:43.072Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的活锁"><a href="#JAVA中的活锁" class="headerlink" title="JAVA中的活锁"></a>JAVA中的活锁</h2><h3 id="什么是活锁"><a href="#什么是活锁" class="headerlink" title="什么是活锁"></a>什么是活锁</h3><p>​ 两个线程在尝试拿锁的机制中，发生多个线程之间互相谦让，不断发生同一个线程总是拿到同一把锁，在尝试拿另一把锁时因为拿不到，而将本来已经持有的锁释放的过程。</p><p>​ 百度定义：活锁指的是任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。 活锁和<strong>死锁</strong>的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><h3 id="造成死锁的原因"><a href="#造成死锁的原因" class="headerlink" title="造成死锁的原因"></a>造成死锁的原因</h3><p>​ 当一系列封锁不能按照其先后顺序执行时，就可能导致一些事务无限期等待某个封锁，从而导致活锁。</p><h3 id="活锁的解决"><a href="#活锁的解决" class="headerlink" title="活锁的解决"></a>活锁的解决</h3><p>​ 每个线程休眠随机数，错开拿锁的时间。</p><h3 id="活锁重现"><a href="#活锁重现" class="headerlink" title="活锁重现"></a>活锁重现</h3><blockquote><p>还拿我们死锁中转账的业务，也可以使用显示锁来解决</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 活锁</span></span><br><span class="line"><span class="comment"> * 转账业务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoneyDeadlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋 一直尝试到转账成功</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">//先锁住转账的账户</span></span><br><span class="line">            <span class="keyword">if</span> (from.tryLock()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                        <span class="comment">//退出</span></span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (to.tryLock()) &#123;</span><br><span class="line">                            <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">                            sleep(<span class="number">100</span>);</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                from.debit(amount);</span><br><span class="line">                                to.credit(amount);</span><br><span class="line">                                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                                <span class="comment">//转账成功退出自旋</span></span><br><span class="line">                                <span class="keyword">return</span>;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】释放TO锁【"</span> + to.name + <span class="string">"】成功"</span>);</span><br><span class="line">                                to.unLock();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】释放FROM锁【"</span> + from.name + <span class="string">"】锁成功"</span>);</span><br><span class="line">                    from.unLock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//休眠随机数字，避开同时同时拿锁释放锁</span></span><br><span class="line">            <span class="comment">//   sleep(new Random().nextInt(10));</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        <span class="comment">//显示锁</span></span><br><span class="line">        <span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name, <span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">debit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance - amount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">credit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance + amount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试获取锁</span></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> lock.tryLock();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试释放锁</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">unLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 休眠</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//创建账户A</span></span><br><span class="line">        Account A = <span class="keyword">new</span> Account(<span class="string">"A"</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建账户B</span></span><br><span class="line">        Account B = <span class="keyword">new</span> Account(<span class="string">"B"</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//A -&gt; B 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(A, B, <span class="number">5</span>));</span><br><span class="line">        <span class="comment">//B -&gt; A 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(B, A, <span class="number">10</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">线程【<span class="number">13</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】释放FROM锁【B】锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">12</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">12</span>】释放FROM锁【A】锁成功</span><br><span class="line">线程【<span class="number">12</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】释放FROM锁【B】锁成功</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>我们发现 转账没有成功一直在尝试拿锁释放锁，没有做具体的事情，但是也没有阻塞，这就是活锁</p><p>避开活锁很简单休眠一个随机数字,把这行代码解开即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠随机数字，避开同时同时拿锁释放锁</span></span><br><span class="line"> sleep(<span class="keyword">new</span> Random().nextInt(<span class="number">10</span>));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">线程【<span class="number">12</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】释放FROM锁【B】锁成功</span><br><span class="line">线程【<span class="number">12</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">12</span>】从【A】账户转账到【B】账户【<span class="number">5</span>】元钱成功</span><br><span class="line">线程【<span class="number">12</span>】释放TO锁【B】成功</span><br><span class="line">线程【<span class="number">12</span>】释放FROM锁【A】锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】从【B】账户转账到【A】账户【<span class="number">10</span>】元钱成功</span><br><span class="line">线程【<span class="number">13</span>】释放TO锁【A】成功</span><br><span class="line">线程【<span class="number">13</span>】释放FROM锁【B】锁成功</span><br></pre></td></tr></table></figure><p>虽然还有部分尝试拿锁，因为我们休眠了100ms ，但是我们的代码是成功的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ 在开发中应该想办法避免死锁，可以尝试使用显示锁，但是显示锁要小心活锁的产生，一直在尝试拿锁释放锁，不做任何事情。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的活锁
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="并发安全" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="并发安全" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91%E5%AE%89%E5%85%A8/"/>
    
      <category term="活锁" scheme="http://www.baiyp.ren/tags/%E6%B4%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA线程池实现02-提交任务</title>
    <link href="http://www.baiyp.ren/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B002.html"/>
    <id>http://www.baiyp.ren/JAVA线程池实现02.html</id>
    <published>2019-08-21T02:55:59.000Z</published>
    <updated>2019-08-27T02:48:29.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA线程池实现02-提交任务"><a href="#JAVA线程池实现02-提交任务" class="headerlink" title="JAVA线程池实现02-提交任务"></a>JAVA线程池实现02-提交任务</h2><p><img src="../images/threadpoolexecutor03.png" alt></p><h3 id="submit提交任务"><a href="#submit提交任务" class="headerlink" title="submit提交任务"></a>submit提交任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交一个带有返回值的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    <span class="comment">//调用execute进行执行</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个FutureTask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 运行的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 返回结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> FutureTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>流程步骤如下</p><ol><li>调用submit方法，传入Runnable或者Callable对象</li><li>判断传入的对象是否为null，为null则抛出异常，不为null继续流程</li><li>将传入的对象转换为RunnableFuture对象</li><li>执行execute方法，传入RunnableFuture对象</li><li>返回RunnableFuture对象</li></ol></blockquote><p><img src="../images/threadpoolexecutor11.png" alt></p><h3 id="execute-执行线程"><a href="#execute-执行线程" class="headerlink" title="execute 执行线程"></a>execute 执行线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在未来执行任务</span></span><br><span class="line"><span class="comment">    * 任务将新建或者现有的线程池中执行</span></span><br><span class="line"><span class="comment">    * 如果线程池关闭或者线程池满了将执行拒绝策略</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1、运行线程数少于核心线程数，则调用addWorker启动一个新的线程</span></span><br><span class="line"><span class="comment">        *   需要检查否应该添加线程</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="comment">//添加线程</span></span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 运行线程数量大于核心线程数量时，上面的if分支针对大于corePoolSize，并且缓存队列加入任务操作成功的情况。</span></span><br><span class="line"><span class="comment">        *  运行中并且将任务加入缓冲队列成功，正常来说这样已经完成了处理逻辑。</span></span><br><span class="line"><span class="comment">        *  但是为了保险起见，增加了状态出现异常的确认判断，如果状态出现异常会继续remove操作，如果执行true，则按照拒绝处理策略驳回任务；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//线程运行状态，并且添加进队列成功</span></span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="comment">//线程未运行并且删除成功</span></span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               <span class="comment">//拒绝任务</span></span><br><span class="line">               reject(command);</span><br><span class="line">           <span class="comment">//线程正在运行中</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">               <span class="comment">//添加任务</span></span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这里针对运行线程数量超过了corePoolSize，并且缓存队列也已经放满的情况。</span></span><br><span class="line"><span class="comment">        *  注意第二个参数是false，可以在下面addWorker方法看到，就是针对线程池最大线程数量maximumPoolSize的判断。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           <span class="comment">//拒绝任务</span></span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实从上面代码注释中可以看出就三个判断，</p><ol><li>核心线程数是否已满</li><li>队列是否已满</li><li>线程池是否已满</li></ol></blockquote><p><img src="../images/threadpoolexecutor07.png" alt></p><blockquote><ol><li>调用execute方法，传入Runable对象</li><li>判断传入的对象是否为null，为null则抛出异常，不为null继续流程</li><li>获取当前线程池的状态和线程个数变量</li><li>判断当前线程数是否小于核心线程数，是走流程5，否则走流程6</li><li>添加线程数，添加成功则结束，失败则重新获取当前线程池的状态和线程个数变量,</li><li>判断线程池是否处于RUNNING状态，是则添加任务到阻塞队列，否则走流程10，添加任务成功则继续流程7</li><li>重新获取当前线程池的状态和线程个数变量</li><li>重新检查线程池状态，不是运行状态则移除之前添加的任务，有一个false走流程9，都为true则走流程11</li><li>检查线程池线程数量是否为0，否则结束流程，是调用addWorker(null, false)，然后结束</li><li>调用!addWorker(command, false)，为true走流程11，false则结束</li><li>调用拒绝策略reject(command)，结束</li></ol></blockquote><p><img src="../images/threadpoolexecutor08.png" alt></p><h4 id="addWorker-增加工作线程"><a href="#addWorker-增加工作线程" class="headerlink" title="addWorker 增加工作线程"></a>addWorker 增加工作线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core 是否是核心线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前线程池状态是否是SHUTDOWN、STOP、TIDYING或者TERMINATED</span></span><br><span class="line">    <span class="comment">// 且！（当前状态为SHUTDOWN、且传入的任务为null，且队列不为null）</span></span><br><span class="line">    <span class="comment">// 条件都成立则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                        firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        ! workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有一个自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取工作线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 工作线程数 &gt;= 队列容量 返回fasle</span></span><br><span class="line"><span class="comment">             * 如果是核心线程 工作线程数&gt;=核心线程数 返回false</span></span><br><span class="line"><span class="comment">             * 如果不是核心线程 工作线程数&gt;=最大线程数 返回false</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//CAS增加c，成功则跳出retry</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//CAS失败执行下面方法，查看当前线程数是否变化，变化则继续retry循环，没变化则继续内部循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs) &#123;</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//CAS成功</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工作线程状态</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//工作线程添加状态</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个工作线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取重入锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//重新检查线程池状态</span></span><br><span class="line">            <span class="comment">//避免ThreadFactory退出故障或者在锁获取前线程池被关闭</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//再次检查线程池状态 ？？？</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//检查thread的状态</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) &#123; <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//任务列表添加任务</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">//获取任务列表大小</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//最大线程数 计数</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize) &#123;</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//线程添加成功</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断worker是否添加成功，成功则启动线程，然后将workerStarted设置为true</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">//启动状态成功</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//判断线程有没有启动成功，没有则调用addWorkerFailed方法</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted) &#123;</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回任务启动状态</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里可以将addWorker分为两部分，第一部分增加线程池个数，第二部分是将任务添加到workder里面并执行。</p></blockquote><p>第一部分主要是两个循环，外层循环主要是判断线程池状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">              ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty())</span><br></pre></td></tr></table></figure><p>展开！运算后等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               (rs != SHUTDOWN ||</span><br><span class="line">             firstTask != <span class="keyword">null</span> ||</span><br><span class="line">             workQueue.isEmpty())</span><br></pre></td></tr></table></figure><blockquote><p>也就是说下面几种情况下会返回false：</p><ul><li>当前线程池状态为STOP，TIDYING，TERMINATED</li><li>当前线程池状态为SHUTDOWN并且已经有了第一个任务</li><li>当前线程池状态为SHUTDOWN并且任务队列为空</li></ul><p>内层循环作用是使用cas增加线程个数，如果线程个数超限则返回false，否者进行cas，cas成功则退出双循环，否者cas失败了，要看当前线程池的状态是否变化了，如果变了，则重新进入外层循环重新获取线程池状态，否者进入内层循环继续进行cas尝试。</p><p>到了第二部分说明CAS成功了，也就是说线程个数加一了，但是现在任务还没开始执行，这里使用全局的独占锁来控制workers里面添加任务，其实也可以使用并发安全的set，但是性能没有独占锁好（这个从注释中知道的）。这里需要注意的是要在获取锁后重新检查线程池的状态，这是因为其他线程可可能在本方法获取锁前改变了线程池的状态，比如调用了shutdown方法。添加成功则启动任务执行。</p></blockquote><p>所以这里也将流程图分为两部分来描述</p><blockquote><p>第一部分流程图</p></blockquote><p><img src="../images/threadpoolexecutor09.png" alt></p><blockquote><p>第二部分流程图</p></blockquote><p><img src="../images/threadpoolexecutor10.png" alt></p><blockquote><p>这里面有一个核心的工作类 Worker</p></blockquote><h4 id="AQS的Worker工作任务"><a href="#AQS的Worker工作任务" class="headerlink" title="AQS的Worker工作任务"></a>AQS的Worker工作任务</h4><blockquote><p>这个类继承了抽象队列同步器 是标准的AQS线程安全的类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 工作任务对象</span></span><br><span class="line"><span class="comment">    * 继承了AQS 抽象队列同步器 以及 Runnable 接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">        * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Thread this worker is running in.  Null if factory fails.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//正在运行的线程，工厂创建线程失败则为null</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Initial task to run.  Possibly null.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//运行的初始任务，可能为null</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Per-thread task counter</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//完成任务的计数器</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//构造方法</span></span><br><span class="line">       Worker(Runnable firstTask) &#123;</span><br><span class="line">           <span class="comment">//设置状态为未运行</span></span><br><span class="line">           setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">           <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">           <span class="comment">//使用线程工厂创建线程</span></span><br><span class="line">           <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Delegates main run loop to outer runWorker</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//实现Runnable的run方法</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//运行任务方法</span></span><br><span class="line">           runWorker(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Lock methods</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">       <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/*是否是独占的</span></span><br><span class="line"><span class="comment">        * @return 0 未锁 1 已锁定</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 尝试获取占用权</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//CAS 设置锁定状态</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="comment">//设置持有者是当前线程</span></span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 尝试释放锁</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//设置是持有者为null</span></span><br><span class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//设置锁定状态为 未锁定</span></span><br><span class="line">           setState(<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 加锁</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 尝试获取锁</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> tryAcquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           release(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 释放</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> isHeldExclusively();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 中断启动</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Thread t;</span><br><span class="line">           <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   t.interrupt();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个类很值得学习，里面最核心的方法是 runWorker 方法</p></blockquote><h4 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h4><blockquote><p>运行任务的主体，通过循环从阻塞队列中拿任务，进行执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取任务 task</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">//是否突然完成任务(异常，或者其他情况)</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//循环获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            w.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当线程池是处于STOP状态或者TIDYING、TERMINATED状态时，设置当前线程处于中断状态</span></span><br><span class="line">        <span class="comment">// 如果不是，当前线程就处于RUNNING或者SHUTDOWN状态，确保当前线程不处于中断状态</span></span><br><span class="line">        <span class="comment">// 重新检查当前线程池的状态是否大于等于STOP状态</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) &#123;</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程执行前执行一些任务，在ThreadPoolExecutor是空实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//运行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//完成任务后执行一些任务，在ThreadPoolExecutor是空实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//完成任务task置为空，交给GC处理</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//完成任务计数器+1</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 正常完成任务为false</span></span><br><span class="line"><span class="comment">         * 否则completedAbruptly 为true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//整个线程结束时调用，线程退出操作。统计整个线程池完成的任务个数之类的工作</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里面有两个核心方法</p><ul><li><strong>getTask</strong>：从队列中获取任务</li><li><strong>processWorkerExit</strong>：处任务并退出</li></ul></blockquote><p>我们先从getTask开始</p><h5 id="getTask-方法"><a href="#getTask-方法" class="headerlink" title="getTask 方法"></a>getTask 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取待执行的任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最后一次poll()是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程不在运行状态并且队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//使用CAS进行工作任务数-1</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前工作任务数</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否进行任务淘汰 如果 allowCoreThreadTimeOut为true 就一直淘汰下去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">//（当前线程数是否大于最大线程数或者）</span></span><br><span class="line">   <span class="comment">//且（线程数大于1或者任务队列为空）</span></span><br><span class="line">    <span class="comment">//这里有个问题(timed &amp;&amp; timedOut)timedOut = false，好像(timed &amp;&amp; timedOut)一直都是false吧</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//CAS方式进行工作线程-1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果需要淘汰淘汰从工作先队列中在指定keepAliveTime时间内获取一个工作线程否则返回null</span></span><br><span class="line"><span class="comment">             * 否则工作线程池为空就一直等待</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果获取超时设置超时时间为true </span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们分析下processWorkerExit方法</p><h4 id="processWorkerExit-方法"><a href="#processWorkerExit-方法" class="headerlink" title="processWorkerExit 方法"></a>processWorkerExit 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理完成后续的线程统计工作</span></span><br><span class="line"><span class="comment">   * 删除完成工作的线程</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> w 工作线程</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> completedAbruptly 是否突然完成（异常情况）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果突然完成，工作线程数统计未统计</span></span><br><span class="line">      <span class="keyword">if</span> (completedAbruptly) &#123; <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">          <span class="comment">//重新对工作线程数-1</span></span><br><span class="line">          decrementWorkerCount();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取锁</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">      <span class="comment">//加锁</span></span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//完成任务数统计</span></span><br><span class="line">          completedTaskCount += w.completedTasks;</span><br><span class="line">          <span class="comment">//从工作任务队列删除队列</span></span><br><span class="line">          workers.remove(w);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//解锁</span></span><br><span class="line">          mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//尝试终止线程池</span></span><br><span class="line">      tryTerminate();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">//正在运行或者停止</span></span><br><span class="line">      <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">          <span class="comment">//没有突然完成</span></span><br><span class="line">          <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">              <span class="comment">// 计算最小工作线程，如果allowCoreThreadTimeOut为true 就是 0 否则就是核心线程数</span></span><br><span class="line">              <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">              <span class="comment">//如果最小线程为0并且工作任务队列不为空则设置最小线程数为1</span></span><br><span class="line">              <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty()) &#123;</span><br><span class="line">                  min = <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//如果工作线程数&gt;=最小线程数返回</span></span><br><span class="line">              <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                  <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">          &#125;</span><br><span class="line">          addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里为止,submit 和 execute已经分析完成了。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA线程池实现-ThreadPoolExecutor
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://www.baiyp.ren/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式03-观察者模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F03.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式03.html</id>
    <published>2019-08-21T01:42:30.000Z</published>
    <updated>2019-09-05T10:28:29.078Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-观察者模式（Observer-Pattern）"><a href="#JAVA设计模式-观察者模式（Observer-Pattern）" class="headerlink" title="JAVA设计模式-观察者模式（Observer Pattern）"></a>JAVA设计模式-观察者模式（Observer Pattern）</h2><p><img src="../images/design-patterns/observer-pattern01.png" alt></p><h3 id="什么是观察者模式"><a href="#什么是观察者模式" class="headerlink" title="什么是观察者模式"></a>什么是观察者模式</h3><p>​ 当对象间存在一对多关系时，则使用观察者模式（Observer Pattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。观察者模式属于行为型模式。</p><p>​ 定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p><h3 id="观察者角色"><a href="#观察者角色" class="headerlink" title="观察者角色"></a>观察者角色</h3><ul><li><p><strong>抽象被观察者角色：</strong>定义了动态增加、删除以及通知观察者对象的方法，职责就是<strong>管理和通知观察者</strong>。持有观察者对象的集合。</p></li><li><p><strong>具体被观察者角色：</strong>一般继承抽象被观察者，实现自己本身的业务逻辑，当状态发生改变时发起通知。</p></li><li><p><strong>抽象观察者角色：</strong>提供一个接口，定义了观察者收到通知时更新自己的方法。</p></li><li><p><strong>具体观察者角色：</strong>实现抽象观察者接口，处理不同具体观察者的不同业务逻辑。</p></li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li><p>观察者和被观察者是抽象耦合的。</p></li><li><p>建立一套触发机制。</p></li><li><p>对象之间的保持高度的协作。当被观察者发生变化时，所有被观察者都会通知到，然后做出相应的动作。</p></li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li><li>如果观察者太多，被观察者通知观察者消耗的时间很多，影响系统的性能。</li><li>当观察者集合中的某一观察者错误时就会导致系统卡壳，因此一般会采用异步方式。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><blockquote><p>灰太狼具有被观察者属性，喜洋洋这些羊咩咩一直都在观察者灰太狼，所以羊咩咩们是观察者。OK，角色确定了，看看具体是怎么实现的…</p></blockquote><h4 id="抽象被观察者"><a href="#抽象被观察者" class="headerlink" title="抽象被观察者"></a>抽象被观察者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 观察者对象的集合</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observerList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 登记观察者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observerList.add(observer);</span><br><span class="line">        System.out.println(<span class="string">"增加了观察者："</span> + observer.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除观察者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dettach</span><span class="params">(Observer observer)</span> </span>&#123;</span><br><span class="line">        observerList.remove(observer);</span><br><span class="line">        System.out.println(<span class="string">"删除了观察者："</span> + observer.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有观察者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observerList) &#123;</span><br><span class="line">            observer.update(<span class="string">"灰太狼要搞事情了"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建被观察者对象"><a href="#创建被观察者对象" class="headerlink" title="创建被观察者对象"></a>创建被观察者对象</h4><blockquote><p>灰太狼是具体被观察者，继承抽象被观察者</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wolf</span> <span class="keyword">extends</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invade</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"灰太狼：我要搞事情了"</span>);</span><br><span class="line">        <span class="comment">// 通知所有观察者</span></span><br><span class="line">        notifyObserver();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="抽象观察者"><a href="#抽象观察者" class="headerlink" title="抽象观察者"></a>抽象观察者</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知更新方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> msg</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="创建观察者对象"><a href="#创建观察者对象" class="headerlink" title="创建观察者对象"></a>创建观察者对象</h4><blockquote><p>喜羊羊是具体观察者</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PleasantSheep</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"喜羊羊"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 具体业务逻辑</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"喜羊羊收到通知："</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><blockquote><p>接下来看客户端如何把观察者模式跑起来</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 灰太狼--被观察者</span></span><br><span class="line">        Wolf wolf = <span class="keyword">new</span> Wolf();</span><br><span class="line">        <span class="comment">// 喜羊羊--观察者</span></span><br><span class="line">        Observer pleasantSheep = <span class="keyword">new</span> PleasantSheep();</span><br><span class="line">        <span class="comment">// 登记观察者</span></span><br><span class="line">        wolf.attach(pleasantSheep);</span><br><span class="line">        <span class="comment">// 灰太狼入侵</span></span><br><span class="line">        wolf.invade();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">增加了观察者：喜羊羊</span><br><span class="line"></span><br><span class="line">灰太狼：我要搞事情了</span><br><span class="line"></span><br><span class="line">喜羊羊收到通知：灰太狼要搞事情了</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在Java中已经提供了Observable类以及一个Observer接口，也就是说Java已经实现了观察者模式的定义</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之观察者模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="观察者模式" scheme="http://www.baiyp.ren/tags/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA线程池实现01-简介</title>
    <link href="http://www.baiyp.ren/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B001.html"/>
    <id>http://www.baiyp.ren/JAVA线程池实现01.html</id>
    <published>2019-08-20T06:55:59.000Z</published>
    <updated>2019-08-27T02:48:20.553Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA线程池实现01-简介"><a href="#JAVA线程池实现01-简介" class="headerlink" title="JAVA线程池实现01-简介"></a>JAVA线程池实现01-简介</h2><p><img src="../images/threadpoolexecutor06.png" alt></p><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>​ 线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件），则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><h3 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h3><p>操作系统创建线程、切换线程状态、终结线程都要进行CPU调度——这是一个耗费时间和系统资源的事情。</p><p>​ 大多数实际场景中是这样的：处理某一次请求的时间是非常短暂的，但是请求数量是巨大的。这种技术背景下，如果我们为每一个请求都单独创建一个线程，那么物理机的所有资源基本上都被操作系统创建线程、切换线程状态、销毁线程这些操作所占用，用于业务请求处理的资源反而减少了。所以最理想的处理方式是，将处理请求的线程数量控制在一个范围，既保证后续的请求不会等待太长时间，又保证物理机将足够的资源用于请求处理本身。另外，一些操作系统是有最大线程数量限制的。当运行的线程数量逼近这个值的时候，操作系统会变得不稳定。这也是我们要限制线程数量的原因。</p><h4 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h4><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁带来的消耗。</li><li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>：使用线程池可以统一进行线程分配、调度和监控。</li><li><strong>线程统一管理</strong>：线程池具有创建线程和销毁线程的能力，线程集中在一起比起分散开来，更加便于管理</li></ul><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="### 继承关系"></a>### 继承关系</h3><blockquote><p>线程池都继承自Exceutor接口</p></blockquote><p><img src="../images/threadpoolexecutor05.png" alt></p><h4 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h4><blockquote><p>Executor接口只有一个方法execute,传入线程任务参数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h4><blockquote><p>ExecutorService接口继承Executor接口，并增加了submit、shutdown、invokeAll等等一系列方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractExecutorService抽象类"><a href="#AbstractExecutorService抽象类" class="headerlink" title="AbstractExecutorService抽象类"></a>AbstractExecutorService抽象类</h4><blockquote><p>bstractExecutorService抽象类实现ExecutorService接口，并且提供了一些方法的默认实现，例如submit方法、invokeAny方法、invokeAll方法。</p><p>像execute方法、线程池的关闭方法（shutdown、shutdownNow等等）就没有提供默认的实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的分类和作用"><a href="#线程池的分类和作用" class="headerlink" title="线程池的分类和作用"></a>线程池的分类和作用</h3><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><blockquote><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。</p></blockquote><ol><li>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）</li><li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟）</li><li>当线程池中，没有可用线程，会重新创建一个线程</li></ol><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p></blockquote><ol><li>线程池中的线程处于一定的量，可以很好的控制线程的并发量</li><li>线程可以重复被使用，在显示关闭之前，都将一直存在</li><li>超出一定量的线程被提交时候需在队列中等待</li></ol><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><blockquote><p>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p></blockquote><ol><li>线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行</li></ol><h4 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h4><blockquote><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p></blockquote><ol><li>线程池中具有指定数量的线程，即便是空线程也将保留</li><li>可定时或者延迟执行线程活动</li></ol><h4 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h4><blockquote><p>创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。</p></blockquote><ol><li>线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行</li><li>可定时或者延迟执行线程活动</li></ol><h3 id="ThreadPoolExecutor源码分析"><a href="#ThreadPoolExecutor源码分析" class="headerlink" title="ThreadPoolExecutor源码分析"></a>ThreadPoolExecutor源码分析</h3><h4 id="为什么要讲ThreadPoolExector类"><a href="#为什么要讲ThreadPoolExector类" class="headerlink" title="为什么要讲ThreadPoolExector类"></a>为什么要讲ThreadPoolExector类</h4><p>​ Exector是ThreadPoolExector的祖父类接口，ThreadPoolExector的直接父类接口是ExectorService，而我们所讲的第三点，其中的不同线程池的分类其实都是Exector中的方法，而在ThreadPoollExector中得到了实现，所以我们要构建的不同种类的线程池主要还是依赖这个类完成，接下来我们就聚焦ThreadPoolExector来看其具体的实现方法。</p><h4 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h4><p><img src="../images/threadpoolexecutor01.jpg" alt></p><h4 id="成员变量分析"><a href="#成员变量分析" class="headerlink" title="成员变量分析"></a>成员变量分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//记录线程池状态和线程数量（总共32位，前三位表示线程池状态，后29位表示线程数量）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程数量统计位数29  Integer.SIZE=32 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量 000 11111111111111111111111111111</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//运行中 111 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭 000 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//停止 001 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//整理 010 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//终止 011 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取运行状态（获取前3位）</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">   <span class="comment">//获取线程个数（获取后29位）</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存放任务的阻塞队列泛型是Runnable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//可重入锁</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取锁的一个条件</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存放任务Worker 的集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//线程池正在运行的数量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//已完成任务的计数器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//线程工厂，可以手工传入 自己构建线程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//拒接策略</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//默认拒绝策略为AbortPolicy</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//空闲线程等待超时时间</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否允许核心线程超时</span></span><br><span class="line"><span class="comment">    * 默认为 false</span></span><br><span class="line"><span class="comment">    * true 核心线程等待超时后 也将会销毁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 核心池大小 不允许超时</span></span><br><span class="line"><span class="comment">    * 除非allowCoreThreadTimeOut为true 这种情况下可为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//最大线程池大小 最大不超过 CAPACITY</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><blockquote><p>我们也可以看出我们在线程池介绍中谈到的关于coreSize和maxiumSize等参数，这些int值对线程池的中的线程池数量进行了限制，还有一些关于锁ReentrantLock的类，这是一个可重入锁，它的主要目的是锁住其操作，因为线程的操作要保证其原子性，防止冲突发生，所以在其源码中很多都对其进行了上锁操作。还有一个很重要的值的全局的变量state:</p></blockquote><h4 id="线城池的状态"><a href="#线城池的状态" class="headerlink" title="线城池的状态"></a>线城池的状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示正在运行中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//表示关闭</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//表示停止</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//表示整理</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//表示结束</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><blockquote><p>这些状态值是线程池目前所处环境的状态的体现，它采用int数字来表现，记住这些值很重要，因为后面有很多方法调用线程池的运行状态，有很多对其值进行判断。</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime 空闲等待时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue 传入的阻塞队列</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//调用重载的构造方法</span></span><br><span class="line">     <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime 空闲等待时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue 传入的阻塞队列</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="comment">///调用重载的构造方法</span></span><br><span class="line">     <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime 空闲等待时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue 传入的阻塞队列</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler 拒绝策略</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="comment">///调用重载的构造方法</span></span><br><span class="line">     <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime 空闲等待时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue 传入的阻塞队列</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler 拒绝策略</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//条件校验，不满足抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">             maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">             maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">             keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="comment">// 阻塞队列，线程工厂，拒绝策略不允许为空</span></span><br><span class="line">     <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">//java安全模式</span></span><br><span class="line">     <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">             <span class="keyword">null</span> :</span><br><span class="line">             AccessController.getContext();</span><br><span class="line">     <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">     <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">     <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">     <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">     <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">     <span class="keyword">this</span>.handler = handler;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看出ThreadPoolExector一共有四个构造函数，但是最后调用的都是最后一个，我们可以只看最后一个，它主要有核心池大小、最大池大小、存活时间、时间单位、阻塞队列、线程工厂这几个参数，其中又对其进行了值范围的检查，如果参数违法就抛出异常，然后构造进去。关于这几个参数，随着后面我们对其方法的讲解，会理解越来越深刻的。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA线程池实现-ThreadPoolExecutor
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://www.baiyp.ren/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://www.baiyp.ren/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.html"/>
    <id>http://www.baiyp.ren/布隆过滤器.html</id>
    <published>2019-08-20T06:23:36.000Z</published>
    <updated>2019-09-05T09:20:31.214Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><img src="../images/bloomfilter01.gif" alt></p><h3 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h3><blockquote><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://baike.baidu.com/item/二进制/361457" rel="external nofollow noopener noreferrer" target="_blank">二进制</a>向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p></blockquote><p>​ 布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p><p>​ 当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。打个比方，当它说不认识你时，肯定就不认识；当它说见过你时，可能根本就没见过面，不过因为你的脸跟它认识的人中某脸比较相似 (某些熟脸的系数组合)，所以误判以前见过你。<br>套在上面的使用场景中，布隆过滤器能准确过滤掉那些已经看过的内容，那些没有看过的新内容，它也会过滤掉极小一部分 (误判)，但是绝大多数新内容它都能准确识别。这样就可以完全保证推荐给用户的内容都是无重复的。</p><h3 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h3><p>​ 其本质就是一个只包含0和1的数组。具体操作当一个元素被加入到集合里面后，该元素通过K个Hash函数运算得到K个hash后的值，然后将K个值映射到这个位数组对应的位置，把对应位置的值设置为1。查询是否存在时，我们就看对应的映射点位置如果全是1，他就很可能存在（跟hash函数的个数和hash函数的设计有关），如果有一个位置是0，那这个元素就一定不存在。</p><p><img src="../images/bloomfilter02.jpg" alt></p><ol><li><p>首先需要初始化一个<strong>二进制的数组，长度设为 L</strong>，同时初始值全为 0 。</p></li><li><p>当<strong>写入一个 A1=1000 的数据时，需要</strong>进行 H 次 hash 函数的运算<strong>（这里为 2 次）；与 HashMap 有点类似，通过</strong>算出的 HashCode 与 L 取模后定位到 0、2 处，将该处的值设为 1。</p></li><li><p>A2=2000 也是同理计算后将 4、7 位置设为 1。</p></li><li><p>当有一个 B1=1000 需要判断是否存在时，也是做两次 Hash 运算，定位到 0、2 处，此时他们的值都为 1 ，所以认为 B1=1000 存在于集合中。</p></li><li><p>当有一个 B2=3000 时，也是同理。第一次 Hash 定位到 index=4 时，数组中的值为 1，所以再进行第二次 Hash 运算，结果定位到 index=5 的值为 0，所以认为 B2=3000 不存在于集合中。</p></li></ol><p>整个的写入、查询的流程就是这样，汇总起来就是：</p><blockquote><p>对写入的数据做 H 次 hash 运算定位到数组中的位置，同时将数据改为 1 。当有数据查询时也是同样的方式定位到数组中。一旦其中的有一位为 0 则认为数据肯定不存在于集合，否则数据可能存在于集合中。</p></blockquote><h3 id="布隆过滤器的特点"><a href="#布隆过滤器的特点" class="headerlink" title="布隆过滤器的特点"></a>布隆过滤器的特点</h3><p><strong>只要返回数据不存在，则肯定不存在</strong>。</p><p><strong>返回数据存在，但只能是大概率存在</strong>。</p><p>同时<strong>不能清除</strong>其中的数据。</p><p>在有限的数组长度中存放大量的数据，即便是<strong>再完美的 Hash 算法也会有冲突，所以有可能两个完全不同的 A、B 两个数据最后定位到的位置是一模一样的</strong>。</p><p>删除数据也是同理，当我把 B 的数据删除时，其实也相当于是把 A 的数据删掉了，这样也会造成后续的误报。</p><p>基于以上的 Hash 冲突的前提，所以 Bloom Filter 有一定的误报率，这个误报率和 Hash 算法的次数 H，以及数组长度 L 都是有关的。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>​ 我们经常会把一部分数据放在Redis等缓存，比如产品详情。这样有查询请求进来，我们可以根据产品Id直接去缓存中取数据，而不用读取数据库，这是提升性能最简单，最普遍，也是最有效的做法。一般的查询请求流程是这样的：先查缓存，有缓存的话直接返回，如果缓存中没有，再去数据库查询，然后再把数据库取出来的数据放入缓存，一切看起来很美好。但是如果现在有大量请求进来，而且都在请求一个不存在的产品Id，会发生什么？既然产品Id都不存在，那么肯定没有缓存，没有缓存，那么大量的请求都怼到数据库，数据库的压力一下子就上来了，还有可能把数据库打死。</p><p>​ 使用布隆过滤器的特点，<strong>只要返回数据不存在，则肯定不存在，返回数据存在，但只能是大概率存在</strong>，这种特点可以大批量的无效请求过滤掉，能够穿透缓存的知识漏网之鱼，无关紧要。</p><h4 id="检查单词拼写"><a href="#检查单词拼写" class="headerlink" title="检查单词拼写"></a>检查单词拼写</h4><p>​ 检查一个单词拼写是否正确，因为有海量的单词数量，每天可能有新的单词，使用布隆过滤器，可以将单词映射到很小的内存中，可以经过简单的几次hash运行就可以进行校验，<strong>只要返回数据不存在，则肯定不存在，返回数据存在，但只能是大概率存在</strong>，虽然可能有误报，但是对系统的提升是革命性的。</p><h3 id="Guava的布隆过滤器"><a href="#Guava的布隆过滤器" class="headerlink" title="Guava的布隆过滤器"></a>Guava的布隆过滤器</h3><blockquote><p>这就又要提起我们的Guava了，它是Google开源的Java包，提供了很多常用的功能。</p><p>Guava中，布隆过滤器的实现主要涉及到2个类，BloomFilter和BloomFilterStrategies，首先来看一下BloomFilter的成员变量。需要注意的是不同Guava版本的BloomFilter实现不同。</p></blockquote><h4 id="布隆过滤器解析"><a href="#布隆过滤器解析" class="headerlink" title="布隆过滤器解析"></a>布隆过滤器解析</h4><h5 id="成员变量分析"><a href="#成员变量分析" class="headerlink" title="成员变量分析"></a>成员变量分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** guava实现的以CAS方式设置每个bit位的bit数组 */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> LockFreeBitArray bits;</span><br><span class="line"> <span class="comment">/** hash函数的个数 */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numHashFunctions;</span><br><span class="line"> <span class="comment">/** guava中将对象转换为byte的通道 */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Funnel&lt;? <span class="keyword">super</span> T&gt; funnel;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将byte转换为n个bit的策略，也是bloomfilter hash映射的具体实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Strategy strategy;</span><br></pre></td></tr></table></figure><p>这是它的4个成员变量:</p><ul><li><p>LockFreeBitArray是定义在<code>BloomFilterStrategies</code>中的内部类，封装了布隆过滤器底层bit数组的操作。</p></li><li><p>numHashFunctions表示哈希函数的个数。</p></li><li><p>Funnel，它和PrimitiveSink配套使用，能将任意类型的对象转化成Java基本数据类型，默认用java.nio.ByteBuffer实现，最终均转化为byte数组。</p></li><li><p>Strategy是定义在BloomFilter类内部的接口，代码如下，主要有2个方法，put和mightContain。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 设置元素 */</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits)</span></span>;</span><br><span class="line">    <span class="comment">/** 判断元素是否存在*/</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits)</span></span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>创建布隆过滤器，<strong>BloomFilter</strong>并没有公有的构造函数，只有一个私有构造函数，而对外它提供了5个重载的<strong>create</strong>方法，在缺省情况下误判率设定为3%，采用<strong>BloomFilterStrategies.MURMUR128_MITZ_64</strong>的实现。</p><p><strong>BloomFilterStrategies.MURMUR128_MITZ_64</strong>是Strategy的两个实现之一，Guava以枚举的方式提供这两个实现，这也是《Effective Java》书中推荐的提供对象的方法之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BloomFilterStrategies implements BloomFilter.Strategy &#123;</span><br><span class="line">    MURMUR128_MITZ_32() &#123;<span class="comment">//....&#125;</span></span><br><span class="line">    MURMUR128_MITZ_64() &#123;<span class="comment">//....&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 二者对应了32位哈希映射函数，和64位哈希映射函数，后者使用了murmur3 hash生成的所有128位，具有更大的空间，不过原理是相通的，我们选择相对简单的<strong>MURMUR128_MITZ_32</strong>来分析。</p><p>先来看一下它的put方法，它用两个hash函数来模拟多个hash函数的情况，这是布隆过滤器的一种优化。</p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line">    <span class="comment">// 先利用murmur3 hash对输入的funnel计算得到128位的哈希值，funnel现将object转换为byte数组，</span></span><br><span class="line">    <span class="comment">// 然后在使用哈希函数转换为long</span></span><br><span class="line">    <span class="keyword">long</span> hash64 = Hashing.murmur3_128().hashObject(object, funnel).asLong();</span><br><span class="line">    <span class="comment">// 根据hash值的高低位算出hash1和hash2</span></span><br><span class="line">    <span class="keyword">int</span> hash1 = (<span class="keyword">int</span>) hash64;</span><br><span class="line">    <span class="keyword">int</span> hash2 = (<span class="keyword">int</span>) (hash64 &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> bitsChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 循环体内采用了2个函数模拟其他函数的思想,相当于每次累加hash2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numHashFunctions; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">    <span class="comment">// 如果是负数就变为正数</span></span><br><span class="line">    <span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        combinedHash = ~combinedHash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过基于bitSize取模的方式获取bit数组中的索引，然后调用set函数设置。</span></span><br><span class="line">    bitsChanged |= bits.set(combinedHash % bitSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitsChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在put方法中，先是将索引位置上的二进制置为1，然后用bitsChanged记录插入结果，如果返回true表明没有重复插入成功，而mightContain方法则是将索引位置上的数值取出，并判断是否为0，只要其中出现一个0，那么立即判断为不存在。</p><h5 id="mightContain方法"><a href="#mightContain方法" class="headerlink" title="mightContain方法"></a>mightContain方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line">    <span class="keyword">long</span> hash64 = Hashing.murmur3_128().hashObject(object, funnel).asLong();</span><br><span class="line">    <span class="keyword">int</span> hash1 = (<span class="keyword">int</span>) hash64;</span><br><span class="line">    <span class="keyword">int</span> hash2 = (<span class="keyword">int</span>) (hash64 &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numHashFunctions; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">    <span class="comment">// Flip all the bits if it's negative (guaranteed positive number)</span></span><br><span class="line">    <span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        combinedHash = ~combinedHash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和put的区别就在这里，从set转换为get，来判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!bits.get(combinedHash % bitSize)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Guava为了提供效率，自己实现了LockFreeBitArray来提供bit数组的无锁设置和读取。我们只来看一下它的put函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">boolean set(long bitIndex) &#123;</span><br><span class="line">    if (get(bitIndex)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int longIndex = (int) (bitIndex &gt;&gt;&gt; LONG_ADDRESSABLE_BITS);</span><br><span class="line">    long mask = 1L &lt;&lt; bitIndex; // only cares about low 6 bits of bitIndex</span><br><span class="line"></span><br><span class="line">    long oldValue;</span><br><span class="line">    long newValue;</span><br><span class="line">    // 经典的CAS自旋重试机制</span><br><span class="line">    do &#123;</span><br><span class="line">    oldValue = data.get(longIndex);</span><br><span class="line">    newValue = oldValue | mask;</span><br><span class="line">    if (oldValue == newValue) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; while (!data.compareAndSet(longIndex, oldValue, newValue));</span><br><span class="line"></span><br><span class="line">    bitCount.increment();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Guava布隆过滤器使用"><a href="#Guava布隆过滤器使用" class="headerlink" title="Guava布隆过滤器使用"></a>Guava布隆过滤器使用</h4><h5 id="引入坐标"><a href="#引入坐标" class="headerlink" title="引入坐标"></a>引入坐标</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;28.0-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaBloomFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置布隆过滤器大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">100000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个BloomFilter</span></span><br><span class="line"><span class="comment">     *  第一个参数Funnel类型的参数</span></span><br><span class="line"><span class="comment">     *  第二个参数 期望处理的数据量</span></span><br><span class="line"><span class="comment">     *  第三个参数 误判率 可不加，默认 0.03D</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//成功计数</span></span><br><span class="line">        <span class="keyword">float</span> success = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//失败计数</span></span><br><span class="line">        <span class="keyword">float</span> fial = <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; stringSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//生成随机字符串</span></span><br><span class="line">            String randomStr = RandomStringUtils.randomNumeric(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//加入到set中</span></span><br><span class="line">            stringSet.add(randomStr);</span><br><span class="line">            <span class="comment">//加入到布隆过滤器</span></span><br><span class="line">            bloomFilter.put(randomStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//生成随机字符串</span></span><br><span class="line">            String randomStr = RandomStringUtils.randomNumeric(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//布隆过滤器校验存在</span></span><br><span class="line">            <span class="keyword">if</span> (bloomFilter.mightContain(randomStr)) &#123;</span><br><span class="line">                <span class="comment">//set中存在</span></span><br><span class="line">                <span class="keyword">if</span> (stringSet.contains(randomStr)) &#123;</span><br><span class="line">                    <span class="comment">//成功计数</span></span><br><span class="line">                    success++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//失败计数</span></span><br><span class="line">                    fial++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//布隆过滤器校验不存在</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//    set中存在</span></span><br><span class="line">                <span class="keyword">if</span> (stringSet.contains(randomStr)) &#123;</span><br><span class="line">                    <span class="comment">//失败计数</span></span><br><span class="line">                    fial++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//成功计数</span></span><br><span class="line">                    success++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"判断成功数："</span>+success + <span class="string">"，判断失败数:"</span> + fial + <span class="string">"，误判率:"</span> + fial / <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断成功数：<span class="number">97084.0</span>，判断失败数:<span class="number">2916.0</span>，误判率:<span class="number">0.02916</span></span><br></pre></td></tr></table></figure><p>可以通过增加误判率的参数来调整误判率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个BloomFilter</span></span><br><span class="line"><span class="comment"> *  第一个参数Funnel类型的参数</span></span><br><span class="line"><span class="comment"> *  第二个参数 期望处理的数据量</span></span><br><span class="line"><span class="comment"> *  第三个参数 误判率 可不加，默认 0.03D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), size,<span class="number">0.00001</span>);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断成功数：<span class="number">100000.0</span>，判断失败数:<span class="number">0.0</span>，误判率:<span class="number">0.0</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      布隆过滤器(BloomFilter)的使用以及原理
    
    </summary>
    
      <category term="架构" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="布隆过滤器" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
    
      <category term="架构" scheme="http://www.baiyp.ren/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="布隆过滤器" scheme="http://www.baiyp.ren/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="BloomFilter" scheme="http://www.baiyp.ren/tags/BloomFilter/"/>
    
  </entry>
  
  <entry>
    <title>JAVA阻塞队列实现</title>
    <link href="http://www.baiyp.ren/JAVA%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://www.baiyp.ren/JAVA阻塞队列实现.html</id>
    <published>2019-08-19T06:55:59.000Z</published>
    <updated>2019-08-22T02:10:10.403Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Thu Sep 05 2019 18:32:42 GMT+0800 (GMT+08:00) --><h2 id="JAVA阻塞队列实现"><a href="#JAVA阻塞队列实现" class="headerlink" title="JAVA阻塞队列实现"></a>JAVA阻塞队列实现</h2><p><img src="../images/blockingqueue01.png" alt></p><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>​ 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><blockquote><p>队列的特点是：<strong>先进先出（FIFO）</strong></p></blockquote><h3 id="BlockingQueue的方法"><a href="#BlockingQueue的方法" class="headerlink" title="BlockingQueue的方法"></a>BlockingQueue的方法</h3><blockquote><p>阻塞队列提供了四种处理方法:</p></blockquote><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td><strong>插入</strong></td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td><strong>移除</strong></td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td><strong>检查</strong></td><td>remove()</td><td>peek()</td><td><em>不可用</em></td><td><em>不可用</em></td></tr></tbody></table><ol><li>抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li><li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li></ol><h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><blockquote><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列，遵循FIFO原则。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列，遵循FIFO原则，默认和最大长度为Integer.MAX_VALUE。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的支持延时无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul></blockquote><p><strong>有界</strong>：有初始化最大长度，达到最大程度继续添加要莫阻塞，要莫抛出异常</p><p><strong>无界</strong>：没有初始化最大长度，能够一直添加，不会阻塞或抛出异常，一直到OOM。</p><blockquote><p>因为阻塞队列实现都差不多，我们就拿ArrayBlockingQueue来看下实现</p></blockquote><h3 id="ArrayBlockingQueue结构"><a href="#ArrayBlockingQueue结构" class="headerlink" title="ArrayBlockingQueue结构"></a>ArrayBlockingQueue结构</h3><p><img src="../images/blockingqueue02.gif" alt></p><blockquote><p>阻塞队列的实现都差不多，我们就拿ArrayBlockingQueue 来举例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//底层数据结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> E[] items;</span><br><span class="line"><span class="comment">//用来为下一个take/poll/remove的索引（出队）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//用来为下一个put/offer/add的索引（入队）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//队列中元素的个数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的可重入锁</span></span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非空的条件</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非满的条件</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创造一个队列，指定队列容量，默认模式为非公平模式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> capacity &lt;1会抛异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayBlockingQueue 的构造方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> capacity 初始化大小 默认Integer</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fair     是否使用公平锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//指定大小&lt;=0 抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//初始化数组的大小</span></span><br><span class="line">       <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">       <span class="comment">//创建可重入锁</span></span><br><span class="line">       lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">       <span class="comment">//创建非空条件</span></span><br><span class="line">       notEmpty = lock.newCondition();</span><br><span class="line">       <span class="comment">//创建非满条件</span></span><br><span class="line">       notFull = lock.newCondition();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><h4 id="offer不阻塞添加"><a href="#offer不阻塞添加" class="headerlink" title="offer不阻塞添加"></a>offer不阻塞添加</h4><blockquote><p>在队尾插入一个元素， 如果队列没满，立即返回true； 如果队列满了，立即返回false</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队尾插入一个元素，</span></span><br><span class="line"><span class="comment"> * 如果队列没满，立即返回true；</span></span><br><span class="line"><span class="comment"> * 如果队列满了，立即返回false</span></span><br><span class="line"><span class="comment"> * 注意：该方法通常优于add(),因为add()失败直接抛异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查非空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//队列满了</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//队列没有满</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer等待超时阻塞添加"><a href="#offer等待超时阻塞添加" class="headerlink" title="offer等待超时阻塞添加"></a>offer等待超时阻塞添加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队尾插入一个元素,如果数组已满，则进入等待，直到出现以下三种情况：</span></span><br><span class="line"><span class="comment"> *  1、被唤醒</span></span><br><span class="line"><span class="comment"> *  2、等待时间超时</span></span><br><span class="line"><span class="comment"> *  3、当前线程被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 需要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//检查非空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//计算等待时间</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//可中断锁加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//队列满</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="comment">//如果超时返回fasle</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 进行等待：</span></span><br><span class="line"><span class="comment">             * 在这个过程中可能发生三件事：</span></span><br><span class="line"><span class="comment">             * 1、被唤醒--&gt;继续当前这个for(;;)循环</span></span><br><span class="line"><span class="comment">             * 2、超时--&gt;继续当前这个for(;;)循环</span></span><br><span class="line"><span class="comment">             * 3、被中断--&gt;之后直接执行catch部分的代码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put阻塞添加"><a href="#put阻塞添加" class="headerlink" title="put阻塞添加"></a>put阻塞添加</h4><blockquote><p>在队尾插入一个元素，如果队列满了，一直阻塞，直到数组不满了或者线程被中断</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队尾插入一个元素</span></span><br><span class="line"><span class="comment"> * 如果队列满了，一直阻塞，直到数组不满了或者线程被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//检查非空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//可中断锁-加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//队列满了 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用的lock.lockInterruptibly() ,当前线程如果调用了Thread.interrupt()方法，那么lockInterruptible()判断的Thread.interrupted()聚会成立，就会抛出异常，其实就是线程中断，该方法就抛出异常。</p></blockquote><h4 id="enqueue入队操作"><a href="#enqueue入队操作" class="headerlink" title="enqueue入队操作"></a>enqueue入队操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队操作</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> x 需要入队的袁旭</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="comment">//putIndex 默认为队列数据的长度</span></span><br><span class="line">      items[putIndex] = x;</span><br><span class="line">      <span class="comment">//队列满了重置为0 从头开始</span></span><br><span class="line">      <span class="keyword">if</span> (++putIndex == items.length) &#123;</span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//统计数字+1</span></span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">//非空的条件阻塞的线程唤醒</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>队列没满items[putIndex] = data;达到数组长度重置putIndex，达到环形队列目的</p></blockquote><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><h4 id="poll非阻塞出队"><a href="#poll非阻塞出队" class="headerlink" title="poll非阻塞出队"></a>poll非阻塞出队</h4><blockquote><p>如果没有元素，直接返回null；如果有元素，将队头元素置null，但是要注意队头是随时变化的，并非一直是items[0]。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 出队</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//队列为空返回努力了,否则出队操作</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="poll-等待超时阻塞出队"><a href="#poll-等待超时阻塞出队" class="headerlink" title="poll 等待超时阻塞出队"></a>poll 等待超时阻塞出队</h4><blockquote><p>从对头删除一个元素，如果数组不空，出队；如果数组已空且已经超时，返回null；如果数组已空且时间未超时，则进入等待，直到出现以下三种情况：</p><ul><li>被唤醒</li><li>等待时间超时</li><li>当前线程被中断</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待超时出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出队的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//计算等待时间</span></span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//可中断锁</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//队列为空</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待时间到了还未没有元素返回null</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 进行等待：</span></span><br><span class="line"><span class="comment">                 * 在这个过程中可能发生三件事：</span></span><br><span class="line"><span class="comment">                 * 1、被唤醒--&gt;继续当前这个for(;;)循环</span></span><br><span class="line"><span class="comment">                 * 2、超时--&gt;继续当前这个for(;;)循环</span></span><br><span class="line"><span class="comment">                 * 3、被中断--&gt;之后直接执行catch部分的代码</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出队</span></span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="take阻塞移除"><a href="#take阻塞移除" class="headerlink" title="take阻塞移除"></a>take阻塞移除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 阻塞移除操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回移除的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       <span class="comment">//可中断锁</span></span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//如果元素为空就阻塞</span></span><br><span class="line">           <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//非空阻塞</span></span><br><span class="line">               notEmpty.await();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//出队操作</span></span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//解锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="dequeue出队操作"><a href="#dequeue出队操作" class="headerlink" title="dequeue出队操作"></a>dequeue出队操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回出队的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//获取第takeIndex个元素</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//删除元素，让GC进行回收</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//takeIndex+1 如果移除到最后一个元素 重置为0 从头开始</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) &#123;</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计长度-1</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//元素</span></span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列不满了唤醒非满线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="延时队列-DelayQueue"><a href="#延时队列-DelayQueue" class="headerlink" title="延时队列 DelayQueue"></a>延时队列 DelayQueue</h4><blockquote><p>在我们的业务中通常会有一些需求是这样的</p><ul><li>淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。</li><li>饿了吗订餐通知:下单成功后60s之后给用户发送短信通知。</li><li>缓存系统，如果key到期了取出来删除</li></ul></blockquote><p>那么这类业务我们可以总结出一个特点:需要延迟工作。<br>由此的情况，就是我们的DelayQueue应用需求的产生。</p><blockquote><p>看一个简单的例子</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(<span class="keyword">int</span> delayedTime, TimeUnit unit, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayedTime = delayedTime;</span><br><span class="line">        <span class="comment">//计算到期时间</span></span><br><span class="line">        <span class="keyword">this</span>.expireTime = System.currentTimeMillis() + (delayedTime &gt; <span class="number">0</span> ? unit.toMillis(delayedTime) : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//延时时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> delayedTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 到期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列需要演示获取水煎</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expireTime - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对比，将延时比较小的放在前面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">        <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ((d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"出队，延时:"</span>+delayedTime+<span class="string">",消息："</span>+message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        DelayQueue&lt;DelayedTask&gt; delayedTasks = <span class="keyword">new</span> DelayQueue&lt;DelayedTask&gt;();</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//生成随机消息</span></span><br><span class="line">                String randomStr = RandomStringUtils.randomNumeric(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">//生成随机数</span></span><br><span class="line">                <span class="keyword">int</span> randomTime = random.nextInt(<span class="number">10</span>);</span><br><span class="line">                DelayedTask task = <span class="keyword">new</span> DelayedTask(randomTime, TimeUnit.SECONDS, randomStr);</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                delayedTasks.add(task);</span><br><span class="line">                System.out.println(<span class="string">"入队，消息："</span> + randomStr + <span class="string">"延时："</span> + randomTime + <span class="string">"秒"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                DelayedTask task = delayedTasks.take();</span><br><span class="line">                System.out.println(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//显示时间进度</span></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">float</span> time = <span class="number">0F</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(time+<span class="string">"秒"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                time += <span class="number">0.5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0</span>秒</span><br><span class="line">入队，消息：<span class="number">8675326967</span>延时：<span class="number">5</span>秒</span><br><span class="line"><span class="number">0.5</span>秒</span><br><span class="line">入队，消息：<span class="number">8861554454</span>延时：<span class="number">0</span>秒</span><br><span class="line">出队，延时:<span class="number">0</span>,消息：<span class="number">8861554454</span></span><br><span class="line"><span class="number">1.0</span>秒</span><br><span class="line"><span class="number">1.5</span>秒</span><br><span class="line">入队，消息：<span class="number">9123579697</span>延时：<span class="number">1</span>秒</span><br><span class="line"><span class="number">2.0</span>秒</span><br><span class="line"><span class="number">2.5</span>秒</span><br><span class="line">出队，延时:<span class="number">1</span>,消息：<span class="number">9123579697</span></span><br><span class="line">入队，消息：<span class="number">5909478713</span>延时：<span class="number">6</span>秒</span><br><span class="line"><span class="number">3.0</span>秒</span><br><span class="line"><span class="number">3.5</span>秒</span><br><span class="line">入队，消息：<span class="number">6287328130</span>延时：<span class="number">0</span>秒</span><br><span class="line">出队，延时:<span class="number">0</span>,消息：<span class="number">6287328130</span></span><br><span class="line"><span class="number">4.0</span>秒</span><br><span class="line"><span class="number">4.5</span>秒</span><br><span class="line">出队，延时:<span class="number">5</span>,消息：<span class="number">8675326967</span></span><br><span class="line">入队，消息：<span class="number">4056656965</span>延时：<span class="number">7</span>秒</span><br><span class="line"><span class="number">5.0</span>秒</span><br><span class="line"><span class="number">5.5</span>秒</span><br><span class="line">入队，消息：<span class="number">8250385270</span>延时：<span class="number">9</span>秒</span><br><span class="line"><span class="number">6.0</span>秒</span><br><span class="line"><span class="number">6.5</span>秒</span><br><span class="line">入队，消息：<span class="number">1949026689</span>延时：<span class="number">1</span>秒</span><br><span class="line"><span class="number">7.0</span>秒</span><br><span class="line"><span class="number">7.5</span>秒</span><br><span class="line">出队，延时:<span class="number">1</span>,消息：<span class="number">1949026689</span></span><br><span class="line">入队，消息：<span class="number">2952840210</span>延时：<span class="number">9</span>秒</span><br><span class="line"><span class="number">8.0</span>秒</span><br><span class="line"><span class="number">8.5</span>秒</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><ul><li>ArrayBlockingQueue是有界的阻塞队列，不接受null</li><li>底层数据接口是数组，下标putIndex/takeIndex，构成一个环形FIFO队列</li><li>所有的增删改查数组公用了一把锁ReentrantLock，入队和出队数组下标和count变更都是靠这把锁来维护安全的。</li><li>阻塞的场景：1获取lock锁，2进入和取出还要满足condition 满了或者空了都等待出队和加入唤醒，ArrayBlockingQueue我们主要是put和take真正用到的阻塞方法（条件不满足）。</li><li>成员cout /putIndex、takeIndex是共享的,所以一些查询方法size、peek、toString、方法也是加上锁保证线程安全，但没有了并发损失了性能。</li><li>remove(Object obj) 返回了第一个equals的Object</li></ul></blockquote><h4 id="三种入队对比"><a href="#三种入队对比" class="headerlink" title="三种入队对比"></a>三种入队对比</h4><ul><li>offer(E e)：如果队列没满，立即返回true； 如果队列满了，立即返回false–&gt;不阻塞</li><li>put(E e)：如果队列满了，一直阻塞，直到数组不满了或者线程被中断–&gt;阻塞</li><li>offer(E e, long timeout, TimeUnit unit)：在队尾插入一个元素,，如果数组已满，则进入等待，直到出现以下三种情况：–&gt;阻塞<ul><li>被唤醒</li><li>等待时间超时</li><li>当前线程被中断</li></ul></li></ul><h4 id="三种出对对比"><a href="#三种出对对比" class="headerlink" title="三种出对对比"></a>三种出对对比</h4><ul><li>poll()：如果没有元素，直接返回null；如果有元素，出队</li><li>take()：如果队列空了，一直阻塞，直到数组不为空或者线程被中断–&gt;阻塞</li><li>poll(long timeout, TimeUnit unit)：如果数组不空，出队；如果数组已空且已经超时，返回null；如果数组已空且时间未超时，则进入等待，直到出现以下三种情况：<ul><li>被唤醒</li><li>等待时间超时</li><li>当前线程被中断</li></ul></li></ul><h4 id="等待通知模式"><a href="#等待通知模式" class="headerlink" title="等待通知模式"></a>等待通知模式</h4><blockquote><p>这里面要理解<strong>等待/通知</strong>模式</p></blockquote><p>阻塞队列使用了等待/通知的设计模式</p><h5 id="标准范式"><a href="#标准范式" class="headerlink" title="标准范式"></a>标准范式</h5><blockquote><p>等待方</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//等待方</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (条件) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo 业务代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通知方</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo 改变数据</span></span><br><span class="line">    condition.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h4><h5 id="标准范式-1"><a href="#标准范式-1" class="headerlink" title="标准范式"></a>标准范式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">wait</span><span class="params">(<span class="keyword">long</span> time, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到期时间</span></span><br><span class="line">    <span class="keyword">long</span> duration = timeUnit.toMillis(time);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            duration += System.currentTimeMillis();</span><br><span class="line">            condition.await(time, timeUnit);</span><br><span class="line">            duration -= System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo 业务代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA阻塞队列实现-ArrayBlockingQueue
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="http://www.baiyp.ren/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
      <category term="ArrayBlockingQueue" scheme="http://www.baiyp.ren/tags/ArrayBlockingQueue/"/>
    
  </entry>
  
</feed>
