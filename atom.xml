<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓风残月的博客</title>
  
  <subtitle>晓风残月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baiyp.ren/"/>
  <updated>2019-08-28T10:16:25.687Z</updated>
  <id>http://www.baiyp.ren/</id>
  
  <author>
    <name>晓风残月</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA中的死锁</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E6%AD%BB%E9%94%81.html"/>
    <id>http://www.baiyp.ren/JAVA中的死锁.html</id>
    <published>2019-08-28T07:33:17.000Z</published>
    <updated>2019-08-28T10:16:25.687Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的死锁"><a href="#JAVA中的死锁" class="headerlink" title="JAVA中的死锁"></a>JAVA中的死锁</h2><p><img src="../images/deadlock01.png" alt></p><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>​ 在多线程环境中，多个进程可以竞争有限数量的资源。当一个进程申请资源时，如果这时没有可用资源，那么这个进程进入等待状态。有时，如果所申请的资源被其他等待进程占有，那么该等待进程有可能再也无法改变状态。这种情况称为<strong>死锁</strong></p><p>​ 在Java中使用多线程，就会<strong>有可能导致死锁</strong>问题。死锁会让程序一直<strong>卡</strong>住，不再程序往下执行。我们只能通过<strong>中止并重启</strong>的方式来让程序重新执行。</p><h3 id="造成死锁的原因"><a href="#造成死锁的原因" class="headerlink" title="造成死锁的原因"></a>造成死锁的原因</h3><ul><li>当前线程<strong>拥有其他线程需要的</strong>资源</li><li>当前线程<strong>等待其他线程已拥有</strong>的资源</li><li><strong>都不放弃</strong>自己拥有的资源</li></ul><h3 id="死锁的必要条件"><a href="#死锁的必要条件" class="headerlink" title="死锁的必要条件"></a>死锁的必要条件</h3><h4 id="互斥"><a href="#互斥" class="headerlink" title="互斥"></a>互斥</h4><p>​ 进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</p><h4 id="不可剥夺"><a href="#不可剥夺" class="headerlink" title="不可剥夺"></a>不可剥夺</h4><p>​ 进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放)。</p><h4 id="请求与保持"><a href="#请求与保持" class="headerlink" title="请求与保持"></a>请求与保持</h4><p>​ 进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</p><h4 id="循环等待"><a href="#循环等待" class="headerlink" title="循环等待"></a>循环等待</h4><p>​ 是指进程发生死锁后，必然存在一个进程–资源之间的环形链，通俗讲就是你等我的资源，我等你的资源，大家一直等。</p><h3 id="死锁的分类"><a href="#死锁的分类" class="headerlink" title="死锁的分类"></a>死锁的分类</h3><h4 id="静态顺序型死锁"><a href="#静态顺序型死锁" class="headerlink" title="静态顺序型死锁"></a>静态顺序型死锁</h4><blockquote><p>线程之间形成相互等待资源的环时，就会形成顺序死锁lock-ordering deadlock，多个线程试图以不同的顺序来获取相同的锁时，容易形成顺序死锁，如果所有线程以固定的顺序来获取锁，就不会出现顺序死锁问题</p></blockquote><p>​ 经典案例是LeftRightDeadlock，两个方法，分别是leftRigth、rightLeft。如果一个线程调用leftRight，另一个线程调用rightLeft，且两个线程是交替执行的，就会发生死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LeftRightDeadLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左边锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object left = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="comment">//右边锁</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object right = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 现持有左边的锁，然后获取右边的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftRigth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">            System.out.println(<span class="string">"leftRigth: left lock，threadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">                System.out.println(<span class="string">"leftRigth: right lock，threadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 现持有右边的锁，然后获取左边的锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            System.out.println(<span class="string">"rightLeft: right lock，threadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">            <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">                System.out.println(<span class="string">"rightLeft: left lock，threadId:"</span> + Thread.currentThread().getId());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 休眠</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        executorService.execute(() -&gt; leftRigth());</span><br><span class="line">        executorService.execute(() -&gt; rightLeft());</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">leftRigth: left lock，threadId:<span class="number">12</span></span><br><span class="line">rightLeft: right lock，threadId:<span class="number">13</span></span><br></pre></td></tr></table></figure><p>我们发现，12号线程锁住了左边要向右边获取锁，13号锁住了右边，要向左边获取锁，因为两边都不释放自己的锁，互不相让，就产生了死锁。</p><h5 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h5><blockquote><p><strong>固定加锁的顺序</strong>(针对锁顺序死锁)</p></blockquote><p>只要交换下锁的顺序，让线程来了之后先获取同一把锁，获取不到就等待，等待上一个线程释放锁再获取锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">leftRigth</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">         ...</span><br><span class="line">           <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">rightLeft</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (left) &#123;</span><br><span class="line">         ...</span><br><span class="line">           <span class="keyword">synchronized</span> (right) &#123;</span><br><span class="line">            ...</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="动态锁顺序型死锁"><a href="#动态锁顺序型死锁" class="headerlink" title="动态锁顺序型死锁"></a>动态锁顺序型死锁</h4><blockquote><p>由于方法入参由外部传递而来，方法内部虽然对两个参数按照固定顺序进行加锁，但是由于外部传递时顺序的不可控，而产生锁顺序造成的死锁，即动态锁顺序死锁。</p></blockquote><p>​ 上例告诉我们，交替的获取锁会导致死锁，且锁是固定的。有时候并锁的执行顺序并不那么清晰，参数导致不同的执行顺序。经典案例是银行账户转账，from账户向to账户转账，在转账之前先获取两个账户的锁，然后开始转账，如果这是to账户向from账户转账，角色互换，也会导致锁顺序死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态顺序型死锁</span></span><br><span class="line"><span class="comment"> * 转账业务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoneyDeadlock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//先锁住转账的账户</span></span><br><span class="line">        <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">            <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">            sleep(<span class="number">100</span>);</span><br><span class="line">            <span class="comment">//在锁住目标账户</span></span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    from.debit(amount);</span><br><span class="line">                    to.credit(amount);</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name, <span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">debit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance - amount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">credit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance + amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 休眠</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//创建账户A</span></span><br><span class="line">        Account A = <span class="keyword">new</span> Account(<span class="string">"A"</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建账户B</span></span><br><span class="line">        Account B = <span class="keyword">new</span> Account(<span class="string">"B"</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//A -&gt; B 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(A, B, <span class="number">5</span>));</span><br><span class="line">        <span class="comment">//B -&gt; A 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(B, A, <span class="number">10</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程【<span class="number">12</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【B】账户锁成功</span><br></pre></td></tr></table></figure><p>然后就没有然后了，产生了死锁，我们发现 因为对象的调用关系，产生了互相锁住资源的问题。</p><h5 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h5><p>​ 根据传入对象的hashCode硬性确定加锁顺序，消除可变性，避免死锁</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.test.thread.deadlock;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态顺序型死锁解决方案</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransferMoneyDeadlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 监视器，第三把锁，为了方式HASH冲突</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object lock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 我们经过上一次得失败，明白了不能依赖参数名称简单的确定锁的顺序，因为参数是</span></span><br><span class="line"><span class="comment">     * 具有动态性的，所以，我们改变一下思路，直接根据传入对象的hashCode()大小来</span></span><br><span class="line"><span class="comment">     * 对锁定顺序进行排序(这里要明白的是如何排序不是关键，有序才是关键)。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> from</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> to</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Account from, Account to, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这里需要说明一下为什么不使用HashCode()因为HashCode方法可以被重写，</span></span><br><span class="line"><span class="comment">         * 所以，我们无法简单的使用父类或者当前类提供的简单的hashCode()方法，</span></span><br><span class="line"><span class="comment">         * 所以，我们就使用系统提供的identityHashCode()方法，该方法保证无论</span></span><br><span class="line"><span class="comment">         * 你是否重写了hashCode方法，都会在虚拟机层面上调用一个名为JVM_IHashCode</span></span><br><span class="line"><span class="comment">         * 的方法来根据对象的存储地址来获取该对象的hashCode(),HashCode如果不重写</span></span><br><span class="line"><span class="comment">         * 的话，其实也是通过这个虚拟机层面上的方法，JVM_IHashCode()方法实现的</span></span><br><span class="line"><span class="comment">         * 这个方法是用C++实现的。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> fromHash = System.identityHashCode(from);</span><br><span class="line">        <span class="keyword">int</span> toHash = System.identityHashCode(to);</span><br><span class="line">        <span class="keyword">if</span> (fromHash &gt; toHash) &#123;</span><br><span class="line">            <span class="comment">//先锁住转账的账户</span></span><br><span class="line">            <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">//在锁住目标账户</span></span><br><span class="line">                <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        from.debit(amount);</span><br><span class="line">                        to.credit(amount);</span><br><span class="line">                        System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fromHash &lt; toHash) &#123;</span><br><span class="line">            <span class="comment">//先锁住转账的账户</span></span><br><span class="line">            <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">                sleep(<span class="number">100</span>);</span><br><span class="line">                <span class="comment">//在锁住目标账户</span></span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                    <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        from.debit(amount);</span><br><span class="line">                        to.credit(amount);</span><br><span class="line">                        System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果传入对象的Hash值相同，那就加让加第三层锁</span></span><br><span class="line">            <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">                <span class="comment">//先锁住转账的账户</span></span><br><span class="line">                <span class="keyword">synchronized</span> (from) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + from.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                    <span class="comment">//休眠增加死锁产生的概率</span></span><br><span class="line">                    sleep(<span class="number">100</span>);</span><br><span class="line">                    <span class="comment">//在锁住目标账户</span></span><br><span class="line">                    <span class="keyword">synchronized</span> (to) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】获取【"</span> + to.name + <span class="string">"】账户锁成功"</span>);</span><br><span class="line">                        <span class="keyword">if</span> (from.balance &lt; amount) &#123;</span><br><span class="line">                            System.out.println(<span class="string">"余额不足"</span>);</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            from.debit(amount);</span><br><span class="line">                            to.credit(amount);</span><br><span class="line">                            System.out.println(<span class="string">"线程【"</span> + Thread.currentThread().getId() + <span class="string">"】从【"</span> + from.name + <span class="string">"】账户转账到【"</span> + to.name + <span class="string">"】账户【"</span> + amount + <span class="string">"】元钱成功"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">        String name;</span><br><span class="line">        <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Account</span><span class="params">(String name, <span class="keyword">int</span> balance)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">debit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance - amount;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">credit</span><span class="params">(<span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.balance = balance + amount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 休眠</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> time</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> time)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(time);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程池</span></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="comment">//创建账户A</span></span><br><span class="line">        Account A = <span class="keyword">new</span> Account(<span class="string">"A"</span>, <span class="number">100</span>);</span><br><span class="line">        <span class="comment">//创建账户B</span></span><br><span class="line">        Account B = <span class="keyword">new</span> Account(<span class="string">"B"</span>, <span class="number">200</span>);</span><br><span class="line">        <span class="comment">//A -&gt; B 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(A, B, <span class="number">5</span>));</span><br><span class="line">        <span class="comment">//B -&gt; A 的转账</span></span><br><span class="line">        executorService.execute(() -&gt; transfer(B, A, <span class="number">10</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程【<span class="number">12</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">12</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">12</span>】从【A】账户转账到【B】账户【<span class="number">5</span>】元钱成功</span><br><span class="line">线程【<span class="number">13</span>】获取【B】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】获取【A】账户锁成功</span><br><span class="line">线程【<span class="number">13</span>】从【B】账户转账到【A】账户【<span class="number">10</span>】元钱成功</span><br></pre></td></tr></table></figure><h4 id="协作对象间的死锁"><a href="#协作对象间的死锁" class="headerlink" title="协作对象间的死锁"></a>协作对象间的死锁</h4><blockquote><p>在协作对象之间可能存在多个锁获取的情况，但是这些获取多个锁的操作并不像在LeftRightDeadLock或transferMoney中那么明显，这两个锁并不一定必须在同一个方法中被获取。如果在持有锁时调用某个外部方法，那么这就需要警惕死锁问题，因为在这个外部方法中可能会获取其他锁，或者阻塞时间过长，导致其他线程无法及时获取当前被持有的锁。</p></blockquote><p>​ 上述两例中，在同一个方法中获取两个锁。实际上，锁并不一定在同一方法中被获取。经典案例，如出租车调度系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 协作对象间的死锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CoordinateDeadlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Taxi 类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Taxi</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String location;</span><br><span class="line">        <span class="keyword">private</span> String destination;</span><br><span class="line">        <span class="keyword">private</span> Dispatcher dispatcher;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Taxi</span><span class="params">(Dispatcher dispatcher, String destination)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.dispatcher = dispatcher;</span><br><span class="line">            <span class="keyword">this</span>.destination = destination;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> String <span class="title">getLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.location;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法先获取Taxi的this对象锁后，然后调用Dispatcher类的方法时，又需要获取</span></span><br><span class="line"><span class="comment">         * Dispatcher类的this方法。</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> location</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.location = location;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" taxi set location:"</span> + location);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>.location.equals(destination)) &#123;</span><br><span class="line">                dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 调度类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatcher</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Set&lt;Taxi&gt; taxis;</span><br><span class="line">        <span class="keyword">private</span> Set&lt;Taxi&gt; availableTaxis;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Dispatcher</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            taxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">            availableTaxis = <span class="keyword">new</span> HashSet&lt;Taxi&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">notifyAvailable</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" notifyAvailable."</span>);</span><br><span class="line">            availableTaxis.add(taxi);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 打印当前位置：有死锁风险</span></span><br><span class="line"><span class="comment">         * 持有当前锁的时候，同时调用Taxi的getLocation这个外部方法；而这个外部方法也是需要加锁的</span></span><br><span class="line"><span class="comment">         * reportLocation的锁的顺序与Taxi的setLocation锁的顺序完全相反</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reportLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" report location."</span>);</span><br><span class="line">            <span class="keyword">for</span> (Taxi t : taxis) &#123;</span><br><span class="line">                t.getLocation();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addTaxi</span><span class="params">(Taxi taxi)</span> </span>&#123;</span><br><span class="line">            taxis.add(taxi);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">final</span> Dispatcher dispatcher = <span class="keyword">new</span> Dispatcher();</span><br><span class="line">        <span class="keyword">final</span> Taxi taxi = <span class="keyword">new</span> Taxi(dispatcher, <span class="string">"软件园"</span>);</span><br><span class="line">        dispatcher.addTaxi(taxi);</span><br><span class="line">        <span class="comment">//先获取dispatcher锁，然后是taxi的锁</span></span><br><span class="line">        executorService.execute(() -&gt; dispatcher.reportLocation());</span><br><span class="line">        <span class="comment">//先获取taxi锁，然后是dispatcher的锁</span></span><br><span class="line">        executorService.execute(() -&gt; taxi.setLocation(<span class="string">"软件园"</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h5><blockquote><p>使用开放调用，开放调用指调用该方法不需要持有锁。</p></blockquote><p>​ 开放调用，是指在调用某个方法时不需要持有锁。开放调用可以避免死锁，这种代码更容易编写。上述调度算法完全可以修改为开发调用，修改同步代码块的范围，使其仅用于保护那些涉及共享状态的操作，避免在同步代码块中执行方法调用。修改Dispatcher的reportLocation方法：</p><h6 id="setLocation方法"><a href="#setLocation方法" class="headerlink" title="setLocation方法"></a>setLocation方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 开放调用，不持有锁期间进行外部方法调用</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> location</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLocation</span><span class="params">(String location)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">this</span>.location = location;</span><br><span class="line">       &#125;</span><br><span class="line">       System.out.println(Thread.currentThread().getName() + <span class="string">" taxi set location:"</span> + location);</span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">this</span>.location.equals(destination)) &#123;</span><br><span class="line">           dispatcher.notifyAvailable(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="reportLocation-方法"><a href="#reportLocation-方法" class="headerlink" title="reportLocation 方法"></a>reportLocation 方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 同步块只包含对共享状态的操作代码</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reportLocation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">          System.out.println(Thread.currentThread().getName() + <span class="string">" report location."</span>);</span><br><span class="line">          Set&lt;Taxi&gt; taxisCopy;</span><br><span class="line">          <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">              taxisCopy = <span class="keyword">new</span> HashSet&lt;Taxi&gt;(taxis);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">for</span> (Taxi t : taxisCopy) &#123;</span><br><span class="line">              t.getLocation();</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><h3 id="死锁问题排查"><a href="#死锁问题排查" class="headerlink" title="死锁问题排查"></a>死锁问题排查</h3><p>​ 拿动态顺序型死锁举例，其他的都一样</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        Account A = <span class="keyword">new</span> Account(<span class="string">"A"</span>, <span class="number">100</span>);</span><br><span class="line">        Account B = <span class="keyword">new</span> Account(<span class="string">"B"</span>, <span class="number">200</span>);</span><br><span class="line">        executorService.execute(() -&gt; transfer(A, B, <span class="number">5</span>));</span><br><span class="line">        executorService.execute(() -&gt; transfer(B, A, <span class="number">10</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="死锁的现象"><a href="#死锁的现象" class="headerlink" title="死锁的现象"></a>死锁的现象</h4><blockquote><p>系统越来越卡，没有任何报错信息，随机性比较高</p></blockquote><h4 id="排查死锁"><a href="#排查死锁" class="headerlink" title="排查死锁"></a>排查死锁</h4><h5 id="使用-jps-jstack"><a href="#使用-jps-jstack" class="headerlink" title="使用 jps + jstack"></a>使用 jps + jstack</h5><ol><li>在 window或linux中使用jps + jstack命令</li></ol><p><img src="../images/deadlock02.jpg" alt></p><ol start="2"><li><p>找到可能发生死锁的类对应的PID</p><blockquote><p>我们对应的类是TransferMoneyDeadlock PID是 13964</p></blockquote></li></ol><h5 id="使用jstack-l-PID"><a href="#使用jstack-l-PID" class="headerlink" title="使用jstack -l PID"></a>使用jstack -l PID</h5><blockquote><p>执行 jstack -l 13964 命令</p></blockquote><p><img src="../images/deadlock03.jpg" alt></p><p>我们观察BLOCKED 就表示阻塞状态</p><ul><li>pool-1-thread-2 等待锁 &lt;0x00000000d673baa8&gt;并且已经获取了锁 &lt;0x00000000d673baf0&gt;</li><li>pool-1-thread-1 等待锁 &lt;0x00000000d673baf0&gt; 并且已经获取了锁&lt;0x00000000d673baa8&gt;</li></ul><p>我们发现他们互相持有各自的锁，并且想获取对方的锁，这就是明显的死锁。</p><h5 id="使用jconsole"><a href="#使用jconsole" class="headerlink" title="使用jconsole"></a>使用jconsole</h5><blockquote><p>使用命令打开jconsole</p></blockquote><p><img src="../images/deadlock04.jpg" alt></p><blockquote><p>打开jconsole界面工具选择我们需要检测的类</p></blockquote><p><img src="../images/deadlock05.jpg" alt></p><blockquote><p>选择检查死锁</p></blockquote><p><img src="../images/deadlock06.jpg" alt></p><blockquote><p>点击检查死锁</p></blockquote><p><img src="../images/deadlock07.jpg" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的死锁
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="死锁" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E6%AD%BB%E9%94%81/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="死锁" scheme="http://www.baiyp.ren/tags/%E6%AD%BB%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>布隆过滤器</title>
    <link href="http://www.baiyp.ren/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8.html"/>
    <id>http://www.baiyp.ren/布隆过滤器.html</id>
    <published>2019-08-27T06:23:36.000Z</published>
    <updated>2019-08-27T07:54:23.666Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h2><p><img src="../images/bloomfilter01.gif" alt></p><h3 id="什么是布隆过滤器"><a href="#什么是布隆过滤器" class="headerlink" title="什么是布隆过滤器"></a>什么是布隆过滤器</h3><blockquote><p>布隆过滤器（Bloom Filter）是1970年由布隆提出的。它实际上是一个很长的<a href="https://baike.baidu.com/item/二进制/361457" rel="external nofollow noopener noreferrer" target="_blank">二进制</a>向量和一系列随机映射函数。布隆过滤器可以用于检索一个元素是否在一个集合中。它的优点是空间效率和查询时间都比一般的算法要好的多，缺点是有一定的误识别率和删除困难。</p></blockquote><p>​ 布隆过滤器可以理解为一个不怎么精确的 set 结构，当你使用它的 contains 方法判断某个对象是否存在时，它可能会误判。但是布隆过滤器也不是特别不精确，只要参数设置的合理，它的精确度可以控制的相对足够精确，只会有小小的误判概率。</p><p>​ 当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。打个比方，当它说不认识你时，肯定就不认识；当它说见过你时，可能根本就没见过面，不过因为你的脸跟它认识的人中某脸比较相似 (某些熟脸的系数组合)，所以误判以前见过你。<br>套在上面的使用场景中，布隆过滤器能准确过滤掉那些已经看过的内容，那些没有看过的新内容，它也会过滤掉极小一部分 (误判)，但是绝大多数新内容它都能准确识别。这样就可以完全保证推荐给用户的内容都是无重复的。</p><h3 id="布隆过滤器的原理"><a href="#布隆过滤器的原理" class="headerlink" title="布隆过滤器的原理"></a>布隆过滤器的原理</h3><p>​ 其本质就是一个只包含0和1的数组。具体操作当一个元素被加入到集合里面后，该元素通过K个Hash函数运算得到K个hash后的值，然后将K个值映射到这个位数组对应的位置，把对应位置的值设置为1。查询是否存在时，我们就看对应的映射点位置如果全是1，他就很可能存在（跟hash函数的个数和hash函数的设计有关），如果有一个位置是0，那这个元素就一定不存在。</p><p><img src="../images/bloomfilter02.jpg" alt></p><ol><li><p>首先需要初始化一个<strong>二进制的数组，长度设为 L</strong>，同时初始值全为 0 。</p></li><li><p>当<strong>写入一个 A1=1000 的数据时，需要</strong>进行 H 次 hash 函数的运算<strong>（这里为 2 次）；与 HashMap 有点类似，通过</strong>算出的 HashCode 与 L 取模后定位到 0、2 处，将该处的值设为 1。</p></li><li><p>A2=2000 也是同理计算后将 4、7 位置设为 1。</p></li><li><p>当有一个 B1=1000 需要判断是否存在时，也是做两次 Hash 运算，定位到 0、2 处，此时他们的值都为 1 ，所以认为 B1=1000 存在于集合中。</p></li><li><p>当有一个 B2=3000 时，也是同理。第一次 Hash 定位到 index=4 时，数组中的值为 1，所以再进行第二次 Hash 运算，结果定位到 index=5 的值为 0，所以认为 B2=3000 不存在于集合中。</p></li></ol><p>整个的写入、查询的流程就是这样，汇总起来就是：</p><blockquote><p>对写入的数据做 H 次 hash 运算定位到数组中的位置，同时将数据改为 1 。当有数据查询时也是同样的方式定位到数组中。一旦其中的有一位为 0 则认为数据肯定不存在于集合，否则数据可能存在于集合中。</p></blockquote><h3 id="布隆过滤器的特点"><a href="#布隆过滤器的特点" class="headerlink" title="布隆过滤器的特点"></a>布隆过滤器的特点</h3><p><strong>只要返回数据不存在，则肯定不存在</strong>。</p><p><strong>返回数据存在，但只能是大概率存在</strong>。</p><p>同时<strong>不能清除</strong>其中的数据。</p><p>在有限的数组长度中存放大量的数据，即便是<strong>再完美的 Hash 算法也会有冲突，所以有可能两个完全不同的 A、B 两个数据最后定位到的位置是一模一样的</strong>。</p><p>删除数据也是同理，当我把 B 的数据删除时，其实也相当于是把 A 的数据删掉了，这样也会造成后续的误报。</p><p>基于以上的 Hash 冲突的前提，所以 Bloom Filter 有一定的误报率，这个误报率和 Hash 算法的次数 H，以及数组长度 L 都是有关的。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>​ 我们经常会把一部分数据放在Redis等缓存，比如产品详情。这样有查询请求进来，我们可以根据产品Id直接去缓存中取数据，而不用读取数据库，这是提升性能最简单，最普遍，也是最有效的做法。一般的查询请求流程是这样的：先查缓存，有缓存的话直接返回，如果缓存中没有，再去数据库查询，然后再把数据库取出来的数据放入缓存，一切看起来很美好。但是如果现在有大量请求进来，而且都在请求一个不存在的产品Id，会发生什么？既然产品Id都不存在，那么肯定没有缓存，没有缓存，那么大量的请求都怼到数据库，数据库的压力一下子就上来了，还有可能把数据库打死。</p><p>​ 使用布隆过滤器的特点，<strong>只要返回数据不存在，则肯定不存在，返回数据存在，但只能是大概率存在</strong>，这种特点可以大批量的无效请求过滤掉，能够穿透缓存的知识漏网之鱼，无关紧要。</p><h4 id="检查单词拼写"><a href="#检查单词拼写" class="headerlink" title="检查单词拼写"></a>检查单词拼写</h4><p>​ 检查一个单词拼写是否正确，因为有海量的单词数量，每天可能有新的单词，使用布隆过滤器，可以将单词映射到很小的内存中，可以经过简单的几次hash运行就可以进行校验，<strong>只要返回数据不存在，则肯定不存在，返回数据存在，但只能是大概率存在</strong>，虽然可能有误报，但是对系统的提升是革命性的。</p><h3 id="Guava的布隆过滤器"><a href="#Guava的布隆过滤器" class="headerlink" title="Guava的布隆过滤器"></a>Guava的布隆过滤器</h3><blockquote><p>这就又要提起我们的Guava了，它是Google开源的Java包，提供了很多常用的功能。</p><p>Guava中，布隆过滤器的实现主要涉及到2个类，BloomFilter和BloomFilterStrategies，首先来看一下BloomFilter的成员变量。需要注意的是不同Guava版本的BloomFilter实现不同。</p></blockquote><h4 id="布隆过滤器解析"><a href="#布隆过滤器解析" class="headerlink" title="布隆过滤器解析"></a>布隆过滤器解析</h4><h5 id="成员变量分析"><a href="#成员变量分析" class="headerlink" title="成员变量分析"></a>成员变量分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** guava实现的以CAS方式设置每个bit位的bit数组 */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> LockFreeBitArray bits;</span><br><span class="line"> <span class="comment">/** hash函数的个数 */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> numHashFunctions;</span><br><span class="line"> <span class="comment">/** guava中将对象转换为byte的通道 */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Funnel&lt;? <span class="keyword">super</span> T&gt; funnel;</span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将byte转换为n个bit的策略，也是bloomfilter hash映射的具体实现</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> Strategy strategy;</span><br></pre></td></tr></table></figure><p>这是它的4个成员变量:</p><ul><li><p>LockFreeBitArray是定义在<code>BloomFilterStrategies</code>中的内部类，封装了布隆过滤器底层bit数组的操作。</p></li><li><p>numHashFunctions表示哈希函数的个数。</p></li><li><p>Funnel，它和PrimitiveSink配套使用，能将任意类型的对象转化成Java基本数据类型，默认用java.nio.ByteBuffer实现，最终均转化为byte数组。</p></li><li><p>Strategy是定义在BloomFilter类内部的接口，代码如下，主要有2个方法，put和mightContain。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 设置元素 */</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits)</span></span>;</span><br><span class="line">    <span class="comment">/** 判断元素是否存在*/</span></span><br><span class="line">    &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits)</span></span>;</span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>创建布隆过滤器，<strong>BloomFilter</strong>并没有公有的构造函数，只有一个私有构造函数，而对外它提供了5个重载的<strong>create</strong>方法，在缺省情况下误判率设定为3%，采用<strong>BloomFilterStrategies.MURMUR128_MITZ_64</strong>的实现。</p><p><strong>BloomFilterStrategies.MURMUR128_MITZ_64</strong>是Strategy的两个实现之一，Guava以枚举的方式提供这两个实现，这也是《Effective Java》书中推荐的提供对象的方法之一。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> BloomFilterStrategies implements BloomFilter.Strategy &#123;</span><br><span class="line">    MURMUR128_MITZ_32() &#123;<span class="comment">//....&#125;</span></span><br><span class="line">    MURMUR128_MITZ_64() &#123;<span class="comment">//....&#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 二者对应了32位哈希映射函数，和64位哈希映射函数，后者使用了murmur3 hash生成的所有128位，具有更大的空间，不过原理是相通的，我们选择相对简单的<strong>MURMUR128_MITZ_32</strong>来分析。</p><p>先来看一下它的put方法，它用两个hash函数来模拟多个hash函数的情况，这是布隆过滤器的一种优化。</p><h5 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">put</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line">    <span class="comment">// 先利用murmur3 hash对输入的funnel计算得到128位的哈希值，funnel现将object转换为byte数组，</span></span><br><span class="line">    <span class="comment">// 然后在使用哈希函数转换为long</span></span><br><span class="line">    <span class="keyword">long</span> hash64 = Hashing.murmur3_128().hashObject(object, funnel).asLong();</span><br><span class="line">    <span class="comment">// 根据hash值的高低位算出hash1和hash2</span></span><br><span class="line">    <span class="keyword">int</span> hash1 = (<span class="keyword">int</span>) hash64;</span><br><span class="line">    <span class="keyword">int</span> hash2 = (<span class="keyword">int</span>) (hash64 &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> bitsChanged = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 循环体内采用了2个函数模拟其他函数的思想,相当于每次累加hash2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numHashFunctions; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">    <span class="comment">// 如果是负数就变为正数</span></span><br><span class="line">    <span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        combinedHash = ~combinedHash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过基于bitSize取模的方式获取bit数组中的索引，然后调用set函数设置。</span></span><br><span class="line">    bitsChanged |= bits.set(combinedHash % bitSize);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bitsChanged;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在put方法中，先是将索引位置上的二进制置为1，然后用bitsChanged记录插入结果，如果返回true表明没有重复插入成功，而mightContain方法则是将索引位置上的数值取出，并判断是否为0，只要其中出现一个0，那么立即判断为不存在。</p><h5 id="mightContain方法"><a href="#mightContain方法" class="headerlink" title="mightContain方法"></a>mightContain方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">mightContain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    T object, Funnel&lt;? <span class="keyword">super</span> T&gt; funnel, <span class="keyword">int</span> numHashFunctions, BitArray bits)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> bitSize = bits.bitSize();</span><br><span class="line">    <span class="keyword">long</span> hash64 = Hashing.murmur3_128().hashObject(object, funnel).asLong();</span><br><span class="line">    <span class="keyword">int</span> hash1 = (<span class="keyword">int</span>) hash64;</span><br><span class="line">    <span class="keyword">int</span> hash2 = (<span class="keyword">int</span>) (hash64 &gt;&gt;&gt; <span class="number">32</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= numHashFunctions; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> combinedHash = hash1 + (i * hash2);</span><br><span class="line">    <span class="comment">// Flip all the bits if it's negative (guaranteed positive number)</span></span><br><span class="line">    <span class="keyword">if</span> (combinedHash &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        combinedHash = ~combinedHash;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 和put的区别就在这里，从set转换为get，来判断是否存在</span></span><br><span class="line">    <span class="keyword">if</span> (!bits.get(combinedHash % bitSize)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Guava为了提供效率，自己实现了LockFreeBitArray来提供bit数组的无锁设置和读取。我们只来看一下它的put函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">boolean set(long bitIndex) &#123;</span><br><span class="line">    if (get(bitIndex)) &#123;</span><br><span class="line">    return false;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int longIndex = (int) (bitIndex &gt;&gt;&gt; LONG_ADDRESSABLE_BITS);</span><br><span class="line">    long mask = 1L &lt;&lt; bitIndex; // only cares about low 6 bits of bitIndex</span><br><span class="line"></span><br><span class="line">    long oldValue;</span><br><span class="line">    long newValue;</span><br><span class="line">    // 经典的CAS自旋重试机制</span><br><span class="line">    do &#123;</span><br><span class="line">    oldValue = data.get(longIndex);</span><br><span class="line">    newValue = oldValue | mask;</span><br><span class="line">    if (oldValue == newValue) &#123;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; while (!data.compareAndSet(longIndex, oldValue, newValue));</span><br><span class="line"></span><br><span class="line">    bitCount.increment();</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Guava布隆过滤器使用"><a href="#Guava布隆过滤器使用" class="headerlink" title="Guava布隆过滤器使用"></a>Guava布隆过滤器使用</h4><h5 id="引入坐标"><a href="#引入坐标" class="headerlink" title="引入坐标"></a>引入坐标</h5><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;guava&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;28.0-jre&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GuavaBloomFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置布隆过滤器大小</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> size = <span class="number">100000</span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建一个BloomFilter</span></span><br><span class="line"><span class="comment">     *  第一个参数Funnel类型的参数</span></span><br><span class="line"><span class="comment">     *  第二个参数 期望处理的数据量</span></span><br><span class="line"><span class="comment">     *  第三个参数 误判率 可不加，默认 0.03D</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), size);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//成功计数</span></span><br><span class="line">        <span class="keyword">float</span> success = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//失败计数</span></span><br><span class="line">        <span class="keyword">float</span> fial = <span class="number">0</span>;</span><br><span class="line">        Set&lt;String&gt; stringSet = <span class="keyword">new</span> HashSet&lt;String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//生成随机字符串</span></span><br><span class="line">            String randomStr = RandomStringUtils.randomNumeric(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//加入到set中</span></span><br><span class="line">            stringSet.add(randomStr);</span><br><span class="line">            <span class="comment">//加入到布隆过滤器</span></span><br><span class="line">            bloomFilter.put(randomStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            <span class="comment">//生成随机字符串</span></span><br><span class="line">            String randomStr = RandomStringUtils.randomNumeric(<span class="number">10</span>);</span><br><span class="line">            <span class="comment">//布隆过滤器校验存在</span></span><br><span class="line">            <span class="keyword">if</span> (bloomFilter.mightContain(randomStr)) &#123;</span><br><span class="line">                <span class="comment">//set中存在</span></span><br><span class="line">                <span class="keyword">if</span> (stringSet.contains(randomStr)) &#123;</span><br><span class="line">                    <span class="comment">//成功计数</span></span><br><span class="line">                    success++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//失败计数</span></span><br><span class="line">                    fial++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//布隆过滤器校验不存在</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//    set中存在</span></span><br><span class="line">                <span class="keyword">if</span> (stringSet.contains(randomStr)) &#123;</span><br><span class="line">                    <span class="comment">//失败计数</span></span><br><span class="line">                    fial++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//成功计数</span></span><br><span class="line">                    success++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"判断成功数："</span>+success + <span class="string">"，判断失败数:"</span> + fial + <span class="string">"，误判率:"</span> + fial / <span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断成功数：<span class="number">97084.0</span>，判断失败数:<span class="number">2916.0</span>，误判率:<span class="number">0.02916</span></span><br></pre></td></tr></table></figure><p>可以通过增加误判率的参数来调整误判率</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建一个BloomFilter</span></span><br><span class="line"><span class="comment"> *  第一个参数Funnel类型的参数</span></span><br><span class="line"><span class="comment"> *  第二个参数 期望处理的数据量</span></span><br><span class="line"><span class="comment"> *  第三个参数 误判率 可不加，默认 0.03D</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> BloomFilter&lt;CharSequence&gt; bloomFilter = BloomFilter.create(Funnels.stringFunnel(), size,<span class="number">0.00001</span>);</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">判断成功数：<span class="number">100000.0</span>，判断失败数:<span class="number">0.0</span>，误判率:<span class="number">0.0</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      布隆过滤器(BloomFilter)的使用以及原理
    
    </summary>
    
      <category term="架构" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="布隆过滤器" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
    
      <category term="架构" scheme="http://www.baiyp.ren/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="布隆过滤器" scheme="http://www.baiyp.ren/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"/>
    
      <category term="BloomFilter" scheme="http://www.baiyp.ren/tags/BloomFilter/"/>
    
  </entry>
  
  <entry>
    <title>JAVA线程池实现03-其余方法</title>
    <link href="http://www.baiyp.ren/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B003.html"/>
    <id>http://www.baiyp.ren/JAVA线程池实现03.html</id>
    <published>2019-08-25T02:55:59.000Z</published>
    <updated>2019-08-27T06:10:17.903Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="JAVA线程池实现03-其余方法"><a href="#JAVA线程池实现03-其余方法" class="headerlink" title="JAVA线程池实现03-其余方法"></a>JAVA线程池实现03-其余方法</h2><p><img src="../images/threadpoolexecutor03.png" alt></p><h3 id="shutdown安全停止任务"><a href="#shutdown安全停止任务" class="headerlink" title="shutdown安全停止任务"></a>shutdown安全停止任务</h3><blockquote><p>注意该方法不会马上停止线程池，会先将线程池置于shutdown状态然后发起中断请求，等待任务自己结束，线程内部要实现中断请求的响应处理，否则就不会终止。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安全的中断任务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查权限</span></span><br><span class="line">            checkShutdownAccess();</span><br><span class="line">            <span class="comment">//更改运行状态</span></span><br><span class="line">            advanceRunState(SHUTDOWN);</span><br><span class="line">            <span class="comment">//中断任务</span></span><br><span class="line">            interruptIdleWorkers();</span><br><span class="line">            <span class="comment">//模板方法，不继承实现则是一个空方法</span></span><br><span class="line">            onShutdown();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尝试中断任务</span></span><br><span class="line">        tryTerminate();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="检查权限-checkShutdownAccess"><a href="#检查权限-checkShutdownAccess" class="headerlink" title="检查权限 checkShutdownAccess"></a>检查权限 checkShutdownAccess</h4><blockquote><p>这主要的目的是为了在系统层面对线程池进行保护，防止其发生意外。比如中断系统进程等，获取了安全管理器之后接下来再对其进行权限检查。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//检查线程池个任务权限</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkShutdownAccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取安全管理器</span></span><br><span class="line">    SecurityManager security = System.getSecurityManager();</span><br><span class="line">    <span class="keyword">if</span> (security != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//检查任务权限</span></span><br><span class="line">        security.checkPermission(shutdownPerm);</span><br><span class="line">        <span class="comment">//获取重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//检查个任务的权限</span></span><br><span class="line">            <span class="keyword">for</span> (ThreadPoolExecutor.Worker w : workers) &#123;</span><br><span class="line">                security.checkAccess(w.thread);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="更改运行状态-advanceRunState"><a href="#更改运行状态-advanceRunState" class="headerlink" title="更改运行状态 advanceRunState"></a>更改运行状态 advanceRunState</h4><blockquote><p>更改线程池的状态</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置运行状态</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">advanceRunState</span><span class="params">(<span class="keyword">int</span> targetState)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">           <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">           <span class="comment">//非运行状态 当前状态&gt; targetState 或者 设置运行状态为 targetState状态成功</span></span><br><span class="line">           <span class="keyword">if</span> (runStateAtLeast(c, targetState) || ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c))))</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="中断工作任务-interruptIdleWorkers"><a href="#中断工作任务-interruptIdleWorkers" class="headerlink" title="中断工作任务 interruptIdleWorkers"></a>中断工作任务 interruptIdleWorkers</h4><blockquote><p>中断任务，但是只是发起中断请求，不会强制中断任务。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 中断任务</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      interruptIdleWorkers(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 中断任务</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyOne 是否只中断一次</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">interruptIdleWorkers</span><span class="params">(<span class="keyword">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//获取重入锁</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">      <span class="comment">//加锁</span></span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (Worker w : workers) &#123;</span><br><span class="line">              Thread t = w.thread;</span><br><span class="line">              <span class="comment">//任务未中断 并且尝试获取锁成功</span></span><br><span class="line">              <span class="keyword">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class="line">                  <span class="keyword">try</span> &#123;</span><br><span class="line">                      <span class="comment">//发起中断请求</span></span><br><span class="line">                      t.interrupt();</span><br><span class="line">                  &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                      <span class="comment">//解锁</span></span><br><span class="line">                      w.unlock();</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">if</span> (onlyOne)</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//解锁</span></span><br><span class="line">          mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="尝试终止任务"><a href="#尝试终止任务" class="headerlink" title="尝试终止任务"></a>尝试终止任务</h4><blockquote><p>尝试终止任务如果有正在运行的任务或者任务队列不为空且运行状态是SHUTDOWN就返回，不进行前置终止。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 尝试终止任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryTerminate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * isRunning 线程正在运行</span></span><br><span class="line"><span class="comment">         * runStateAtLeast 线程池已经中断</span></span><br><span class="line"><span class="comment">         * 或者 线程池停止并且任务队列不为空 返回</span></span><br><span class="line"><span class="comment">         * 不进行强制终止</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//正在运行或者</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) ||  runStateAtLeast(c, TIDYING) ||  (runStateOf(c) == SHUTDOWN &amp;&amp; ! workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前工作线程不为0</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) != <span class="number">0</span>) &#123; <span class="comment">// Eligible to terminate</span></span><br><span class="line">            <span class="comment">//发起中断请求 只终止一次</span></span><br><span class="line">            interruptIdleWorkers(ONLY_ONE);</span><br><span class="line">            <span class="comment">//返回</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取重入锁</span></span><br><span class="line">        <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">        <span class="comment">//加锁</span></span><br><span class="line">        mainLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//设置运行状态为真理状态</span></span><br><span class="line">            <span class="keyword">if</span> (ctl.compareAndSet(c, ctlOf(TIDYING, <span class="number">0</span>))) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//空方法，用于终止线程后的自定义任务</span></span><br><span class="line">                    terminated();</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//设置线程池为终止状态</span></span><br><span class="line">                    ctl.set(ctlOf(TERMINATED, <span class="number">0</span>));</span><br><span class="line">                    <span class="comment">//通知所有线程</span></span><br><span class="line">                    termination.signalAll();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//解锁</span></span><br><span class="line">            mainLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// else retry on failed CAS</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdownNow马上终止线程"><a href="#shutdownNow马上终止线程" class="headerlink" title="shutdownNow马上终止线程"></a>shutdownNow马上终止线程</h3><blockquote><p>该方法是马上中断线程池，如果有未完成的任务先发起中断请求，然后将线程池中的任务删除，并将删除的数据放进一个临时的队列并且返回。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 马上终止线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 未完成的任务列表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Runnable&gt; tasks;</span><br><span class="line">    <span class="comment">//获取重入锁</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    mainLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//检查权限</span></span><br><span class="line">        checkShutdownAccess();</span><br><span class="line">        <span class="comment">//设置状态为终止</span></span><br><span class="line">        advanceRunState(STOP);</span><br><span class="line">        <span class="comment">//发起中断请求</span></span><br><span class="line">        interruptWorkers();</span><br><span class="line">        <span class="comment">//将线程池任务队列清空，并返回未完成的任务</span></span><br><span class="line">        tasks = drainQueue();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mainLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//尝试终止任务</span></span><br><span class="line">    tryTerminate();</span><br><span class="line">    <span class="keyword">return</span> tasks;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="drainQueue-清空队列"><a href="#drainQueue-清空队列" class="headerlink" title="drainQueue 清空队列"></a>drainQueue 清空队列</h4><blockquote><p>清理队列并且返回未完成任务的列表</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 清空队列，并返回清除的数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Runnable&gt; <span class="title">drainQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    BlockingQueue&lt;Runnable&gt; q = workQueue;</span><br><span class="line">    ArrayList&lt;Runnable&gt; taskList = <span class="keyword">new</span> ArrayList&lt;Runnable&gt;();</span><br><span class="line">    <span class="comment">//批量获取任务</span></span><br><span class="line">    q.drainTo(taskList);</span><br><span class="line">    <span class="comment">//为防止还有剩余数据，做一次查询</span></span><br><span class="line">    <span class="keyword">if</span> (!q.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Runnable r : q.toArray(<span class="keyword">new</span> Runnable[<span class="number">0</span>])) &#123;</span><br><span class="line">            <span class="comment">//删除队列中的元素</span></span><br><span class="line">            <span class="keyword">if</span> (q.remove(r)) &#123;</span><br><span class="line">                <span class="comment">//添加到队列</span></span><br><span class="line">                taskList.add(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> taskList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="shutdown与shutdownNow"><a href="#shutdown与shutdownNow" class="headerlink" title="shutdown与shutdownNow"></a>shutdown与shutdownNow</h3><blockquote><p>到这里我们发现shutdown和 shutdownNow很像，但是有差别，shutdownNow就强制在调用后会清空任务列表，强制终止任务，但是shutdown不会，shutdown会等待任务完成然后才会进行终止。</p></blockquote><h3 id="isShutdown-线程池是否关闭"><a href="#isShutdown-线程池是否关闭" class="headerlink" title="isShutdown 线程池是否关闭"></a>isShutdown 线程池是否关闭</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ! isRunning(ctl.get());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="isTerminating-线程池是否正在终止"><a href="#isTerminating-线程池是否正在终止" class="headerlink" title="isTerminating 线程池是否正在终止"></a>isTerminating 线程池是否正在终止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminating</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="keyword">return</span> ! isRunning(c) &amp;&amp; runStateLessThan(c, TERMINATED);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="线程池是否终止"><a href="#线程池是否终止" class="headerlink" title="线程池是否终止"></a>线程池是否终止</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> runStateAtLeast(ctl.get(), TERMINATED);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA线程池实现-ThreadPoolExecutor
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://www.baiyp.ren/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>JAVA线程池实现02-提交任务</title>
    <link href="http://www.baiyp.ren/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B002.html"/>
    <id>http://www.baiyp.ren/JAVA线程池实现02.html</id>
    <published>2019-08-21T02:55:59.000Z</published>
    <updated>2019-08-27T02:48:29.586Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="JAVA线程池实现02-提交任务"><a href="#JAVA线程池实现02-提交任务" class="headerlink" title="JAVA线程池实现02-提交任务"></a>JAVA线程池实现02-提交任务</h2><p><img src="../images/threadpoolexecutor03.png" alt></p><h3 id="submit提交任务"><a href="#submit提交任务" class="headerlink" title="submit提交任务"></a>submit提交任务</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 提交一个带有返回值的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> task 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> result 结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> Future</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    <span class="comment">//调用execute进行执行</span></span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个FutureTask</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> runnable 运行的任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value 返回结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &lt;T&gt; 泛型</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> FutureTask</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>流程步骤如下</p><ol><li>调用submit方法，传入Runnable或者Callable对象</li><li>判断传入的对象是否为null，为null则抛出异常，不为null继续流程</li><li>将传入的对象转换为RunnableFuture对象</li><li>执行execute方法，传入RunnableFuture对象</li><li>返回RunnableFuture对象</li></ol></blockquote><p><img src="../images/threadpoolexecutor11.png" alt></p><h3 id="execute-执行线程"><a href="#execute-执行线程" class="headerlink" title="execute 执行线程"></a>execute 执行线程</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在未来执行任务</span></span><br><span class="line"><span class="comment">    * 任务将新建或者现有的线程池中执行</span></span><br><span class="line"><span class="comment">    * 如果线程池关闭或者线程池满了将执行拒绝策略</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> command</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 1、运行线程数少于核心线程数，则调用addWorker启动一个新的线程</span></span><br><span class="line"><span class="comment">        *   需要检查否应该添加线程</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">           <span class="comment">//添加线程</span></span><br><span class="line">           <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>)) &#123;</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           c = ctl.get();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 运行线程数量大于核心线程数量时，上面的if分支针对大于corePoolSize，并且缓存队列加入任务操作成功的情况。</span></span><br><span class="line"><span class="comment">        *  运行中并且将任务加入缓冲队列成功，正常来说这样已经完成了处理逻辑。</span></span><br><span class="line"><span class="comment">        *  但是为了保险起见，增加了状态出现异常的确认判断，如果状态出现异常会继续remove操作，如果执行true，则按照拒绝处理策略驳回任务；</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//线程运行状态，并且添加进队列成功</span></span><br><span class="line">       <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">           <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">           <span class="comment">//线程未运行并且删除成功</span></span><br><span class="line">           <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">               <span class="comment">//拒绝任务</span></span><br><span class="line">               reject(command);</span><br><span class="line">           <span class="comment">//线程正在运行中</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">               <span class="comment">//添加任务</span></span><br><span class="line">               addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 这里针对运行线程数量超过了corePoolSize，并且缓存队列也已经放满的情况。</span></span><br><span class="line"><span class="comment">        *  注意第二个参数是false，可以在下面addWorker方法看到，就是针对线程池最大线程数量maximumPoolSize的判断。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">           <span class="comment">//拒绝任务</span></span><br><span class="line">           reject(command);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>其实从上面代码注释中可以看出就三个判断，</p><ol><li>核心线程数是否已满</li><li>队列是否已满</li><li>线程池是否已满</li></ol></blockquote><p><img src="../images/threadpoolexecutor07.png" alt></p><blockquote><ol><li>调用execute方法，传入Runable对象</li><li>判断传入的对象是否为null，为null则抛出异常，不为null继续流程</li><li>获取当前线程池的状态和线程个数变量</li><li>判断当前线程数是否小于核心线程数，是走流程5，否则走流程6</li><li>添加线程数，添加成功则结束，失败则重新获取当前线程池的状态和线程个数变量,</li><li>判断线程池是否处于RUNNING状态，是则添加任务到阻塞队列，否则走流程10，添加任务成功则继续流程7</li><li>重新获取当前线程池的状态和线程个数变量</li><li>重新检查线程池状态，不是运行状态则移除之前添加的任务，有一个false走流程9，都为true则走流程11</li><li>检查线程池线程数量是否为0，否则结束流程，是调用addWorker(null, false)，然后结束</li><li>调用!addWorker(command, false)，为true走流程11，false则结束</li><li>调用拒绝策略reject(command)，结束</li></ol></blockquote><p><img src="../images/threadpoolexecutor08.png" alt></p><h4 id="addWorker-增加工作线程"><a href="#addWorker-增加工作线程" class="headerlink" title="addWorker 增加工作线程"></a>addWorker 增加工作线程</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 添加工作线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstTask 任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> core 是否是核心线程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    retry:</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查当前线程池状态是否是SHUTDOWN、STOP、TIDYING或者TERMINATED</span></span><br><span class="line">    <span class="comment">// 且！（当前状态为SHUTDOWN、且传入的任务为null，且队列不为null）</span></span><br><span class="line">    <span class="comment">// 条件都成立则返回false</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">                ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                        firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                        ! workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//有一个自旋</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//获取工作线程数</span></span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 工作线程数 &gt;= 队列容量 返回fasle</span></span><br><span class="line"><span class="comment">             * 如果是核心线程 工作线程数&gt;=核心线程数 返回false</span></span><br><span class="line"><span class="comment">             * 如果不是核心线程 工作线程数&gt;=最大线程数 返回false</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                    wc &gt;= (core ? corePoolSize : maximumPoolSize)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">//CAS增加c，成功则跳出retry</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) &#123;</span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl</span></span><br><span class="line">            <span class="comment">//CAS失败执行下面方法，查看当前线程数是否变化，变化则继续retry循环，没变化则继续内部循环</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs) &#123;</span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//CAS成功</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//工作线程状态</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//工作线程添加状态</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;</span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个工作线程</span></span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask);</span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取重入锁</span></span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="comment">//重新检查线程池状态</span></span><br><span class="line">            <span class="comment">//避免ThreadFactory退出故障或者在锁获取前线程池被关闭</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line">                <span class="comment">//再次检查线程池状态 ？？？</span></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">//检查thread的状态</span></span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive()) &#123; <span class="comment">// precheck that t is startable</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//任务列表添加任务</span></span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="comment">//获取任务列表大小</span></span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="comment">//最大线程数 计数</span></span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize) &#123;</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//线程添加成功</span></span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//判断worker是否添加成功，成功则启动线程，然后将workerStarted设置为true</span></span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start();</span><br><span class="line">                <span class="comment">//启动状态成功</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//判断线程有没有启动成功，没有则调用addWorkerFailed方法</span></span><br><span class="line">        <span class="keyword">if</span> (! workerStarted) &#123;</span><br><span class="line">            addWorkerFailed(w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回任务启动状态</span></span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里可以将addWorker分为两部分，第一部分增加线程池个数，第二部分是将任务添加到workder里面并执行。</p></blockquote><p>第一部分主要是两个循环，外层循环主要是判断线程池状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">              ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">                  firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                  ! workQueue.isEmpty())</span><br></pre></td></tr></table></figure><p>展开！运算后等价于</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">               (rs != SHUTDOWN ||</span><br><span class="line">             firstTask != <span class="keyword">null</span> ||</span><br><span class="line">             workQueue.isEmpty())</span><br></pre></td></tr></table></figure><blockquote><p>也就是说下面几种情况下会返回false：</p><ul><li>当前线程池状态为STOP，TIDYING，TERMINATED</li><li>当前线程池状态为SHUTDOWN并且已经有了第一个任务</li><li>当前线程池状态为SHUTDOWN并且任务队列为空</li></ul><p>内层循环作用是使用cas增加线程个数，如果线程个数超限则返回false，否者进行cas，cas成功则退出双循环，否者cas失败了，要看当前线程池的状态是否变化了，如果变了，则重新进入外层循环重新获取线程池状态，否者进入内层循环继续进行cas尝试。</p><p>到了第二部分说明CAS成功了，也就是说线程个数加一了，但是现在任务还没开始执行，这里使用全局的独占锁来控制workers里面添加任务，其实也可以使用并发安全的set，但是性能没有独占锁好（这个从注释中知道的）。这里需要注意的是要在获取锁后重新检查线程池的状态，这是因为其他线程可可能在本方法获取锁前改变了线程池的状态，比如调用了shutdown方法。添加成功则启动任务执行。</p></blockquote><p>所以这里也将流程图分为两部分来描述</p><blockquote><p>第一部分流程图</p></blockquote><p><img src="../images/threadpoolexecutor09.png" alt></p><blockquote><p>第二部分流程图</p></blockquote><p><img src="../images/threadpoolexecutor10.png" alt></p><blockquote><p>这里面有一个核心的工作类 Worker</p></blockquote><h4 id="AQS的Worker工作任务"><a href="#AQS的Worker工作任务" class="headerlink" title="AQS的Worker工作任务"></a>AQS的Worker工作任务</h4><blockquote><p>这个类继承了抽象队列同步器 是标准的AQS线程安全的类。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 工作任务对象</span></span><br><span class="line"><span class="comment">    * 继承了AQS 抽象队列同步器 以及 Runnable 接口</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">        * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Thread this worker is running in.  Null if factory fails.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//正在运行的线程，工厂创建线程失败则为null</span></span><br><span class="line">       <span class="keyword">final</span> Thread thread;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Initial task to run.  Possibly null.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//运行的初始任务，可能为null</span></span><br><span class="line">       Runnable firstTask;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Per-thread task counter</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//完成任务的计数器</span></span><br><span class="line">       <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//构造方法</span></span><br><span class="line">       Worker(Runnable firstTask) &#123;</span><br><span class="line">           <span class="comment">//设置状态为未运行</span></span><br><span class="line">           setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">           <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">           <span class="comment">//使用线程工厂创建线程</span></span><br><span class="line">           <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * Delegates main run loop to outer runWorker</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="comment">//实现Runnable的run方法</span></span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="comment">//运行任务方法</span></span><br><span class="line">           runWorker(<span class="keyword">this</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Lock methods</span></span><br><span class="line">       <span class="comment">//</span></span><br><span class="line">       <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">       <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">/*是否是独占的</span></span><br><span class="line"><span class="comment">        * @return 0 未锁 1 已锁定</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 尝试获取占用权</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//CAS 设置锁定状态</span></span><br><span class="line">           <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">               <span class="comment">//设置持有者是当前线程</span></span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 尝试释放锁</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@param</span> unused</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">           <span class="comment">//设置是持有者为null</span></span><br><span class="line">           setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//设置锁定状态为 未锁定</span></span><br><span class="line">           setState(<span class="number">0</span>);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 加锁</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           acquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 尝试获取锁</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> tryAcquire(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//释放锁</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           release(<span class="number">1</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 释放</span></span><br><span class="line"><span class="comment">        * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> isHeldExclusively();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 中断启动</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Thread t;</span><br><span class="line">           <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   t.interrupt();</span><br><span class="line">               &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>这个类很值得学习，里面最核心的方法是 runWorker 方法</p></blockquote><h4 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h4><blockquote><p>运行任务的主体，通过循环从阻塞队列中拿任务，进行执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 运行任务</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> w 任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread wt = Thread.currentThread();</span><br><span class="line">    <span class="comment">//获取任务 task</span></span><br><span class="line">    Runnable task = w.firstTask;</span><br><span class="line">    w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">    w.unlock(); <span class="comment">// allow interrupts</span></span><br><span class="line">    <span class="comment">//是否突然完成任务(异常，或者其他情况)</span></span><br><span class="line">    <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//循环获取任务</span></span><br><span class="line">        <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//加锁</span></span><br><span class="line">            w.lock();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 当线程池是处于STOP状态或者TIDYING、TERMINATED状态时，设置当前线程处于中断状态</span></span><br><span class="line">        <span class="comment">// 如果不是，当前线程就处于RUNNING或者SHUTDOWN状态，确保当前线程不处于中断状态</span></span><br><span class="line">        <span class="comment">// 重新检查当前线程池的状态是否大于等于STOP状态</span></span><br><span class="line">            <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) &#123;</span><br><span class="line">                wt.interrupt();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//线程执行前执行一些任务，在ThreadPoolExecutor是空实现</span></span><br><span class="line">                beforeExecute(wt, task);</span><br><span class="line">                Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//运行任务</span></span><br><span class="line">                    task.run();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                    thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//完成任务后执行一些任务，在ThreadPoolExecutor是空实现</span></span><br><span class="line">                    afterExecute(task, thrown);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">//完成任务task置为空，交给GC处理</span></span><br><span class="line">                task = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//完成任务计数器+1</span></span><br><span class="line">                w.completedTasks++;</span><br><span class="line">                <span class="comment">//解锁</span></span><br><span class="line">                w.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 正常完成任务为false</span></span><br><span class="line"><span class="comment">         * 否则completedAbruptly 为true</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//整个线程结束时调用，线程退出操作。统计整个线程池完成的任务个数之类的工作</span></span><br><span class="line">        processWorkerExit(w, completedAbruptly);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里面有两个核心方法</p><ul><li><strong>getTask</strong>：从队列中获取任务</li><li><strong>processWorkerExit</strong>：处任务并退出</li></ul></blockquote><p>我们先从getTask开始</p><h5 id="getTask-方法"><a href="#getTask-方法" class="headerlink" title="getTask 方法"></a>getTask 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取待执行的任务</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//最后一次poll()是否超时</span></span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取运行状态</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程不在运行状态并且队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//使用CAS进行工作任务数-1</span></span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取当前工作任务数</span></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 是否进行任务淘汰 如果 allowCoreThreadTimeOut为true 就一直淘汰下去</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line">        <span class="comment">//（当前线程数是否大于最大线程数或者）</span></span><br><span class="line">   <span class="comment">//且（线程数大于1或者任务队列为空）</span></span><br><span class="line">    <span class="comment">//这里有个问题(timed &amp;&amp; timedOut)timedOut = false，好像(timed &amp;&amp; timedOut)一直都是false吧</span></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="comment">//CAS方式进行工作线程-1</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 如果需要淘汰淘汰从工作先队列中在指定keepAliveTime时间内获取一个工作线程否则返回null</span></span><br><span class="line"><span class="comment">             * 否则工作线程池为空就一直等待</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果获取超时设置超时时间为true </span></span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们分析下processWorkerExit方法</p><h4 id="processWorkerExit-方法"><a href="#processWorkerExit-方法" class="headerlink" title="processWorkerExit 方法"></a>processWorkerExit 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 处理完成后续的线程统计工作</span></span><br><span class="line"><span class="comment">   * 删除完成工作的线程</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> w 工作线程</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> completedAbruptly 是否突然完成（异常情况）</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processWorkerExit</span><span class="params">(Worker w, <span class="keyword">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//如果突然完成，工作线程数统计未统计</span></span><br><span class="line">      <span class="keyword">if</span> (completedAbruptly) &#123; <span class="comment">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class="line">          <span class="comment">//重新对工作线程数-1</span></span><br><span class="line">          decrementWorkerCount();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//获取锁</span></span><br><span class="line">      <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">      <span class="comment">//加锁</span></span><br><span class="line">      mainLock.lock();</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="comment">//完成任务数统计</span></span><br><span class="line">          completedTaskCount += w.completedTasks;</span><br><span class="line">          <span class="comment">//从工作任务队列删除队列</span></span><br><span class="line">          workers.remove(w);</span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">          <span class="comment">//解锁</span></span><br><span class="line">          mainLock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//尝试终止线程池</span></span><br><span class="line">      tryTerminate();</span><br><span class="line"></span><br><span class="line">      <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">      <span class="comment">//正在运行或者停止</span></span><br><span class="line">      <span class="keyword">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class="line">          <span class="comment">//没有突然完成</span></span><br><span class="line">          <span class="keyword">if</span> (!completedAbruptly) &#123;</span><br><span class="line">              <span class="comment">// 计算最小工作线程，如果allowCoreThreadTimeOut为true 就是 0 否则就是核心线程数</span></span><br><span class="line">              <span class="keyword">int</span> min = allowCoreThreadTimeOut ? <span class="number">0</span> : corePoolSize;</span><br><span class="line">              <span class="comment">//如果最小线程为0并且工作任务队列不为空则设置最小线程数为1</span></span><br><span class="line">              <span class="keyword">if</span> (min == <span class="number">0</span> &amp;&amp; !workQueue.isEmpty()) &#123;</span><br><span class="line">                  min = <span class="number">1</span>;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//如果工作线程数&gt;=最小线程数返回</span></span><br><span class="line">              <span class="keyword">if</span> (workerCountOf(c) &gt;= min)</span><br><span class="line">                  <span class="keyword">return</span>; <span class="comment">// replacement not needed</span></span><br><span class="line">          &#125;</span><br><span class="line">          addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>到这里为止,submit 和 execute已经分析完成了。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA线程池实现-ThreadPoolExecutor
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://www.baiyp.ren/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>JAVA线程池实现01-简介</title>
    <link href="http://www.baiyp.ren/JAVA%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B001.html"/>
    <id>http://www.baiyp.ren/JAVA线程池实现01.html</id>
    <published>2019-08-20T06:55:59.000Z</published>
    <updated>2019-08-27T02:48:20.553Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="JAVA线程池实现01-简介"><a href="#JAVA线程池实现01-简介" class="headerlink" title="JAVA线程池实现01-简介"></a>JAVA线程池实现01-简介</h2><p><img src="../images/threadpoolexecutor06.png" alt></p><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池"></a>什么是线程池</h3><p>​ 线程池是一种多线程处理形式，处理过程中将任务添加到队列，然后在创建线程后自动启动这些任务。线程池线程都是后台线程。每个线程都使用默认的堆栈大小，以默认的优先级运行，并处于多线程单元中。如果某个线程在托管代码中空闲（如正在等待某个事件），则线程池将插入另一个辅助线程来使所有处理器保持繁忙。如果所有线程池线程都始终保持繁忙，但队列中包含挂起的工作，则线程池将在一段时间后创建另一个辅助线程但线程的数目永远不会超过最大值。超过最大值的线程可以排队，但他们要等到其他线程完成后才启动。</p><h3 id="为什么使用线程池"><a href="#为什么使用线程池" class="headerlink" title="为什么使用线程池"></a>为什么使用线程池</h3><p>操作系统创建线程、切换线程状态、终结线程都要进行CPU调度——这是一个耗费时间和系统资源的事情。</p><p>​ 大多数实际场景中是这样的：处理某一次请求的时间是非常短暂的，但是请求数量是巨大的。这种技术背景下，如果我们为每一个请求都单独创建一个线程，那么物理机的所有资源基本上都被操作系统创建线程、切换线程状态、销毁线程这些操作所占用，用于业务请求处理的资源反而减少了。所以最理想的处理方式是，将处理请求的线程数量控制在一个范围，既保证后续的请求不会等待太长时间，又保证物理机将足够的资源用于请求处理本身。另外，一些操作系统是有最大线程数量限制的。当运行的线程数量逼近这个值的时候，操作系统会变得不稳定。这也是我们要限制线程数量的原因。</p><h4 id="线程池的优点"><a href="#线程池的优点" class="headerlink" title="线程池的优点"></a>线程池的优点</h4><ul><li><strong>降低资源消耗</strong>：通过重复利用已创建的线程降低线程创建和销毁带来的消耗。</li><li><strong>提高响应速度</strong>：当任务到达时，任务可以不需要等待线程创建就能立即执行。</li><li><strong>提高线程的可管理性</strong>：使用线程池可以统一进行线程分配、调度和监控。</li><li><strong>线程统一管理</strong>：线程池具有创建线程和销毁线程的能力，线程集中在一起比起分散开来，更加便于管理</li></ul><h3 id="继承关系"><a href="#继承关系" class="headerlink" title="### 继承关系"></a>### 继承关系</h3><blockquote><p>线程池都继承自Exceutor接口</p></blockquote><p><img src="../images/threadpoolexecutor05.png" alt></p><h4 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h4><blockquote><p>Executor接口只有一个方法execute,传入线程任务参数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ExecutorService接口"><a href="#ExecutorService接口" class="headerlink" title="ExecutorService接口"></a>ExecutorService接口</h4><blockquote><p>ExecutorService接口继承Executor接口，并增加了submit、shutdown、invokeAll等等一系列方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line"></span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                  <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AbstractExecutorService抽象类"><a href="#AbstractExecutorService抽象类" class="headerlink" title="AbstractExecutorService抽象类"></a>AbstractExecutorService抽象类</h4><blockquote><p>bstractExecutorService抽象类实现ExecutorService接口，并且提供了一些方法的默认实现，例如submit方法、invokeAny方法、invokeAll方法。</p><p>像execute方法、线程池的关闭方法（shutdown、shutdownNow等等）就没有提供默认的实现。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractExecutorService</span> <span class="keyword">implements</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">        execute(ftask);</span><br><span class="line">        <span class="keyword">return</span> ftask;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> &lt;T&gt; <span class="function">T <span class="title">doInvokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;... &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class="line">                                         <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException &#123;...&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程池的分类和作用"><a href="#线程池的分类和作用" class="headerlink" title="线程池的分类和作用"></a>线程池的分类和作用</h3><h4 id="newCachedThreadPool"><a href="#newCachedThreadPool" class="headerlink" title="newCachedThreadPool"></a>newCachedThreadPool</h4><blockquote><p>创建一个可根据需要创建新线程的线程池，但是在以前构造的线程可用时将重用它们，并在需要时使用提供的 ThreadFactory 创建新线程。</p></blockquote><ol><li>线程池中数量没有固定，可达到最大值（Interger. MAX_VALUE）</li><li>线程池中的线程可进行缓存重复利用和回收（回收默认时间为1分钟）</li><li>当线程池中，没有可用线程，会重新创建一个线程</li></ol><h4 id="newFixedThreadPool"><a href="#newFixedThreadPool" class="headerlink" title="newFixedThreadPool"></a>newFixedThreadPool</h4><blockquote><p>创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。如果在关闭前的执行期间由于失败而导致任何线程终止，那么一个新线程将代替它执行后续的任务（如果需要）。在某个线程被显式地关闭之前，池中的线程将一直存在。</p></blockquote><ol><li>线程池中的线程处于一定的量，可以很好的控制线程的并发量</li><li>线程可以重复被使用，在显示关闭之前，都将一直存在</li><li>超出一定量的线程被提交时候需在队列中等待</li></ol><h4 id="newSingleThreadExecutor"><a href="#newSingleThreadExecutor" class="headerlink" title="newSingleThreadExecutor"></a>newSingleThreadExecutor</h4><blockquote><p>创建一个使用单个 worker 线程的 Executor，以无界队列方式来运行该线程。（注意，如果因为在关闭前的执行期间出现失败而终止了此单个线程，那么如果需要，一个新线程将代替它执行后续的任务）。可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。与其他等效的 newFixedThreadPool(1) 不同，可保证无需重新配置此方法所返回的执行程序即可使用其他的线程。</p></blockquote><ol><li>线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行</li></ol><h4 id="newScheduleThreadPool"><a href="#newScheduleThreadPool" class="headerlink" title="newScheduleThreadPool"></a>newScheduleThreadPool</h4><blockquote><p>创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。</p></blockquote><ol><li>线程池中具有指定数量的线程，即便是空线程也将保留</li><li>可定时或者延迟执行线程活动</li></ol><h4 id="newSingleThreadScheduledExecutor"><a href="#newSingleThreadScheduledExecutor" class="headerlink" title="newSingleThreadScheduledExecutor"></a>newSingleThreadScheduledExecutor</h4><blockquote><p>创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。</p></blockquote><ol><li>线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行</li><li>可定时或者延迟执行线程活动</li></ol><h3 id="ThreadPoolExecutor源码分析"><a href="#ThreadPoolExecutor源码分析" class="headerlink" title="ThreadPoolExecutor源码分析"></a>ThreadPoolExecutor源码分析</h3><h4 id="为什么要讲ThreadPoolExector类"><a href="#为什么要讲ThreadPoolExector类" class="headerlink" title="为什么要讲ThreadPoolExector类"></a>为什么要讲ThreadPoolExector类</h4><p>​ Exector是ThreadPoolExector的祖父类接口，ThreadPoolExector的直接父类接口是ExectorService，而我们所讲的第三点，其中的不同线程池的分类其实都是Exector中的方法，而在ThreadPoollExector中得到了实现，所以我们要构建的不同种类的线程池主要还是依赖这个类完成，接下来我们就聚焦ThreadPoolExector来看其具体的实现方法。</p><h4 id="线程池的执行流程"><a href="#线程池的执行流程" class="headerlink" title="线程池的执行流程"></a>线程池的执行流程</h4><p><img src="../images/threadpoolexecutor01.jpg" alt></p><h4 id="成员变量分析"><a href="#成员变量分析" class="headerlink" title="成员变量分析"></a>成员变量分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//记录线程池状态和线程数量（总共32位，前三位表示线程池状态，后29位表示线程数量）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程数量统计位数29  Integer.SIZE=32 </span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容量 000 11111111111111111111111111111</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//运行中 111 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//关闭 000 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN = <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//停止 001 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP = <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//整理 010 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING = <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//终止 011 00000000000000000000000000000</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED = <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取运行状态（获取前3位）</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">   <span class="comment">//获取线程个数（获取后29位）</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 存放任务的阻塞队列泛型是Runnable</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//可重入锁</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//获取锁的一个条件</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//存放任务Worker 的集合</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//线程池正在运行的数量</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//已完成任务的计数器</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">long</span> completedTaskCount;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//线程工厂，可以手工传入 自己构建线程</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//拒接策略</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//默认拒绝策略为AbortPolicy</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> RejectedExecutionHandler defaultHandler = <span class="keyword">new</span> ThreadPoolExecutor.AbortPolicy();</span><br><span class="line"></span><br><span class="line">   <span class="comment">//空闲线程等待超时时间</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 是否允许核心线程超时</span></span><br><span class="line"><span class="comment">    * 默认为 false</span></span><br><span class="line"><span class="comment">    * true 核心线程等待超时后 也将会销毁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> allowCoreThreadTimeOut;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 核心池大小 不允许超时</span></span><br><span class="line"><span class="comment">    * 除非allowCoreThreadTimeOut为true 这种情况下可为0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//最大线程池大小 最大不超过 CAPACITY</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br></pre></td></tr></table></figure><blockquote><p>我们也可以看出我们在线程池介绍中谈到的关于coreSize和maxiumSize等参数，这些int值对线程池的中的线程池数量进行了限制，还有一些关于锁ReentrantLock的类，这是一个可重入锁，它的主要目的是锁住其操作，因为线程的操作要保证其原子性，防止冲突发生，所以在其源码中很多都对其进行了上锁操作。还有一个很重要的值的全局的变量state:</p></blockquote><h4 id="线城池的状态"><a href="#线城池的状态" class="headerlink" title="线城池的状态"></a>线城池的状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//表示正在运行中</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//表示关闭</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//表示停止</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//表示整理</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//表示结束</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure><blockquote><p>这些状态值是线程池目前所处环境的状态的体现，它采用int数字来表现，记住这些值很重要，因为后面有很多方法调用线程池的运行状态，有很多对其值进行判断。</p></blockquote><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime 空闲等待时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue 传入的阻塞队列</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//调用重载的构造方法</span></span><br><span class="line">     <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), defaultHandler);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime 空闲等待时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue 传入的阻塞队列</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">     <span class="comment">///调用重载的构造方法</span></span><br><span class="line">     <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             threadFactory, defaultHandler);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime 空闲等待时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue 传入的阻塞队列</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler 拒绝策略</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="comment">///调用重载的构造方法</span></span><br><span class="line">     <span class="keyword">this</span>(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue,</span><br><span class="line">             Executors.defaultThreadFactory(), handler);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 创建线程池</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> corePoolSize 核心线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> maximumPoolSize 最大线程池大小</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> keepAliveTime 空闲等待时间</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> workQueue 传入的阻塞队列</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> threadFactory 线程工厂</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> handler 拒绝策略</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                           TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                           BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                           ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                           RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//条件校验，不满足抛出异常</span></span><br><span class="line">     <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">             maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">             maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">             keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">     <span class="comment">// 阻塞队列，线程工厂，拒绝策略不允许为空</span></span><br><span class="line">     <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">     <span class="comment">//java安全模式</span></span><br><span class="line">     <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">             <span class="keyword">null</span> :</span><br><span class="line">             AccessController.getContext();</span><br><span class="line">     <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">     <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">     <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">     <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">     <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">     <span class="keyword">this</span>.handler = handler;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><blockquote><p>可以看出ThreadPoolExector一共有四个构造函数，但是最后调用的都是最后一个，我们可以只看最后一个，它主要有核心池大小、最大池大小、存活时间、时间单位、阻塞队列、线程工厂这几个参数，其中又对其进行了值范围的检查，如果参数违法就抛出异常，然后构造进去。关于这几个参数，随着后面我们对其方法的讲解，会理解越来越深刻的。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA线程池实现-ThreadPoolExecutor
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="线程池" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    
      <category term="ThreadPoolExecutor" scheme="http://www.baiyp.ren/tags/ThreadPoolExecutor/"/>
    
  </entry>
  
  <entry>
    <title>JAVA阻塞队列实现</title>
    <link href="http://www.baiyp.ren/JAVA%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97%E5%AE%9E%E7%8E%B0.html"/>
    <id>http://www.baiyp.ren/JAVA阻塞队列实现.html</id>
    <published>2019-08-19T06:55:59.000Z</published>
    <updated>2019-08-22T02:10:10.403Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="JAVA阻塞队列实现"><a href="#JAVA阻塞队列实现" class="headerlink" title="JAVA阻塞队列实现"></a>JAVA阻塞队列实现</h2><p><img src="../images/blockingqueue01.png" alt></p><h3 id="什么是阻塞队列"><a href="#什么是阻塞队列" class="headerlink" title="什么是阻塞队列"></a>什么是阻塞队列</h3><p>​ 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><blockquote><p>队列的特点是：<strong>先进先出（FIFO）</strong></p></blockquote><h3 id="BlockingQueue的方法"><a href="#BlockingQueue的方法" class="headerlink" title="BlockingQueue的方法"></a>BlockingQueue的方法</h3><blockquote><p>阻塞队列提供了四种处理方法:</p></blockquote><table><thead><tr><th>方法\处理方式</th><th>抛出异常</th><th>返回特殊值</th><th>一直阻塞</th><th>超时退出</th></tr></thead><tbody><tr><td><strong>插入</strong></td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td><strong>移除</strong></td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td><strong>检查</strong></td><td>remove()</td><td>peek()</td><td><em>不可用</em></td><td><em>不可用</em></td></tr></tbody></table><ol><li>抛出异常：是指当阻塞队列满时候，再往队列里插入元素，会抛出IllegalStateException(“Queue full”)异常。当队列为空时，从队列里获取元素时会抛出NoSuchElementException异常 。</li><li>返回特殊值：插入方法会返回是否成功，成功则返回true。移除方法，则是从队列里拿出一个元素，如果没有则返回null</li><li>一直阻塞：当阻塞队列满时，如果生产者线程往队列里put元素，队列会一直阻塞生产者线程，直到拿到数据，或者响应中断退出。当队列空时，消费者线程试图从队列里take元素，队列也会阻塞消费者线程，直到队列可用。</li><li>超时退出：当阻塞队列满时，队列会阻塞生产者线程一段时间，如果超过一定的时间，生产者线程就会退出。</li></ol><h3 id="Java里的阻塞队列"><a href="#Java里的阻塞队列" class="headerlink" title="Java里的阻塞队列"></a>Java里的阻塞队列</h3><blockquote><ul><li>ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列，遵循FIFO原则。</li><li>LinkedBlockingQueue ：一个由链表结构组成的有界阻塞队列，遵循FIFO原则，默认和最大长度为Integer.MAX_VALUE。</li><li>PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的支持延时无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul></blockquote><p><strong>有界</strong>：有初始化最大长度，达到最大程度继续添加要莫阻塞，要莫抛出异常</p><p><strong>无界</strong>：没有初始化最大长度，能够一直添加，不会阻塞或抛出异常，一直到OOM。</p><blockquote><p>因为阻塞队列实现都差不多，我们就拿ArrayBlockingQueue来看下实现</p></blockquote><h3 id="ArrayBlockingQueue结构"><a href="#ArrayBlockingQueue结构" class="headerlink" title="ArrayBlockingQueue结构"></a>ArrayBlockingQueue结构</h3><p><img src="../images/blockingqueue02.gif" alt></p><blockquote><p>阻塞队列的实现都差不多，我们就拿ArrayBlockingQueue 来举例</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//底层数据结构</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> E[] items;</span><br><span class="line"><span class="comment">//用来为下一个take/poll/remove的索引（出队）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">//用来为下一个put/offer/add的索引（入队）</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">//队列中元素的个数</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义的可重入锁</span></span><br><span class="line">   <span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非空的条件</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"></span><br><span class="line">   <span class="comment">//非满的条件</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创造一个队列，指定队列容量，默认模式为非公平模式</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> capacity &lt;1会抛异常</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>(capacity, <span class="keyword">false</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * ArrayBlockingQueue 的构造方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> capacity 初始化大小 默认Integer</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> fair     是否使用公平锁</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">ArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//指定大小&lt;=0 抛出异常</span></span><br><span class="line">       <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//初始化数组的大小</span></span><br><span class="line">       <span class="keyword">this</span>.items = <span class="keyword">new</span> Object[capacity];</span><br><span class="line">       <span class="comment">//创建可重入锁</span></span><br><span class="line">       lock = <span class="keyword">new</span> ReentrantLock(fair);</span><br><span class="line">       <span class="comment">//创建非空条件</span></span><br><span class="line">       notEmpty = lock.newCondition();</span><br><span class="line">       <span class="comment">//创建非满条件</span></span><br><span class="line">       notFull = lock.newCondition();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><h4 id="offer不阻塞添加"><a href="#offer不阻塞添加" class="headerlink" title="offer不阻塞添加"></a>offer不阻塞添加</h4><blockquote><p>在队尾插入一个元素， 如果队列没满，立即返回true； 如果队列满了，立即返回false</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队尾插入一个元素，</span></span><br><span class="line"><span class="comment"> * 如果队列没满，立即返回true；</span></span><br><span class="line"><span class="comment"> * 如果队列满了，立即返回false</span></span><br><span class="line"><span class="comment"> * 注意：该方法通常优于add(),因为add()失败直接抛异常</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//检查非空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//加锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//队列满了</span></span><br><span class="line">        <span class="keyword">if</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//队列没有满</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            enqueue(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="offer等待超时阻塞添加"><a href="#offer等待超时阻塞添加" class="headerlink" title="offer等待超时阻塞添加"></a>offer等待超时阻塞添加</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队尾插入一个元素,如果数组已满，则进入等待，直到出现以下三种情况：</span></span><br><span class="line"><span class="comment"> *  1、被唤醒</span></span><br><span class="line"><span class="comment"> *  2、等待时间超时</span></span><br><span class="line"><span class="comment"> *  3、当前线程被中断</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> e 需要添加的元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> unit 时间单位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//检查非空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="comment">//计算等待时间</span></span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//可中断锁加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//队列满</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="comment">//如果超时返回fasle</span></span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">             <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 进行等待：</span></span><br><span class="line"><span class="comment">             * 在这个过程中可能发生三件事：</span></span><br><span class="line"><span class="comment">             * 1、被唤醒--&gt;继续当前这个for(;;)循环</span></span><br><span class="line"><span class="comment">             * 2、超时--&gt;继续当前这个for(;;)循环</span></span><br><span class="line"><span class="comment">             * 3、被中断--&gt;之后直接执行catch部分的代码</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            nanos = notFull.awaitNanos(nanos);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put阻塞添加"><a href="#put阻塞添加" class="headerlink" title="put阻塞添加"></a>put阻塞添加</h4><blockquote><p>在队尾插入一个元素，如果队列满了，一直阻塞，直到数组不满了或者线程被中断</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队尾插入一个元素</span></span><br><span class="line"><span class="comment"> * 如果队列满了，一直阻塞，直到数组不满了或者线程被中断</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">//检查非空</span></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    <span class="comment">//可中断锁-加锁</span></span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//队列满了 阻塞</span></span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        enqueue(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//解锁</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里使用的lock.lockInterruptibly() ,当前线程如果调用了Thread.interrupt()方法，那么lockInterruptible()判断的Thread.interrupted()聚会成立，就会抛出异常，其实就是线程中断，该方法就抛出异常。</p></blockquote><h4 id="enqueue入队操作"><a href="#enqueue入队操作" class="headerlink" title="enqueue入队操作"></a>enqueue入队操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 入队操作</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> x 需要入队的袁旭</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">      <span class="comment">// assert items[putIndex] == null;</span></span><br><span class="line">      <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">      <span class="comment">//putIndex 默认为队列数据的长度</span></span><br><span class="line">      items[putIndex] = x;</span><br><span class="line">      <span class="comment">//队列满了重置为0 从头开始</span></span><br><span class="line">      <span class="keyword">if</span> (++putIndex == items.length) &#123;</span><br><span class="line">          putIndex = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//统计数字+1</span></span><br><span class="line">      count++;</span><br><span class="line">      <span class="comment">//非空的条件阻塞的线程唤醒</span></span><br><span class="line">      notEmpty.signal();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><blockquote><p>队列没满items[putIndex] = data;达到数组长度重置putIndex，达到环形队列目的</p></blockquote><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><h4 id="poll非阻塞出队"><a href="#poll非阻塞出队" class="headerlink" title="poll非阻塞出队"></a>poll非阻塞出队</h4><blockquote><p>如果没有元素，直接返回null；如果有元素，将队头元素置null，但是要注意队头是随时变化的，并非一直是items[0]。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 出队</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       lock.lock();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//队列为空返回努力了,否则出队操作</span></span><br><span class="line">           <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="poll-等待超时阻塞出队"><a href="#poll-等待超时阻塞出队" class="headerlink" title="poll 等待超时阻塞出队"></a>poll 等待超时阻塞出队</h4><blockquote><p>从对头删除一个元素，如果数组不空，出队；如果数组已空且已经超时，返回null；如果数组已空且时间未超时，则进入等待，直到出现以下三种情况：</p><ul><li>被唤醒</li><li>等待时间超时</li><li>当前线程被中断</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待超时出队</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> timeout 超时时间</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit 单位</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 出队的元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//计算等待时间</span></span><br><span class="line">        <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">        <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">        <span class="comment">//可中断锁</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//队列为空</span></span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//等待时间到了还未没有元素返回null</span></span><br><span class="line">                <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * 进行等待：</span></span><br><span class="line"><span class="comment">                 * 在这个过程中可能发生三件事：</span></span><br><span class="line"><span class="comment">                 * 1、被唤醒--&gt;继续当前这个for(;;)循环</span></span><br><span class="line"><span class="comment">                 * 2、超时--&gt;继续当前这个for(;;)循环</span></span><br><span class="line"><span class="comment">                 * 3、被中断--&gt;之后直接执行catch部分的代码</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                nanos = notEmpty.awaitNanos(nanos);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//出队</span></span><br><span class="line">            <span class="keyword">return</span> dequeue();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="take阻塞移除"><a href="#take阻塞移除" class="headerlink" title="take阻塞移除"></a>take阻塞移除</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 阻塞移除操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> 返回移除的元素</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">       <span class="comment">//可中断锁</span></span><br><span class="line">       lock.lockInterruptibly();</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="comment">//如果元素为空就阻塞</span></span><br><span class="line">           <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="comment">//非空阻塞</span></span><br><span class="line">               notEmpty.await();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">//出队操作</span></span><br><span class="line">           <span class="keyword">return</span> dequeue();</span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">           <span class="comment">//解锁</span></span><br><span class="line">           lock.unlock();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="dequeue出队操作"><a href="#dequeue出队操作" class="headerlink" title="dequeue出队操作"></a>dequeue出队操作</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 出队操作</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回出队的元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert lock.getHoldCount() == 1;</span></span><br><span class="line">    <span class="comment">// assert items[takeIndex] != null;</span></span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    <span class="comment">//获取第takeIndex个元素</span></span><br><span class="line">    E x = (E) items[takeIndex];</span><br><span class="line">    <span class="comment">//删除元素，让GC进行回收</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//takeIndex+1 如果移除到最后一个元素 重置为0 从头开始</span></span><br><span class="line">    <span class="keyword">if</span> (++takeIndex == items.length) &#123;</span><br><span class="line">        takeIndex = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//统计长度-1</span></span><br><span class="line">    count--;</span><br><span class="line">    <span class="keyword">if</span> (itrs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//元素</span></span><br><span class="line">        itrs.elementDequeued();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//队列不满了唤醒非满线程</span></span><br><span class="line">    notFull.signal();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="延时队列-DelayQueue"><a href="#延时队列-DelayQueue" class="headerlink" title="延时队列 DelayQueue"></a>延时队列 DelayQueue</h4><blockquote><p>在我们的业务中通常会有一些需求是这样的</p><ul><li>淘宝订单业务:下单之后如果三十分钟之内没有付款就自动取消订单。</li><li>饿了吗订餐通知:下单成功后60s之后给用户发送短信通知。</li><li>缓存系统，如果key到期了取出来删除</li></ul></blockquote><p>那么这类业务我们可以总结出一个特点:需要延迟工作。<br>由此的情况，就是我们的DelayQueue应用需求的产生。</p><blockquote><p>看一个简单的例子</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelayedTask</span> <span class="keyword">implements</span> <span class="title">Delayed</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelayedTask</span><span class="params">(<span class="keyword">int</span> delayedTime, TimeUnit unit, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.delayedTime = delayedTime;</span><br><span class="line">        <span class="comment">//计算到期时间</span></span><br><span class="line">        <span class="keyword">this</span>.expireTime = System.currentTimeMillis() + (delayedTime &gt; <span class="number">0</span> ? unit.toMillis(delayedTime) : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">this</span>.message = message;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//延时时长</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> delayedTime;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 到期时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> expireTime;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取队列需要演示获取水煎</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> unit</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expireTime - System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 对比，将延时比较小的放在前面</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> other</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Delayed other)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> d = (getDelay(TimeUnit.NANOSECONDS) - other.getDelay(TimeUnit.NANOSECONDS));</span><br><span class="line">        <span class="keyword">return</span> (d == <span class="number">0</span>) ? <span class="number">0</span> : ((d &lt; <span class="number">0</span>) ? -<span class="number">1</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"出队，延时:"</span>+delayedTime+<span class="string">",消息："</span>+message;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        DelayQueue&lt;DelayedTask&gt; delayedTasks = <span class="keyword">new</span> DelayQueue&lt;DelayedTask&gt;();</span><br><span class="line">        <span class="comment">//生产者</span></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="comment">//生成随机消息</span></span><br><span class="line">                String randomStr = RandomStringUtils.randomNumeric(<span class="number">10</span>);</span><br><span class="line">                <span class="comment">//生成随机数</span></span><br><span class="line">                <span class="keyword">int</span> randomTime = random.nextInt(<span class="number">10</span>);</span><br><span class="line">                DelayedTask task = <span class="keyword">new</span> DelayedTask(randomTime, TimeUnit.SECONDS, randomStr);</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                delayedTasks.add(task);</span><br><span class="line">                System.out.println(<span class="string">"入队，消息："</span> + randomStr + <span class="string">"延时："</span> + randomTime + <span class="string">"秒"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//消费者</span></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                DelayedTask task = delayedTasks.take();</span><br><span class="line">                System.out.println(task);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//显示时间进度</span></span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">float</span> time = <span class="number">0F</span>;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                System.out.println(time+<span class="string">"秒"</span>);</span><br><span class="line">                Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                time += <span class="number">0.5</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.0</span>秒</span><br><span class="line">入队，消息：<span class="number">8675326967</span>延时：<span class="number">5</span>秒</span><br><span class="line"><span class="number">0.5</span>秒</span><br><span class="line">入队，消息：<span class="number">8861554454</span>延时：<span class="number">0</span>秒</span><br><span class="line">出队，延时:<span class="number">0</span>,消息：<span class="number">8861554454</span></span><br><span class="line"><span class="number">1.0</span>秒</span><br><span class="line"><span class="number">1.5</span>秒</span><br><span class="line">入队，消息：<span class="number">9123579697</span>延时：<span class="number">1</span>秒</span><br><span class="line"><span class="number">2.0</span>秒</span><br><span class="line"><span class="number">2.5</span>秒</span><br><span class="line">出队，延时:<span class="number">1</span>,消息：<span class="number">9123579697</span></span><br><span class="line">入队，消息：<span class="number">5909478713</span>延时：<span class="number">6</span>秒</span><br><span class="line"><span class="number">3.0</span>秒</span><br><span class="line"><span class="number">3.5</span>秒</span><br><span class="line">入队，消息：<span class="number">6287328130</span>延时：<span class="number">0</span>秒</span><br><span class="line">出队，延时:<span class="number">0</span>,消息：<span class="number">6287328130</span></span><br><span class="line"><span class="number">4.0</span>秒</span><br><span class="line"><span class="number">4.5</span>秒</span><br><span class="line">出队，延时:<span class="number">5</span>,消息：<span class="number">8675326967</span></span><br><span class="line">入队，消息：<span class="number">4056656965</span>延时：<span class="number">7</span>秒</span><br><span class="line"><span class="number">5.0</span>秒</span><br><span class="line"><span class="number">5.5</span>秒</span><br><span class="line">入队，消息：<span class="number">8250385270</span>延时：<span class="number">9</span>秒</span><br><span class="line"><span class="number">6.0</span>秒</span><br><span class="line"><span class="number">6.5</span>秒</span><br><span class="line">入队，消息：<span class="number">1949026689</span>延时：<span class="number">1</span>秒</span><br><span class="line"><span class="number">7.0</span>秒</span><br><span class="line"><span class="number">7.5</span>秒</span><br><span class="line">出队，延时:<span class="number">1</span>,消息：<span class="number">1949026689</span></span><br><span class="line">入队，消息：<span class="number">2952840210</span>延时：<span class="number">9</span>秒</span><br><span class="line"><span class="number">8.0</span>秒</span><br><span class="line"><span class="number">8.5</span>秒</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><ul><li>ArrayBlockingQueue是有界的阻塞队列，不接受null</li><li>底层数据接口是数组，下标putIndex/takeIndex，构成一个环形FIFO队列</li><li>所有的增删改查数组公用了一把锁ReentrantLock，入队和出队数组下标和count变更都是靠这把锁来维护安全的。</li><li>阻塞的场景：1获取lock锁，2进入和取出还要满足condition 满了或者空了都等待出队和加入唤醒，ArrayBlockingQueue我们主要是put和take真正用到的阻塞方法（条件不满足）。</li><li>成员cout /putIndex、takeIndex是共享的,所以一些查询方法size、peek、toString、方法也是加上锁保证线程安全，但没有了并发损失了性能。</li><li>remove(Object obj) 返回了第一个equals的Object</li></ul></blockquote><h4 id="三种入队对比"><a href="#三种入队对比" class="headerlink" title="三种入队对比"></a>三种入队对比</h4><ul><li>offer(E e)：如果队列没满，立即返回true； 如果队列满了，立即返回false–&gt;不阻塞</li><li>put(E e)：如果队列满了，一直阻塞，直到数组不满了或者线程被中断–&gt;阻塞</li><li>offer(E e, long timeout, TimeUnit unit)：在队尾插入一个元素,，如果数组已满，则进入等待，直到出现以下三种情况：–&gt;阻塞<ul><li>被唤醒</li><li>等待时间超时</li><li>当前线程被中断</li></ul></li></ul><h4 id="三种出对对比"><a href="#三种出对对比" class="headerlink" title="三种出对对比"></a>三种出对对比</h4><ul><li>poll()：如果没有元素，直接返回null；如果有元素，出队</li><li>take()：如果队列空了，一直阻塞，直到数组不为空或者线程被中断–&gt;阻塞</li><li>poll(long timeout, TimeUnit unit)：如果数组不空，出队；如果数组已空且已经超时，返回null；如果数组已空且时间未超时，则进入等待，直到出现以下三种情况：<ul><li>被唤醒</li><li>等待时间超时</li><li>当前线程被中断</li></ul></li></ul><h4 id="等待通知模式"><a href="#等待通知模式" class="headerlink" title="等待通知模式"></a>等待通知模式</h4><blockquote><p>这里面要理解<strong>等待/通知</strong>模式</p></blockquote><p>阻塞队列使用了等待/通知的设计模式</p><h5 id="标准范式"><a href="#标准范式" class="headerlink" title="标准范式"></a>标准范式</h5><blockquote><p>等待方</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//等待方</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (条件) &#123;</span><br><span class="line">            condition.await();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo 业务代码</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>通知方</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//todo 改变数据</span></span><br><span class="line">    condition.signal();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="等待超时模式"><a href="#等待超时模式" class="headerlink" title="等待超时模式"></a>等待超时模式</h4><h5 id="标准范式-1"><a href="#标准范式-1" class="headerlink" title="标准范式"></a>标准范式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">wait</span><span class="params">(<span class="keyword">long</span> time, TimeUnit timeUnit)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取到期时间</span></span><br><span class="line">    <span class="keyword">long</span> duration = timeUnit.toMillis(time);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (duration &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            duration += System.currentTimeMillis();</span><br><span class="line">            condition.await(time, timeUnit);</span><br><span class="line">            duration -= System.currentTimeMillis();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//todo 业务代码</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA阻塞队列实现-ArrayBlockingQueue
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="阻塞队列" scheme="http://www.baiyp.ren/tags/%E9%98%BB%E5%A1%9E%E9%98%9F%E5%88%97/"/>
    
      <category term="ArrayBlockingQueue" scheme="http://www.baiyp.ren/tags/ArrayBlockingQueue/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的分布式事务08-分布式事务总结</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A108.html"/>
    <id>http://www.baiyp.ren/JAVA中的分布式事务08.html</id>
    <published>2019-08-18T02:05:25.000Z</published>
    <updated>2019-08-22T02:09:38.642Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的分布式事务08-分布式事务总结"><a href="#JAVA中的分布式事务08-分布式事务总结" class="headerlink" title="JAVA中的分布式事务08-分布式事务总结"></a>JAVA中的分布式事务08-分布式事务总结</h2><h3 id="各方案使用场景"><a href="#各方案使用场景" class="headerlink" title="各方案使用场景"></a>各方案使用场景</h3><p>​ 介绍完分布式事务相关理论和常见解决方案后，最终的目的在实际项目中运用，因此，总结一下各个方案的常见的使用场景。</p><p><img src="../images/transaction27.png" alt="方案比较"></p><h4 id="2PC-3PC"><a href="#2PC-3PC" class="headerlink" title="2PC/3PC"></a>2PC/3PC</h4><blockquote><p>依赖于数据库，能够很好的提供强一致性和强事务性，但相对来说延迟比较高，比较适合传统的单体应用，在同一个方法中存在跨库操作的情况，不适合高并发和高性能要求的场景。</p></blockquote><h4 id="TCC"><a href="#TCC" class="headerlink" title="TCC"></a>TCC</h4><blockquote><p>适用于执行时间确定且较短，实时性要求高，对数据一致性要求高，比如互联网金融企业最核心的三个服务：交易、支付、账务。</p></blockquote><h4 id="本地消息表-MQ事务"><a href="#本地消息表-MQ事务" class="headerlink" title="本地消息表/MQ事务"></a>本地消息表/MQ事务</h4><blockquote><p>都适用于事务中参与方支持操作幂等，对一致性要求不高，业务上能容忍数据不一致到一个人工检查周期，事务涉及的参与方、参与环节较少，业务上有对账/校验系统兜底。</p></blockquote><h4 id="Saga事务"><a href="#Saga事务" class="headerlink" title="Saga事务"></a>Saga事务</h4><blockquote><p>由于Saga事务不能保证隔离性，需要在业务层控制并发，适合于业务场景事务并发操作同一资源较少的情况。<br>Saga相比缺少预提交动作，导致补偿动作的实现比较麻烦，例如业务是发送短信，补偿动作则得再发送一次短信说明撤销，用户体验比较差。Saga事务较适用于补偿动作容易处理的场景。</p></blockquote><h3 id="分布式事务的分类"><a href="#分布式事务的分类" class="headerlink" title="分布式事务的分类"></a>分布式事务的分类</h3><h4 id="刚性事务"><a href="#刚性事务" class="headerlink" title="刚性事务"></a>刚性事务</h4><blockquote><p>刚性事务是指再解决事务中需要锁表的操作,相对来说性能低</p></blockquote><p>2PC，3PC</p><h4 id="柔性事务"><a href="#柔性事务" class="headerlink" title="柔性事务"></a>柔性事务</h4><blockquote><p>是指再解决事务中不需要锁表的操作，因为不需要锁表，导致会发生临时不一致。</p></blockquote><p>TCC，本地消息表，MQ事务，Saga</p><h3 id="分布式事务方案设计"><a href="#分布式事务方案设计" class="headerlink" title="分布式事务方案设计"></a>分布式事务方案设计</h3><p>​ 实际运用理论时进行架构设计时，许多人容易犯“手里有了锤子，看什么都觉得像钉子”的错误，设计方案时考虑的问题场景过多，各种重试，各种补偿机制引入系统，导致设计出来的系统过于复杂，落地遥遥无期。</p><blockquote><p>世界上解决一个计算机问题最简单的方法：“恰好”不需要解决它！—— 阿里中间件技术专家沈询</p></blockquote><p>​ 有些问题，看起来很重要，但实际上我们可以通过<strong>合理的设计</strong>或者将<strong>问题分解</strong>来规避。设计分布式事务系统也不是需要考虑所有异常情况，不必过度设计各种回滚，补偿机制。如果硬要把时间花在解决问题本身，实际上不仅效率低下，而且也是一种浪费。</p><p>​ 如果系统要实现回滚流程的话，有可能系统复杂度将大大提升，且很容易出现Bug，估计出现Bug的概率会比需要事务回滚的概率大很多。在设计系统时，我们需要衡量是否值得花这么大的代价来解决这样一个出现概率非常小的问题，可以考虑当出现这个概率很小的问题，能否采用<strong>人工解决</strong>的方式，这也是大家在解决疑难问题时需要多多思考的地方。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的分布式事务分布式事务总结
    
    </summary>
    
      <category term="架构" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式事务" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="架构" scheme="http://www.baiyp.ren/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式事务" scheme="http://www.baiyp.ren/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="总结" scheme="http://www.baiyp.ren/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码解析02</title>
    <link href="http://www.baiyp.ren/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%9002.html"/>
    <id>http://www.baiyp.ren/ThreadLocal源码解析02.html</id>
    <published>2019-08-17T02:49:37.000Z</published>
    <updated>2019-08-22T02:08:13.186Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="ThreadLocal源码解析02"><a href="#ThreadLocal源码解析02" class="headerlink" title="ThreadLocal源码解析02"></a>ThreadLocal源码解析02</h2><blockquote><p>上一节我们详细解析了set方法，现在我们来解析get方法</p></blockquote><h3 id="ThreadLocal-get-方法"><a href="#ThreadLocal-get-方法" class="headerlink" title="ThreadLocal.get 方法"></a>ThreadLocal.get 方法</h3><blockquote><p>ThreadLocal.get 方法相对来说简单</p></blockquote><p>我们先来看下get的流程图</p><p><img src="../images/threadlocal_source01.png" alt></p><p>下面我们解析代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ThreadLocal 中的值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//同set方法类似获取对应线程中的ThreadLocalMap实例</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//从Map中根据ThreadLocal获取entry</span></span><br><span class="line">            ThreadLocal.ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="comment">//如果Entry 不为空 则返回</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T) e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为空返回初始化值</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 初始化设值的方法，可以被子类覆盖。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置初始化的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取初始化值，默认为null(如果没有子类进行覆盖)</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//同set方法类似获取对应线程中的ThreadLocalMap实例</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//不为空不用再初始化，直接调用set操作设值</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//第一次初始化，createMap在上面介绍set()的时候有介绍过。</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回初始化后的值</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们发现首先从当前线程中获取ThreadLocalMap 然后从map中根据ThreadLocal获取entry，entry不为空则返回value，否则调用setInitialValue设置初始值并返回。</p><p>我们深入到 map.getEntry(this);方法</p><h4 id="ThreadLocalMap-getEntry-方法"><a href="#ThreadLocalMap-getEntry-方法" class="headerlink" title="ThreadLocalMap.getEntry 方法"></a>ThreadLocalMap.getEntry 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 根据 ThreadLocal 获取获取entry</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key 当前的threadLocal</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> ThreadLocal.ThreadLocalMap.<span class="function">Entry <span class="title">getEntry</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//计算 table 中需要映射的下标</span></span><br><span class="line">       <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (table.length - <span class="number">1</span>);</span><br><span class="line">       <span class="comment">//从table中获取entry</span></span><br><span class="line">       ThreadLocal.ThreadLocalMap.Entry e = table[i];</span><br><span class="line">       <span class="comment">//如果entry 不为空且entry中的key和传入的key匹配则返回entry</span></span><br><span class="line">       <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == key)</span><br><span class="line">           <span class="keyword">return</span> e;</span><br><span class="line">       <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">//发生了hash冲突，当前的entry为空或者key和传入的key不一致</span></span><br><span class="line">           <span class="keyword">return</span> getEntryAfterMiss(key, i, e);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="getEntryAfterMiss"><a href="#getEntryAfterMiss" class="headerlink" title="getEntryAfterMiss"></a>getEntryAfterMiss</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 通过直接计算出来的key找不到对于的value的时候适用这个方法.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> ThreadLocal.ThreadLocalMap.<span class="function">Entry <span class="title">getEntryAfterMiss</span><span class="params">(ThreadLocal&lt;?&gt; key, <span class="keyword">int</span> i, ThreadLocal.ThreadLocalMap.Entry e)</span> </span>&#123;</span><br><span class="line">      ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">while</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">          ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">          <span class="comment">//如果当前的key和传入的key匹配则返回</span></span><br><span class="line">          <span class="keyword">if</span> (k == key)</span><br><span class="line">              <span class="keyword">return</span> e;</span><br><span class="line">          <span class="keyword">if</span> (k == <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">//清除无效的entry</span></span><br><span class="line">              expungeStaleEntry(i);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//基于线性探测法向后扫描</span></span><br><span class="line">              i = nextIndex(i, len);</span><br><span class="line">          &#125;</span><br><span class="line">          e = tab[i];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//找不到返回null</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>到这里 get方法以及完结了。</p><h3 id="ThreadLocal-remove-方法"><a href="#ThreadLocal-remove-方法" class="headerlink" title="ThreadLocal.remove 方法"></a>ThreadLocal.remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//同set方法类似获取对应线程中的ThreadLocalMap实例</span></span><br><span class="line">      ThreadLocal.ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">      <span class="keyword">if</span> (m != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">//调用ThreadLocalMap的remove方法进行清除entry</span></span><br><span class="line">          m.remove(<span class="keyword">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据ThreadLocal 删除entry</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key 当前的ThreadLocal</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(ThreadLocal&lt;?&gt; key)</span> </span>&#123;</span><br><span class="line">      ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line">      <span class="comment">//计算 table 中需要映射的下标</span></span><br><span class="line">      <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">      <span class="comment">//进行线性探测，查找正确的key</span></span><br><span class="line">      <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.get() == key) &#123;</span><br><span class="line">              <span class="comment">//调用weakrefrence的clear()清除引用</span></span><br><span class="line">              e.clear();</span><br><span class="line">              <span class="comment">//连续段清除</span></span><br><span class="line">              expungeStaleEntry(i);</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​ remove()在有上面了解后可以说极为简单了，就是找到对应的table[],调用weakrefrence的clear()清除引用，然后再调用expungeStaleEntry()进行清除。</p><h3 id="ThreadLocal-防止hash冲突的"><a href="#ThreadLocal-防止hash冲突的" class="headerlink" title="ThreadLocal 防止hash冲突的"></a>ThreadLocal 防止hash冲突的</h3><blockquote><p>到这里整个threadLocal 基本介绍完成了，但是还少一块，如何处理hash冲突的</p></blockquote><h4 id="生成映射下标"><a href="#生成映射下标" class="headerlink" title="生成映射下标"></a>生成映射下标</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br></pre></td></tr></table></figure><p>这一段代码和 求模的效果类似，根据hash生成一个0-(INITIAL_CAPACITY-1)之间的数</p><p>我们发现计算冲突与threadLocalHashCode 和 INITIAL_CAPACITY有关</p><h5 id="INITIAL-CAPACITY值的设置"><a href="#INITIAL-CAPACITY值的设置" class="headerlink" title="INITIAL_CAPACITY值的设置"></a>INITIAL_CAPACITY值的设置</h5><p>例如 ：</p><p>10 0001 0111 1101</p><p>00 0000 0000 1111 &amp; (INITIAL_CAPACITY-1) 即 15</p><hr><p>00 0000 0000 1101 13</p><p>所以这种算法只对后半段的数据敏感 如果是其他值 后面可能包含0 例如 0011 这样只有两位参与了运算，重复率就增加了，如果下面的值全是1 就更加平均了，什么时候全是1呢 就是 2的N次幂-1</p><p>例如</p><p>2^4=16=10000B</p><p>16-1=15= 01111B</p><p>所以只有当INITIAL_CAPACITY值时2的n次幂的时候才对hash的数据敏感，因为是与运算，只利用了hahs二进制的后半段。</p><h5 id="threadLocalHashCode-值的设置"><a href="#threadLocalHashCode-值的设置" class="headerlink" title="threadLocalHashCode 值的设置"></a>threadLocalHashCode 值的设置</h5><p>我们看下threadLocalHashCode 的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> threadLocalHashCode = nextHashCode();</span><br><span class="line"> <span class="comment">//返回下一个hashCode</span></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextHashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="comment">//通过CAS的方式进行获取并且相加</span></span><br><span class="line">     <span class="keyword">return</span> nextHashCode.getAndAdd(HASH_INCREMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面有一个神奇的数字 HASH_INCREMENT</p><p>他的声明是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br></pre></td></tr></table></figure><h5 id="神奇的数字"><a href="#神奇的数字" class="headerlink" title="神奇的数字"></a>神奇的数字</h5><p>既然<strong>ThreadLocal</strong>用map就避免不了冲突的产生</p><p>这里碰撞其实有两种类型</p><ol><li>只有一个ThreadLocal实例的时候(上面推荐的做法)，当向thread-local变量中设置多个值的时产生的碰撞，碰撞解决是通过开放定址法， 且是线性探测(linear-probe)</li><li>多个ThreadLocal实例的时候，最极端的是每个线程都new一个ThreadLocal实例，此时利用特殊的哈希码<strong>0x61c88647</strong>大大降低碰撞的几率， 同时利用开放定址法处理碰撞</li></ol><p>注意 <strong>0x61c88647</strong>的利用主要是为了多个ThreadLocal实例的情况下用的</p><p>注意实例变量threadLocalHashCode, 每当创建ThreadLocal实例时这个值都会累加 0x61c88647,<strong>为了让哈希码能均匀的分布在2的N次方的数组里, 即</strong> <code>Entry[] table</code>的大小必须是2的N次方</p><p>我们看下table的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * The table, resized as necessary.</span></span><br><span class="line"><span class="comment"> * 该表根据需要调整大小。</span></span><br><span class="line"><span class="comment"> * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment"> * table.length必须始终是2的幂。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Entry[] table;</span><br></pre></td></tr></table></figure><p><code>key.threadLocalHashCode &amp; (len-1)</code>这么用是什么意思? 我们上面定义了table数组的长度是16 =2^4</p><p>​ <strong>ThreadLocalMap</strong> 中Entry[] table的大小<strong>必须是2的N次方</strong>呀(len = 2^N)，那 <code>len-1</code> 的二进制表示就是低位连续的N个1， 那 <code>key.threadLocalHashCode &amp; (len-1)</code> 的值就是 <code>threadLocalHashCode</code> 的低N位, 这样就能均匀的产生均匀的分布? 我们做个实验。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//神奇的数字</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> HASH_INCREMENT = <span class="number">0x61c88647</span>;</span><br><span class="line"><span class="comment">//模拟table大小 16 2^4</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> tableSize = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    getHashIndex(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getHashIndex</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> nextHashCode = HASH_INCREMENT;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; i++) &#123;</span><br><span class="line">        <span class="comment">//每次进行*2 计算</span></span><br><span class="line">        nextHashCode += HASH_INCREMENT;</span><br><span class="line">        <span class="comment">//计算映射的小标</span></span><br><span class="line">        <span class="keyword">int</span> index = nextHashCode &amp; (tableSize - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//用Map进行统计</span></span><br><span class="line">        Integer count = map.computeIfAbsent(index, x -&gt; <span class="number">0</span>);</span><br><span class="line">        map.put(index, ++count);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(map);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">0</span>=<span class="number">62</span>, <span class="number">1</span>=<span class="number">63</span>, <span class="number">2</span>=<span class="number">62</span>, <span class="number">3</span>=<span class="number">63</span>, <span class="number">4</span>=<span class="number">62</span>, <span class="number">5</span>=<span class="number">63</span>, <span class="number">6</span>=<span class="number">62</span>, <span class="number">7</span>=<span class="number">62</span>, <span class="number">8</span>=<span class="number">63</span>, <span class="number">9</span>=<span class="number">62</span>, <span class="number">10</span>=<span class="number">63</span>, <span class="number">11</span>=<span class="number">62</span>, <span class="number">12</span>=<span class="number">63</span>, <span class="number">13</span>=<span class="number">62</span>, <span class="number">14</span>=<span class="number">63</span>, <span class="number">15</span>=<span class="number">63</span>&#125;</span><br></pre></td></tr></table></figure><p>我们发现数据分布的惊人的平均，比我们写的随机数更平均。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="Hash冲突怎么解决"><a href="#Hash冲突怎么解决" class="headerlink" title="Hash冲突怎么解决"></a>Hash冲突怎么解决</h4><p>​ 和HashMap的最大的不同在于，ThreadLocalMap结构非常简单，没有next引用，也就是说ThreadLocalMap中解决Hash冲突的方式并非链表的方式，而是采用线性探测的方式，所谓线性探测，就是根据初始key的hashcode值确定元素在table数组中的位置，如果发现这个位置上已经有其他key值的元素被占用，则利用固定的算法寻找一定步长的下个位置，依次判断，直至找到能够存放的位置。</p><h4 id="内存泄露问题"><a href="#内存泄露问题" class="headerlink" title="内存泄露问题"></a>内存泄露问题</h4><p>​ threadlocal里面使用了一个存在弱引用的map,当释放掉threadlocal的强引用以后,map里面的value却没有被回收.而这块value永远不会被访问到了. 所以存在着内存泄露. 最好的做法是将调用threadlocal的remove方法.</p><p>​ 因为ThreadLocal本身又清理机制，调用，get,set,remove等方法时会触发自动清理机制，清理掉key为空的主句，但是不是实时的，会有延后，在没有调用get,set,remove方法时，过期的entry时内存泄漏状态，推荐不适用了调用remove方法。</p><h4 id="hash散列算法"><a href="#hash散列算法" class="headerlink" title="hash散列算法"></a>hash散列算法</h4><p>​ 在实际使用中，不同的输入可能会散列成相同的输出，这时也就产生了冲突。通过上文提到的 <code>HASH_INCREMENT</code> 再借助一定的算法，就可以将哈希码能均匀的分布在 2 的 N 次方的数组里，保证了散列表的离散度，从而降低了冲突几率，使用<code>nextHashCode &amp; (tableSize - 1);</code>这种方式进行下标映射性能更高，使用用<code>HASH_INCREMENT</code> <strong>0x61c88647</strong> 这个神奇的数字让数据分布的更平均。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      ThreadLocal源码解析
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="ThreadLocal" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/ThreadLocal/"/>
    
    
      <category term="ThreadLocal" scheme="http://www.baiyp.ren/tags/ThreadLocal/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码解析01</title>
    <link href="http://www.baiyp.ren/ThreadLocal%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%9001.html"/>
    <id>http://www.baiyp.ren/ThreadLocal源码解析01.html</id>
    <published>2019-08-16T11:49:37.000Z</published>
    <updated>2019-08-22T02:08:03.643Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="ThreadLocal源码解析01"><a href="#ThreadLocal源码解析01" class="headerlink" title="ThreadLocal源码解析01"></a>ThreadLocal源码解析01</h2><blockquote><p>先看下set的流程图</p></blockquote><p><img src="../images/threadlocal_source06.png" alt></p><h3 id="ThreadLocal-简介"><a href="#ThreadLocal-简介" class="headerlink" title="ThreadLocal 简介"></a>ThreadLocal 简介</h3><p>​ ThreadLocal 在面试中经常提到，关于ThreadLocal使用不当造成OOM以及在特殊场景下，通过ThreadLocal可以轻松实现一些看起来复杂的功能，都说明值得花时间研究其原理。</p><p>​ ThreadLocal 不是 Thread，是一个<strong>线程内部的数据存储类</strong>，通过它可以在指定的线程中存储数据，每个线程存储的是主线程变量的副本，子线程操作的是对副本进行操作，不影响其他子线程的中的数据，所以一般说，ThreadLocal不保证线程的安全，只保证线程的隔离。</p><p>​ 举个例子，如果ThreadLocal保存保存的是一个静态变量，副本都是静态变量自己，这样就又会出现线程安全问题。</p><h4 id="ThreadLocal-注意事项"><a href="#ThreadLocal-注意事项" class="headerlink" title="ThreadLocal 注意事项"></a>ThreadLocal 注意事项</h4><ol><li><p>ThreadLocal类封装了getMap()、set()、get()、remove()4个核心方法</p></li><li><p>通过getMap()获取每个<strong>子线程</strong>Thread持有自己的<strong>ThreadLocalMap</strong>实例, 因此它们是不存在并发竞争的。可以理解为每个线程有自己的变量副本。</p></li><li><p>ThreadLocalMap中Entry[]数组存储数据，初始化长度16，后续每次都是2倍扩容。主线程中定义了几个变量，Entry[]中就有几个key。</p></li><li><p>Entry的key是对ThreadLocal的弱引用，当抛弃掉ThreadLocal对象时，垃圾收集器会忽略这个key的引用而清理掉ThreadLocal对象， 防止了内存泄漏。</p></li></ol><h2 id="源码解读"><a href="#源码解读" class="headerlink" title="源码解读"></a>源码解读</h2><blockquote><p>看源码要有入口我们先从初始化开始</p></blockquote><h3 id="ThreadLocal-初始化方式"><a href="#ThreadLocal-初始化方式" class="headerlink" title="ThreadLocal 初始化方式"></a>ThreadLocal 初始化方式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 定义一个ThreadLocal</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//设置变量的值</span></span><br><span class="line">       threadLocal.set(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们发现ThreadLocal的set方法是设置值的，他为什么能是变量的副本呢我们进入set方法</p><h3 id="ThreadLocal-set-方法"><a href="#ThreadLocal-set-方法" class="headerlink" title="ThreadLocal.set 方法"></a>ThreadLocal.set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置此线程局部变量的当前线程副本</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取当前线程</span></span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    <span class="comment">//根据当前线程获取ThreadLocalMap</span></span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果map为空就创建一个显得Map参数是当前线程和我们需要设置的值</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我看看set方法 很简单，获取当前线程，根据当前线程获取ThreadLocalMap，有的话就set没有就创建</p><p>我们可以这样理解 ThreadLocalMap 和当前线程有关，我们进去看下</p><h4 id="ThreadLocal-getMap方法"><a href="#ThreadLocal-getMap方法" class="headerlink" title="ThreadLocal.getMap方法"></a>ThreadLocal.getMap方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从当前线程获取  ThreadLocalMap</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>好吧到这里 确定了ThreadLocalMap 实在当前线程中存储了，这也解释了为什么是变量的副本，调用ThreadLocal的set方法实际上是将值放进当前的线程中了，每个线程中的值是不一样的。</p><p>我们需要进入Thread内部看源码了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//再Thread 中定义的ThreadLocalMap</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>我们发现ThreadLocalMap 实在Thread类中定义的</p><p>到这里ThreadLocal.getMap方法解析完了，我们需要看createMap方法了。</p><h4 id="ThreadLocal-createMap方法"><a href="#ThreadLocal-createMap方法" class="headerlink" title="ThreadLocal.createMap方法"></a>ThreadLocal.createMap方法</h4><blockquote><p>set 方法是获取线程内部的ThreadLocalMap，初始化肯定为空，就需要调用createMap了</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建ThreadLocalMap</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * this 就是ThreadLocal 本身</span></span><br><span class="line"><span class="comment">        * </span></span><br><span class="line"><span class="comment">        * firstValue 就是我们需要保存的值</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我看看这段代码，很有意思，ThreadLocalMap的key是threadLocal本身，value则是我们需要设置的值，这里就出现一个问题，key是相同的，如果一个ThreadLocal有多个值肯定会被覆盖，所以可以确定，ThreadLocalMap是用来处理<strong>一个线程中存在多个ThreadLocal</strong>的问题，value肯定有更细化的对象存储，我们进去看看ThreadLocalMap的构造方法。</p><h4 id="ThreadLocalMap的构造方法"><a href="#ThreadLocalMap的构造方法" class="headerlink" title="ThreadLocalMap的构造方法"></a>ThreadLocalMap的构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *构建一个最初包含（firstkey，firstvalue）的新的 ThreadLocalMap。</span></span><br><span class="line"><span class="comment"> *因为Thread中的 ThreadLocalMaps是懒加载构造的，所以我们只创建</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstKey ThreadLocal 本身</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> firstValue  需要存放的第一个值</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ThreadLocalMap(ThreadLocal&lt;?&gt; firstKey, Object firstValue) &#123;</span><br><span class="line">    <span class="comment">//创建一个Entry数组的表，初始化大小为INITIAL_CAPACITY</span></span><br><span class="line">    table = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[INITIAL_CAPACITY];</span><br><span class="line">    <span class="comment">//通过与运算将threadLocalHashCode映射到一个数组下标</span></span><br><span class="line">    <span class="comment">//他比取模或者求余速度快性能高</span></span><br><span class="line">    <span class="keyword">int</span> i = firstKey.threadLocalHashCode &amp; (INITIAL_CAPACITY - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//将取模后的值映射到对应的Entry数组中的某个位置</span></span><br><span class="line">    table[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(firstKey, firstValue);</span><br><span class="line">    <span class="comment">//因为第一次调用设置size为1</span></span><br><span class="line">    size = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//计算下次需要扩容的值</span></span><br><span class="line">    setThreshold(INITIAL_CAPACITY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//setThreshold方法是计算扩容下次扩容的阈值的</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setThreshold</span><span class="params">(<span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    threshold = len * <span class="number">2</span> / <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下Entry</p><h5 id="ThreadLocalMap-Entry"><a href="#ThreadLocalMap-Entry" class="headerlink" title="ThreadLocalMap.Entry"></a>ThreadLocalMap.Entry</h5><p><img src="../images/threadlocal_source02.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal作为key进行软引用</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">          <span class="comment">//与ThreadLocal相绑定的值</span></span><br><span class="line">            Object value;</span><br><span class="line">     Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里使用了<strong>WeakReference</strong> 软引用</p><p><strong>WeakReference</strong>： 当一个对象仅仅被weak reference（软引用）指向, 而没有任何其他strong reference（强引用）指向的时候, 如果这时GC运行, 那么这个对象就会被回收，不论当前的内存空间是否足够，这个对象都会被回收。</p><p>也就是如果当前线程的ThreadLocal 被销毁后，因为当前线程引用了ThreadLocalMap，所以当前线程和entry还是强引用，因为ThreadLocal在entry是软引用，所以垃圾回收key(ThreadLocal)会被销毁，entry中的value没有被销毁，但是没有key造成无法访问，这就造成了<strong>内存泄漏</strong>，ThreadLocal为了防止内存泄漏我们会在后面详细的说。</p><p><img src="../images/threadlocal02.png" alt></p><h4 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h4><p>我们回顾上面介绍的内容我们看下ThreadLocal整体结构的图解</p><p><img src="../images/threadlocal_source04.png" alt></p><h4 id="ThreadLocalMap-set方法"><a href="#ThreadLocalMap-set方法" class="headerlink" title="ThreadLocalMap.set方法"></a>ThreadLocalMap.set方法</h4><blockquote><p>我们上面介绍了getMap和createMap方法，我们来看看map.set方法</p></blockquote><h5 id="线性探测算法"><a href="#线性探测算法" class="headerlink" title="线性探测算法"></a>线性探测算法</h5><p>​ ThreadLocalMap使用<code>线性探测法</code>来解决哈希冲突，线性探测法的地址增量di = 1, 2, … , m-1，其中，i为探测次数。该方法一次探测下一个地址，直到有空的地址后插入，若整个空间都找不到空余的地址，则产生溢出。假设当前table长度为16，也就是说如果计算出来key的hash值为14，如果table[14]上已经有值，并且其key与当前key不一致，那么就发生了hash冲突，这个时候将14加1得到15，取table[15]进行判断，这个时候如果还是冲突会回到0，取table[0],以此类推，直到可以插入。</p><p>先看一下线性探测相关的代码，从中也可以看出来table实际是一个环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**java</span></span><br><span class="line"><span class="comment">    * 获取环形数组的下一个索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">nextIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ((i + <span class="number">1</span> &lt; len) ? i + <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 获取环形数组的上一个索引</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">prevIndex</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> ((i - <span class="number">1</span> &gt;= <span class="number">0</span>) ? i - <span class="number">1</span> : len - <span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h5 id="ThreadLocalMap的set"><a href="#ThreadLocalMap的set" class="headerlink" title="ThreadLocalMap的set()"></a>ThreadLocalMap的set()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 将Value设置进对应的ThreadLocal 的key 中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">    <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">    <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">    <span class="comment">// path would fail more often than not.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 不使用 get的快速路径 set一般是替换方式</span></span><br><span class="line"><span class="comment">     * 快速路径一般会失败</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">    <span class="comment">//获取table的长度</span></span><br><span class="line">    <span class="keyword">int</span> len = tab.length;</span><br><span class="line">    <span class="comment">//计算需要映射的table下标</span></span><br><span class="line">    <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 根据获取到的索引进行循环，如果当前索引上的table[i]不为空，在没有return的情况下，</span></span><br><span class="line"><span class="comment">     * 就使用nextIndex()获取下一个（上面提到到线性探测法）。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (ThreadLocal.ThreadLocalMap.Entry e = tab[i]; e != <span class="keyword">null</span>; e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">        <span class="comment">//获取当前的ThreadLocal</span></span><br><span class="line">        ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">        <span class="comment">//如果entry中的ThreadLocal(k) 和 传进来的 ThreadLocal(key)是同一个</span></span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">            <span class="comment">//将 e.value替换为新的value</span></span><br><span class="line">            e.value = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * table[i]上的key为空，说明被回收了（上面的弱引用中提到过）。</span></span><br><span class="line"><span class="comment">         * 这个时候说明改table[i]可以重新使用，用新的key-value将其替换,并删除其他无效的entry</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//对key为空的entry进行重新赋值替换</span></span><br><span class="line">            replaceStaleEntry(key, value, i);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找到为空的插入位置，插入值，在为空的位置插入需要对size进行加1操作</span></span><br><span class="line">    tab[i] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line">    <span class="keyword">int</span> sz = ++size;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * cleanSomeSlots用于清除那些e.get()==null，也就是table[index] != null &amp;&amp; table[index].get()==null</span></span><br><span class="line"><span class="comment">     * 之前提到过，这种数据key关联的对象已经被回收，所以这个Entry(table[index])可以被置null。</span></span><br><span class="line"><span class="comment">     * 如果没有清除任何entry,并且当前使用量达到了负载因子所定义(长度的2/3)，那么进行rehash()</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">        rehash();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 大致分析上面都已经标注出来了，需要注意的是Entry对象是继承是WeakReference也就是一个弱引用是会被回收的，所以对应 的key值可能是为null的。存放对象之后是需要判断数组中存储对象的个数是否超过了设定的临界值threshold的大小，如果超过了需要扩容，并且还要重新计算扩容后所有对象的位置。扩容的方法是rehash()</p><h6 id="replaceStaleEntry-替换无效的key"><a href="#replaceStaleEntry-替换无效的key" class="headerlink" title="replaceStaleEntry 替换无效的key"></a>replaceStaleEntry 替换无效的key</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 替换无效entry</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceStaleEntry</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                  <span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">       ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">       <span class="keyword">int</span> len = tab.length;</span><br><span class="line">       ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 根据传入的无效entry的位置（staleSlot）,向前扫描</span></span><br><span class="line"><span class="comment">        * 一段连续的entry(这里的连续是指一段相邻的entry并且table[i] != null),</span></span><br><span class="line"><span class="comment">        * 直到找到一个无效entry，或者扫描完也没找到</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">int</span> slotToExpunge = staleSlot;<span class="comment">//之后用于清理的起点</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = prevIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = prevIndex(i, len))</span><br><span class="line">           <span class="keyword">if</span> (e.get() == <span class="keyword">null</span>)</span><br><span class="line">               slotToExpunge = i;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 向后扫描一段连续的entry</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = nextIndex(staleSlot, len);</span><br><span class="line">            (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">            i = nextIndex(i, len)) &#123;</span><br><span class="line">           ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 如果找到了key，将其与传入的无效entry替换，也就是与table[staleSlot]进行替换</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">               e.value = value;</span><br><span class="line"></span><br><span class="line">               tab[i] = tab[staleSlot];</span><br><span class="line">               tab[staleSlot] = e;</span><br><span class="line"></span><br><span class="line">               <span class="comment">//如果向前查找没有找到无效entry，则更新slotToExpunge为当前值i</span></span><br><span class="line">               <span class="keyword">if</span> (slotToExpunge == staleSlot)</span><br><span class="line">                   slotToExpunge = i;</span><br><span class="line">               cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 如果向前查找没有找到无效entry，并且当前向后扫描的entry无效，则更新slotToExpunge为当前值i</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (k == <span class="keyword">null</span> &amp;&amp; slotToExpunge == staleSlot)</span><br><span class="line">               slotToExpunge = i;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * 如果没有找到key,也就是说key之前不存在table中</span></span><br><span class="line"><span class="comment">        * 就直接最开始的无效entry——tab[staleSlot]上直接新增即可</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">       tab[staleSlot] = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry(key, value);</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * slotToExpunge != staleSlot,说明存在其他的无效entry需要进行清理。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">if</span> (slotToExpunge != staleSlot)</span><br><span class="line">           cleanSomeSlots(expungeStaleEntry(slotToExpunge), len);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h6 id="expungeStaleEntry-连续段清除"><a href="#expungeStaleEntry-连续段清除" class="headerlink" title="expungeStaleEntry 连续段清除"></a>expungeStaleEntry 连续段清除</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 连续段清除</span></span><br><span class="line"><span class="comment">     * 根据传入的staleSlot,清理对应的无效entry——table[staleSlot],</span></span><br><span class="line"><span class="comment">     * 并且根据当前传入的staleSlot,向后扫描一段连续的entry(这里的连续是指一段相邻的entry并且table[i] != null),</span></span><br><span class="line"><span class="comment">     * 对可能存在hash冲突的entry进行rehash，并且清理遇到的无效entry.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> staleSlot key为null,需要无效entry所在的table中的索引</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回下一个为空的solt的索引。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">expungeStaleEntry</span><span class="params">(<span class="keyword">int</span> staleSlot)</span> </span>&#123;</span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">        <span class="keyword">int</span> len = tab.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 清理无效entry，置空</span></span><br><span class="line">        tab[staleSlot].value = <span class="keyword">null</span>;</span><br><span class="line">        tab[staleSlot] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//size减1，置空后table的被使用量减1</span></span><br><span class="line">        size--;</span><br><span class="line"></span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry e;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 从staleSlot开始向后扫描一段连续的entry</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (i = nextIndex(staleSlot, len);</span><br><span class="line">             (e = tab[i]) != <span class="keyword">null</span>;</span><br><span class="line">             i = nextIndex(i, len)) &#123;</span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">//如果遇到key为null,表示无效entry，进行清理.</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                e.value = <span class="keyword">null</span>;</span><br><span class="line">                tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                size--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果key不为null,计算索引</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 计算出来的索引——h，与其现在所在位置的索引——i不一致，置空当前的table[i]</span></span><br><span class="line"><span class="comment">                 * 从h开始向后线性探测到第一个空的slot，把当前的entry挪过去。</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (h != i) &#123;</span><br><span class="line">                    tab[i] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">while</span> (tab[h] != <span class="keyword">null</span>)</span><br><span class="line">                        h = nextIndex(h, len);</span><br><span class="line">                    tab[h] = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//下一个为空的solt的索引。</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h6 id="cleanSomeSlots-清理脏数据"><a href="#cleanSomeSlots-清理脏数据" class="headerlink" title="cleanSomeSlots 清理脏数据"></a>cleanSomeSlots 清理脏数据</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 启发式的扫描清除，扫描次数由传入的参数n决定</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> i 从i向后开始扫描（不包括i，因为索引为i的Slot肯定为null）</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> n 控制扫描次数，正常情况下为 log2(n) ，</span></span><br><span class="line"><span class="comment">    * 如果找到了无效entry，会将n重置为table的长度len,进行段清除。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * map.set()点用的时候传入的是元素个数，replaceStaleEntry()调用的时候传入的是table的长度len</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span> true if any stale entries have been removed.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">cleanSomeSlots</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">       ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">       <span class="keyword">int</span> len = tab.length;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           i = nextIndex(i, len);</span><br><span class="line">           ThreadLocal.ThreadLocalMap.Entry e = tab[i];</span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">//重置n为len</span></span><br><span class="line">               n = len;</span><br><span class="line">               removed = <span class="keyword">true</span>;</span><br><span class="line">               <span class="comment">//依然调用expungeStaleEntry来进行无效entry的清除</span></span><br><span class="line">               i = expungeStaleEntry(i);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">while</span> ( (n &gt;&gt;&gt;= <span class="number">1</span>) != <span class="number">0</span>);<span class="comment">//无符号的右移动，可以用于控制扫描次数在log2(n)</span></span><br><span class="line">       <span class="keyword">return</span> removed;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>n的用途</p><p>​ 主要用于<strong>扫描控制（scan control），从while中是通过n来进行条件判断的说明n就是用来控制扫描趟数（循环次数）的</strong>。在扫描过程中，如果没有遇到脏entry就整个扫描过程持续log2(n)次，log2(n)的得来是因为<code>n &gt;&gt;&gt;= 1</code>，每次n右移一位相当于n除以2。如果在扫描过程中遇到脏entry的话就会令n为当前hash表的长度（<code>n=len</code>），再扫描log2(n)趟，注意此时n增加无非就是多增加了循环次数从而通过nextIndex往后搜索的范围扩大，示意图如下<br><img src="../images/threadlocal_source05.png" alt></p><h6 id="rehash-重新整理"><a href="#rehash-重新整理" class="headerlink" title="rehash 重新整理"></a>rehash 重新整理</h6><blockquote><p>rehash 方法分两步</p><p>1、先是删除过期的对象：expungeStaleEntries()；</p><p>2、如果存储对象个数大于临界值的3/4，扩容</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 刷新ThreadLocal</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rehash</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="comment">//全清理过期的数据</span></span><br><span class="line">    expungeStaleEntries();</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * threshold = 2/3 * len</span></span><br><span class="line"><span class="comment">     * 所以threshold - threshold / 4 = 1en/2</span></span><br><span class="line"><span class="comment">     * 这里主要是因为上面做了一次全清理所以size减小，需要进行判断。</span></span><br><span class="line"><span class="comment">     * 判断的时候把阈值调低了。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (size &gt;= threshold - threshold / <span class="number">4</span>)</span><br><span class="line">        <span class="comment">//扩容</span></span><br><span class="line">        resize();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="expungeStaleEntries-全清理无效的entry"><a href="#expungeStaleEntries-全清理无效的entry" class="headerlink" title="expungeStaleEntries  全清理无效的entry"></a>expungeStaleEntries 全清理无效的entry</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 全清理，清理所有无效entry</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">expungeStaleEntries</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      ThreadLocal.ThreadLocalMap.Entry[] tab = table;</span><br><span class="line">      <span class="keyword">int</span> len = tab.length;</span><br><span class="line">      <span class="comment">//遍历整个table</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">          ThreadLocal.ThreadLocalMap.Entry e = tab[j];</span><br><span class="line">         <span class="comment">// Entry存在且key不存在 就是 threadLoca已被GC回收</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span> &amp;&amp; e.get() == <span class="keyword">null</span>)</span><br><span class="line">              <span class="comment">//使用连续段清理</span></span><br><span class="line">              expungeStaleEntry(j);</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>​ 删除数组中过时的Entry对象。有些小伙伴可能会有些疑问什么是过时的Entry？为什么会过时？其实这个在前面说过，Entry是弱引用会被回收。这个方法中判断的删除条件是，Entry对象不为空并且key值为空。可见expungStaleEntry(j) 方法就是删除指定索引的Entry对象。</p><h6 id="resize扩容方法"><a href="#resize扩容方法" class="headerlink" title="resize扩容方法"></a>resize扩容方法</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 扩容，扩大为原来的2倍（这样保证了长度为2的冥）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//将table 赋值为old table</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] oldTab = table;</span><br><span class="line">    <span class="keyword">int</span> oldLen = oldTab.length;</span><br><span class="line">    <span class="comment">//扩容是原来的二倍</span></span><br><span class="line">    <span class="keyword">int</span> newLen = oldLen * <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//创建一个新的table</span></span><br><span class="line">    ThreadLocal.ThreadLocalMap.Entry[] newTab = <span class="keyword">new</span> ThreadLocal.ThreadLocalMap.Entry[newLen];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历old table</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldLen; ++j) &#123;</span><br><span class="line">        <span class="comment">//获取当前遍历到的entry</span></span><br><span class="line">        ThreadLocal.ThreadLocalMap.Entry e = oldTab[j];</span><br><span class="line">        <span class="comment">//如果存在entry</span></span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//获取key</span></span><br><span class="line">            ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line">            <span class="comment">//虽然做过一次清理，但在扩容的时候可能会又存在key==null的情况。</span></span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//将value置为空，让GC进行回收</span></span><br><span class="line">                e.value = <span class="keyword">null</span>; <span class="comment">// Help the GC</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//重新计算下标</span></span><br><span class="line">                <span class="keyword">int</span> h = k.threadLocalHashCode &amp; (newLen - <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//同样适用线性探测来设置值，如果发生hahs冲突找到向后找到最近的一个空位</span></span><br><span class="line">                <span class="keyword">while</span> (newTab[h] != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    h = nextIndex(h, newLen);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将entry 放进计算出的table对应的下标数组中</span></span><br><span class="line">                newTab[h] = e;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重新设置下次扩容的阈值</span></span><br><span class="line">    setThreshold(newLen);</span><br><span class="line">    <span class="comment">//赋值threadLocal 的size</span></span><br><span class="line">    size = count;</span><br><span class="line">    <span class="comment">//将新的table赋值为 table对象</span></span><br><span class="line">    table = newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 先是创建一个是原来容量两倍的Entry[]数组，在遍历原来的数组，将key值为空的Entry对象的value置为空方便GC回收，key不为空的Entry对象先根据key的hashcode计算需要存放的位置存入新的数组中，存储结束后别忘了更新临界值。</p><p>到这里整个set方法的过程也完结了</p><blockquote><p>下一篇介绍其他的方法以及threadlocal的总结</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      ThreadLocal源码解析
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="ThreadLocal" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/ThreadLocal/"/>
    
    
      <category term="ThreadLocal" scheme="http://www.baiyp.ren/tags/ThreadLocal/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>JAVA中的分布式事务07-Saga事务(最终一致性)</title>
    <link href="http://www.baiyp.ren/JAVA%E4%B8%AD%E7%9A%84%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A107.html"/>
    <id>http://www.baiyp.ren/JAVA中的分布式事务07.html</id>
    <published>2019-08-16T02:05:25.000Z</published>
    <updated>2019-08-22T02:09:30.959Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="JAVA中的分布式事务07-Saga事务-最终一致性"><a href="#JAVA中的分布式事务07-Saga事务-最终一致性" class="headerlink" title="JAVA中的分布式事务07-Saga事务(最终一致性)"></a>JAVA中的分布式事务07-Saga事务(最终一致性)</h2><h3 id="方案简介"><a href="#方案简介" class="headerlink" title="方案简介"></a>方案简介</h3><p>​ Saga事务源于1987年普林斯顿大学的Hecto和Kenneth发表的如何处理long lived transaction（长活事务）论文，Saga事务核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则根据相反顺序一次调用补偿操作。</p><h3 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h3><h4 id="Saga事务基本协议"><a href="#Saga事务基本协议" class="headerlink" title="Saga事务基本协议"></a>Saga事务基本协议</h4><ul><li><p>每个Saga事务由一系列幂等的有序子事务(sub-transaction) Ti 组成。</p></li><li><p>每个Ti 都有对应的幂等补偿动作Ci，补偿动作用于撤销Ti造成的结果。</p></li></ul><p>可以看到，和TCC相比，Saga没有“预留”动作，它的Ti就是直接提交到库。</p><p>下面以下单流程为例，整个操作包括：创建订单、扣减库存、支付、增加积分<br>Saga的执行顺序有两种：</p><p><img src="../images/transaction22.png" alt="Saga事务执行顺序"></p><blockquote><p>事务正常执行完成<br>T1, T2, T3, …, Tn，例如：扣减库存(T1)，创建订单(T2)，支付(T3)，依次有序完成整个事务。</p><p>事务回滚<br>T1, T2, …, Tj, Cj,…, C2, C1，其中0 &lt; j &lt; n，例如：扣减库存(T1)，创建订单(T2)，支付(T3，支付失败)，支付回滚(C3)，订单回滚(C2)，恢复库存(C1)。</p></blockquote><h4 id="Saga的两种恢复策略"><a href="#Saga的两种恢复策略" class="headerlink" title="Saga的两种恢复策略"></a>Saga的两种恢复策略</h4><h5 id="向前恢复-forward-recovery"><a href="#向前恢复-forward-recovery" class="headerlink" title="向前恢复(forward recovery)"></a>向前恢复(forward recovery)</h5><p><img src="../images/transaction23.png" alt="Saga事务向前恢复"></p><blockquote><p>对应于上面第一种执行顺序，适用于必须要成功的场景，发生失败进行重试，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的子事务(sub-transaction)。该情况下不需要Ci。</p></blockquote><h5 id="向后恢复-backward-recovery"><a href="#向后恢复-backward-recovery" class="headerlink" title="向后恢复(backward recovery)"></a>向后恢复(backward recovery)</h5><p><img src="../images/transaction24.png" alt="Saga事务向后恢复"></p><blockquote><p>对应于上面提到的第二种执行顺序，其中j是发生错误的子事务(sub-transaction)，这种做法的效果是撤销掉之前所有成功的子事务，使得整个Saga的执行结果撤销。</p></blockquote><h3 id="Saga事务常见的有两种不同的实现方式"><a href="#Saga事务常见的有两种不同的实现方式" class="headerlink" title="Saga事务常见的有两种不同的实现方式"></a>Saga事务常见的有两种不同的实现方式</h3><h4 id="命令协调-Order-Orchestrator"><a href="#命令协调-Order-Orchestrator" class="headerlink" title="命令协调(Order Orchestrator)"></a>命令协调(Order Orchestrator)</h4><blockquote><p><strong>中央协调器负责集中处理事件的决策和业务逻辑排序。</strong></p></blockquote><p>​ 中央协调器（Orchestrator，简称OSO）以命令/回复的方式与每项服务进行通信，全权负责告诉每个参与者该做什么以及什么时候该做什么。</p><p><img src="../images/transaction25.png" alt="命令协调模式"></p><p>以电商订单的例子为例：</p><blockquote><p>1、事务发起方的主业务逻辑请求OSO服务开启订单事务<br>2、OSO向库存服务请求扣减库存，库存服务回复处理结果。<br>3、OSO向订单服务请求创建订单，订单服务回复创建结果。<br>4、OSO向支付服务请求支付，支付服务回复处理结果。<br>5、主业务逻辑接收并处理OSO事务处理结果回复。</p></blockquote><p>​ 中央协调器必须事先知道执行整个订单事务所需的流程(例如通过读取配置)。如果有任何失败，它还负责通过向每个参与者发送命令来撤销之前的操作来协调分布式的回滚。基于中央协调器协调一切时，回滚要容易得多，因为协调器默认是执行正向流程，回滚时只要执行反向流程即可。</p><h4 id="事件编排-Event-Choreography"><a href="#事件编排-Event-Choreography" class="headerlink" title="事件编排 (Event Choreography)"></a>事件编排 (Event Choreography)</h4><blockquote><p><strong>没有中央协调器（没有单点风险）时，每个服务产生并观察其他服务的事件，并决定是否应采取行动</strong>。</p></blockquote><p>​ 在事件编排方法中，第一个服务执行一个事务，然后发布一个事件。该事件被一个或多个服务进行监听，这些服务再执行本地事务并发布（或不发布）新的事件。</p><p>当最后一个服务执行本地事务并且不发布任何事件时，意味着分布式事务结束，或者它发布的事件没有被任何Saga参与者听到都意味着事务结束。</p><p>以电商订单的例子为例：</p><p><img src="../images/transaction26.png" alt="事件编排模式"></p><blockquote><p>1、事务发起方的主业务逻辑发布开始订单事件<br>2、库存服务监听开始订单事件，扣减库存，并发布库存已扣减事件<br>2、订单服务监听库存已扣减事件，创建订单，并发布订单已创建事件<br>4、支付服务监听订单已创建事件，进行支付，并发布订单已支付事件<br>5、主业务逻辑监听订单已支付事件并处理。</p></blockquote><h3 id="方案总结"><a href="#方案总结" class="headerlink" title="方案总结"></a>方案总结</h3><h4 id="命令协调设计的优点和缺点"><a href="#命令协调设计的优点和缺点" class="headerlink" title="命令协调设计的优点和缺点"></a>命令协调设计的优点和缺点</h4><h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul><li>1、服务之间关系简单，避免服务之间的循环依赖关系，因为Saga协调器会调用Saga参与者，但参与者不会调用协调器</li><li>2、程序开发简单，只需要执行命令/回复(其实回复消息也是一种事件消息)，降低参与者的复杂性。</li><li>3、易维护扩展，在添加新步骤时，事务复杂性保持线性，回滚更容易管理，更容易实施和测试</li></ul><h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul><li>1、中央协调器容易处理逻辑容易过于复杂，导致难以维护。</li><li>2、存在协调器单点故障风险。</li></ul><h4 id="事件-编排设计的优点和缺点"><a href="#事件-编排设计的优点和缺点" class="headerlink" title="事件/编排设计的优点和缺点"></a>事件/编排设计的优点和缺点</h4><h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul><li>1、避免中央协调器单点故障风险。</li><li>2、当涉及的步骤较少服务开发简单，容易实现。</li></ul><h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul><li>1、服务之间存在循环依赖的风险。</li><li>2、当涉及的步骤较多，服务间关系混乱，难以追踪调测。</li></ul><p>值得补充的是，由于Saga模型中没有Prepare阶段，因此事务间不能保证隔离性，当多个Saga事务操作同一资源时，就会产生更新丢失、脏数据读取等问题，这时需要在业务层控制并发，例如：在应用层面加锁，或者应用层面预先冻结资源。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA中的分布式事务Saga事务(最终一致性)
    
    </summary>
    
      <category term="架构" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式事务" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
    
      <category term="架构" scheme="http://www.baiyp.ren/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="分布式事务" scheme="http://www.baiyp.ren/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    
      <category term="Saga" scheme="http://www.baiyp.ren/tags/Saga/"/>
    
  </entry>
  
  <entry>
    <title>JAVA动态代理源码分析</title>
    <link href="http://www.baiyp.ren/JAVA%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90.html"/>
    <id>http://www.baiyp.ren/JAVA动态代理源码分析.html</id>
    <published>2019-08-15T02:28:05.000Z</published>
    <updated>2019-08-22T02:07:51.270Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="JAVA动态代理源码分析"><a href="#JAVA动态代理源码分析" class="headerlink" title="JAVA动态代理源码分析"></a>JAVA动态代理源码分析</h2><p><img src="../images/proxy.jpg" alt></p><h3 id="动态代理简介"><a href="#动态代理简介" class="headerlink" title="动态代理简介"></a>动态代理简介</h3><p>​ <strong>Proxy</strong>模式是常用的设计模式，其特征是代理类与委托类有同样的接口，代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后处理消息等。</p><p>用户可以更加结构图，自己编码完成Proxy模式。这种实现称为静态代理。</p><p>​ Java提供了java.lang.reflect.<strong>Proxy</strong>类与<strong>InvocationHandler</strong>接口，配合反射，可以实现动态代理。静态代理的代理类与代理操作，都是事先编码，运行过程种无法修改代理结构。动态代理的代理与代理操作，都是在运行过程中，动态生成，可以在运行过程中，修改代理结构，符合面向对象的开闭原则。</p><p>​ 最最最主要的原因就是，<strong>在不改变目标对象方法的情况下对方法进行增强</strong>，比如，我们希望对方法的调用增加日志记录，或者对方法的调用进行拦截，等等…</p><p>​ 动态代理用于将在不需要修改原代码的情况下进行代码的增加，spring中的AOP，事务，都是使用动态代理来实现的，我们天天都在使用动态代理只是自己不知道而已。</p><h3 id="动态代理三大要素"><a href="#动态代理三大要素" class="headerlink" title="动态代理三大要素"></a>动态代理三大要素</h3><ol><li><p>需要定义一个接口</p><p>java动态代理类只能代理接口<strong>（不支持抽象类）</strong>，如果没有接口就要使用<strong>cjlib</strong></p></li><li><p>需要一个实现类继承这个接口</p></li><li><p>编写一个增强类实现 InvocationHandler接口</p><p>代理类都需要实现InvocationHandler接口的<strong>invoke方法</strong></p></li></ol><h3 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h3><h4 id="先定义一个接口"><a href="#先定义一个接口" class="headerlink" title="先定义一个接口"></a>先定义一个接口</h4><blockquote><p>定义一个海外代购的接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 海外代购</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Buying</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buy</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写一个实现类"><a href="#编写一个实现类" class="headerlink" title="编写一个实现类"></a>编写一个实现类</h4><blockquote><p>实现类实现接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuyingImpl</span> <span class="keyword">implements</span> <span class="title">Buying</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">buy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"开始逻辑处理"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"买了个锤子"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写一个增将类"><a href="#编写一个增将类" class="headerlink" title="编写一个增将类"></a>编写一个增将类</h4><blockquote><p>编写一个增强类，主要要包裹一个需要需要增强的对象也就是我们的BuyingImpl，并实现InvocationHandler接口，在invoke方法中写增强实现</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 海外代购增强类</span></span><br><span class="line"><span class="comment"> * 注意实现 InvocationHandler</span></span><br><span class="line"><span class="comment"> *  动态代理类只能代理接口（不支持抽象类），代理类都需要实现InvocationHandler类，实现invoke方法。</span></span><br><span class="line"><span class="comment"> *  该invoke方法就是调用被代理接口的所有方法时需要调用的 。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuingHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 包裹一个需要增强的目标对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BuingHandler</span><span class="params">(Object targetObject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetObject = targetObject;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取代理类</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getProxy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span><br><span class="line"><span class="comment">         * 第一个参数指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器</span></span><br><span class="line"><span class="comment">         * 第二个参数要实现和目标对象一样的接口，所以只需要拿到目标对象的实现接口</span></span><br><span class="line"><span class="comment">         * 第三个参数表明这些被拦截的方法在被拦截时需要执行哪个InvocationHandler的invoke方法</span></span><br><span class="line"><span class="comment">         * 根据传入的目标返回一个代理对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),</span><br><span class="line">                targetObject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联的这个实现类的方法被调用时将被执行</span></span><br><span class="line"><span class="comment">     * InvocationHandler接口的方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 表示代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 示原对象被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 表示方法的参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回的是对象的一个接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//反射调用原始的需要增强的方法</span></span><br><span class="line">        Object value = method.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里面要注意 <strong>method</strong> 是我们需要增强的方法，<strong>args</strong> 是我们需要增强的参数数组</p><h4 id="编写Main方法"><a href="#编写Main方法" class="headerlink" title="编写Main方法"></a>编写Main方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建BuingHandler 类</span></span><br><span class="line">        BuingHandler buingHandler = <span class="keyword">new</span> BuingHandler(<span class="keyword">new</span> BuyingImpl());</span><br><span class="line">        <span class="comment">//获取代理对象</span></span><br><span class="line">        Buying buying = (Buying) buingHandler.getProxy();</span><br><span class="line">        <span class="comment">//调用具体接口</span></span><br><span class="line">        String value = buying.buy();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">前置增强</span><br><span class="line">开始逻辑处理</span><br><span class="line">后置增强</span><br><span class="line">买了个锤子</span><br></pre></td></tr></table></figure><p>我们就这样实现了动态代理，我们没有修改原有代码的情况下做了增强</p><p>我们实现了 其那只以及后置增强</p><h4 id="我们运行下看下接口对象"><a href="#我们运行下看下接口对象" class="headerlink" title="我们运行下看下接口对象"></a>我们运行下看下接口对象</h4><p><img src="../images/proxy02.jpg" alt></p><p>我们看到实际对象是$Proxy0，我们发现动态代理给我们换了一个对象，我们要研究下他是怎么实现的</p><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><blockquote><p>读源码首先找到入口，没有不得入口就像无头的苍蝇，苍蝇还不叮无缝的蛋呢</p><p>下面内容有点多，也有点绕，请跟着思路来一点点解析</p></blockquote><h4 id="1、首先找到入口"><a href="#1、首先找到入口" class="headerlink" title="1、首先找到入口"></a>1、首先找到入口</h4><blockquote><p>我们创建代理对象调用的是</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),</span><br><span class="line">                targetObject.getClass().getInterfaces(), <span class="keyword">this</span>);</span><br></pre></td></tr></table></figure><p>所以我们先从Proxy.newProxyInstance开始入手</p><h4 id="2、newProxyInstance方法"><a href="#2、newProxyInstance方法" class="headerlink" title="2、newProxyInstance方法"></a>2、newProxyInstance方法</h4><blockquote><p>进入newProxyInstance方法内部</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">//增强实现不能为空，为空就抛出异常</span></span><br><span class="line">        Objects.requireNonNull(h);</span><br><span class="line">        <span class="comment">//对接口数组进行clone</span></span><br><span class="line">        <span class="keyword">final</span> Class&lt;?&gt;[] intfs = interfaces.clone();</span><br><span class="line">        <span class="comment">//进项权限检查</span></span><br><span class="line">        <span class="keyword">final</span> SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Look up or generate the designated proxy class.</span></span><br><span class="line"><span class="comment">         * ********核心代码入口***********</span></span><br><span class="line"><span class="comment">         * 查找或者是生成一个特定的代理类对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Invoke its constructor with the designated invocation handler.</span></span><br><span class="line"><span class="comment">         * 使用指定的调用处理程序调用其构造函数</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (sm != <span class="keyword">null</span>) &#123;</span><br><span class="line">                checkNewProxyPermission(Reflection.getCallerClass(), cl);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//  从代理类对象中查找参数为InvocationHandler的构造器</span></span><br><span class="line">            <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line">            <span class="keyword">final</span> InvocationHandler ih = h;</span><br><span class="line">            <span class="comment">// 检测构造器是否是Public修饰，如果不是则强行转换为可以访问的。</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(cl.getModifiers())) &#123;</span><br><span class="line">                AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Void&gt;() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Void <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        cons.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//通过反射，将h作为参数，实例化代理类，返回代理类实例。</span></span><br><span class="line">            <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException | InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            Throwable t = e.getCause();</span><br><span class="line">            <span class="keyword">if</span> (t <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">                <span class="keyword">throw</span> (RuntimeException) t;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(t.toString(), t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InternalError(e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>上面代码的核心方法是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br></pre></td></tr></table></figure><p>找到了核心方法继续深入</p><h4 id="3、getProxyClass0方法入口"><a href="#3、getProxyClass0方法入口" class="headerlink" title="3、getProxyClass0方法入口"></a>3、getProxyClass0方法入口</h4><blockquote><p>生成一个代理对象的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 生成一个代理对象</span></span><br><span class="line"><span class="comment">    * Generate a proxy class.  Must call the checkProxyAccess method</span></span><br><span class="line"><span class="comment">    * to perform permission checks before calling this.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                          Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">       <span class="comment">//接口数量不能大于65535 否则报错 具体为什么 不太清楚</span></span><br><span class="line">       <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//根据类加载器生成代理字节码文件</span></span><br><span class="line">       <span class="comment">// If the proxy class defined by the given loader implementing</span></span><br><span class="line">       <span class="comment">//如果接口存在缓存中们就从缓存中获取</span></span><br><span class="line">       <span class="comment">// the given interfaces exists, this will simply return the cached copy;</span></span><br><span class="line">       <span class="comment">//否则，它将通过proxyClassFactory创建代理类</span></span><br><span class="line">       <span class="comment">// otherwise, it will create the proxy class via the ProxyClassFactory</span></span><br><span class="line">       <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这一段代码是从缓存中获取代理对象，核心的代码还在里面 <code>proxyClassCache.get(loader, interfaces);</code></p><p>因为 proxyClassCache 是一个WeakCache 的类，所以我们先来学习下WeakCache</p><h4 id="4、WeakCache类"><a href="#4、WeakCache类" class="headerlink" title="4、WeakCache类"></a>4、WeakCache类</h4><h5 id="WeakCache-方法声明"><a href="#WeakCache-方法声明" class="headerlink" title="WeakCache 方法声明"></a>WeakCache 方法声明</h5><p>在这个方法中，是直接从一个叫proxyClassCache缓存中读取的，来看一下这个缓存的声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * a cache of proxy classes</span></span><br><span class="line"><span class="comment">    * 缓存代理的class字节码文件，如果没有则使用ProxyClassFactory创建</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">       proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>里涉及到三个类：WeakCache,KeyFactory,ProxyClassFactory，其中后面两个类都是Proxy类的静态内部类，从类名可以大概猜测到，keyFactory是用来生产key的，ProxyClassFactory是用来生产代理类对象的，这个稍后会提到。</p><h5 id="WeakCache类的大概结构"><a href="#WeakCache类的大概结构" class="headerlink" title="WeakCache类的大概结构"></a>WeakCache类的大概结构</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WeakCache</span>&lt;<span class="title">K</span>, <span class="title">P</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ReferenceQueue&lt;K&gt; refQueue</span><br><span class="line">            = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">    <span class="comment">// the key type is Object for supporting null key</span></span><br><span class="line">    <span class="comment">// key的类型为Object，支持null key,这里的null key并不是真的可以使用null最为key,而是一个new Objdec()对象实例。ConcurrentHashMap,不允许键或值null，而HashMap可以。ConcurrentHashMap是线程安全的，HashMap不是。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt;&gt; map  = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Supplier&lt;V&gt;, Boolean&gt; reverseMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, ?&gt; subKeyFactory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BiFunction&lt;K, P, V&gt; valueFactory;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeakCache</span><span class="params">(BiFunction&lt;K, P, ?&gt; subKeyFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                     BiFunction&lt;K, P, V&gt; valueFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.subKeyFactory = Objects.requireNonNull(subKeyFactory);</span><br><span class="line">        <span class="keyword">this</span>.valueFactory = Objects.requireNonNull(valueFactory);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//核心入口方法 我们接下来介绍这个类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">        ...</span><br></pre></td></tr></table></figure><p>上面的源代码中写明，代理对象的核心方法是get , 我们结合上下文 发现 key是loader 类加载器，parameter是接口数组interfaces</p><h4 id="5、proxyClassCache-get"><a href="#5、proxyClassCache-get" class="headerlink" title="5、proxyClassCache.get"></a>5、proxyClassCache.get</h4><blockquote><p>这个对象是从缓存中获取字节码对象，key是接口，value是对象的字节码文件，如果给定的接口存在则返回字节码文件，如果不存在则调用proxyClassFactory创建代理类进行创建</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * return proxyClassCache.get(loader, interfaces);</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 获取代理对象的核心方法</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key       类加载器 loader</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> parameter 接口的数组 interfaces</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//接口数组不能为空，否则抛出异常</span></span><br><span class="line">        Objects.requireNonNull(parameter);</span><br><span class="line">        <span class="comment">// 删除过时的条目</span></span><br><span class="line">        expungeStaleEntries();</span><br><span class="line">        <span class="comment">// 生成缓存key对象实例，如果key = null，cacheKey = new Object();</span></span><br><span class="line">        Object cacheKey = WeakCache.CacheKey.valueOf(key, refQueue);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// lazily install the 2nd level valuesMap for the particular cacheKey</span></span><br><span class="line">        <span class="comment">// 从缓存map中读取指定cacheKey的缓存数据valuesMap</span></span><br><span class="line">        ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap = map.get(cacheKey);</span><br><span class="line">        <span class="keyword">if</span> (valuesMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果valuesMap为null,则新增</span></span><br><span class="line">            <span class="comment">// putIfAbsent方法解释：如果值存在则返回值，并且不对原来的值做任何更改，如果不存在则新增，并返回null</span></span><br><span class="line">            <span class="comment">//map.putIfAbsent 是map中新增的一个方法 存在则返回，不存在put然后在返回</span></span><br><span class="line">            ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; oldValuesMap = map.putIfAbsent(cacheKey, valuesMap = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;());</span><br><span class="line">            <span class="comment">//赋值</span></span><br><span class="line">            <span class="keyword">if</span> (oldValuesMap != <span class="keyword">null</span>) &#123;</span><br><span class="line">                valuesMap = oldValuesMap;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// create subKey and retrieve the possible Supplier&lt;V&gt; stored by that</span></span><br><span class="line">        <span class="comment">// subKey from valuesMap</span></span><br><span class="line">        <span class="comment">//获取subKey，这里用到了上面提到的Proxy的静态内部类 KeyFactory:subKeyFactory.apply(ket,parameter)</span></span><br><span class="line">        Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));</span><br><span class="line">        <span class="comment">// 从valuesMap中获取supplier</span></span><br><span class="line">        Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">        WeakCache.Factory factory = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// supplier might be a Factory or a CacheValue&lt;V&gt; instance</span></span><br><span class="line">                <span class="comment">//  4、从工厂中获取代理类对象</span></span><br><span class="line">                V value = supplier.get();</span><br><span class="line">                <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//5、返回</span></span><br><span class="line">                    <span class="keyword">return</span> value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// else no supplier in cache</span></span><br><span class="line">            <span class="comment">// or a supplier that returned null (could be a cleared CacheValue</span></span><br><span class="line">            <span class="comment">// or a Factory that wasn't successful in installing the CacheValue)</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// lazily construct a Factory</span></span><br><span class="line">            <span class="comment">//1、实例化工厂</span></span><br><span class="line">            <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">                factory = <span class="keyword">new</span> WeakCache.Factory(key, parameter, subKey, valuesMap);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//2、将supplier保存到valuesMap中</span></span><br><span class="line">                supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">                <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// successfully installed Factory</span></span><br><span class="line">                    <span class="comment">// 3、赋值</span></span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// else retry with winning supplier</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果subKey和supplier都匹配则则将supplier替换为新生成的factory</span></span><br><span class="line">                <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                    <span class="comment">// successfully replaced</span></span><br><span class="line">                    <span class="comment">// cleared CacheEntry / unsuccessful Factory</span></span><br><span class="line">                    <span class="comment">// with our Factory</span></span><br><span class="line">                    <span class="comment">//替换成功赋值</span></span><br><span class="line">                    supplier = factory;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// retry with current supplier</span></span><br><span class="line">                    <span class="comment">//使用当前的supplier进行重试</span></span><br><span class="line">                    supplier = valuesMap.get(subKey);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为程序中Proxy.newProxyInstance是第一次执行，所以while循环开始的时候，supplier，valuesMap都是null。在这个前提下，我为代码的执行顺序做了一个编号，从1-5执行。</p><p>可以看到第5步，也就是源代码的第47行将结果返回，那么，代理类对象就是在第4步，也就是第43行生成的。而且也可以从第3步，也就是第65行发现supplier就是factory。</p><p>那么接下来，就分析一下Factory.get方法。</p><h4 id="6、Factory-get方法"><a href="#6、Factory-get方法" class="headerlink" title="6、Factory.get方法"></a>6、Factory.get方法</h4><p>Factory类是WeakCache的内部类。这个类中除去构造方法外，就是get方法了，下面是这个代码的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Factory 实现类Supplier 接口</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> <span class="keyword">implements</span> <span class="title">Supplier</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="comment">//类加载器 loader</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> K key;</span><br><span class="line">      接口的数组 interfaces</span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> P parameter;</span><br><span class="line">      <span class="comment">//这里的subkey 就是上面的 KeyFactory 可以会看 WeakCache 方法声明</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> Object subKey;</span><br><span class="line">      <span class="comment">//提供者的MAP key是KeyFactory ，value 是 Factory 本身</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">final</span> ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//构造方法</span></span><br><span class="line">      Factory(K key, P parameter, Object subKey,</span><br><span class="line">              ConcurrentMap&lt;Object, Supplier&lt;V&gt;&gt; valuesMap) &#123;</span><br><span class="line">          <span class="keyword">this</span>.key = key;</span><br><span class="line">          <span class="keyword">this</span>.parameter = parameter;</span><br><span class="line">          <span class="keyword">this</span>.subKey = subKey;</span><br><span class="line">          <span class="keyword">this</span>.valuesMap = valuesMap;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123; <span class="comment">// serialize access</span></span><br><span class="line">          <span class="comment">// re-check</span></span><br><span class="line">          <span class="comment">//检查 如果 supplier不是自己 返回</span></span><br><span class="line">          Supplier&lt;V&gt; supplier = valuesMap.get(subKey);</span><br><span class="line">          <span class="keyword">if</span> (supplier != <span class="keyword">this</span>) &#123;</span><br><span class="line">              <span class="comment">// something changed while we were waiting:</span></span><br><span class="line">              <span class="comment">// might be that we were replaced by a CacheValue</span></span><br><span class="line">              <span class="comment">// or were removed because of failure -&gt;</span></span><br><span class="line">              <span class="comment">// return null to signal WeakCache.get() to retry</span></span><br><span class="line">              <span class="comment">// the loop</span></span><br><span class="line">              <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// else still us (supplier == this)</span></span><br><span class="line"></span><br><span class="line">          <span class="comment">// create new value</span></span><br><span class="line">          <span class="comment">//定义一个新的对象</span></span><br><span class="line">          V value = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="comment">/**</span></span><br><span class="line"><span class="comment">               * valueFactory就是WeakCache的valueFactory属性，因为Factory是WeakCache的内部类，所以可以直接访问WeakCache的valueFactory属性</span></span><br><span class="line"><span class="comment">               * 我们可以回去看看第四第五 proxyClassCache.get 以及 WeakCache 的简单结构 注意valueFactory 发现就是 ProxyClassFactory</span></span><br><span class="line"><span class="comment">               * 就在这一步生成了 代理对象</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">              value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123; <span class="comment">// remove us on failure</span></span><br><span class="line">                  valuesMap.remove(subKey, <span class="keyword">this</span>);</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// the only path to reach here is with non-null value</span></span><br><span class="line">          <span class="comment">//校验对象不为空</span></span><br><span class="line">          <span class="keyword">assert</span> value != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// wrap value with CacheValue (WeakReference)</span></span><br><span class="line">          WeakCache.CacheValue&lt;V&gt; cacheValue = <span class="keyword">new</span> WeakCache.CacheValue&lt;&gt;(value);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// put into reverseMap</span></span><br><span class="line">          <span class="comment">//缓存代理对象</span></span><br><span class="line">          reverseMap.put(cacheValue, Boolean.TRUE);</span><br><span class="line"></span><br><span class="line">          <span class="comment">// try replacing us with CacheValue (this should always succeed)</span></span><br><span class="line">          <span class="comment">//并将valuesMap替换为最新生成的对象</span></span><br><span class="line">          <span class="keyword">if</span> (!valuesMap.replace(subKey, <span class="keyword">this</span>, cacheValue)) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Should not reach here"</span>);</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// successfully replaced us with new CacheValue -&gt; return the value</span></span><br><span class="line">          <span class="comment">// wrapped by it</span></span><br><span class="line">          <span class="comment">//返回对象</span></span><br><span class="line">          <span class="keyword">return</span> value;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>我们核心注意的是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br></pre></td></tr></table></figure><p>这里的valueFactory就是Proxy的静态内部类ProxyClassFactory，上面也提到过，那么就接着分析ProxyClassFactory的apply方法吧。</p><h4 id="7、ProxyClassFactory-apply方法"><a href="#7、ProxyClassFactory-apply方法" class="headerlink" title="7、ProxyClassFactory.apply方法"></a>7、ProxyClassFactory.apply方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一个利用给定的类加载器和接口类数组生成，定义并返回代理类对象的工厂方法</span></span><br><span class="line"><span class="comment"> * A factory function that generates, defines and returns the proxy class given</span></span><br><span class="line"><span class="comment"> * the ClassLoader and array of interfaces.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyClassFactory</span></span></span><br><span class="line">        implements BiFunction&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// prefix for all proxy class names</span></span><br><span class="line">    <span class="comment">//所有代理类对象的前缀 这个就回答了为什么代理类都带有$Proxy</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String proxyClassNamePrefix = <span class="string">"$Proxy"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// next number to use for generation of unique proxy class names</span></span><br><span class="line">    <span class="comment">//用于生成唯一代理类名称的下一个数字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicLong nextUniqueNumber = <span class="keyword">new</span> AtomicLong();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 开始我们的核心方法apply</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> loader 类加载器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> interfaces 接口数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; apply(ClassLoader loader, Class&lt;?&gt;[] interfaces) &#123;</span><br><span class="line"></span><br><span class="line">        Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line">        <span class="comment">//接口校验循环</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the class loader resolves the name of this</span></span><br><span class="line"><span class="comment">             * interface to the same Class object.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//加载接口类，获得接口类的类对象，第二个参数为false表示不进行实例化</span></span><br><span class="line">                interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//进行校验</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        intf + <span class="string">" is not visible from class loader"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that the Class object actually represents an</span></span><br><span class="line"><span class="comment">             * interface.</span></span><br><span class="line"><span class="comment">             * 验证是否是接口 不是接口报错</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        interfaceClass.getName() + <span class="string">" is not an interface"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Verify that this interface is not a duplicate.</span></span><br><span class="line"><span class="comment">             * 验证此接口不是重复的，重复的就报错</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                        <span class="string">"repeated interface: "</span> + interfaceClass.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代理类的包名</span></span><br><span class="line">        String proxyPkg = <span class="keyword">null</span>;     <span class="comment">// package to define proxy class in</span></span><br><span class="line">        <span class="comment">//访问权限</span></span><br><span class="line">        <span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Record the package of a non-public proxy interface so that the</span></span><br><span class="line"><span class="comment">         * proxy class will be defined in the same package.  Verify that</span></span><br><span class="line"><span class="comment">         * all non-public proxy interfaces are in the same package.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">            <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">            <span class="comment">//如果接口是public就跳过 我们的接口基本上不会走这里</span></span><br><span class="line">            <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">                accessFlags = Modifier.FINAL;</span><br><span class="line">                String name = intf.getName();</span><br><span class="line">                <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">                String pkg = ((n == -<span class="number">1</span>) ? <span class="string">""</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    proxyPkg = pkg;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                            <span class="string">"non-public interfaces from different packages"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// if no non-public proxy interfaces, use com.sun.proxy package</span></span><br><span class="line">            <span class="comment">//如果没有public的接口 就是用 com.sun.proxy 的包前缀</span></span><br><span class="line">            <span class="comment">//类似于com.sun.proxy.$Proxy0</span></span><br><span class="line">            proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">"."</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Choose a name for the proxy class to generate.</span></span><br><span class="line"><span class="comment">         * 生成代理类的类名</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//生成代理类的序号</span></span><br><span class="line">        <span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line">        <span class="comment">//生成代理类的完全限定名</span></span><br><span class="line">        String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Generate the specified proxy class.</span></span><br><span class="line"><span class="comment">         * 生成代理类class文件</span></span><br><span class="line"><span class="comment">         * 这个是生成的核心方法</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                proxyName, interfaces, accessFlags);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//返回代理类对象</span></span><br><span class="line">            <span class="keyword">return</span> defineClass0(loader, proxyName,</span><br><span class="line">                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassFormatError e) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * A ClassFormatError here means that (barring bugs in the</span></span><br><span class="line"><span class="comment">             * proxy class generation code) there was some other</span></span><br><span class="line"><span class="comment">             * invalid aspect of the arguments supplied to the proxy</span></span><br><span class="line"><span class="comment">             * class creation (such as virtual machine limitations</span></span><br><span class="line"><span class="comment">             * exceeded).</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码的第111行，生成了代理类的class文件，并且在115行返回了我们需要的代理类对象。那么怎么找到这个生成的代理类class文件呢？</p><p>到这里 我们就跟完了动态代理的核心流程，我们解释了为什么 代理类都带有$Proxy，以及后面的序号是怎么来的。</p><p>生成代码的核心代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">                   proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure><p>ProxyGenerator是根据代理名称接口生成代理类的核心代码，我们就不跟进去了，以后有时间再进去，里面都是字节码操作的知识了，也是在<strong>sun.misc</strong>包下，一般是不开源的，如果需要可以去下载sun包的源码，1.8之后就不开源了。</p><h4 id="查看生成的代理类"><a href="#查看生成的代理类" class="headerlink" title="查看生成的代理类"></a>查看生成的代理类</h4><p>我们上面最终跟到了ProxyGenerator类，ProxyGenerator是生成字节码文件的核心代码，我们想看下生成的字节码怎么办呢，我们自己去生成并且输出出来。</p><p>看代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生成代理字节码数组文件 传入一个接口数组</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile =  ProxyGenerator.generateProxyClass(<span class="string">"com.sun.proxy"</span>, <span class="keyword">new</span> Class[]&#123;Buying.class&#125;, <span class="number">1</span>);</span><br><span class="line"><span class="comment">//将字节数组转换成class文件并输出到本地</span></span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/com.sun.proxy.class"</span>));</span><br><span class="line">        fos.write(proxyClassFile);</span><br><span class="line">        fos.flush();</span><br><span class="line">        fos.close();</span><br></pre></td></tr></table></figure><p>我们反编译以下 com.sun.proxy.class</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了Proxy类，实现了Buying接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">proxy</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Buying</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line">    <span class="comment">//构造方法，直接调用了父类，也就是Proxy的构造方法，参数paramInvocationHandler就是我们的BuingHandler实例化对象handler</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">proxy</span><span class="params">(InvocationHandler paramInvocationHandler)</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(paramInvocationHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现equals 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> var1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Boolean)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var3;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var4);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现toString方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//实现了Buying 接口的 buy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">buy</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 这里的h就是我们的BuingHandler 实例</span></span><br><span class="line"><span class="comment">             * 调用 父类 Proxy 里面我们传入的 BuingHandler 对象</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> (String)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 实现了hashCode方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span>   </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Integer)<span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//静态代码块，做初始化操作</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//通过反射，获取Object对象方法对象的equals 方法</span></span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            <span class="comment">//通过反射，获取Object对象方法对象的toString 方法</span></span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            <span class="comment">//通过反射，获取Buying对象方法对象的buy 方法</span></span><br><span class="line">            m3 = Class.forName(<span class="string">"com.test.proxy.Buying"</span>).getMethod(<span class="string">"buy"</span>);</span><br><span class="line">            <span class="comment">//通过反射，获取Object对象方法对象的hashCode 方法</span></span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类实例化的代码是：cons.newInstance(new Object[]{h})。这里是通过反射调用代理类对象的构造方法，传入了参数h（我们的BuingHandler实例化对象handler）。</p><p>​ 这个构造方法，就是上述反编译代码里的构造方法，而上述反编译代码里的构造方法调用了Proxy类的构造方法，来看一下Proxy类的构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">protected</span> InvocationHandler h;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Proxy</span><span class="params">(InvocationHandler h)</span> </span>&#123;</span><br><span class="line">    Objects.requireNonNull(h);</span><br><span class="line">    <span class="keyword">this</span>.h = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 这里将我们传入的handler直接赋值给了InvocationHandler h。上述反编译代码中的super.h 就是我们传入的handler。</p><p>所以proxy.buy();方法在执行的时候会去调用BuingHandler类的invoke方法。</p><p>好了到这里我们的源码解析已经完了。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA动态代理源码分析
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="动态代理" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="动态代理" scheme="http://www.baiyp.ren/tags/%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>java中AQS-03源代码实现</title>
    <link href="http://www.baiyp.ren/java%E4%B8%AD%E7%9A%84AQS-03.html"/>
    <id>http://www.baiyp.ren/java中的AQS-03.html</id>
    <published>2019-08-11T09:47:16.000Z</published>
    <updated>2019-08-22T02:06:15.698Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="java中AQS的源代码实现"><a href="#java中AQS的源代码实现" class="headerlink" title="java中AQS的源代码实现"></a>java中AQS的源代码实现</h2><p><img src="../images/aqs01.png" alt></p><h2 id="AQS的源代码实现"><a href="#AQS的源代码实现" class="headerlink" title="AQS的源代码实现"></a>AQS的源代码实现</h2><p>主要通过独占式同步状态的获取和释放、共享式同步状态的获取和释放来看下AQS是如何实现的。</p><h3 id="独占式同步状态的获取和释放"><a href="#独占式同步状态的获取和释放" class="headerlink" title="独占式同步状态的获取和释放"></a>独占式同步状态的获取和释放</h3><p>独占式同步状态调用的方法是acquire，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">         acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">         selfInterrupt();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>​ 上述代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等待的相关工作，其主要逻辑是：首先调用子类实现的<strong>tryAcquire</strong>方法，该方法保证线程安全的获取同步状态，如果同步状态获取失败，则构造独占式同步节点（同一时刻只能有一个线程成功获取同步状态）并通过<strong>addWaiter</strong>方法将该节点加入到同步队列的尾部，最后调用<strong>acquireQueued</strong>方法，使得该节点以自旋的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p><p>下面来首先来看下节点构造和加入同步队列是如何实现的。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当前线程构造成Node节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// Try the fast path of enq; backup to full enq on failure</span></span><br><span class="line">        <span class="comment">// 尝试快速在尾节点后新增节点 提升算法效率 先将尾节点指向pred</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//尾节点不为空  当前线程节点的前驱节点指向尾节点</span></span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="comment">//并发处理 尾节点有可能已经不是之前的节点 所以需要CAS更新</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">//CAS更新成功 当前线程为尾节点 原先尾节点的后续节点就是当前节点</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//第一个入队的节点或者是尾节点后续节点新增失败时进入enq</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//尾节点为空  第一次入队  设置头尾节点一致 同步队列的初始化</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//所有的线程节点在构造完成第一个节点后 依次加入到同步队列中</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​ 节点进入同步队列之后，就进入了一个自旋的过程，每个线程节点都在自省地观察，当条件满足，获取到了同步状态，就可以从这个自旋过程中退出，否则依旧留在这个自旋过程中并会阻塞节点的线程，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前线程节点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//前驱节点为头节点且成功获取同步状态</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    <span class="comment">//设置当前节点为头节点</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//是否阻塞</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>再来看看shouldParkAfterFailedAcquire和parkAndCheckInterrupt是怎么来阻塞当前线程的，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//前驱节点的状态决定后续节点的行为</span></span><br><span class="line">　　　　 <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*前驱节点为-1 后续节点可以被阻塞</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*前驱节点是初始或者共享状态就设置为-1 使后续节点阻塞</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//阻塞线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>节点自旋的过程大致示意图如下，其实就是对图二、图三的补充。</p><p><img src="../images/aqs08.png" alt></p><p>整个独占式获取同步状态的流程图大致如下：</p><p><img src="../images/aqs09.png" alt></p><p>​ 当同步状态获取成功之后，当前线程从acquire方法返回，对于锁这种并发组件而言，就意味着当前线程获取了锁。有获取同步状态的方法，就存在其对应的释放方法，该方法为release，现在来看下这个方法的实现，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;<span class="comment">//同步状态释放成功</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//直接释放头节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * If status is negative (i.e., possibly needing signal) try</span></span><br><span class="line"><span class="comment">         * to clear in anticipation of signalling.  It is OK if this</span></span><br><span class="line"><span class="comment">         * fails or if status is changed by waiting thread.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*寻找符合条件的后续节点</span></span><br><span class="line"><span class="comment">         * Thread to unpark is held in successor, which is normally</span></span><br><span class="line"><span class="comment">         * just the next node.  But if cancelled or apparently null,</span></span><br><span class="line"><span class="comment">         * traverse backwards from tail to find the actual</span></span><br><span class="line"><span class="comment">         * non-cancelled successor.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//唤醒后续节点</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​ 独占式释放是非常简单而且明确的。</p><p>总结下独占式同步状态的获取和释放：在获取同步状态时，同步器维护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步器调用<strong>tryRelease</strong>方法释放同步状态，然后唤醒头节点的后继节点。</p><h3 id="共享式同步状态的获取和释放"><a href="#共享式同步状态的获取和释放" class="headerlink" title="共享式同步状态的获取和释放"></a>共享式同步状态的获取和释放</h3><p>共享式同步状态调用的方法是acquireShared，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取同步状态的返回值大于等于0时表示可以获取同步状态</span></span><br><span class="line">        <span class="comment">//小于0时表示可以获取不到同步状态  需要进入队列等待</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//和独占式一样的入队操作</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//自旋</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">//前驱结点为头节点且成功获取同步状态 可退出自旋</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">//退出自旋的节点变成首节点</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Try to signal next queued node if:</span></span><br><span class="line"><span class="comment">         *   Propagation was indicated by caller,</span></span><br><span class="line"><span class="comment">         *     or was recorded (as h.waitStatus either before</span></span><br><span class="line"><span class="comment">         *     or after setHead) by a previous operation</span></span><br><span class="line"><span class="comment">         *     (note: this uses sign-check of waitStatus because</span></span><br><span class="line"><span class="comment">         *      PROPAGATE status may transition to SIGNAL.)</span></span><br><span class="line"><span class="comment">         * and</span></span><br><span class="line"><span class="comment">         *   The next node is waiting in shared mode,</span></span><br><span class="line"><span class="comment">         *     or we don't know, because it appears null</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * The conservatism in both of these checks may cause</span></span><br><span class="line"><span class="comment">         * unnecessary wake-ups, but only when there are multiple</span></span><br><span class="line"><span class="comment">         * racing acquires/releases, so most need signals now or soon</span></span><br><span class="line"><span class="comment">         * anyway.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared方法可以释放同步状态，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//释放同步状态</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">//唤醒后续等待的节点</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">　　　　<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    <span class="comment">//唤醒后续节点</span></span><br><span class="line">　　　　　　　　　　　　unparkSuccessor(h);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>unparkSuccessor方法和独占式是一样的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      java中AQS的源代码实现
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="AQS" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/AQS/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/tags/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="AQS" scheme="http://www.baiyp.ren/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>CLH队列锁的原理</title>
    <link href="http://www.baiyp.ren/CLH%E9%98%9F%E5%88%97%E9%94%81.html"/>
    <id>http://www.baiyp.ren/CLH队列锁.html</id>
    <published>2019-08-11T09:24:14.000Z</published>
    <updated>2019-08-22T02:04:44.403Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="CLH队列锁的原理"><a href="#CLH队列锁的原理" class="headerlink" title="CLH队列锁的原理"></a>CLH队列锁的原理</h2><p><img src="../images/clh01.png" alt></p><h3 id="什么是CLH队列锁"><a href="#什么是CLH队列锁" class="headerlink" title="什么是CLH队列锁"></a>什么是CLH队列锁</h3><p>​ CLH锁是有由Craig, Landin, and Hagersten这三个人发明的锁，取了三个人名字的首字母，所以叫 CLH Lock。</p><p>​ CLH锁是一个自旋锁。能确保无饥饿性。提供先来先服务的公平性。</p><p>​ CLH队列锁也是一种基于<strong>链表</strong>的可扩展、高性能、公平的自旋锁，申请线程仅仅在本地变量上自旋，它不断轮询前驱的状态，假设发现前驱释放了锁就结束自旋。</p><p>就像这样</p><p><img src="../images/clh02.png" alt></p><h4 id="当一个线程需要获取锁时"><a href="#当一个线程需要获取锁时" class="headerlink" title="当一个线程需要获取锁时"></a>当一个线程需要获取锁时</h4><ol><li>创建一个的QNode，将其中的locked设置为true表示需要获取锁，myPred表示对其前驱结点的引用</li></ol><p><img src="../images/clh03.png" alt></p><ol start="2"><li>线程A对tail域调用getAndSet方法，使自己成为队列的尾部，同时获取一个指向其前驱结点的引用myPred</li></ol><p><img src="../images/clh04.png" alt></p><ol start="3"><li>线程B需要获得锁，同样的流程再来一遍</li></ol><p><img src="../images/clh05.png" alt></p><ol start="4"><li>线程就在前驱结点的locked字段上旋转，直到前驱结点释放锁(前驱节点的锁值 locked ==<br>false)</li></ol><ol start="5"><li>当一个线程需要释放锁时，将当前结点的locked域设置为false，同时回收前驱结点</li></ol><p><img src="../images/clh06.png" alt></p><p>如上图所示，前驱结点释放锁，线程A的myPred所指向的前驱结点的locked字段变为false，线程A就可以获取到锁。</p><p>CLH队列锁的优点是空间复杂度低（如果有n个线程，L个锁，每个线程每次只获取一个锁，那么需要的存储空间是O（L+n），n个线程有n个myNode，L个锁有L个tail）。CLH队列锁常用在SMP体系结构下。</p><p>Java中的AQS是CLH队列锁的一种变体实现。</p><h3 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h3><h4 id="SMP-Symmetric-Multi-Processor"><a href="#SMP-Symmetric-Multi-Processor" class="headerlink" title="SMP(Symmetric Multi-Processor)"></a>SMP(Symmetric Multi-Processor)</h4><p><img src="../images/clh07.png" alt></p><p>​ 对称多处理器结构，指服务器中多个CPU对称工作，每个CPU访问内存地址所需时间相同。其主要特征是共享，包含对CPU，内存，I/O等进行共享。</p><p>​ SMP能够保证内存一致性，但这些共享的资源很可能成为性能瓶颈，随着CPU数量的增加，每个CPU都要访问相同的内存资源，可能导致内存访问冲突，</p><p>​ 可能会导致CPU资源的浪费。常用的PC机就属于这种。</p><h4 id="NUMA-Non-Uniform-Memory-Access"><a href="#NUMA-Non-Uniform-Memory-Access" class="headerlink" title="NUMA(Non-Uniform Memory Access)"></a>NUMA(Non-Uniform Memory Access)</h4><p><img src="../images/clh08.png" alt></p><p>​ 非一致存储访问，将CPU分为CPU模块，每个CPU模块由多个CPU组成，并且具有独立的本地内存、I/O槽口等，模块之间可以通过互联模块相互访问，</p><p>​ 访问本地内存的速度将远远高于访问远地内存(系统内其它节点的内存)的速度，这也是非一致存储访问的由来。NUMA较好地解决SMP的扩展问题，</p><p>当CPU数量增加时，因为访问远地内存的延时远远超过本地内存，系统性能无法线性增加。</p><h3 id="CLH-的缺点"><a href="#CLH-的缺点" class="headerlink" title="CLH 的缺点"></a>CLH 的缺点</h3><p>CLH唯一的缺点是在NUMA系统结构下性能很差，但是在SMP系统结构下该法还是非常有效的。解决NUMA系统结构的思路是MCS队列锁</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      CLH队列锁的原理
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="队列锁" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/%E9%98%9F%E5%88%97%E9%94%81/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/tags/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="队列锁" scheme="http://www.baiyp.ren/tags/%E9%98%9F%E5%88%97%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>java中的读写锁</title>
    <link href="http://www.baiyp.ren/java%E4%B8%AD%E7%9A%84%E8%AF%BB%E5%86%99%E9%94%81.html"/>
    <id>http://www.baiyp.ren/java中的读写锁.html</id>
    <published>2019-08-11T08:35:32.000Z</published>
    <updated>2019-08-22T02:06:51.109Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="java中的读写锁"><a href="#java中的读写锁" class="headerlink" title="java中的读写锁"></a>java中的读写锁</h2><h3 id="ReentrantReadWriteLock-读写锁"><a href="#ReentrantReadWriteLock-读写锁" class="headerlink" title="ReentrantReadWriteLock 读写锁"></a>ReentrantReadWriteLock 读写锁</h3><p>​ 之前提到锁（如Mutex和ReentrantLock）基本都是排他锁，这些锁在同一时刻只允许一个线程进行访问，而读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写锁，使得并发性相比一般的排他锁有了很大提升。</p><p>​ 除了保证写操作对读操作的可见性以及并发性的提升之外，读写锁能够简化读写交互场景的编程方式。假设在程序中定义一个共享的用作缓存数据结构，它大部分时间提供读服务（例如查询和搜索），而写操作占有的时间很少，但是写操作完成之后的更新需要对后续的读服务可见。</p><p>在没有读写锁支持的（Java 5之前）时候，如果需要完成上述工作就要使用Java的等待通知机制，就是当写操作开始时，所有晚于写操作的读操作均会进入等待状态，只有写操作完成并进行通知之后，所有等待的读操作才能继续执行（写操作之间依靠synchronized关键进行同步），这样做的目的是使读操作能读取到正确的数据，不会出现脏读。改用读写锁实现上述功能，只需要在读操作时获取读锁，写操作时获取写锁即可。当写锁被获取到时，后续（非当前写操作线程）的读写操作都会被阻塞，写锁释放之后，所有操作继续执行，编程方式相对于使用等待通知机制的实现方式而言，变得简单明了。</p><p>一般情况下，读写锁的性能都会比排它锁好，因为大多数场景读是多于写的。在读多于写的情况下，读写锁能够提供比排它锁更好的并发性和吞吐量</p><p>ReentrantReadWriteLock其实实现的是ReadWriteLock接口</p><p>ReadWriteLock接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReadWriteLock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取读锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">readLock</span><span class="params">()</span></span>;</span><br><span class="line"><span class="comment">//获取写锁</span></span><br><span class="line">    <span class="function">Lock <span class="title">writeLock</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ReentrantReadWriteLock类"><a href="#ReentrantReadWriteLock类" class="headerlink" title="ReentrantReadWriteLock类"></a>ReentrantReadWriteLock类</h4><h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个ReentrantReadWriteLock实例.</span></span><br><span class="line">ReentrantReadWriteLock()        </span><br><span class="line"></span><br><span class="line"><span class="comment">//创建一个具有给定公平策略的ReentrantReadWriteLock实例.</span></span><br><span class="line">ReentrantReadWriteLock(<span class="keyword">boolean</span> fair)</span><br></pre></td></tr></table></figure><h5 id="常用方法摘要"><a href="#常用方法摘要" class="headerlink" title="常用方法摘要"></a>常用方法摘要</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回用于读取操作的锁.</span></span><br><span class="line">Lock ReentrantReadWriteLock.ReadLock.readLock()   </span><br><span class="line"></span><br><span class="line"><span class="comment">//返回用于写入操作的锁.</span></span><br><span class="line">Lock ReentrantReadWriteLock.WriteLock.writeLock()</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回等待获取读取或写入锁的线程估计数目.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getQueueLength</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果此锁的公平设置为 true,则返回 true.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isFair</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回标识此锁及其锁状态的字符串.</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><h5 id="ReadLock-WriteLock静态内部类"><a href="#ReadLock-WriteLock静态内部类" class="headerlink" title="ReadLock/WriteLock静态内部类"></a>ReadLock/WriteLock静态内部类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//试图获取锁.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果当前线程未被中断,则获取锁.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span>        </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回绑定到此 Lock 实例的新 Condition 实例.</span></span></span><br><span class="line"><span class="function">Condition <span class="title">newCondition</span><span class="params">()</span>         </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//仅在调用时锁为空闲状态才获取该锁.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>          </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//如果锁在给定的等待时间内空闲,并且当前线程未被中断,则获取锁.</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time， TimeUnit unit)</span>        </span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//试图释放锁.</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//返回标识此锁及其锁状态的字符串.</span></span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>因为ReadLock不支持条件，因此当调用了ReadLock的newCondition()方法时将会抛出UnsupportedOperationException异常。</p><p>使用ReentrantReadWriteLock的读锁以及写锁，将会遵循<strong>读读共享</strong>、<strong>写写互斥</strong>、<strong>读写互斥</strong>。</p><h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReentrantReadWriteLockTest</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建读写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ReadWriteLock lock = <span class="keyword">new</span> ReentrantReadWriteLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock readLock = lock.readLock();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Lock writeLock = lock.writeLock();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reading</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"尝试获取读锁："</span> + Thread.currentThread().getId());</span><br><span class="line">        readLock.lock();</span><br><span class="line">        System.out.println(<span class="string">"获取读锁成功："</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始进行读操作："</span> + Thread.currentThread().getId());</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"释放读锁成功："</span> + Thread.currentThread().getId());</span><br><span class="line">            readLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"尝试获取写锁："</span> + Thread.currentThread().getId());</span><br><span class="line">        writeLock.lock();</span><br><span class="line">        System.out.println(<span class="string">"获取写锁成功："</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始进行写操作："</span> + Thread.currentThread().getId());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"释放写锁成功："</span> + Thread.currentThread().getId());</span><br><span class="line">            writeLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="读读共享"><a href="#读读共享" class="headerlink" title="读读共享"></a>读读共享</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//读读共享</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">           executorService.submit(() -&gt; reading());</span><br><span class="line">       &#125;</span><br><span class="line">       executorService.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">尝试获取读锁：<span class="number">12</span></span><br><span class="line">尝试获取读锁：<span class="number">14</span></span><br><span class="line">尝试获取读锁：<span class="number">13</span></span><br><span class="line">获取读锁成功：<span class="number">14</span></span><br><span class="line">开始进行读操作：<span class="number">14</span></span><br><span class="line">获取读锁成功：<span class="number">12</span></span><br><span class="line">开始进行读操作：<span class="number">12</span></span><br><span class="line">获取读锁成功：<span class="number">13</span></span><br><span class="line">开始进行读操作：<span class="number">13</span></span><br><span class="line">释放读锁成功：<span class="number">12</span></span><br><span class="line">释放读锁成功：<span class="number">14</span></span><br><span class="line">释放读锁成功：<span class="number">13</span></span><br></pre></td></tr></table></figure><p>读锁能被多个线程同时获取，能提高读取的效率 (虽然只用读锁时可以不进行释放，但<strong>会影响写锁的获取</strong>)</p><h4 id="写写互斥"><a href="#写写互斥" class="headerlink" title="写写互斥"></a>写写互斥</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//读读共享</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">           executorService.submit(() -&gt; writing());</span><br><span class="line">       &#125;</span><br><span class="line">       executorService.shutdown();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">尝试获取写锁：<span class="number">12</span></span><br><span class="line">尝试获取写锁：<span class="number">13</span></span><br><span class="line">尝试获取写锁：<span class="number">14</span></span><br><span class="line">获取写锁成功：<span class="number">12</span></span><br><span class="line">开始进行写操作：<span class="number">12</span></span><br><span class="line">释放写锁成功：<span class="number">12</span></span><br><span class="line">获取写锁成功：<span class="number">13</span></span><br><span class="line">开始进行写操作：<span class="number">13</span></span><br><span class="line">释放写锁成功：<span class="number">13</span></span><br><span class="line">获取写锁成功：<span class="number">14</span></span><br><span class="line">开始进行写操作：<span class="number">14</span></span><br><span class="line">释放写锁成功：<span class="number">14</span></span><br></pre></td></tr></table></figure><p>写锁同一时刻只能被一个线程获取。</p><h4 id="读写互斥"><a href="#读写互斥" class="headerlink" title="读写互斥"></a>读写互斥</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//读写互斥</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            reading();</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            writing();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">尝试获取读锁：<span class="number">12</span></span><br><span class="line">获取读锁成功：<span class="number">12</span></span><br><span class="line">开始进行读操作：<span class="number">12</span></span><br><span class="line">尝试获取写锁：<span class="number">13</span></span><br><span class="line">尝试获取读锁：<span class="number">14</span></span><br><span class="line">尝试获取写锁：<span class="number">15</span></span><br><span class="line">尝试获取读锁：<span class="number">16</span></span><br><span class="line">尝试获取写锁：<span class="number">17</span></span><br><span class="line">释放读锁成功：<span class="number">12</span></span><br><span class="line">获取写锁成功：<span class="number">13</span></span><br><span class="line">开始进行写操作：<span class="number">13</span></span><br><span class="line">释放写锁成功：<span class="number">13</span></span><br><span class="line">获取读锁成功：<span class="number">14</span></span><br><span class="line">开始进行读操作：<span class="number">14</span></span><br><span class="line">释放读锁成功：<span class="number">14</span></span><br><span class="line">获取写锁成功：<span class="number">15</span></span><br><span class="line">开始进行写操作：<span class="number">15</span></span><br><span class="line">释放写锁成功：<span class="number">15</span></span><br><span class="line">获取读锁成功：<span class="number">16</span></span><br><span class="line">开始进行读操作：<span class="number">16</span></span><br><span class="line">释放读锁成功：<span class="number">16</span></span><br><span class="line">获取写锁成功：<span class="number">17</span></span><br><span class="line">开始进行写操作：<span class="number">17</span></span><br><span class="line">释放写锁成功：<span class="number">17</span></span><br></pre></td></tr></table></figure><p>​ 读的时候不能写，写的时候不能读，即获取读锁时如果写锁此时被线程持有则将等待写锁被释放，获取写锁时如果读锁此时有被线程持有则将等待读锁被释放且写锁未被持有。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      java中的读写锁的使用
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="读写锁" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/tags/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="读写锁" scheme="http://www.baiyp.ren/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>java中AQS-02方法结构</title>
    <link href="http://www.baiyp.ren/java%E4%B8%AD%E7%9A%84AQS-02.html"/>
    <id>http://www.baiyp.ren/java中的AQS-02.html</id>
    <published>2019-08-10T09:47:16.000Z</published>
    <updated>2019-08-22T02:06:07.777Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="java中AQS的方法结构"><a href="#java中AQS的方法结构" class="headerlink" title="java中AQS的方法结构"></a>java中AQS的方法结构</h2><p><img src="../images/aqs01.png" alt></p><h3 id="AQS的方法结构"><a href="#AQS的方法结构" class="headerlink" title="AQS的方法结构"></a>AQS的方法结构</h3><p>如果我们理解了上一节的设计思路，我们大致就能知道AQS的主要数据结构了。</p><table><thead><tr><th>组件</th><th>数据结构</th></tr></thead><tbody><tr><td>同步状态</td><td>volatile int state</td></tr><tr><td>阻塞</td><td>LockSupport类</td></tr><tr><td>队列</td><td>Node节点</td></tr><tr><td>条件队列</td><td>ConditionObject</td></tr></tbody></table><p>进而再来看下AQS的主要方法及其作用。</p><table><thead><tr><th>属性、方法</th><th>描述、作用</th></tr></thead><tbody><tr><td>int getState()</td><td>获取当前同步状态</td></tr><tr><td>void setState(int newState)</td><td>设置当前同步状态</td></tr><tr><td>boolean compareAndSetState(int expect, int update)</td><td>通过CAS设置当前状态，此方法保证状态设置的原子性</td></tr><tr><td>boolean tryAcquire(int arg)</td><td>钩子方法，独占式获取同步状态，AQS没有具体实现，具体实现都在子类中，实现此方法需要查询当前同步状态并判断同步状态是否符合预期，然后再CAS设置同步状态</td></tr><tr><td>boolean tryRelease(int arg)</td><td>钩子方法，独占式释放同步状态，AQS没有具体实现，具体实现都在子类中，等待获取同步状态的线程将有机会获取同步状态</td></tr><tr><td>int tryAcquireShared(int arg)</td><td>钩子方法，共享式获取同步状态，AQS没有具体实现，具体实现都在子类中，返回大于等于0的值表示获取成功，反之失败</td></tr><tr><td>boolean tryReleaseShared(int arg)</td><td>钩子方法，共享式释放同步状态，AQS没有具体实现，具体实现都在子类中</td></tr><tr><td>boolean isHeldExclusively()</td><td>钩子方法，AQS没有具体实现，具体实现都在子类中，当前同步器是否在独占模式下被线程占用，一般该方法表示是否被当前线程所独占</td></tr><tr><td>void acquire(int arg)</td><td>模板方法，独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则会进入同步队列等待，此方法会调用子类重写的tryAcquire方法</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>模板方法，与acquire相同，但是此方法可以响应中断，当前线程未获取到同步状态而进入同步队列中，如果当前线程被中断，此方法会抛出InterruptedException并返回</td></tr><tr><td>boolean tryAcquireNanos(int arg, long nanosTimeout)</td><td>模板方法，在acquireInterruptibly基础上增加了超时限制，如果当前线程在超时时间内没有获取到同步状态，则会返回false,如果获取到了则会返回true</td></tr><tr><td>boolean release(int arg)</td><td>模板方法，独占式的释放同步状态，该方法会在释放同步状态后，将同步队列中的第一个节点包含的线程唤醒</td></tr><tr><td>void acquireShared(int arg)</td><td>模板方法，共享式的获取同步状态，如果当前系统未获取到同步状态，将会进入同步队列等待，与acquire的主要区别在于同一时刻可以有多个线程获取到同步状态</td></tr><tr><td>void acquireSharedInterruptibly(int arg)</td><td>模板方法，与acquireShared一致，但是可以响应中断</td></tr><tr><td>boolean tryAcquireSharedNanos(int arg, long nanosTimeout)</td><td>模板方法，在acquireSharedInterruptibly基础上增加了超时限制</td></tr><tr><td>boolean releaseShared(int arg)</td><td>模板方法，共享式的释放同步状态</td></tr><tr><td>Collection<thread>getQueuedThreads()</thread></td><td>模板方法，获取等待在同步队列上的线程集合</td></tr><tr><td>Node int waitStatus</td><td>等待状态1、 CANCELLED，值为1，在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待，节点进入该状态后将不会变化；2、 SIGNAL，值为-1，后续节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后续节点，使后续节点的线程得以运行；3、 CONDITION，值为-2，节点在条件队列中，节点线程等待在Condition上，当其他线程对Condition调用了signal()方法后，该节点将会从条件队列中转移到同步队列中，加入到对同步状态的获取中；4、 PROPAGATE，值为-3，表示下一次共享式同步状态获取将会无条件地传播下去</td></tr><tr><td>Node prev</td><td>前驱节点，当节点加入同步队列时被设置</td></tr><tr><td>Node next</td><td>后续节点</td></tr><tr><td>Thread thread</td><td>获取同步状态的线程</td></tr><tr><td>Node nextWaiter</td><td>条件队列中的后续节点，如果当前节点是共享的，那么这个字段将是一个SHARED变量，也就是说节点类型（独占和共享）和条件队列中的后续节点共用同一个字段</td></tr><tr><td>LockSupport void park()</td><td>阻塞当前线程，如果调用unpark方法或者当前线程被中断，才能从park方法返回</td></tr><tr><td>LockSupport void unpark(Thread thread)</td><td>唤醒处于阻塞状态的线程</td></tr><tr><td>ConditionObject Node firstWaiter</td><td>条件队列首节点</td></tr><tr><td>ConditionObject Node lastWaiter</td><td>条件队列尾节点</td></tr><tr><td>void await()</td><td>当前线程进入等待状态直到signal或中断，当前线程将进入运行状态且从await方法返回的情况，包括：其他线程调用该Condition的signal或者signalAll方法，且当前线程被选中唤醒；其他线程调用interrupt方法中断当前线程；如果当前线程从await方法返回表明该线程已经获取了Condition对象对应的锁</td></tr><tr><td>void awaitUninterruptibly()</td><td>和await方法类似，但是对中断不敏感</td></tr><tr><td>long awaitNanos(long nanosTimeout)</td><td>当前线程进入等待状态直到被signal、中断或者超时。返回值表示剩余的时间。</td></tr><tr><td>boolean awaitUntil(Date deadline)</td><td>当前线程进入等待状态直到被signal、中断或者某个时间。如果没有到指定时间就被通知，方法返回true，否则表示到了指定时间，返回false</td></tr><tr><td>void signal()</td><td>唤醒一个等待在Condition上的线程，该线程从等待方法返回前必须获得与Condition相关联的锁</td></tr><tr><td>void signalAll()</td><td>唤醒所有等待在Condition上的线程，能够从等待方法返回的线程必须获得与Condition相关联的锁</td></tr></tbody></table><p>看到这，我们对AQS的数据结构应该基本上有一个大致的认识，有了这个基本面的认识，我们就可以来看下AQS的源代码。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      java中AQS的方法结构
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="AQS" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/AQS/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/tags/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="AQS" scheme="http://www.baiyp.ren/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>java中的显示锁Lock</title>
    <link href="http://www.baiyp.ren/java%E4%B8%AD%E7%9A%84%E6%98%BE%E7%A4%BA%E9%94%81.html"/>
    <id>http://www.baiyp.ren/java中的显示锁.html</id>
    <published>2019-08-10T01:41:11.000Z</published>
    <updated>2019-08-22T02:07:25.590Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h3 id="java中的显示锁Lock"><a href="#java中的显示锁Lock" class="headerlink" title="java中的显示锁Lock"></a>java中的显示锁Lock</h3><p>​ <img src="../images/reentrantlock01.png" alt></p><h3 id="什么是显示锁"><a href="#什么是显示锁" class="headerlink" title="什么是显示锁"></a>什么是显示锁</h3><p>在Java 1.5之前，协调对共享对象的访问可以使用的机制只有<strong>synchronized</strong>和<strong>volatile</strong>两种。Java1.5增加了一种新的机制,Lock,Lock是一个接口，提供了无条件的、可轮询的、定时的、可中断的锁获取操作，所有的加锁和解锁操作方法都是显示的，因而称为显示锁,Lock并不是替代内置加锁的方法，而是当内置加锁机制不适用时，作为一种可选择的高级功能。</p><h4 id="Lock和synchronized的比较"><a href="#Lock和synchronized的比较" class="headerlink" title="Lock和synchronized的比较"></a>Lock和synchronized的比较</h4><ol><li><p>synchronized代码更简洁</p></li><li><p>Lock可以在获取锁可以被中断，超时获取锁，尝试获取锁</p></li><li><p>synchronized在1.8以前是性能低下的，到了1.8之后经过改良，性能基本行和Lock相持平，如果不是特殊场景推荐使用synchronized。</p></li></ol><h4 id="Lock-的实现类"><a href="#Lock-的实现类" class="headerlink" title="Lock 的实现类"></a>Lock 的实现类</h4><ul><li>ReentrantLock</li><li>ReentrantReadWriteLock</li></ul><h3 id="Lock的API"><a href="#Lock的API" class="headerlink" title="Lock的API"></a>Lock的API</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Lock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//可中断锁，在获取锁的过程中可以中断线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//尝试获取锁，如果成功返回true，否则返回false</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//超时获取锁，</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    <span class="comment">//释放锁</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取Condition 对象</span></span><br><span class="line">    <span class="function">Condition <span class="title">newCondition</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="Lock-使用的标准范式"><a href="#Lock-使用的标准范式" class="headerlink" title="Lock 使用的标准范式"></a>Lock 使用的标准范式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   <span class="comment">//todo 需要加锁的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">   <span class="comment">//释放锁</span></span><br><span class="line">   lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h3><p>​ 任意一个Java对象，都拥有一组监视器方法（定义在java.lang.Object上），主要包括wait()、wait(long timeout)、notify()以及notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Condition</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//使当前线程在接收到信号前或被中断前一直保持等待状态.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使当前线程在接收到信号前或被中断前或达到指定时间前一直保持等待状态(TimeUnit为时间单位).</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使当前线程在接收到信号前或被中断前或达到指定时间前一直保持等待状态(单位为毫秒).</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">awaitNanos</span><span class="params">(<span class="keyword">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使当前线程在接收到信号前或被中断前或达到最后日期期限前一直保持等待状态.</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//是当前线程进入等待状态，对中断不敏感</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">awaitUninterruptibly</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒一个在该Condition实例等待的线程.</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//唤醒所有在该Condition实例等待的线程.   </span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">signalAll</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="Condition-使用的标准范式"><a href="#Condition-使用的标准范式" class="headerlink" title="Condition 使用的标准范式"></a>Condition 使用的标准范式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个显示锁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Condition 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 等待方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> InterruptedException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">conditionSignal</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><h4 id="锁可重入"><a href="#锁可重入" class="headerlink" title="锁可重入"></a>锁可重入</h4><p>​ <strong>简单地讲</strong>就是：“同一个线程对于已经获得到的锁，可以多次继续申请到该锁的使用权”。而synchronized关键字隐式的支持重进入，比如一个synchronized修饰的递归方法，在方法执行时，执行线程在获取了锁之后仍能连续多次地获得该锁。ReentrantLock在调用lock()方法时，已经获取到锁的线程，能够再次调用lock()方法获取锁而不被阻塞。</p><h4 id="公平和非公平锁"><a href="#公平和非公平锁" class="headerlink" title="公平和非公平锁"></a>公平和非公平锁</h4><p>​ 如果在时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之，是不公平的。公平的获取锁，也就是等待时间最长的线程最优先获取锁，也可以说锁获取是顺序的。 ReentrantLock提供了一个构造函数，能够控制锁是否是公平的。事实上，公平的锁机制往往没有非公平的效率高。</p><p>​ 在激烈竞争的情况下,非公平锁的性能高于公平锁的性能的一个原因是:在恢复一个被挂起的线程与该线程真正开始运行之间存在着严重的延迟。假设线程A持有一个锁,并且线程B请求这个锁。由于这个锁已被线程A持有,因此B将被挂起。当A释放锁时,B将被唤醒,因此会再次尝试获取锁。与此同时,如果C也请求这个锁,那么C很可能会在B被完全唤醒之前获得、使用以及释放这个锁。这样的情况是一种“双赢”的局面:B获得锁的时刻并没有推迟,C更早地获得了锁,并且吞吐量也获得了提高。</p><h4 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建线程池</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个显示锁对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建 Condition 对象</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"尝试获取锁,线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    lock.lock();</span><br><span class="line">    System.out.println(<span class="string">"获取锁成功,线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">"使线程进入等待状态,线程："</span> + Thread.currentThread().getId());</span><br><span class="line">        <span class="comment">//进入等待状态并释放所资源</span></span><br><span class="line">        condition.await();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        System.out.println(<span class="string">"释放锁,线程："</span> + Thread.currentThread().getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通知全部</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">latch</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        condition.signalAll();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            handel();</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">    latch();</span><br><span class="line">    executorService.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">尝试获取锁,线程：<span class="number">13</span></span><br><span class="line">尝试获取锁,线程：<span class="number">16</span></span><br><span class="line">尝试获取锁,线程：<span class="number">15</span></span><br><span class="line">尝试获取锁,线程：<span class="number">14</span></span><br><span class="line">尝试获取锁,线程：<span class="number">12</span></span><br><span class="line">获取锁成功,线程：<span class="number">13</span></span><br><span class="line">使线程进入等待状态,线程：<span class="number">13</span></span><br><span class="line">获取锁成功,线程：<span class="number">16</span></span><br><span class="line">使线程进入等待状态,线程：<span class="number">16</span></span><br><span class="line">获取锁成功,线程：<span class="number">15</span></span><br><span class="line">使线程进入等待状态,线程：<span class="number">15</span></span><br><span class="line">获取锁成功,线程：<span class="number">14</span></span><br><span class="line">使线程进入等待状态,线程：<span class="number">14</span></span><br><span class="line">获取锁成功,线程：<span class="number">12</span></span><br><span class="line">使线程进入等待状态,线程：<span class="number">12</span></span><br><span class="line">释放锁,线程：<span class="number">13</span></span><br><span class="line">释放锁,线程：<span class="number">16</span></span><br><span class="line">释放锁,线程：<span class="number">12</span></span><br><span class="line">释放锁,线程：<span class="number">14</span></span><br><span class="line">释放锁,线程：<span class="number">15</span></span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      java中的显示锁的使用
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="显示锁" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/%E6%98%BE%E7%A4%BA%E9%94%81/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/tags/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="显示锁" scheme="http://www.baiyp.ren/tags/%E6%98%BE%E7%A4%BA%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>java中的AQS-01原理以及使用</title>
    <link href="http://www.baiyp.ren/java%E4%B8%AD%E7%9A%84AQS-01.html"/>
    <id>http://www.baiyp.ren/java中的AQS-01.html</id>
    <published>2019-08-09T09:47:16.000Z</published>
    <updated>2019-08-22T02:06:00.069Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="java中的AQS"><a href="#java中的AQS" class="headerlink" title="java中的AQS"></a>java中的AQS</h2><p><img src="../images/aqs01.png" alt></p><h3 id="什么是AQS"><a href="#什么是AQS" class="headerlink" title="什么是AQS"></a>什么是AQS</h3><p>​ AQS是AbstractQueuedSynchronizer的简称。AQS提供了一种实现阻塞锁和一系列依赖FIFO等待队列的同步器的框架，如下图所示。AQS为一系列同步器依赖于一个单独的原子变量（state）的同步器提供了一个非常有用的基础。子类们必须定义改变state变量的protected方法，这些方法定义了state是如何被获取或释放的。鉴于此，本类中的其他方法执行所有的排队和阻塞机制。子类也可以维护其他的state变量，但是为了保证同步，必须原子地操作这些变量。</p><p><img src="../images/aqs02.png" alt></p><p>​ AbstractQueuedSynchronizer中对state的操作是原子的，且不能被继承。所有的同步机制的实现均依赖于对改变量的原子操作。为了实现不同的同步机制，我们需要创建一个非共有的（non-public internal）扩展了AQS类的内部辅助类来实现相应的同步逻辑。AbstractQueuedSynchronizer并不实现任何同步接口，它提供了一些可以被具体实现类直接调用的一些原子操作方法来重写相应的同步逻辑。AQS同时提供了互斥模式（exclusive）和共享模式（shared）两种不同的同步逻辑。一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如<code>ReadWriteLock</code>。接下来将详细介绍AbstractQueuedSynchronizer的提供的一些具体实现方法。</p><h3 id="AQS的设计和结构"><a href="#AQS的设计和结构" class="headerlink" title="AQS的设计和结构"></a>AQS的设计和结构</h3><h4 id="设计思想"><a href="#设计思想" class="headerlink" title="设计思想"></a>设计思想</h4><p>同步器的核心方法是acquire和release操作，其背后的思想也比较简洁明确。</p><h5 id="acquire操作"><a href="#acquire操作" class="headerlink" title="acquire操作"></a>acquire操作</h5><p>while (当前同步器的状态不允许获取操作) {</p><p>​ 如果当前线程不在队列中，则将其插入队列</p><p>阻塞当前线程</p><p>}</p><p>如果线程位于队列中，则将其移出队列</p><h5 id="release操作"><a href="#release操作" class="headerlink" title="release操作"></a>release操作</h5><p>更新<strong>同步器的状态</strong></p><p>if (新的状态允许某个被阻塞的线程获取成功){</p><p>​ 　　<strong>解除队列</strong>中一个或多个<strong>线程</strong>的<strong>阻塞</strong>状态</p><p>}</p><h5 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h5><p>​ 从这两个操作中的思想中我们可以提取出三大关键操作：<strong>同步器的状态变更、线程阻塞和释放、插入和移出队列</strong>。所以为了实现这两个操作，需要协调三大关键操作引申出来的三个基本组件：</p><ul><li><p>同步器状态的原子性管理；</p></li><li><p>线程阻塞与解除阻塞；</p></li><li><p>队列的管理；</p></li></ul><p>由这三个基本组件，我们来看j.u.c是怎么设计的。</p><h4 id="同步状态"><a href="#同步状态" class="headerlink" title="同步状态"></a>同步状态</h4><p>​ AQS类使用单个int（32位）来保存同步状态，并暴露出getState、setState以及compareAndSet操作来读取和更新这个同步状态。其中属性state被声明为volatile，并且通过使用CAS指令来实现compareAndSetState，使得当且仅当同步状态拥有一个一致的期望值的时候，才会被原子地设置成新值，这样就达到了同步状态的原子性管理，确保了同步状态的原子性、可见性和有序性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> newState)</span> </span>&#123;</span><br><span class="line">    state = newState;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">compareAndSetState</span><span class="params">(<span class="keyword">int</span> expect, <span class="keyword">int</span> update)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// See below for intrinsics setup to support this</span></span><br><span class="line">    <span class="keyword">return</span> unsafe.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, expect, update);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基于AQS的具体实现类（如锁、信号量等）必须根据暴露出的状态相关的方法定义tryAcquire和tryRelease方法，以控制acquire和release操作。当同步状态满足时，tryAcquire方法必须返回true，而当新的同步状态允许后续acquire时，tryRelease方法也必须返回true。这些方法都接受一个int类型的参数用于传递想要的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//尝试获取</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尝试释放</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="阻塞"><a href="#阻塞" class="headerlink" title="阻塞"></a>阻塞</h4><p>​ 通过JUC包提供了LockSupport类来解决这个问题。方法LockSupport.park阻塞当前线程直到有个LockSupport.unpark方法被调用。unpark的调用是没有被计数的，因此在一个park调用前多次调用unpark方法只会解除一个park操作。另外，它们作用于每个线程而不是每个同步器。一个线程在一个新的同步器上调用park操作可能会立即返回，因为在此之前可以有多余的unpark操作。但是，在缺少一个unpark操作时，下一次调用park就会阻塞。虽然可以显式地取消多余的unpark调用，但并不值得这样做。在需要的时候多次调用park会更高效。park方法同样支持可选的相对或绝对的超时设置，以及与JVM的Thread.interrupt结合 ，可通过中断来unpark一个线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LockSupport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LockSupport</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// Cannot be instantiated.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒指定线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (thread != <span class="keyword">null</span>)</span><br><span class="line">            UNSAFE.unpark(thread);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//阻塞当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UNSAFE.park(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h4><p>​ 整个框架的核心就是如何管理线程阻塞队列，该队列是严格的FIFO队列，因此不支持线程优先级的同步。同步队列的最佳选择是自身没有使用底层锁来构造的非阻塞数据结构，业界主要有两种选择，一种是MCS锁，另一种是CLH锁。其中CLH一般用于自旋，但是相比MCS，CLH更容易实现取消和超时，所以同步队列选择了CLH作为实现的基础。</p><p>CLH队列实际并不那么像队列，它的出队和入队与实际的业务使用场景密切相关。它是一个链表队列，通过AQS的两个字段head（头节点）和tail（尾节点）来存取，这两个字段是volatile类型，初始化的时候都指向了一个空节点。</p><p><img src="../images/aqs03.png" alt></p><p>​ <strong>入队操作</strong>：CLH队列是FIFO队列，故新的节点到来的时候，是要插入到当前队列的尾节点之后。试想一下，当一个线程成功地获取了同步状态，其他线程将无法获取到同步状态，转而被构造成为节点并加入到同步队列中，而这个加入队列的过程必须要保证线程安全，因此同步器提供了一个CAS方法，它需要传递当前线程“认为”的尾节点和当前节点，只有设置成功后，当前节点才正式与之前的尾节点建立关联。入队操作示意图大致如下：</p><p><img src="../images/aqs04.png" alt></p><p>​ <strong>出队操作</strong>：因为遵循FIFO规则，所以能成功获取到AQS同步状态的必定是首节点，首节点的线程在释放同步状态时，会唤醒后续节点，而后续节点会在获取AQS同步状态成功的时候将自己设置为首节点。设置首节点是由获取同步成功的线程来完成的，由于只能有一个线程可以获取到同步状态，所以设置首节点的方法不需要像入队这样的CAS操作，只需要将首节点设置为原首节点的后续节点同时断开原节点、后续节点的引用即可。出队操作示意图大致如下：</p><p><img src="../images/aqs05.png" alt></p><h4 id="条件队列"><a href="#条件队列" class="headerlink" title="条件队列"></a>条件队列</h4><p>​ 上一节的队列其实是AQS的同步队列，这一节的队列是条件队列，队列的管理除了有同步队列，还有条件队列。AQS只有一个同步队列，但是可以有多个条件队列。AQS框架提供了一个ConditionObject类，给维护独占同步的类以及实现Lock接口的类使用。</p><p>​ <strong>ConditionObject</strong>类实现了<strong>Condition</strong>接口，Condition接口提供了类似Object管程式的方法，如await、signal和signalAll操作，还扩展了带有超时、检测和监控的方法。ConditionObject类有效地将条件与其它同步操作结合到了一起。该类只支持Java风格的管程访问规则，这些规则中，当且仅当当前线程持有锁且要操作的条件（condition）属于该锁时，条件操作才是合法的。这样，一个ConditionObject关联到一个ReentrantLock上就表现的跟内置的管程（通过Object.wait等）一样了。两者的不同仅仅在于方法的名称、额外的功能以及用户可以为每个锁声明多个条件。</p><p>ConditionObject类和AQS共用了内部节点，有自己单独的条件队列。signal操作是通过将节点从条件队列转移到同步队列中来实现的，没有必要在需要唤醒的线程重新获取到锁之前将其唤醒。signal操作大致示意图如下：</p><p><img src="../images/aqs06.png" alt></p><p>await操作就是当前线程节点从同步队列进入条件队列进行等待，大致示意图如下：</p><p><img src="../images/aqs07.png" alt></p><p>​ 实现这些操作主要复杂在，因超时或Thread.interrupt导致取消了条件等待时，该如何处理。await和signal几乎同时发生就会有竞态问题，最终的结果遵照内置管程相关的规范。JSR133修订以后，就要求如果中断发生在signal操作之前，await方法必须在重新获取到锁后，抛出InterruptedException。但是，如果中断发生在signal后，await必须返回且不抛异常，同时设置线程的中断状态。</p><h3 id="AQS应用"><a href="#AQS应用" class="headerlink" title="AQS应用"></a>AQS应用</h3><p>AQS被大量的应用在了同步工具上。</p><p><strong>ReentrantLock</strong>：ReentrantLock类使用AQS同步状态来保存锁重复持有的次数。当锁被一个线程获取时，ReentrantLock也会记录下当前获得锁的线程标识，以便检查是否是重复获取，以及当错误的线程试图进行解锁操作时检测是否存在非法状态异常。ReentrantLock也使用了AQS提供的ConditionObject，还向外暴露了其它监控和监测相关的方法。</p><p><strong>ReentrantReadWriteLock</strong>：ReentrantReadWriteLock类使用AQS同步状态中的16位来保存写锁持有的次数，剩下的16位用来保存读锁的持有次数。WriteLock的构建方式同ReentrantLock。ReadLock则通过使用acquireShared方法来支持同时允许多个读线程。</p><p><strong>Semaphore</strong>：Semaphore类（信号量）使用AQS同步状态来保存信号量的当前计数。它里面定义的acquireShared方法会减少计数，或当计数为非正值时阻塞线程；tryRelease方法会增加计数，在计数为正值时还要解除线程的阻塞。</p><p><strong>CountDownLatch</strong>：CountDownLatch类使用AQS同步状态来表示计数。当该计数为0时，所有的acquire操作（对应到CountDownLatch中就是await方法）才能通过。</p><p><strong>FutureTask</strong>：FutureTask类使用AQS同步状态来表示某个异步计算任务的运行状态（初始化、运行中、被取消和完成）。设置（FutureTask的set方法）或取消（FutureTask的cancel方法）一个FutureTask时会调用AQS的release操作，等待计算结果的线程的阻塞解除是通过AQS的acquire操作实现的。</p><p><strong>SynchronousQueues</strong>：SynchronousQueues类使用了内部的等待节点，这些节点可以用于协调生产者和消费者。同时，它使用AQS同步状态来控制当某个消费者消费当前一项时，允许一个生产者继续生产，反之亦然。</p><p>​ 除了这些JUC提供的工具，还可以基于AQS自定义符合自己需求的同步器。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      java中的AQS的原理以及使用
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="AQS" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/AQS/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/tags/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="AQS" scheme="http://www.baiyp.ren/tags/AQS/"/>
    
  </entry>
  
  <entry>
    <title>java原子操作CAS</title>
    <link href="http://www.baiyp.ren/java%E5%8E%9F%E5%AD%90%E6%93%8D%E4%BD%9CCAS.html"/>
    <id>http://www.baiyp.ren/java原子操作CAS.html</id>
    <published>2019-08-09T00:11:30.000Z</published>
    <updated>2019-08-22T02:05:21.307Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="java原子操作CAS"><a href="#java原子操作CAS" class="headerlink" title="java原子操作CAS"></a>java原子操作CAS</h2><p><img src="../images/cas04.png" alt></p><h3 id="什么是CAS"><a href="#什么是CAS" class="headerlink" title="什么是CAS"></a>什么是CAS</h3><blockquote><p>CAS（Compare and Swap），即比较并替换，是用于实现多线程同步的原子指令。</p></blockquote><p>​ 假定有两个操作A和B，如果从执行A的线程来看，当另一个线程执行B时，要么将B全部执行完，要么完全不执行B，那么A和B对彼此来说是原子的。</p><p>​ 实现原子操作可以使用锁，锁机制，满足基本的需求是没有问题的了，但是有的时候我们的需求并非这么简单，我们需要更有效，更加灵活的机制，<strong>synchronized</strong>关键字是基于阻塞的锁机制，也就是说当一个线程拥有锁的时候，访问同一资源的其它线程需要等待，直到该线程释放锁，</p><p>​ 这里会有些问题：首先，如果被阻塞的线程优先级很高很重要怎么办？其次，如果获得锁的线程一直不释放锁怎么办？（这种情况是非常糟糕的）。还有一种情况，如果有大量的线程来竞争资源，那CPU将会花费大量的时间和资源来处理这些竞争，同时，还有可能出现一些例如死锁之类的情况，最后，其实锁机制是一种比较粗糙，粒度比较大的机制，相对于像计数器这样的需求有点儿过于笨重。</p><p>​ 实现原子操作还可以使用当前的<strong>处理器</strong>基本都支持CAS的指令，只不过每个厂家所实现的算法并不一样，每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p><p>​ CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。循环CAS就是在一个循环里不断的做cas操作，直到成功为止。</p><p>​ CAS是怎么实现线程的安全呢？语言层面不做处理，我们将其交给硬件—CPU和内存，利用CPU的多处理能力，实现硬件层面的阻塞，再加上volatile变量的特性即可实现基于原子操作的线程安全。</p><p><img src="../images/cas01.png" alt></p><h3 id="悲观锁，乐观锁"><a href="#悲观锁，乐观锁" class="headerlink" title="悲观锁，乐观锁"></a>悲观锁，乐观锁</h3><p>说到CAS，不得不提到两个专业词语：悲观锁，乐观锁。我们先来看看什么是悲观锁，什么是乐观锁。</p><h4 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h4><p>​ 顾名思义，就是比较悲观的锁，总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁（共享资源每次只给一个线程使用，其它线程阻塞，用完后再把资源转让给其它线程）。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。Java中<strong>synchronized</strong>和<strong>ReentrantLock</strong>等独占锁就是悲观锁思想的实现。</p><h4 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h4><p>​ 反之，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号机制和CAS算法实现。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。我们今天讲的CAS就是乐观锁。</p><h3 id="CAS-的优点"><a href="#CAS-的优点" class="headerlink" title="CAS 的优点"></a>CAS 的优点</h3><p>​ 非阻塞的轻量级乐观锁, 通过CPU指令实现, 在资源竞争不激烈的情况下性能高, 相比synchronize重量级悲观锁, synchronize有复杂的加锁, 解锁和唤醒线程操作.。</p><h3 id="CAS实现原子操作的三大问题"><a href="#CAS实现原子操作的三大问题" class="headerlink" title="CAS实现原子操作的三大问题"></a>CAS实现原子操作的三大问题</h3><h4 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h4><p><img src="../images/cas02.png" alt></p><p>​ 因为CAS需要在操作值的时候，检查值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它的值没有发生变化，但是实际上却变化了。</p><p>​ 就像上图描述的一样，线程A原来的值是10，线程B修改为了20，但是线程C又将值修改为了10，这个时候线程A来读取了，与旧值做判断，发现还是10，没有修改过，就做了更新操作，但是我们知道，值有过变更。</p><h4 id="循环时间长开销大"><a href="#循环时间长开销大" class="headerlink" title="循环时间长开销大"></a>循环时间长开销大</h4><p>自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。</p><h4 id="只能保证一个共享变量的原子操作"><a href="#只能保证一个共享变量的原子操作" class="headerlink" title="只能保证一个共享变量的原子操作"></a>只能保证一个共享变量的原子操作</h4><p>​ 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p><p>​ 还有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如，有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。从Java 1.5开始，JDK提供了AtomicReference类来保证引用对象之间的原子性，就可以把多个变量放在一个对象里来进行CAS操作。</p><h3 id="Jdk中相关原子操作类的使用"><a href="#Jdk中相关原子操作类的使用" class="headerlink" title="Jdk中相关原子操作类的使用"></a>Jdk中相关原子操作类的使用</h3><p>JDK的CAS原子操作类在JUC包下 我看看下</p><p><img src="../images/cas03.png" alt></p><h4 id="JAVA中如何实现CAS操作"><a href="#JAVA中如何实现CAS操作" class="headerlink" title="JAVA中如何实现CAS操作"></a>JAVA中如何实现CAS操作</h4><blockquote><p>先来一波操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">//  private static AtomicInteger count = new AtomicInteger(0);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Cas 自旋操作</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">accumulation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//自旋</span></span><br><span class="line">        <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">            <span class="comment">//获取旧值</span></span><br><span class="line">            <span class="keyword">int</span> oldValue = count.get();</span><br><span class="line">            <span class="comment">//比较并且交换</span></span><br><span class="line">            <span class="keyword">boolean</span> flag = count.compareAndSet(oldValue, oldValue + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果成功退出自旋</span></span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//失败打印信息再来一次</span></span><br><span class="line">            System.out.println(<span class="string">"数据已被修改自旋再来一次"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//五个线程再跑</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sleep(<span class="number">1000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//每个线程让count自增100次</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; <span class="number">100</span>; n++) &#123;</span><br><span class="line">                    accumulation();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        sleep(<span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">数据已被修改自旋再来一次</span><br><span class="line">数据已被修改自旋再来一次</span><br><span class="line">数据已被修改自旋再来一次</span><br><span class="line">数据已被修改自旋再来一次</span><br><span class="line"><span class="number">500</span></span><br></pre></td></tr></table></figure><p>这个是我们自己实现了累加操作，但是实际上JDK给我们提供了累加操作方法</p><p>将public static void accumulation() 方法替换为下面的方法就可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count.incrementAndGet();</span><br></pre></td></tr></table></figure><p>我们进去看看他是怎么操作的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在进入getAndAddInt 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object o, <span class="keyword">long</span> offset, <span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> v;</span><br><span class="line">       <span class="keyword">do</span> &#123;</span><br><span class="line">           v = getIntVolatile(o, offset);</span><br><span class="line">       &#125; <span class="keyword">while</span> (!compareAndSwapInt(o, offset, v, v + delta));</span><br><span class="line">       <span class="keyword">return</span> v;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>我们发现，JDK也是通过自旋来实现的，和我们的效果一摸一样，他的核心方法是<strong>compareAndSwapInt</strong></p><h3 id="我们常用的CAS操作类"><a href="#我们常用的CAS操作类" class="headerlink" title="我们常用的CAS操作类"></a>我们常用的CAS操作类</h3><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>•int addAndGet（int delta）：以原子方式将输入的数值与实例中的值（AtomicInteger里的value）相加，并返回结果。</p><p>•boolean compareAndSet（int expect，int update）：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。</p><p>•int getAndIncrement()：以原子方式将当前值加1，注意，这里返回的是自增前的值。</p><p>•int getAndSet（int newValue）：以原子方式设置为newValue的值，并返回旧值。</p><h4 id="AtomicIntegerArray"><a href="#AtomicIntegerArray" class="headerlink" title="AtomicIntegerArray"></a>AtomicIntegerArray</h4><p>主要是提供原子的方式更新数组里的整型，其常用方法如下。</p><p>•int addAndGet（int i，int delta）：以原子方式将输入值与数组中索引i的元素相加。</p><p>•boolean compareAndSet（int i，int expect，int update）：如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。</p><p>需要注意的是，数组value通过构造方法传递进去，然后AtomicIntegerArray会将当前数组复制一份，所以当AtomicIntegerArray对内部的数组元素进行修改时，不会影响传入的数组。</p><h3 id="更新引用类型"><a href="#更新引用类型" class="headerlink" title="更新引用类型"></a>更新引用类型</h3><p>​ 原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子更新多个变量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下3个类。</p><h4 id="AtomicReference"><a href="#AtomicReference" class="headerlink" title="AtomicReference"></a>AtomicReference</h4><p>原子更新引用类型。</p><h4 id="AtomicStampedReference"><a href="#AtomicStampedReference" class="headerlink" title="AtomicStampedReference"></a>AtomicStampedReference</h4><p>​ 利用版本戳的形式记录了每次改变以后的版本号，这样的话就不会存在ABA问题了。这就是AtomicStampedReference的解决方案。AtomicMarkableReference跟AtomicStampedReference差不多， AtomicStampedReference是使用pair的int stamp作为计数器使用，AtomicMarkableReference的pair使用的是boolean mark。 还是那个水的例子，AtomicStampedReference可能关心的是动过几次，AtomicMarkableReference关心的是有没有被人动过，方法都比较简单。</p><h4 id="AtomicMarkableReference："><a href="#AtomicMarkableReference：" class="headerlink" title="AtomicMarkableReference："></a>AtomicMarkableReference：</h4><p>​ 原子更新带有标记位的引用类型。可以原子更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference（V initialRef，booleaninitialMark）。</p><h3 id="原子更新字段类"><a href="#原子更新字段类" class="headerlink" title="原子更新字段类"></a>原子更新字段类</h3><p>​ 如果需原子地更新某个类里的某个字段时，就需要使用原子更新字段类，Atomic包提供了以下3个类进行原子字段更新。</p><p>​ 要想原子地更新字段类需要两步。第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。第二步，更新类的字段（属性）必须使用public volatile修饰符。</p><h4 id="AtomicIntegerFieldUpdater："><a href="#AtomicIntegerFieldUpdater：" class="headerlink" title="AtomicIntegerFieldUpdater："></a>AtomicIntegerFieldUpdater：</h4><p>原子更新整型的字段的更新器。</p><h4 id="AtomicLongFieldUpdater："><a href="#AtomicLongFieldUpdater：" class="headerlink" title="AtomicLongFieldUpdater："></a>AtomicLongFieldUpdater：</h4><p>原子更新长整型字段的更新器。</p><h4 id="AtomicReferenceFieldUpdater："><a href="#AtomicReferenceFieldUpdater：" class="headerlink" title="AtomicReferenceFieldUpdater："></a>AtomicReferenceFieldUpdater：</h4><p>原子更新引用类型里的字段。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      java原子操作CAS的详解
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="CAS" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%AB%98%E7%BA%A7/CAS/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="高级" scheme="http://www.baiyp.ren/tags/%E9%AB%98%E7%BA%A7/"/>
    
      <category term="CAS" scheme="http://www.baiyp.ren/tags/CAS/"/>
    
  </entry>
  
  <entry>
    <title>java并发工具类-Exchanger</title>
    <link href="http://www.baiyp.ren/java%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB-06.html"/>
    <id>http://www.baiyp.ren/java并发工具类-06.html</id>
    <published>2019-08-07T10:04:39.000Z</published>
    <updated>2019-08-22T02:04:25.048Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="java并发工具类-Exchanger"><a href="#java并发工具类-Exchanger" class="headerlink" title="java并发工具类-Exchanger"></a>java并发工具类-Exchanger</h2><p><img src="../images/exchanger01.png" alt></p><h3 id="Exchanger-简介"><a href="#Exchanger-简介" class="headerlink" title="Exchanger 简介"></a>Exchanger 简介</h3><p>​ Exchange位于JUC包下面，主要是用于线程之间数据交换的工具类，经常用于管道设计和遗传算法中，Exchanger用于进行线程间的数据交换，它提供一个同步点，在这个同步点，两个线程可以交换彼此的数据。这两个线程通过exchange 方法交换数据，如果第一个线程先执行exchange 方法，它会一直等待第二个线程也执行exchange 方法，当两个线程都到达同步点时，这两个线程就可以交换数据。</p><p>可以将Exchange看做是一个双向数据传输的SynchronousQueue。</p><ul><li>此类提供对外的操作是同步的；</li><li>用于成对出现的线程之间交换数据；</li><li>可以视作双向的同步队列；</li><li>可应用于基因算法、流水线设计等场景。</li></ul><h3 id="Exchanger-提供的方法"><a href="#Exchanger-提供的方法" class="headerlink" title="Exchanger 提供的方法"></a>Exchanger 提供的方法</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a new Exchanger.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Exchanger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      participant = <span class="keyword">new</span> Participant();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>创建一个新的Exchange。</p><h4 id="主要方法"><a href="#主要方法" class="headerlink" title="主要方法"></a>主要方法</h4><p>这个类提供对外的接口非常简洁，一个无参构造函数，两个重载的范型exchange方法：</p><blockquote><p>等待另外一个线程到达此交换点（除非当前线程被中断），将给定的对象x传送给该线程，并且接收该线程的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x)</span> <span class="keyword">throws</span> InterruptedException</span></span><br></pre></td></tr></table></figure><blockquote><p>等待另外一个线程到达此交换点（除非当前线程被中断，或者超出了指定的等待时间），将指定的对象x传送给该线程，同时接收该线程的对象。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">exchange</span><span class="params">(V x, <span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, TimeoutException</span></span><br></pre></td></tr></table></figure><h3 id="Exchanger的应用场景"><a href="#Exchanger的应用场景" class="headerlink" title="Exchanger的应用场景"></a>Exchanger的应用场景</h3><p>​ Exchanger可以用于遗传算法，遗传算法里需要选出两个人作为交配对象，这时候会交换两人的数据，并使用交叉规则得出2个交配结果。</p><p>​ 只要用于两个线程之间交换数据。</p><p>​ 如果两个线程有一个没有到达exchange方法，则会一直等待,如果担心有特殊情况发生，避免一直等待，可以使用exchange(V x, long timeout, TimeUnit unit)设置最大等待时长。</p><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><p>​ 比如生活中两个人，一个人有零食，另一个人有钱，他们两个想等价交换，对好口号在某个地方相见，一个人先到了之后，必须等另一个人带着需要的东西来了之后，才能开始交换。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExchangerTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Exchanger exchanger = <span class="keyword">new</span> Exchanger();</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">//线程1 拿着零食来交换</span></span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            String data1 = <span class="string">"零食"</span>;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">"正在把数据 "</span> + data1 + <span class="string">" 换出去"</span>);</span><br><span class="line">            String data2 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"正在交换等待10s"</span>);</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) Math.random() * <span class="number">10000</span>);</span><br><span class="line">                <span class="comment">//开始交换数</span></span><br><span class="line">                data2 = (String) exchanger.exchange(data1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">"换回的数据为 "</span> + data2);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程2 拿着钱来交换</span></span><br><span class="line">        service.submit(() -&gt; &#123;</span><br><span class="line">            String data1 = <span class="string">"钱"</span>;</span><br><span class="line">            System.out.println(<span class="string">"线程"</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">"正在把数据 "</span> + data1 + <span class="string">" 交换出去"</span>);</span><br><span class="line">            String data2 = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"正在交换等待10s"</span>);</span><br><span class="line">                Thread.sleep((<span class="keyword">long</span>) (Math.random() * <span class="number">10000</span>));</span><br><span class="line">                <span class="comment">//开始交换数</span></span><br><span class="line">                data2 = (String) exchanger.exchange(data1);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"线程 "</span> + Thread.currentThread().getName() +</span><br><span class="line">                    <span class="string">"交换回来的数据是: "</span> + data2);</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        service.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">1</span>正在把数据 零食 换出去</span><br><span class="line">正在交换等待<span class="number">10</span>s</span><br><span class="line">线程pool-<span class="number">1</span>-thread-<span class="number">2</span>正在把数据 钱 交换出去</span><br><span class="line">正在交换等待<span class="number">10</span>s</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">2</span>交换回来的数据是: 零食</span><br><span class="line">线程 pool-<span class="number">1</span>-thread-<span class="number">1</span>换回的数据为 钱</span><br></pre></td></tr></table></figure><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      java并发工具类-Exchanger的使用
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="工具类" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="工具类" scheme="http://www.baiyp.ren/tags/%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>java变得牛逼的方法</title>
    <link href="http://www.baiyp.ren/%E5%8F%98%E5%BE%97%E7%89%9B%E9%80%BC%E7%9A%84%E6%96%B9%E6%B3%95.html"/>
    <id>http://www.baiyp.ren/变得牛逼的方法.html</id>
    <published>2019-08-05T13:51:08.000Z</published>
    <updated>2019-08-22T02:03:39.580Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Wed Aug 28 2019 18:18:12 GMT+0800 (GMT+08:00) --><h2 id="变得牛逼的方法"><a href="#变得牛逼的方法" class="headerlink" title="变得牛逼的方法"></a>变得牛逼的方法</h2><p><img src="../images/nb01.jpg" alt></p><h3 id="信息获取"><a href="#信息获取" class="headerlink" title="信息获取"></a>信息获取</h3><h4 id="习惯使用百度"><a href="#习惯使用百度" class="headerlink" title="习惯使用百度"></a>习惯使用百度</h4><blockquote><p>让周围人都认为你习惯于使用百度</p></blockquote><h4 id="多关注些大咖的微博"><a href="#多关注些大咖的微博" class="headerlink" title="多关注些大咖的微博"></a>多关注些大咖的微博</h4><blockquote><p>让周围人都认为你的知识都是从大咖那里学来的，不要让周围人找到学习的重点</p></blockquote><h3 id="知识学习和技能训练"><a href="#知识学习和技能训练" class="headerlink" title="知识学习和技能训练"></a>知识学习和技能训练</h3><h4 id="混淆认识-知识幻觉"><a href="#混淆认识-知识幻觉" class="headerlink" title="混淆认识 知识幻觉"></a>混淆认识 知识幻觉</h4><blockquote><p>给周围人灌输知识很容易获取，通过很简单的方式就可以掌握，把各种不一样的知识混淆视听，让他们找不到重点，感觉自己很牛逼的样子。</p></blockquote><h4 id="培养他人学习使用碎片化时间"><a href="#培养他人学习使用碎片化时间" class="headerlink" title="培养他人学习使用碎片化时间"></a>培养他人学习使用碎片化时间</h4><blockquote><p>培养周围人在工作期间，多看CSDN，博客等文章，让他们感觉自己在学习，在进步。</p></blockquote><h4 id="不断提供各种各样看起来有价值的学习资料"><a href="#不断提供各种各样看起来有价值的学习资料" class="headerlink" title="不断提供各种各样看起来有价值的学习资料"></a>不断提供各种各样看起来有价值的学习资料</h4><blockquote><p>大量提供几十个G的学习视频和资料，不要告诉他们重点是什么，让他们看到资料就头大，学几节课就放弃的那种。</p></blockquote><h4 id="让他们去看一些枯燥的书，基础知识"><a href="#让他们去看一些枯燥的书，基础知识" class="headerlink" title="让他们去看一些枯燥的书，基础知识"></a>让他们去看一些枯燥的书，基础知识</h4><blockquote><p>提供一些JAVA基础书籍，JAVA核心技术上下卷，让他们学完后忘记，忘记后继续学，到怀疑自己是不是学JAVA的料，到怀疑人生。</p></blockquote><h4 id="框架只要使用"><a href="#框架只要使用" class="headerlink" title="框架只要使用"></a>框架只要使用</h4><blockquote><p>培养周围人框架只用论，不要探究原理，并且嘲讽那些探究原理的人。</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      java变得牛逼的方法
    
    </summary>
    
      <category term="架构" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="装逼" scheme="http://www.baiyp.ren/categories/%E6%9E%B6%E6%9E%84/%E8%A3%85%E9%80%BC/"/>
    
    
      <category term="架构" scheme="http://www.baiyp.ren/tags/%E6%9E%B6%E6%9E%84/"/>
    
      <category term="装逼" scheme="http://www.baiyp.ren/tags/%E8%A3%85%E9%80%BC/"/>
    
  </entry>
  
</feed>
