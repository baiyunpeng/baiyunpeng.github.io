<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>晓风残月的博客</title>
  
  <subtitle>晓风残月</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.baiyp.ren/"/>
  <updated>2019-09-15T08:47:34.396Z</updated>
  <id>http://www.baiyp.ren/</id>
  
  <author>
    <name>晓风残月</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>HashMap实现原理</title>
    <link href="http://www.baiyp.ren/HashMap%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/HashMap实现原理.html</id>
    <published>2019-09-12T01:11:04.000Z</published>
    <updated>2019-09-15T08:47:34.396Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="HashMap实现原理"><a href="#HashMap实现原理" class="headerlink" title="HashMap实现原理"></a>HashMap实现原理</h2><p><img src="../images/map/hashmap/hashmap01.png" alt></p><p>​ HashMap也是我们使用非常多的Collection，它是基于哈希表的 Map 接口的实现，以key-value的形式存在。在HashMap中，key-value总是会当做一个整体来处理，系统会根据hash算法来来计算key-value的存储位置，我们总是可以通过key快速地存、取value。下面就来分析HashMap的存取。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>​ HashMap实现了Map接口，继承AbstractMap。其中Map接口定义了键映射到值的规则，而AbstractMap类提供 Map 接口的骨干实现，以最大限度地减少实现此接口所需的工作，其实AbstractMap类已经实现了Map。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HashMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractMap</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">Map</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;, <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//序列号，序列化的时候使用。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">362498820763181265L</span>;</span><br><span class="line">    <span class="comment">/**默认容量，1向左移位4个，00000001变成00010000，也就是2的4次方为16，使用移位是因为移位是计算机基础运算，效率比加减乘除快。**/</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//最大容量，2的30次方。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line">    <span class="comment">//负载因子，用于扩容使用。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line">    <span class="comment">//当某个桶节点数量大于8时，会转换为红黑树。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line">    <span class="comment">//当某个桶节点数量小于6时，会转换为链表，前提是它当前是红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line">    <span class="comment">//当整个hashMap中元素数量大于64时，也会进行转为红黑树结构。</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line">    <span class="comment">//存储元素的数组，transient关键字表示该属性不能被序列化</span></span><br><span class="line">    <span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line">    <span class="comment">//将数据转换成set的另一种存储形式，这个变量主要用于迭代功能。</span></span><br><span class="line">    <span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line">    <span class="comment">//元素数量</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="comment">//统计该map修改的次数</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line">    <span class="comment">//临界值，也就是元素数量达到临界值时，会进行扩容。</span></span><br><span class="line">    <span class="keyword">int</span> threshold;</span><br><span class="line">    <span class="comment">//也是负载因子，只不过这个是变量。</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里讲讲为什么默认容量大小为16，负载因子为0.75，主要原因是这两个常量的值都是经过大量的计算和统计得出来的最优解，仅仅是这样而已。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>HashMap提供了三个构造函数：</p><ul><li><p>HashMap()：构造一个具有默认初始容量 (16) 和默认负载因子 (0.75) 的空 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DEFAULT_LOAD_FACTOR = 0.75f</span></span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HashMap(int initialCapacity)：构造一个带指定初始容量和默负载因子 (0.75) 的空 HashMap。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li>HashMap(int initialCapacity, float loadFactor)：构造一个带指定初始容量和负载因子的空 HashMap。</li></ul><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><blockquote><p>调用构造方法进行初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 构造方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> initialCapacity 初始容量</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> loadFactor      扩容因子</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//容量参数不合理 报错</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                   initialCapacity);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//初始容量不能 &gt; 最大容量值，HashMap的最大容量值为2^30</span></span><br><span class="line">       <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">           initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">       <span class="comment">//扩容因子不合理报错</span></span><br><span class="line">       <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor)) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                   loadFactor);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//初始化扩容因子</span></span><br><span class="line">       <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">       <span class="comment">//设置下次扩容阈值</span></span><br><span class="line">       <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>​ 在这里提到了两个参数：初始容量，负载因子。这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中桶的数量，初始容量是创建哈希表时的容量，负载因子是哈希表在其容量自动增加之前可以达到多满的一种尺度，它衡量的是一个散列表的空间的使用程度，负载因子越大表示散列表的装填程度越高，反之愈小。对于使用链表法的散列表来说，查找一个元素的平均时间是O(1+a)，因此如果负载因子越大，对空间的利用更充分，然而后果是查找效率的降低；如果负载因子太小，那么散列表的数据将过于稀疏，对空间造成严重浪费。系统默认负载因子为0.75，一般情况下我们是无需修改的。</p><h4 id="tableSizeFor"><a href="#tableSizeFor" class="headerlink" title="tableSizeFor"></a>tableSizeFor</h4><blockquote><p>根据参数返回最近的2的n次幂的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">//是返回大于输入参数且最近的2的整数次幂的数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//　让cap-1再赋值给n的目的是另找到的目标值大于或等于原值</span></span><br><span class="line">       <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">       n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">       <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种方法的效率非常高，可见Java8对容器优化了很多</p><h3 id="内部数据结构"><a href="#内部数据结构" class="headerlink" title="内部数据结构"></a>内部数据结构</h3><h4 id="Node"><a href="#Node" class="headerlink" title="Node"></a>Node</h4><blockquote><p>Node是 HashMap的静态内部，HashMap主干是一个Node数组，Node是HashMap的最基本组成单位。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * HashMap 的Node 节点元素</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;K&gt; 元素的key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> &lt;V&gt; 元素的Value</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">// 这个节点所在位置的hash值</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="comment">//这个节点的Key</span></span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        <span class="comment">//这个节点的value</span></span><br><span class="line">        V value;</span><br><span class="line">        <span class="comment">//后继节点</span></span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">        <span class="comment">//构造方法</span></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 获取HashCode</span></span><br><span class="line"><span class="comment">         * key和value 的hash做异或运算 防止hash冲突</span></span><br><span class="line"><span class="comment">          * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 设置value</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> newValue</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            <span class="comment">//替换当前node的value</span></span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="comment">//返回旧的value</span></span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * equals 比较</span></span><br><span class="line"><span class="comment">         * 如果 key和value都一致 判断equals相等</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> o</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在jdk8之前HashMap是数组加链表的形式实现，但是在1.8之后为提高哈希冲突后链表的查询速度，当桶内链表长度超过<strong>树化阀值</strong>且总长度超过<strong>最小树化容量</strong>后会将链表转换为红黑树。</p><h4 id="速度"><a href="#速度" class="headerlink" title="速度"></a>速度</h4><h5 id="查询与修改"><a href="#查询与修改" class="headerlink" title="查询与修改"></a>查询与修改</h5><p>先用散列函数对键进行散列，没有冲突的情况下查询是下标查询，时间复杂度是 O(1),速度很快。</p><p>存在哈希冲突的情况，需要对链表/红黑树进行遍历，equals比对查询。</p><p>性能上，考虑是链表/红黑树上的元素越是越好，越均匀越好；此外HashMap主干未必越长越好，会有用不到的桶浪费空间。</p><h5 id="增加与删除"><a href="#增加与删除" class="headerlink" title="增加与删除"></a>增加与删除</h5><p>​ 由于查询速度快，而桶里用链表/红黑树实现，所以添加和删除效率也很高。HashMap会在size超过阀值后进行调整大下(resize)，所以根据具体情况提前给HashMap一个合适的初始长度是个不错的习惯。</p><h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><blockquote><p>put方法是一个重点方法，这里有 HashMap初始化，数据在 HashMap中是如何储存的，什么情况下链表会转换为红黑树等内容，需要仔细研究。</p></blockquote><p><img src="../images/map/hashmap/hashmap03.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * put 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这里继续调用putVal方法</span></span><br><span class="line">    <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="putVal-方法"><a href="#putVal-方法" class="headerlink" title="putVal 方法"></a>putVal 方法</h4><blockquote><p>putVal是final修饰的方法，子类 LinkedHashMap也是用的这各方法，evict（看下面的的第5个参数）就是给 LinkedHashMap使用的，HashMap中并没有什么用。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * putVal 方法 真正进行插入操作的方法，</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> hash         传入key的哈希值</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> onlyIfAbsent 如果该值是true,如果存在值就不会进行修改操作</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> evict        LinekdHashMap尾操作使用，这里暂无用途</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">       Node&lt;K, V&gt;[] tab;</span><br><span class="line">       Node&lt;K, V&gt; p;</span><br><span class="line">       <span class="keyword">int</span> n, i;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**********初始化********/</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果table长度是0或table是null会调整一次大小</span></span><br><span class="line">       <span class="comment">// 这时tab会指向调整大下后的Node&lt;K,V&gt;[](主干数组)</span></span><br><span class="line">       <span class="comment">// n被赋值为新数组长度</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// 如果没有调整大小，tab指向table</span></span><br><span class="line">       <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">           n = (tab = resize()).length;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/********开始查找键的位置，并存储value*******/</span></span><br><span class="line">       <span class="comment">// i = (n - 1) &amp; hash这个是获取key应该在哪个桶里,下面详说</span></span><br><span class="line">       <span class="comment">// 这里将p指向当前key所需要的那个桶</span></span><br><span class="line">       <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 如果空桶，也就是无哈希冲突的情况，直接丢个Node进去。</span></span><br><span class="line">           <span class="comment">// 此时的tab就是table</span></span><br><span class="line">           tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">           <span class="comment">//存在冲突，开始寻找我们要找的节点</span></span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">           Node&lt;K, V&gt; e;</span><br><span class="line">           K k;</span><br><span class="line">           <span class="comment">// 判断第一个节点是不是我们找的</span></span><br><span class="line">           <span class="comment">// 此时k储存了 p.key</span></span><br><span class="line">           <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">               <span class="comment">// hash值相等，key值相等，定位完成,是修改操作</span></span><br><span class="line">               <span class="comment">// e来储存p这个节点，一会修改</span></span><br><span class="line">               e = p;</span><br><span class="line">               <span class="comment">// 判断是否是红黑树节点</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">               <span class="comment">// 是红黑树节点，存在就返回那个节点，不存在就返回null</span></span><br><span class="line">               e = ((TreeNode&lt;K, V&gt;) p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">               <span class="comment">// 最终，是链表了，开始对链表遍历查找</span></span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                   <span class="comment">// 上面知道第一个接点不是我们要的，直接获取下一个，并储存给e</span></span><br><span class="line">                   <span class="comment">// 下一个是空，直接丢个Node在这里，然后p.next指向这里</span></span><br><span class="line">                   <span class="comment">// 这里下一个节点地址给了e</span></span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                       <span class="comment">// ！大于树化阀值，开始树化</span></span><br><span class="line">                       <span class="comment">// 注意-1是因为binCount是索引而不是长度</span></span><br><span class="line">                       <span class="comment">// 其实此时链表长度已经是7+1（索引） + 1（新进来的Node）</span></span><br><span class="line">                       <span class="comment">// 已经大于树化阀值8，也就是说链表长度为8时是不会树化的</span></span><br><span class="line"></span><br><span class="line">                       <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                           <span class="comment">//树化</span></span><br><span class="line">                           treeifyBin(tab, hash);</span><br><span class="line">                       <span class="comment">//加进去就跳出循环了</span></span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">// 下个节点有值，且是我们找的节点，跳出去</span></span><br><span class="line">                   <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="comment">//下一个节点不是我们找的节点继续编历</span></span><br><span class="line">                   p = e;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 上面说了，这有修改操作e才能不是null</span></span><br><span class="line">           <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">               V oldValue = e.value;</span><br><span class="line">               <span class="comment">// 给e新值</span></span><br><span class="line">               <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   e.value = value;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 这个是LinkedHashMap用的，HashMap里是个空实现</span></span><br><span class="line">               afterNodeAccess(e);</span><br><span class="line">               <span class="comment">// 修改就会把旧值返回去</span></span><br><span class="line">               <span class="keyword">return</span> oldValue;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*********修改完成的后续操作**********/</span></span><br><span class="line">       <span class="comment">// 修改次数加1</span></span><br><span class="line">       ++modCount;</span><br><span class="line">       <span class="comment">// 如果size大于阀值，会执行resize()方法调整大小</span></span><br><span class="line">       <span class="keyword">if</span> (++size &gt; threshold) &#123;</span><br><span class="line">           resize();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 这个是给LinkedHashMap用的，HashMap里也是个空实现</span></span><br><span class="line">       afterNodeInsertion(evict);</span><br><span class="line">       <span class="comment">// 添加成功返回null</span></span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="hash-方法"><a href="#hash-方法" class="headerlink" title="hash 方法"></a>hash 方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * hash 运算</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *  key是null就返回0，key不是null就先取hashCode（）</span></span><br><span class="line"><span class="comment">     *  然后与这个hashCode（）无符号右移进行亦或运算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="为什么要使用异或运算"><a href="#为什么要使用异或运算" class="headerlink" title="为什么要使用异或运算"></a>为什么要使用异或运算</h5><ul><li>这是因为找key的位置时，<code>(n - 1) &amp; hash</code>是table的索引，n的长度不够大时，只和hashCode()的低16位有关，这样发生冲突的概率就变高。</li><li>为减少这种影响，设计者权衡了speed, utility, and quality，将高16位与低16位异或来减少这种影响。设计者考虑到现在的hashCode分布的已经很不错了，而且当发生较大碰撞时也用树形存储降低了冲突。仅仅异或一下，既减少了系统的开销，也不会造成的因为高16位没有参与下标的计算(table长度比较小时)而引起的碰撞。</li></ul><p><img src="../images/map/hashmap/hashmap04.jpg" alt></p><h4 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h4><blockquote><p>这也是一个很重要的方法，主要包括两部分，第一部分是根据size是否超过阀值判断是否需要进行扩容，第二部分是扩容后将原Node[]中数据复制到扩容后的Node[]中</p></blockquote><p><img src="../images/map/hashmap/hashmap05.png" alt></p><h5 id="扩容的三种情况"><a href="#扩容的三种情况" class="headerlink" title="扩容的三种情况"></a>扩容的三种情况</h5><ul><li><p>使用默认构造方法初始化HashMap。从前文可以知道HashMap在一开始初始化的时候会返回一个空的table，并且thershold为0。因此第一次扩容的容量为默认值DEFAULT_INITIAL_CAPACITY也就是16。同时threshold = DEFAULT_INITIAL_CAPACITY * DEFAULT_LOAD_FACTOR = 12。</p></li><li><p>指定初始容量的构造方法初始化HashMap。那么从下面源码可以看到初始容量会等于threshold，接着threshold = 当前的容量（threshold） * DEFAULT_LOAD_FACTOR。</p></li><li><p>HashMap不是第一次扩容。如果HashMap已经扩容过的话，那么每次table的容量以及threshold量为原有的两倍</p></li></ul><p>这边也可以引申到一个问题就是HashMap是先插入数据再进行扩容的，但是如果是刚刚初始化容器的时候是先扩容再插入数据。</p><h5 id="扩容部分"><a href="#扩容部分" class="headerlink" title="扩容部分"></a>扩容部分</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 扩容方法</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K, V&gt;[] resize() &#123;</span><br><span class="line">       Node&lt;K, V&gt;[] oldTab = table;</span><br><span class="line">       <span class="comment">// 原容量，table为null返回0，否则返回table长度</span></span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="comment">//原始阈值</span></span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="comment">//新容量，新阈值</span></span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">// table已经初始化，旧容量&gt;0</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 容量已经超过最大容量，直接返回去</span></span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">               <span class="comment">// 2倍扩容后小于最大容量，并且原容量大于默认初始化容量(我还没想清楚为什么要大于默认初始容量)</span></span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) &#123;</span><br><span class="line">               <span class="comment">// 阀值加倍</span></span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 原数组容量为0，未初始化，但阀值不为0</span></span><br><span class="line">           <span class="comment">// 也就是构造方法里threshold = tableSizeFor(initialCapacity）这个步骤</span></span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) &#123; <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">           <span class="comment">// 啥都没有，默认构造</span></span><br><span class="line">       &#125;<span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>) (DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">// 新数组阀值未被赋值</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="comment">// 使用新的容量*负载因子计算阀值</span></span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>) newCap * loadFactor;</span><br><span class="line">           <span class="comment">// 取计算后阀值和最大容量里较小的那个</span></span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>) MAXIMUM_CAPACITY ?</span><br><span class="line">                   (<span class="keyword">int</span>) ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br></pre></td></tr></table></figure><h5 id="复制数据部分"><a href="#复制数据部分" class="headerlink" title="复制数据部分"></a>复制数据部分</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建新的数组</span></span><br><span class="line">   Node&lt;K, V&gt;[] newTab = (Node&lt;K, V&gt;[]) <span class="keyword">new</span> Node[newCap];</span><br><span class="line"></span><br><span class="line">   table = newTab;</span><br><span class="line">   <span class="comment">//开始复制数据</span></span><br><span class="line">   <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">//开始遍历</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">           Node&lt;K, V&gt; e;</span><br><span class="line">           <span class="comment">// 获取桶的第一个节点</span></span><br><span class="line">           <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">               oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">               <span class="comment">//没有后继节点，说明为空，直接移过去</span></span><br><span class="line">               <span class="keyword">if</span> (e.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="comment">//如果是红黑树，分裂放入新数组</span></span><br><span class="line">               &#125; <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                   ((TreeNode&lt;K, V&gt;) e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="comment">//链表操作在下面</span></span><br><span class="line">               &#125; <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                   <span class="comment">// 不是直接进行计算元素在新数组中的位置，而是原位置加原数组长度</span></span><br><span class="line">                   Node&lt;K, V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K, V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                   Node&lt;K, V&gt; next;</span><br><span class="line">                   <span class="keyword">do</span> &#123;</span><br><span class="line">                       <span class="comment">// 把链表下一个节点放在 next里</span></span><br><span class="line">                       next = e.next;</span><br><span class="line">                       <span class="comment">// 该节点不需要移动</span></span><br><span class="line">                       <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                           <span class="comment">// 尾元素为空，说明链表为空，确定为首元素</span></span><br><span class="line">                           <span class="keyword">if</span> (loTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               loHead = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 尾元素有就将元素放进尾元素的后继节点</span></span><br><span class="line">                               loTail.next = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 确定尾元素</span></span><br><span class="line">                           loTail = e;</span><br><span class="line">                           <span class="comment">// 该节点需要移动</span></span><br><span class="line">                       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                           <span class="comment">// 尾元素为空，说明链表为空，确定为首元素</span></span><br><span class="line">                           <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>) &#123;</span><br><span class="line">                               hiHead = e;</span><br><span class="line">                           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="comment">// 尾元素有就将元素放进尾元素的后继节点</span></span><br><span class="line">                               hiTail.next = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="comment">// 确定尾元素</span></span><br><span class="line">                           hiTail = e;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="comment">//直到遍历完链表跳出</span></span><br><span class="line">                   &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                   <span class="comment">// 把两个首元素放在两个桶里就可以了</span></span><br><span class="line">                   <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j] = loHead;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                       newTab[j + oldCap] = hiHead;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 返回新的数组</span></span><br><span class="line">   <span class="keyword">return</span> newTab;</span><br></pre></td></tr></table></figure><p>复制过程，a过去，假设计算后位置不边，进到i,此时i为null，a进去后即是head，又是tail</p><p>然后循环，到b，假设计算后还是i，i中已经有a，所以b直接丢到a后面，a任是head,单tail已经变成了b</p><p>以此类推，a,b,c,d都会放在i,j中</p><p>其实是先拼完链表才装进桶里的，这里只是方便描述，说成是一个一个过去</p><p>至此，put方法已经说完了，重点是putVal,hash和resize三个方法。</p><h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p><img src="../images/map/hashmap/hashmap06.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 返回指定的key映射的value，如果value为null，则返回null</span></span><br><span class="line"><span class="comment">     * get可以分为三个步骤：</span></span><br><span class="line"><span class="comment">     * 1.通过hash(Object key)方法计算key的哈希值hash。</span></span><br><span class="line"><span class="comment">     * 2.通过getNode( int hash, Object key)方法获取node。</span></span><br><span class="line"><span class="comment">     * 3.如果node为null，返回null，否则返回node.value。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@see</span> #put(Object, Object)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K, V&gt; e;</span><br><span class="line">        <span class="comment">//根据key及其hash值查询node节点，如果存在，则返回该节点的value值</span></span><br><span class="line">        <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其最终是调用了 <code>getNode</code> 函数。 其逻辑如下</p><h4 id="getNode方法"><a href="#getNode方法" class="headerlink" title="getNode方法"></a>getNode方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * getNode 方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash 指定参数key的哈希值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key  指定参数的 key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回node，如果没有则返回null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K, V&gt;[] tab;</span><br><span class="line">    Node&lt;K, V&gt; first, e;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    K k;</span><br><span class="line">    <span class="comment">//如果哈希表不为空，而且key对应的桶上不为空</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点就和指定参数hash和key匹配上了</span></span><br><span class="line">        <span class="keyword">if</span> (first.hash == hash &amp;&amp; ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">            <span class="comment">//返回第一个元素</span></span><br><span class="line">            <span class="keyword">return</span> first;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果桶中的第一个节点没有匹配上，而且有后续节点</span></span><br><span class="line">        <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//如果是红黑树</span></span><br><span class="line">            <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                <span class="comment">//如果当前的桶采用红黑树，则调用红黑树的get方法去获取节点</span></span><br><span class="line">                <span class="keyword">return</span> ((TreeNode&lt;K, V&gt;) first).getTreeNode(hash, key);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果当前的桶不采用红黑树，即桶中节点结构为链式结构</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="comment">//匹配上key</span></span><br><span class="line">                <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                    <span class="comment">//返回节点</span></span><br><span class="line">                    <span class="keyword">return</span> e;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//遍历元素直到 没有后继节点</span></span><br><span class="line">            &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//找不到 返回 null</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="remove-方法"><a href="#remove-方法" class="headerlink" title="remove 方法"></a>remove 方法</h3><blockquote><p>remove就是先找到节点位置，然后移除,核心方法是removeNode()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 删除方法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key 所要删除元素的key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">            <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeNode"><a href="#removeNode" class="headerlink" title="removeNode"></a>removeNode</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 删除Node节点</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash       要删除元素的hash</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key        删除元素的key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> value      remove方法重载时使用，只有同时匹配key-value时移除该节点</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> matchValue 为true时才会同时匹配key-value进行删除</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> movable    删除节点后是否改变红黑树的结构，般都为true只有在iterator的时候才为false</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K, V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value, <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">     <span class="comment">/*******查找节点的部分*******/</span></span><br><span class="line"></span><br><span class="line">     Node&lt;K, V&gt;[] tab;</span><br><span class="line">     Node&lt;K, V&gt; p;</span><br><span class="line">     <span class="keyword">int</span> n, index;</span><br><span class="line">     <span class="comment">// 1.原数组不为null</span></span><br><span class="line">     <span class="comment">// 2. 原数组长度大于0</span></span><br><span class="line">     <span class="comment">// 3.key数组中的位置不为空</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp; (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">// 声明两个节点node，e</span></span><br><span class="line">         Node&lt;K, V&gt; node = <span class="keyword">null</span>, e;</span><br><span class="line">         K k;</span><br><span class="line">         V v;</span><br><span class="line">         <span class="comment">// 第一个节点就我们要找的节点</span></span><br><span class="line">         <span class="keyword">if</span> (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">             <span class="comment">// 先给node，在下面删掉</span></span><br><span class="line">             node = p;</span><br><span class="line">             <span class="comment">//如果第一个不是则向后查找</span></span><br><span class="line">         &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">             <span class="comment">// 如果是红黑树，获取该接点并给node</span></span><br><span class="line">             <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 node = ((TreeNode&lt;K, V&gt;) p).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="keyword">do</span> &#123;</span><br><span class="line">                     <span class="comment">// 如果是要找的节点就把这个节点给node</span></span><br><span class="line">                     <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                         node = e;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="comment">// 不是把节点给p记录</span></span><br><span class="line">                     p = e;</span><br><span class="line">                     <span class="comment">//遍历节点一直到没有后继节点</span></span><br><span class="line">                 &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="comment">/**********删除节点的部分*********/</span></span><br><span class="line">         <span class="comment">//节点不为空</span></span><br><span class="line">         <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value || (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">             <span class="comment">// 如果是红黑树节点，使用removeTreeNode移除</span></span><br><span class="line">             <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode) &#123;</span><br><span class="line">                 ((TreeNode&lt;K, V&gt;) node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">             &#125; <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                 <span class="comment">// 这里执行的就是上面的第一种情况，桶里的第一个节点就是要移除的</span></span><br><span class="line">                 tab[index] = node.next;</span><br><span class="line">             <span class="keyword">else</span> &#123;</span><br><span class="line">                 <span class="comment">// 直接将移除的上个节点指向下一个节点</span></span><br><span class="line">                 p.next = node.next;</span><br><span class="line">             &#125;</span><br><span class="line">             <span class="comment">// 修改次数再加1</span></span><br><span class="line">             ++modCount;</span><br><span class="line">             <span class="comment">// 长度 -1</span></span><br><span class="line">             --size;</span><br><span class="line">             <span class="comment">// 给LinkedList使用，这里没啥用</span></span><br><span class="line">             afterNodeRemoval(node);</span><br><span class="line">             <span class="comment">// 删除的值返回去</span></span><br><span class="line">             <span class="keyword">return</span> node;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">// 根本没有这个</span></span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>我们现在可以回答开始的几个问题，加深对HashMap的理解：</p><p>1.什么时候会使用HashMap？他有什么特点？</p><blockquote><p>是基于Map接口的实现，存储键值对时，它可以接收null的键值，是非同步的，HashMap存储着Entry(hash, key, value, next)对象。</p></blockquote><p>2.你知道HashMap的工作原理吗？</p><blockquote><p>通过hash的方法，通过put和get存储和获取对象。存储对象时，我们将K/V传给put方法时，它调用hashCode计算hash从而得到bucket位置，进一步存储，HashMap会根据当前bucket的占用情况自动调整容量(超过Load Facotr则resize为原来的2倍)。获取对象时，我们将K传给get，它调用hashCode计算hash从而得到bucket位置，并进一步调用equals()方法确定键值对。如果发生碰撞的时候，Hashmap通过链表将产生碰撞冲突的元素组织起来，在Java 8中，如果一个bucket中碰撞冲突的元素超过某个限制(默认是8)，则使用红黑树来替换链表，从而提高速度。</p></blockquote><p>3.你知道get和put的原理吗？equals()和hashCode()的都有什么作用？</p><blockquote><p>通过对key的hashCode()进行hashing，并计算下标( n-1 &amp; hash)，从而获得buckets的位置。如果产生碰撞，则利用key.equals()方法去链表或树中去查找对应的节点</p></blockquote><p>4.你知道hash的实现吗？为什么要这样实现？</p><blockquote><p>在Java 1.8的实现中，是通过hashCode()的高16位异或低16位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)，主要是从速度、功效、质量来考虑的，这么做可以在bucket的n比较小的时候，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p></blockquote><p>5.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p><blockquote><p>如果超过了负载因子(默认0.75)，则会重新resize一个原来长度两倍的HashMap，并且重新调用hash方法。<br>关于Java集合的小抄中是这样描述的：<br>以Entry[]数组实现的哈希桶数组，用Key的哈希值取模桶数组的大小可得到数组下标。<br>插入元素时，如果两条Key落在同一个桶(比如哈希值1和17取模16后都属于第一个哈希桶)，Entry用一个next属性实现多个Entry以单向链表存放，后入桶的Entry将next指向桶当前的Entry。<br>查找哈希值为17的key时，先定位到第一个哈希桶，然后以链表遍历桶里所有元素，逐个比较其key值。<br>当Entry数量达到桶数量的75%时(很多文章说使用的桶数量达到了75%，但看代码不是)，会成倍扩容桶数组，并重新分配所有原来的Entry，所以这里也最好有个预估值。<br>取模用位运算(hash &amp; (arrayLength-1))会比较快，所以数组的大小永远是2的N次方， 你随便给一个初始值比如17会转为32。默认第一次放入元素时的初始值是16。<br>iterator()时顺着哈希桶数组来遍历，看起来是个乱序。</p></blockquote><p>6.当两个对象的hashcode相同会发生什么？</p><blockquote><p>因为hashcode相同，所以它们的bucket位置相同，‘碰撞’会发生。因为HashMap使用链表存储对象，这个Entry(包含有键值对的Map.Entry对象)会存储在链表中。</p></blockquote><p>7.如果两个键的hashcode相同，你如何获取值对象？</p><blockquote><p>找到bucket位置之后，会调用keys.equals()方法去找到链表中正确的节点，最终找到要找的值对象。因此，设计HashMap的key类型时，如果使用不可变的、声明作final的对象，并且采用合适的equals()和hashCode()方法的话，将会减少碰撞的发生，提高效率。不可变性能够缓存不同键的hashcode，这将提高整个获取对象的速度，使用String，Interger这样的wrapper类作为键是非常好的选择</p></blockquote><p>8.如果HashMap的大小超过了负载因子(load factor)定义的容量，怎么办？</p><blockquote><p>默认的负载因子大小为0.75，也就是说，当一个map填满了75%的bucket时候，和其它集合类(如ArrayList等)一样，将会创建原来HashMap大小的两倍的bucket数组，来重新调整map的大小，并将原来的对象放入新的bucket数组中。这个过程叫作rehashing，因为它调用hash方法找到新的bucket位置</p></blockquote><p>9.你了解重新调整HashMap大小存在什么问题吗？</p><blockquote><p>当重新调整HashMap大小的时候，确实存在条件竞争，因为如果两个线程都发现HashMap需要重新调整大小了，它们会同时试着调整大小。在调整大小的过程中，存储在链表中的元素的次序会反过来，因为移动到新的bucket位置的时候，HashMap并不会将元素放在链表的尾部，而是放在头部，这是为了避免尾部遍历(tail traversing)。如果条件竞争发生了，那么就死循环了。因此在并发环境下，我们使用CurrentHashMap来替代HashMap</p></blockquote><p>10.为什么String, Interger这样的wrapper类适合作为键？</p><blockquote><p>因为String是不可变的，也是final的，而且已经重写了equals()和hashCode()方法了。其他的wrapper类也有这个特点。不可变性是必要的，因为为了要计算hashCode()，就要防止键值改变，如果键值在放入时和获取时返回不同的hashcode的话，那么就不能从HashMap中找到你想要的对象。不可变性还有其他的优点如线程安全。如果你可以仅仅通过将某个field声明成final就能保证hashCode是不变的，那么请这么做吧。因为获取对象的时候要用到equals()和hashCode()方法，那么键对象正确的重写这两个方法是非常重要的。如果两个不相等的对象返回不同的hashcode的话，那么碰撞的几率就会小些，这样就能提高HashMap的性能</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      HashMap实现原理
    
    </summary>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/"/>
    
      <category term="HashMap" scheme="http://www.baiyp.ren/categories/%E6%BA%90%E7%A0%81/HashMap/"/>
    
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="HashMap" scheme="http://www.baiyp.ren/tags/HashMap/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾收集器</title>
    <link href="http://www.baiyp.ren/JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8.html"/>
    <id>http://www.baiyp.ren/JVM垃圾收集器.html</id>
    <published>2019-09-10T10:10:53.000Z</published>
    <updated>2019-09-15T04:54:37.921Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JVM垃圾收集器"><a href="#JVM垃圾收集器" class="headerlink" title="JVM垃圾收集器"></a>JVM垃圾收集器</h2><p><img src="../images/jvm/jvm21.jpg" alt></p><h3 id="常见的垃圾收集器"><a href="#常见的垃圾收集器" class="headerlink" title="常见的垃圾收集器"></a>常见的垃圾收集器</h3><p><img src="../images/jvm/jvm31.png" alt></p><h4 id="Serial收集器（复制算法"><a href="#Serial收集器（复制算法" class="headerlink" title="Serial收集器（复制算法)"></a>Serial收集器（复制算法)</h4><p>新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是client级别默认的GC方式，可以通过<code>-XX:+UseSerialGC</code>来强制指定。</p><h4 id="Serial-Old收集器-标记-整理算法"><a href="#Serial-Old收集器-标记-整理算法" class="headerlink" title="Serial Old收集器(标记-整理算法)"></a>Serial Old收集器(标记-整理算法)</h4><p>老年代单线程收集器，Serial收集器的老年代版本。</p><h4 id="ParNew收集器-停止-复制算法"><a href="#ParNew收集器-停止-复制算法" class="headerlink" title="ParNew收集器(停止-复制算法)　"></a>ParNew收集器(停止-复制算法)</h4><p>新生代收集器，可以认为是Serial收集器的多线程版本,在多核CPU环境下有着比Serial更好的表现。</p><h4 id="Parallel-Old-Scavenge收集器-停止-复制算法"><a href="#Parallel-Old-Scavenge收集器-停止-复制算法" class="headerlink" title="Parallel Old/Scavenge收集器(停止-复制算法)"></a>Parallel Old/Scavenge收集器(停止-复制算法)</h4><p>​ 关注吞吐量的垃圾收集器，高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>​ 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间），虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。</p><h4 id="CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）"><a href="#CMS-Concurrent-Mark-Sweep-收集器（标记-清理算法）" class="headerlink" title="CMS(Concurrent Mark Sweep)收集器（标记-清理算法）"></a>CMS(Concurrent Mark Sweep)收集器（标记-清理算法）</h4><p>​ 收集器是一种以获取最短回收停顿时间为目标的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统的服务端上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户带来较好的体验。CMS收集器就非常符合这类应用的需求。</p><p>-XX:+UseConcMarkSweepGC ，一般新生代使用ParNew，老年代的用CMS</p><p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，</p><h3 id="GC是什么时候触发的"><a href="#GC是什么时候触发的" class="headerlink" title="GC是什么时候触发的"></a>GC是什么时候触发的</h3><blockquote><p>由于对象进行了分代处理，因此垃圾回收区域、时间也不一样。GC有两种类型：Scavenge GC和Full GC。</p></blockquote><h4 id="Scavenge-GC"><a href="#Scavenge-GC" class="headerlink" title="Scavenge GC"></a>Scavenge GC</h4><p>​ 一般情况下，当新对象生成，并且在Eden申请空间失败时，就会触发Scavenge GC，对Eden区域进行GC，清除非存活对象，并且把尚且存活的对象移动到Survivor区。然后整理Survivor的两个区。这种方式的GC是对年轻代的Eden区进行，不会影响到年老代。因为大部分对象都是从Eden区开始的，同时Eden区不会分配的很大，所以Eden区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使Eden去能尽快空闲出来。</p><h4 id="Full-GC"><a href="#Full-GC" class="headerlink" title="Full GC"></a>Full GC</h4><p>​ 对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以比Scavenge GC要慢，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC：</p><ul><li><p>年老代（Tenured）被写满；</p></li><li><p>持久代（Perm）被写满；</p></li><li><p>System.gc()被显示调用；</p></li><li><p>上一次GC之后Heap的各域分配策略动态变化</p></li></ul><h3 id="垃圾回收过程"><a href="#垃圾回收过程" class="headerlink" title="垃圾回收过程"></a>垃圾回收过程</h3><h4 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h4><blockquote><p>整个过程分为4个步骤</p></blockquote><h5 id="初始标记"><a href="#初始标记" class="headerlink" title="初始标记"></a>初始标记</h5><p>​ 仅仅只是标记一下 GC Roots 能直接关联到的对象，速度很快，需要停顿（STW -Stop the world）。</p><h5 id="并发标记"><a href="#并发标记" class="headerlink" title="并发标记"></a>并发标记</h5><p>​ 从GC Root 开始对堆中对象进行可达性分析，找到存活对象，它在整个回收过程中耗时最长，不需要停顿。</p><h5 id="重新标记"><a href="#重新标记" class="headerlink" title="重新标记"></a>重新标记</h5><p>​ 为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要停顿(STW)。这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><h5 id="并发清除"><a href="#并发清除" class="headerlink" title="并发清除"></a>并发清除</h5><p>不需要停顿。</p><p><img src="../images/jvm/jvm32.png" alt></p><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><p>​ 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li><p><strong>CPU资源敏感</strong>：因为并发阶段多线程占据CPU资源，如果CPU资源不足，效率会明显降低。</p></li><li><p><strong>浮动垃圾：</strong>由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。</p><p>​ 由于浮动垃圾的存在，因此需要预留出一部分内存，意味着 CMS 收集不能像其它收集器那样等待老年代快满的时候再回收。</p><p>​ 在1.6的版本中老年代空间使用率阈值(92%)</p><p>​ 如果预留的内存不够存放浮动垃圾，就会出现 Concurrent Mode Failure，这时虚拟机将临时启用 Serial Old 来替代 CMS。</p></li><li><p><strong>会产生空间碎片：</strong>标记 - 清除算法会导致产生不连续的空间碎片</p></li></ul><h4 id="G1垃圾回收器"><a href="#G1垃圾回收器" class="headerlink" title="G1垃圾回收器"></a>G1垃圾回收器</h4><blockquote><p>G1中重要的参数：-XX:+UseG1GC 使用G1垃圾回收器</p></blockquote><h5 id="内部布局改变"><a href="#内部布局改变" class="headerlink" title="内部布局改变"></a>内部布局改变</h5><blockquote><p>G1 把堆划分成多个大小相等的独立区域（Region），新生代和老年代不再物理隔离。</p></blockquote><p><img src="../images/jvm/jvm33.png" alt></p><p><strong>算法</strong>：标记—整理 （humongous） 和复制回收算法(survivor)。</p><h5 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h5><h6 id="Young-GC"><a href="#Young-GC" class="headerlink" title="Young GC"></a>Young GC</h6><p>​ 选定所有年轻代里的Region。通过控制年轻代的region个数，即年轻代内存大小，来控制young GC的时间开销。（复制回收算法）</p><h6 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h6><p>​ 选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region。</p><p>​ Mixed GC不是full GC，它只能回收部分老年代的Region。如果mixed GC实在无法跟上程序分配内存的速度，导致老年代填满无法继续进行Mixed GC，就会使用serial old GC（full GC）来收集整个GC heap。所以我们可以知道，G1是不提供full GC的。</p><h6 id="全局并发标记（global-concurrent-marking）"><a href="#全局并发标记（global-concurrent-marking）" class="headerlink" title="全局并发标记（global concurrent marking）"></a>全局并发标记（global concurrent marking）</h6><ul><li><strong>初始标记：</strong>仅仅只是标记一下GC Roots 能直接关联到的对象，并且修改TAMS（Nest Top Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可以的Region中创建对象，此阶段需要停顿线程(STW)，但耗时很短。</li></ul><ul><li><strong>并发标记：</strong>从GC Root 开始对堆中对象进行可达性分析，找到存活对象，此阶段耗时较长，但可与用户程序并发执行。</li></ul><ul><li><strong>最终标记：</strong>为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程(STW)，但是可并行执行。</li></ul><ul><li><strong>筛选回收：</strong>首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。</li></ul><p><img src="../images/jvm/jvm34.png" alt></p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><h6 id="空间整合"><a href="#空间整合" class="headerlink" title="空间整合"></a>空间整合</h6><p>​ 不会产生内存碎片</p><p>​ 算法：标记—整理 （humongous） 和复制回收算法(survivor)。</p><h6 id="可预测的停顿"><a href="#可预测的停顿" class="headerlink" title="可预测的停顿"></a>可预测的停顿</h6><p>​ G1收集器之所以能建立可预测的停顿时间模型，是因为它可以有计划地避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region（这也就是Garbage-First名称的来由）。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集器在有限的时间内可以获取尽可能高的收集效率。</p><p>G1把内存“化整为零”的思路，理解起来似</p><h5 id="G1GC主要的参数"><a href="#G1GC主要的参数" class="headerlink" title="G1GC主要的参数"></a><strong>G1GC</strong>主要的参数</h5><table><thead><tr><th><strong>参数</strong></th><th><strong>含义</strong></th></tr></thead><tbody><tr><td>-XX:G1HeapRegionSize=n</td><td>设置Region大小，并非最终值</td></tr><tr><td>-XX:MaxGCPauseMillis</td><td>设置G1收集过程目标时间，默认值200ms，不是硬性条件</td></tr><tr><td>-XX:G1NewSizePercent</td><td>新生代最小值，默认值5%</td></tr><tr><td>-XX:G1MaxNewSizePercent</td><td>新生代最大值，默认值60%</td></tr><tr><td>-XX:ParallelGCThreads</td><td>STW期间，并行GC线程数</td></tr><tr><td>-XX:ConcGCThreads=n</td><td>并发标记阶段，并行执行的线程数</td></tr><tr><td>-XX:InitiatingHeapOccupancyPercent</td><td>设置触发标记周期的 Java 堆占用率阈值。默认值是45%。这里的java堆占比指的是non_young_capacity_bytes，包括old+humongous</td></tr></tbody></table><h3 id="Stop-The-World现象"><a href="#Stop-The-World现象" class="headerlink" title="Stop The World现象"></a>Stop The World现象</h3><blockquote><p>Java中Stop-The-World机制简称STW，是在执行垃圾收集算法时，Java应用程序的其他所有线程都被挂起（除了垃圾收集帮助器之外）。Java中一种全局暂停现象，全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互；这些现象多半是由于gc引起。</p></blockquote><p><img src="../images/jvm/jvm35.jpg" alt></p><p>​ JVM里有一条特殊的线程－－VM Threads，专门用来执行一些特殊的VM Operation，比如分派GC，thread dump等，这些任务，都需要整个Heap，以及所有线程的状态是静止的，一致的才能进行。所以JVM引入了安全点(Safe Point)的概念，想办法在需要进行VM Operation时，通知所有的线程进入一个静止的安全点。</p><p>​ GC收集器和我们GC调优的目标就是尽可能的减少STW的时间和次数。</p><p><img src="../images/jvm/jvm36.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM垃圾收集器
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="垃圾回收" scheme="http://www.baiyp.ren/categories/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="垃圾回收" scheme="http://www.baiyp.ren/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM垃圾回收机制</title>
    <link href="http://www.baiyp.ren/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6.html"/>
    <id>http://www.baiyp.ren/JVM垃圾回收机制.html</id>
    <published>2019-09-10T10:10:53.000Z</published>
    <updated>2019-09-15T04:53:30.007Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JVM垃圾回收机制"><a href="#JVM垃圾回收机制" class="headerlink" title="JVM垃圾回收机制"></a>JVM垃圾回收机制</h2><p><img src="../images/jvm/jvm21.jpg" alt></p><h3 id="哪些内存需要回收"><a href="#哪些内存需要回收" class="headerlink" title="哪些内存需要回收"></a>哪些内存需要回收</h3><p>​ 由于程序计数器、虚拟机栈、本地方法栈的生命周期都跟随线程的生命周期，当线程销毁了，内存也就回收了，所以这几个区域不用过多地考虑内存回收。由于堆和方法区的内存都是动态分配的，而且是线程共享的，所以内存回收主要关注这部分区域。</p><p>​ 垃圾收集器在对堆区和方法区进行回收前，首先要确定这些区域的对象哪些可以被回收，哪些暂时还不能回收，这就要用到判断对象是否存活的算法</p><h3 id="如何判断对象是否存活"><a href="#如何判断对象是否存活" class="headerlink" title="如何判断对象是否存活"></a>如何判断对象是否存活</h3><h4 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h4><p>​ 引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，就将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），但当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><ul><li><p><strong>优点</strong>：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。</p></li><li><p><strong>缺点</strong>：无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0</p></li></ul><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p><img src="../images/jvm/jvm22.jpg" alt></p><p>​ 可达性分析算法是从离散数学中的图论引入的，程序把所有的引用关系看作一张图，从一个节点GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点，无用的节点将会被判定为是可回收的对象。</p><p>在Java语言中，可作为GC Roots的对象包括下面几种：</p><ul><li>虚拟机栈中引用的对象（栈帧中的本地变量表）；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（Native方法）引用的对象。</li></ul><h3 id="各种引用（Reference）"><a href="#各种引用（Reference）" class="headerlink" title="各种引用（Reference）"></a>各种引用（Reference）</h3><blockquote><p>传统定义：Reference中存储的数据代表的是另一块内存的起始地址。</p></blockquote><p>​ 无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。在Java语言中，将引用又分为强引用、软引用、弱引用、虚引用4种，这四种引用强度依次逐渐减弱。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>​ 在程序代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。</p><h4 id="软引用-SoftReference"><a href="#软引用-SoftReference" class="headerlink" title="软引用(SoftReference)"></a>软引用(SoftReference)</h4><p>​ 用来描述一些还有用但并非必须的对象。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收后还没有足够的内存，才会抛出内存溢出异常。</p><p>​ 软引用非常适合于创建缓存。当系统内存不足的时候，缓存中的内容是可以被释放的，一些有用但是并非必需，用软引用关联的对象，系统将要发生OOM，这些对象就会被回收。</p><h4 id="弱引用-WeakReference"><a href="#弱引用-WeakReference" class="headerlink" title="弱引用(WeakReference)"></a>弱引用(WeakReference)</h4><p>​ 也是用来描述非必需对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。</p><h4 id="虚引用-PhantomReference"><a href="#虚引用-PhantomReference" class="headerlink" title="虚引用 (PhantomReference)"></a>虚引用 (PhantomReference)</h4><p>​ 也叫幽灵引用或幻影引用（名字真会取，很魔幻的样子），是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。它的作用是能在这个对象被收集器回收时收到一个系统通知。</p><h3 id="对象死亡前的最后一次挣扎"><a href="#对象死亡前的最后一次挣扎" class="headerlink" title="对象死亡前的最后一次挣扎"></a>对象死亡前的最后一次挣扎</h3><blockquote><p>即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程。</p></blockquote><h4 id="第一次标记"><a href="#第一次标记" class="headerlink" title="第一次标记"></a>第一次标记</h4><p>​ 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。</p><h4 id="第二次标记"><a href="#第二次标记" class="headerlink" title="第二次标记"></a>第二次标记</h4><p>​ 第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。在<code>finalize()</code>方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</p><p>第二次标记成功的对象将真的会被回收，如果对象在<code>finalize()</code>方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p><h4 id="请忘记-finalize"><a href="#请忘记-finalize" class="headerlink" title="请忘记 finalize"></a>请忘记 finalize</h4><p>finalize可以完成对象的拯救，但是JVM不保证一定能执行，所以请忘记这个“坑”。</p><h3 id="方法区如何判断是否需要回收"><a href="#方法区如何判断是否需要回收" class="headerlink" title="方法区如何判断是否需要回收"></a>方法区如何判断是否需要回收</h3><blockquote><p>方法区存储内容是否需要回收的判断可就不一样咯。方法区主要回收的内容有：废弃常量和无用的类。对于废弃常量也可通过引用的可达性来判断，但是对于无用的类则需要同时满足下面3个条件：</p></blockquote><ul><li>该类所有的实例都已经被回收，也就是Java堆中不存在该类的任何实例；</li><li>加载该类的<code>ClassLoader</code>已经被回收；</li><li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h3 id="常用的垃圾收集算法"><a href="#常用的垃圾收集算法" class="headerlink" title="常用的垃圾收集算法"></a>常用的垃圾收集算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p><img src="../images/jvm/jvm23.png" alt></p><p>​ <strong>标记-清除算</strong>法采用从根集合（GC Roots）进行扫描，对存活的对象进行标记，标记完毕后，再扫描整个空间中未被标记的对象，进行回收，如下图所示。标记-清除算法不需要进行对象的移动，只需对不存活的对象进行处理，在存活对象比较多的情况下极为高效，但由于标记-清除算法直接回收不存活的对象，因此会造成内存碎片。</p><p><img src="../images/jvm/jvm24.jpg" alt></p><h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><img src="../images/jvm/jvm25.png" style="zoom:60%"><p>​ <strong>复制算法</strong>的提出是为了克服句柄的开销和解决内存碎片的问题。它开始时把堆分成 一个对象 面和多个空闲面， 程序从对象面为对象分配空间，当对象满了，基于copying算法的垃圾 收集就从根集合（GC Roots）中扫描活动对象，并将每个 活动对象复制到空闲面(使得活动对象所占的内存之间没有空闲洞)，这样空闲面变成了对象面，原来的对象面变成了空闲面，程序会在新的对象面中分配内存。</p><p><img src="../images/jvm/jvm26.jpg" alt></p><h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><img src="../images/jvm/jvm27.jpg" style="zoom:60%"><p>​ <strong>标记-整理算</strong>法采用标记-清除算法一样的方式进行对象的标记，但在清除时不同，在回收不存活的对象占用的空间后，会将所有的存活对象往左端空闲空间移动，并更新对应的指针。标记-整理算法是在标记-清除算法的基础上，又进行了对象的移动，因此成本更高，但是却解决了内存碎片的问题。具体流程见下图：</p><p><img src="../images/jvm/jvm28.jpg" alt></p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>​ 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），在堆区之外还有一个代就是永久代（Permanet Generation）。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。</p><p><img src="../images/jvm/jvm30.jpg" alt></p><h5 id="年轻代（Young-Generation）的回收算法"><a href="#年轻代（Young-Generation）的回收算法" class="headerlink" title="年轻代（Young Generation）的回收算法"></a>年轻代（Young Generation）的回收算法</h5><ul><li><p>所有新生成的对象首先都是放在年轻代的。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象。</p></li><li><p>新生代内存按照8:1:1的比例分为一个eden区和两个survivor(survivor0,survivor1)区。一个Eden区，两个 Survivor区(一般而言)。大部分对象在Eden区中生成。回收时先将eden区存活对象复制到一个survivor0区，然后清空eden区，当这个survivor0区也存放满了时，则将eden区和survivor0区存活对象复制到另一个survivor1区，然后清空eden和这个survivor0区，此时survivor0区是空的，然后将survivor0区和survivor1区交换，即保持survivor1区为空， 如此往复。</p></li><li><p>当survivor1区不足以存放 eden和survivor0的存活对象时，就将存活对象直接存放到老年代。若是老年代也满了就会触发一次Full GC，也就是新生代、老年代都进行回收。</p></li><li><p>新生代发生的GC也叫做Minor GC，MinorGC发生频率比较高(不一定等Eden区满了才触发)。</p></li></ul><h4 id="老年代（Old-Generation）的回收算法"><a href="#老年代（Old-Generation）的回收算法" class="headerlink" title="老年代（Old Generation）的回收算法"></a>老年代（Old Generation）的回收算法</h4><ul><li><p>在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p></li><li><p>内存比新生代也大很多(大概比例是1:2)，当老年代内存满时触发Major GC即Full GC，Full GC发生频率比较低，老年代对象存活时间比较长，存活率标记高</p></li></ul><h4 id="持久代（Permanent-Generation）的回收算法"><a href="#持久代（Permanent-Generation）的回收算法" class="headerlink" title="持久代（Permanent Generation）的回收算法"></a>持久代（Permanent Generation）的回收算法</h4><p>​  用于存放静态文件，如Java类、方法等。持久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持久代空间来存放这些运行过程中新增的类。持久代也称方法区。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM垃圾回收机制
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="垃圾回收" scheme="http://www.baiyp.ren/categories/jvm/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="垃圾回收" scheme="http://www.baiyp.ren/tags/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/"/>
    
  </entry>
  
  <entry>
    <title>JVM对象分配</title>
    <link href="http://www.baiyp.ren/JVM%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D.html"/>
    <id>http://www.baiyp.ren/JVM对象分配.html</id>
    <published>2019-09-10T06:10:53.000Z</published>
    <updated>2019-09-15T03:16:18.072Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JVM对象分配"><a href="#JVM对象分配" class="headerlink" title="JVM对象分配"></a>JVM对象分配</h2><p><img src="../images/jvm/jvm14.png" alt></p><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><blockquote><p>这里的对象限于普通Java对象，不包括数组和Class对象。</p><p>虚拟机遇到一条new指令时：根据new的参数是否能在常量池中定位到一个类的符号引用,如果没有，说明还未定义该类，抛出ClassNotFoundException；</p></blockquote><p><img src="../images/jvm/jvm15.png" alt></p><p>​</p><h4 id="检查加载"><a href="#检查加载" class="headerlink" title="检查加载"></a>检查加载</h4><p>​ 虚拟机遇到一条new指令时，首先检查指令的参数能否在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，必须先执行相应的类加载过程。</p><h4 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h4><blockquote><p>对象所需要的内存在类加载完成后可以被完全确定，所以只需要把一块确定大小的内存区域从堆中划分出来给这个对象即可。</p></blockquote><h5 id="指针碰撞（Bump-the-Pointer）"><a href="#指针碰撞（Bump-the-Pointer）" class="headerlink" title="指针碰撞（Bump the Pointer）"></a>指针碰撞（Bump the Pointer）</h5><blockquote><p>java堆内存空间规整的情况下使用</p></blockquote><p>​ 如果堆的内存是规整的，所有使用的内存在一边，未使用的内存在另一边，中间是一个作为分界点的指针，那分配空间只需要移动作为分界点的指针（移动距离等于该对象需要的空间）。</p><h5 id="空闲列表（Free-List）"><a href="#空闲列表（Free-List）" class="headerlink" title="空闲列表（Free List）"></a>空闲列表（Free List）</h5><blockquote><p>java堆空间不规整的情况下使用</p></blockquote><p>​ 如果堆的内存是不规整的，那么虚拟机需要维护一个列表，记录那些内存块是可用的，在分配的时候划分一个足够大的内存块给该对象，并且更新列表的记录。Java堆内存是否规整取决于所采用的垃圾收集器是否带有压缩整理的功能。</p><h4 id="并发安全"><a href="#并发安全" class="headerlink" title="并发安全"></a>并发安全</h4><p>​ 除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。</p><h5 id="CAS机制"><a href="#CAS机制" class="headerlink" title="CAS机制"></a>CAS机制</h5><p>​ 对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性。</p><h5 id="分配缓冲"><a href="#分配缓冲" class="headerlink" title="分配缓冲"></a>分配缓冲</h5><p>​ 另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块私有内存，也就是本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），如果设置了虚拟机参数 -XX:+UseTLAB，在线程初始化时，同时也会申请一块指定大小的内存，只给当前线程使用，这样每个线程都单独拥有一个Buffer，如果需要分配内存，就在自己的Buffer上分配，这样就不存在竞争的情况，可以大大提升分配效率，当Buffer容量不够的时候，再重新从Eden区域申请一块继续使用。</p><p>​ TLAB的目的是在为新对象分配内存空间时，让每个Java应用线程能在使用自己专属的分配指针来分配空间（Eden区，默认Eden的1%），减少同步开销。</p><p>​ TLAB只是让每个线程有私有的分配指针，但底下存对象的内存空间还是给所有线程访问的，只是其它线程无法在这个区域分配而已。当一个TLAB用满（分配指针top撞上分配极限end了），就新申请一个TLAB。</p><p>分配内存后，虚拟机设置对象的一些必要信息，这些信息存在在对象的对象头中。一般来说，执行new指令后，会接着执行<init>方法，将对象初始化。这样一个真正可用的对象才算完全产生出来。</init></p><p>​ 编译器为每个类生成至少一个实例初始化方法，即<init>()方法。此方法与源程序里的每个<strong>构造方法</strong>对应。如果类没有声明构造方法，则生成一个默认构造方法，该方法仅调用父类的默认构造方法，同时生成与该默认构造方法对应的<init>()方法。<init>()方法内容大概为</init></init></init></p><ul><li>调用另一个<init>()方法（本类的另外一个<init>()方法或父类的<init>()方法）;</init></init></init></li><li>初始化实例变量;</li><li>与其对应的构造方法内的字节码</li></ul><h4 id="内存空间初始化"><a href="#内存空间初始化" class="headerlink" title="内存空间初始化"></a>内存空间初始化</h4><p>​ （<strong>注意不是构造方法</strong>）内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值(如int值为0，boolean值为false等等)。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><h4 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h4><p>​ 接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。</p><h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>​ 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始，所有的字段都还为零值。所以，一般来说，执行new指令之后会接着把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><blockquote><p>对象在内存中的布局可以分为3块区域：</p><ul><li>对象头（header);</li><li>实例数据(Instance Data);</li><li>对齐填充(Padding);</li></ul></blockquote><p><img src="../images/jvm/jvm16.png" alt></p><h4 id="对象头（header"><a href="#对象头（header" class="headerlink" title="对象头（header)"></a>对象头（header)</h4><blockquote><p>对象头包括两部分信息</p></blockquote><ul><li>第一部分用于存储对象自身的运行时数据。如哈希码，GC分代年龄，锁状态标志，线程持有的锁，偏向线程id，偏向时间戳等。考虑到虚拟机的空间效率，此部分在32位和64位虚拟机中只占32位或者64位的大小。</li><li>第二部分是类型指针。即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。（并不是所有的虚拟机实现都保留类型指针，查找对象 的元数据信息不一定要通过对象本身）</li></ul><p><strong>如果该对象是数组，那么对象头还会保留一块数据，用于记录数组长度。</strong></p><h4 id="实例数据-Instance-Data"><a href="#实例数据-Instance-Data" class="headerlink" title="实例数据(Instance Data)"></a>实例数据(Instance Data)</h4><p>​ 实例数据是对象真正存储的有效信息，也是在代码中定义的各种类型的字段内容。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。Hotspot虚拟机默认策略是longs/doubles，ints，shorts/chars，bytes/booleans，oops（Ordinary Object Pointers），相同宽度的字段总是分配到一起。在这个去前提下，父类中定义的变量会出现在子类之前。</p><h4 id="对齐填充-Padding"><a href="#对齐填充-Padding" class="headerlink" title="对齐填充(Padding)"></a>对齐填充(Padding)</h4><p>​ 对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对对象的大小必须是8字节的整数倍。对象正好是9字节的整数，所以当对象其他数据部分（对象实例数据）没有对齐时，就需要通过对齐填充来补全。</p><h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>​ Java程序通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机中的规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机的实现而定的。目前主流的访问方式有试用句柄和直接指针两种：</p><h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><blockquote><p>句柄是一种特殊的<a href="https://baike.baidu.com/item/智能指针/10784135" rel="external nofollow noopener noreferrer" target="_blank">智能指针</a> 。句柄与普通指针的区别在于，指针包含的是引用对象的内存地址，而句柄则是由系统所管理的引用标识，该标识可以被系统重新定位到一个内存地址上。</p></blockquote><p><img src="../images/jvm/jvm17.jpg" alt></p><p>​ Java堆划分出一块内存作为句柄池，reference中存储的就是对象的句柄地址，句柄中包含了对象实例数据与类型数据各自的具体地址信息</p><h4 id="直接指针访问"><a href="#直接指针访问" class="headerlink" title="直接指针访问"></a>直接指针访问</h4><blockquote><p>如果使用直接指针访问， reference中存储的直接就是对象地址。</p></blockquote><p><img src="../images/jvm/jvm18.jpg" alt></p><p>​ 这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。</p><p>使 用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><p>​ 对Sun HotSpot而言，它是使用直接指针访问方式进行对象访问的。</p><h3 id="堆内存分配策略"><a href="#堆内存分配策略" class="headerlink" title="堆内存分配策略"></a>堆内存分配策略</h3><blockquote><p>HotSpot JVM把年轻代分为了三部分：1个Eden区和2个Survivor区（分别叫from（S1）和to（S2））</p></blockquote><p><img src="../images/jvm/jvm19.png" alt></p><p>​ Eden和Survival的默认分配比例为<strong>8：1</strong>。一般情况下，新创建的对象都会被分配到Eden区(一些大对象特殊处理，后面会说到)，这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。对象在Survivor区中每熬过一次Minor GC，年龄就会增加1岁，当它的年龄增加到一定程度时，就会被移动到年老代中。</p><p>​ 因为年轻代中的对象基本都是朝生夕死的(80%以上)，所以在年轻代的垃圾回收算法使用的是复制算法，复制算法的基本思想就是将内存分为两块，每次只用其中一块，当这一块内存用完，就将还活着的对象复制到另外一块上面。复制算法不会产生内存碎片。</p><p>​ 在GC开始的时候，对象只会存在于Eden区和名为“From”的Survivor区，Survivor区“To”是空的。紧接着进行GC，Eden区中所有存活的对象都会被复制到“To”，而在“From”区中，仍存活的对象会根据他们的年龄值来决定去向。年龄达到一定值(年龄阈值，可以通过-XX:MaxTenuringThreshold来设置)的对象会被移动到年老代中，没有达到阈值的对象会被复制到“To”区域。经过这次GC后，Eden区和From区已经被清空。这个时候，“From”和“To”会交换他们的角色，也就是新的“To”就是上次GC前的“From”，新的“From”就是上次GC前的“To”。不管怎样，都会保证名为To的Survivor区域是空的。Minor GC会一直重复这样的过程，直到“To”区被填满，“To”区被填满之后，会将所有对象移动到年老代中。</p><p>​ 在年轻代中经历了N次垃圾回收后仍然存活的对象，就会被放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象。</p><p>​ 永久代主要用于存放静态文件，Java类、方法等。永久代对垃圾回收没有显著影响，但是有些应用可能动态生成或者调用一些class，例如Hibernate 等，在这种时候需要设置一个比较大的持永久代空间来存放这些运行过程中新增的类。永久代大小通过-XX: MaxPermSize =<n>进行设置。</n></p><h4 id="优先使用Eden区域"><a href="#优先使用Eden区域" class="headerlink" title="优先使用Eden区域"></a>优先使用Eden区域</h4><p>​ 大多数新生代对象都在Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。</p><h4 id="大对象直接放入老年代"><a href="#大对象直接放入老年代" class="headerlink" title="大对象直接放入老年代"></a>大对象直接放入老年代</h4><p>​ 大对象是指需要大量内存空间的Java对象，最典型的大对象就是那种很长的字符串和数组（byte[ ]就是典型的大对象）。出现大对象很容易导致内存还有不少空间就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p><p>​ 虚拟机提供了一个-XX: PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存）。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>​ Java虚拟机采用分代收集的思想来管理虚拟机内存。虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并且经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄增加到一定程度（默认15岁），就会被晋升到老年代。对晋升到老年代的对象的阈值可以通过-XX:MaxTenuringThreshold设置。</p><h4 id="动态判断对象年龄"><a href="#动态判断对象年龄" class="headerlink" title="动态判断对象年龄"></a>动态判断对象年龄</h4><p>​ 虚拟并不是永远都要求对象年龄必须达到MaxTenuringThreshold才能晋升为老年代的，如果在Survivor的空间相同年龄的所有对象大小总和大于Survivor空间的一半时，年龄大于或者等于该年龄的对象直接进入老年代，无需要等到MaxTenuringThreshold中要求的年龄。</p><h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p><img src="../images/jvm/jvm20.png" alt></p><p>​ 在发生Minor GC之前，虚拟机会先检查老年代可用的连续空间是否大于所有新生代的总空间，如果大于的话，那么这个GC就可以保证安全，如果不成立的，那么可能会造成晋升老年代的时候内存不足。在这样的情况下，虚拟机会先检查HandlePromotionFailure设置值是否允许担保失败，如果是允许的，那么说明虚拟机允许这样的风险存在并坚持运行，然后检查老年代的最大连续可用空间是否大于历次晋升老年代对象的平均大小，如果大于的话，就执行Minor GC,如果小于，或者HandlePromotionFailure设置不允许冒险，那么就会先进行一次Full GC将老年代的内存清理出来，然后再判断。</p><p>​ 上面提到的风险，是由于新生代因为存活对象采用复制算法，但为了内存利用率，只使用其中的一个Survivor空间，将存活的对象备份到Survivor空间上，一旦出现大量对象在一次Minor GC以后依然存活（最坏的计划就是没有发现有对象死亡需要清理），那么就需要老年代来分担一部分内存，把在Survivor上分配不下的对象直接进入老年代，因为我们不知道实际上具体需要多大内存，我们只能估算一个合理值，这个值采用的方法就是计算出每次晋升老年代的平均内存大小作为参考，如果需要的话，那就提前进行一次Full GC.</p><p>​ 取平均值在大多数情况下是可行的，但是因为内存分配的不确定性太多，保不定哪次运行突然出现某些大对象或者Minor GC以后多数对象依然存活，导致内存远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure）。如果出现了HandlePromotionFailure失败，那就只好在失败后重新发起一次Full GC。这样的情况下，担保失败是要付出代价的，大部分情况下都还是会将HandlePromotionFailure开关打开，毕竟失败的几率比较小，这样的担保可以避免Full GC过于频繁，垃圾收集器频繁的启动肯定是不好的。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM对象分配
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="对象分配" scheme="http://www.baiyp.ren/categories/jvm/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="对象分配" scheme="http://www.baiyp.ren/tags/%E5%AF%B9%E8%B1%A1%E5%88%86%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM整体介绍</title>
    <link href="http://www.baiyp.ren/JVM%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D.html"/>
    <id>http://www.baiyp.ren/JVM整体介绍.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T14:17:20.473Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:26 GMT+0800 (GMT+08:00) --><h2 id="JVM整体介绍"><a href="#JVM整体介绍" class="headerlink" title="JVM整体介绍"></a>JVM整体介绍</h2><h3 id="JAVA技术体系结构"><a href="#JAVA技术体系结构" class="headerlink" title="JAVA技术体系结构"></a>JAVA技术体系结构</h3><blockquote><p>Java虚拟机（Java Virtual Machine 简称 JVM）是<strong>运行所有Java程序</strong>的抽象计算机，是Java语言的运行环境，它是Java 最具吸引力的特性之一。</p></blockquote><p><img src="../images/jvm/jvm01.png" alt></p><p>Java虚拟机是整个Java技术体系最重要的基础。</p><h3 id="为什么要了解虚拟机"><a href="#为什么要了解虚拟机" class="headerlink" title="为什么要了解虚拟机"></a>为什么要了解虚拟机</h3><ul><li><p>首先，Java 虚拟机提供了许多配置参数，用于满足不同应用场景下，对程序性能的需求。学习Java 虚拟机，你可以针对自己的应用，最优化匹配运行参数。</p></li><li><p>其次，Java 虚拟机本身是一种工程产品，在实现过程中自然存在不少局限性。学习 Java 虚拟机，可以更好地规避它在使用中的 Bug，也可以更快地识别出 Java 虚拟机中的错误</p></li><li><p>再次，Java 虚拟机拥有当前最前沿、最成熟的垃圾回收算法实现，以及即时编译器实现。学习Java 虚拟机，我们可以了解背后的设计决策，今后再遇到其他代码托管技术也能触类旁通。</p></li><li><p>最后，Java 虚拟机发展到了今天，已经脱离 Java 语言，形成了一套相对独立的、高性能的执行方案。除了 Java 外，Scala、Clojure、Groovy，以及时下热门的 Kotlin，这些语言都可以运行在 Java 虚拟机之上。学习 Java 虚拟机，便可以了解这些语言的通用机制，甚至于让这些语言共享生态系统。</p></li></ul><h3 id="未来的Java技术"><a href="#未来的Java技术" class="headerlink" title="未来的Java技术"></a>未来的Java技术</h3><ul><li><p><strong>模块化</strong>:OSGI（动态化、模块化），应用层面就是微服务，互联网的发展方向</p></li><li><p><strong>混合语言</strong>：多个语言都可以运行在JVM中，google的Kotlin 成为了 Android 的官方语言。Scala(Kafka)</p></li><li><p><strong>多核并行</strong>：CPU从高频次转变为多核心，多核时代。JDK1.7引入了Fork/Join，JDK1.8提出lambda表达式(函数式编程天生适合并行运行)</p></li><li><p><strong>丰富语法：</strong>JDK5提出自动装箱、泛型(并发编程讲到)、动态注解等语法。JDK7二进制原生支持。try-catch-finally 至try-with-resource</p></li><li><p><strong>64**</strong>位：**虽然同样的程序64位内存消耗比32位要多一点，但是支持内存大，所以虚拟机都会完全过渡到64位，32位的JVM有4G的堆大小限制。</p></li><li><p><strong>更强的垃圾回收器（现在主流CMS、G1）：</strong>JDK11 –ZGC（暂停时间不超过10毫秒，且不会随着堆的增加而增加，TB级别的堆回收））：有色指针、加载屏障。JDK12支持并发类卸载，进一步缩短暂停时间 JDK13(计划于2019年9月)将最大堆大小从4TB增加到16TB</p></li></ul><h3 id="JVM的整体介绍"><a href="#JVM的整体介绍" class="headerlink" title="JVM的整体介绍"></a>JVM的整体介绍</h3><p><img src="../images/jvm/jvm02.jpg" alt></p><h4 id="JVM是如何工作的"><a href="#JVM是如何工作的" class="headerlink" title="JVM是如何工作的"></a>JVM是如何工作的</h4><blockquote><p>JVM分成3个主要的子系统</p><ul><li><p>类加载器子系统</p></li><li><p>运行时数据区</p></li><li><p>执行引擎</p></li></ul></blockquote><h5 id="类加载器子系统"><a href="#类加载器子系统" class="headerlink" title="类加载器子系统"></a>类加载器子系统</h5><blockquote><p>Java的动态类加载功能是通过类加载子系统去处理的。</p><p>它并不是在编译时候，而是在首次运行时加载引用类时、连接并初始化类文件。</p></blockquote><h6 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h6><blockquote><p>类通过该组件加载。通过引导类加载器，扩展类加载器，应用类加载器这三个类加载器帮助完成加载。</p></blockquote><ol><li><p><strong>引导类加载器</strong></p><p>负责从引导类路径去加载类，除了rt.jar之外，没其他别的jar。给予该加载器最高的优先级。</p></li><li><p><strong>扩展类加载器</strong></p><p>负责加载ext目录（jre\lib）的类</p></li><li><p><strong>应用加载器</strong></p><p>负责加载类路径中应用级别的类，path提到的环境变量，等等。</p></li></ol><p>以上的类加载器在加载类文件的时候遵循委托层次算法。</p><h6 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h6><ol><li><strong>验证</strong>-字节码验证器验证生成的字节码是否正确，如果验证失败，我们将收到验证的错误信息。</li><li><strong>准备</strong>-为所有的静态变量分配内存和默认值</li><li><strong>解析</strong>-用方法区的原始引用代替所有符号内存引用。</li></ol><h6 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h6><blockquote><p>这是类加载的最后一个阶段，此时所有的静态变量都用原始值去赋值，并且将运行静态代码块。</p></blockquote><h5 id="运行时数据区"><a href="#运行时数据区" class="headerlink" title="运行时数据区"></a>运行时数据区</h5><blockquote><p>运行时数据区域分成5个主要的组件</p></blockquote><h6 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h6><blockquote><p>所有类级的数据都存储在这里，包括静态变量。</p><p>每个JVM只有一个方法区，它是一个共享资源。</p></blockquote><h6 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h6><blockquote><p>所有的对象和对应的实例变量以及数组都存储在这里。</p><p>每个JVM只有一个堆区，由于方法区和堆区为多个线程共享内存，所以存储的数据不是线程安全的。</p></blockquote><h6 id="栈区"><a href="#栈区" class="headerlink" title="栈区"></a>栈区</h6><blockquote><p>为每个线程，创建一个单独的运行时栈。为每个方法调用，在栈内存创建一个条目，称之为栈帧。所有本地变量都会在栈内存中创建。由于它不是共享的资源，所有是线程安全的。</p><p>栈帧被分成3子实体</p></blockquote><ol><li>本地变量数组-涉及跟方法有关的本地变量和对应的值都存储在这里。</li><li>操作数栈-如果需要执行中间操作，操作数堆栈作为运行时工作区来执行操作。</li><li>帧数据-所有和对应方法的标记都存储在里面。在发生异常的情况下，捕捉块信息在这里维护。</li></ol><h6 id="程序计数器寄存器"><a href="#程序计数器寄存器" class="headerlink" title="程序计数器寄存器"></a>程序计数器寄存器</h6><blockquote><p>每个线程都有自己的程序计数器寄存器，持有当前执行指令的地址，一旦当前指令执行被运行，下一个指令将会更新到程序计数器寄存器。</p></blockquote><h5 id="执行引擎"><a href="#执行引擎" class="headerlink" title="执行引擎"></a>执行引擎</h5><blockquote><p>字节码被分配到执行引擎执行的运行时数据区。执行引擎一块一块的读取字节码并执行。</p></blockquote><h6 id="解释器"><a href="#解释器" class="headerlink" title="解释器"></a>解释器</h6><blockquote><p>解释器解释字节码很快，但是执行的很慢。解释器的缺点是当一个方法被调用多次，每次都需要一个新的解释。</p></blockquote><h6 id="JIT编译器"><a href="#JIT编译器" class="headerlink" title="JIT编译器"></a>JIT编译器</h6><blockquote><p>JIT弥补了解释器的缺点。执行引擎将利用解释器转换字节码，但是当他找到重复的编码，它就使用编译器。编译器编译全部的字节码并变成本地代码</p><p>这些本地码将直接被方法调用重复地使用，这就改善了系统的性能。</p></blockquote><ol><li><strong>中间代码生成器</strong>-生成中间代码。</li><li><strong>代码优化器</strong>-负责优化上面生成的代码</li><li><strong>目标代码生成器</strong>-负责生成机器码或者本地代码</li><li><strong>分析器</strong>-一个特殊的组件，负责寻找hotspots,即是否方法被调用多次。</li></ol><h6 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h6><blockquote><p>收集和清除未被引用的对象，可以通过System.gc()触发垃圾回收，但是不保证一定执行。创建收集对象的JVM垃圾收集。</p></blockquote><p><strong>Java Native Interface (JNI)：</strong>JNI和本地方法库互动，特供本地库所需的执行引擎。</p><p><strong>Native Method Libraries:</strong> 这是执行引擎所需的本地方法的一个集合</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM整体介绍
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="内存结构" scheme="http://www.baiyp.ren/categories/jvm/%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="整体介绍" scheme="http://www.baiyp.ren/tags/%E6%95%B4%E4%BD%93%E4%BB%8B%E7%BB%8D/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区-线程私有</title>
    <link href="http://www.baiyp.ren/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89.html"/>
    <id>http://www.baiyp.ren/JVM运行时数据区-线程私有.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T14:17:13.110Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JVM运行时数据区-线程私有"><a href="#JVM运行时数据区-线程私有" class="headerlink" title="JVM运行时数据区-线程私有"></a>JVM运行时数据区-线程私有</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="什么是运行时数据区"><a href="#什么是运行时数据区" class="headerlink" title="什么是运行时数据区"></a>什么是运行时数据区</h3><blockquote><p>JVM在运行过程中会把它所管理的内存划分成若干不同的数据区域！</p><p>这个是抽象概念，内部实现依赖寄存器、高速缓存、主内存（具体要分析JVM源码 C++语言实现，没必要看）</p><p>计算机的运行=指令+数据，指令用于执行方法的，数据用于存放数据和对象的。</p></blockquote><p>​ Java虚拟机在执行Java程序的过程中会把它管理的内存分为若干个不同的数据区域。这些区域有着各自的用途，一级创建和销毁的时间，有的区域随着虚拟机进程的启动而存在，有些区域则依赖用户线程的启动和结束而建立和销毁。根据《Java虚拟机规范》中规定，jvm所管理的内存大致包括以下几个运行时数据区域。</p><ul><li><strong>线程私有</strong>:程序计数器、虚拟机栈、本地方法栈</li><li><strong>线程共享</strong>：堆、方法区</li></ul><p><img src="../images/jvm/jvm04.png" alt></p><p>与线程之间的关系：</p><table><thead><tr><th>区域</th><th>是否线程共享</th><th>是否会内存溢出</th></tr></thead><tbody><tr><td>程序计数器</td><td>否</td><td>不会</td></tr><tr><td>虚拟机栈</td><td>否</td><td>会</td></tr><tr><td>本地方法栈</td><td>否</td><td>会</td></tr><tr><td>堆</td><td>是</td><td>会</td></tr><tr><td>方法区</td><td>是</td><td>会</td></tr></tbody></table><h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><blockquote><p>程序计数器是一块较小的内存空间，它的作用可以看作是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。</p></blockquote><h4 id="特-点"><a href="#特-点" class="headerlink" title="特 点"></a>特 点</h4><ul><li><p>如果线程正在执行的是Java 方法，则这个计数器记录的是正在执行的虚拟机字节码指令地址</p></li><li><p>如果正在执行的是Native 方法，则这个技术器值为空（Undefined）</p></li><li><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</p></li></ul><h4 id="为什么需要程序计数器"><a href="#为什么需要程序计数器" class="headerlink" title="为什么需要程序计数器"></a>为什么需要程序计数器</h4><ul><li><p>Java是多线程的，意味着线程切换</p></li><li><p>确保多线程情况下的程序正常执行</p></li></ul><h4 id="存储那些内容"><a href="#存储那些内容" class="headerlink" title="存储那些内容"></a>存储那些内容</h4><p>看一个代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line">        <span class="keyword">int</span> b = <span class="number">200</span>;</span><br><span class="line">        <span class="keyword">int</span> c = <span class="number">300</span>;</span><br><span class="line">        <span class="keyword">return</span> (a + b) * c;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这是一段非常简单的计算代码，我们先编译成Class 文件再使用 javap 反汇编工具看下class 文件中数据格式，如下图</p><img src="../images/jvm/jvm05.jpg" style="zoom:50%"><p>当执行到方法<strong>test()</strong>时在当前的线程中会创建相应的程序计数器，在计数器中为存放执行地址 （红框中的）0 2 3…等等。</p><p>这也说明在我们程序运行过程中计数器中改变的只是值，而不会随着程序的运行需要更大的空间，也就不会发生溢出情况。</p><h3 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h3><h4 id="什么是虚拟机栈"><a href="#什么是虚拟机栈" class="headerlink" title="什么是虚拟机栈"></a>什么是虚拟机栈</h4><blockquote><p>虚拟机栈是用于描述java方法执行的内存模型。</p></blockquote><p>​ 每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“<strong>局部变量表、操作数栈、动态链接、方法出口</strong>”几个部分。我们常说的“堆内存、栈内存”中的“栈内存”指的便是虚拟机栈，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。</p><p>方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：</p><img src="../images/jvm/jvm06.png" style="zoom:75%"><h4 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h4><blockquote><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。</p></blockquote><img src="../images/jvm/jvm07.png" style="zoom:75%"><h5 id="栈帧中的元素"><a href="#栈帧中的元素" class="headerlink" title="栈帧中的元素"></a>栈帧中的元素</h5><h6 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h6><p>​ 局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需要分配的局部变量表的最大容量。</p><img src="../images/jvm/jvm08.jpg" style="zoom:50%"><h6 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h6><p>​ 操作数栈（Operand Stack）也常称为操作栈，它是一个后入先出（Last In First Out，LIFO）栈。同局部变量表一样，操作数栈的最大深度也在编译的时候写入到Code属性的max_stacks数据项中。</p><blockquote><p>操作数是运算符作用于的实体，是表达式中的一个组成部分，它规定了指令中进行数字运算的量 。<br>表达式是操作数与操作符的组合。</p></blockquote><h6 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h6><p>​ 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。Class文文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数。这些符号引用一部分会在类加载阶段或者第一次使用的时候就转化为直接引用，这种转化称为静态解析。另外一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p><h6 id="返回地址"><a href="#返回地址" class="headerlink" title="返回地址"></a>返回地址</h6><p>​ 无论采用何种退出方式，在方法退出之后，都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的PC计数器的值可以作为返回地址，栈帧中很可能会保存这计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p><blockquote><p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p></blockquote><p>​ 虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧之中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。</p><h4 id="虚拟机栈的特点"><a href="#虚拟机栈的特点" class="headerlink" title="虚拟机栈的特点"></a>虚拟机栈的特点</h4><ul><li>虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。</li><li>栈的大小缺省为1M，可用参数 –Xss调整大小，例如-Xss256k</li><li>在编译程序代码的时候，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</li></ul><h4 id="虚拟机栈的StackOverflowError"><a href="#虚拟机栈的StackOverflowError" class="headerlink" title="虚拟机栈的StackOverflowError"></a>虚拟机栈的StackOverflowError</h4><p>若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。</p><p>JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用。</p><h4 id="虚拟机栈的OutOfMemoryError"><a href="#虚拟机栈的OutOfMemoryError" class="headerlink" title="虚拟机栈的OutOfMemoryError"></a>虚拟机栈的OutOfMemoryError</h4><p>​ 不同于StackOverflowError，OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。</p><p>JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常。</p><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>​ 本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。</p><p>不同的是，本地方法栈服务的对象是JVM执行的<strong>native</strong>方法，而虚拟机栈服务的是JVM执行的java方法。如何去服务native方法？native方法使用什么语言实现？怎么组织像栈帧这种为了服务方法的数据结构？虚拟机规范并未给出强制规定，因此不同的虚拟机实可以进行自由实现，我们常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM运行时数据区-线程私有
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
      <category term="线程私有" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>JVM运行时数据区-线程私有</title>
    <link href="http://www.baiyp.ren/JVM%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA-%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB.html"/>
    <id>http://www.baiyp.ren/JVM运行时数据区-线程共享.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T14:17:05.305Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JVM运行时数据区-线程共享"><a href="#JVM运行时数据区-线程共享" class="headerlink" title="JVM运行时数据区-线程共享"></a>JVM运行时数据区-线程共享</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="方法区-永久代"><a href="#方法区-永久代" class="headerlink" title="方法区(永久代)"></a>方法区(永久代)</h3><blockquote><p>方法区在JVM中也是一个非常重要的区域，它与堆一样，是被线程共享的区域。在方法区中，存储了每个类的信息（包括类的名称、方法信息、字段信息）、静态变量、常量以及编译器编译后的代码等。</p><p><strong>方法区（method area）</strong>只是<strong>JVM规范</strong>中定义的一个概念，用于存储类信息、常量池、静态变量、JIT编译后的代码等数据，具体放在哪里，不同的实现可以放在不同的地方。而<strong>永久代</strong>是<strong>Hotspot</strong>虚拟机特有的概念，是方法区的一种实现，别的JVM都没有这个东西</p></blockquote><p>​ 主要存放已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据（比如spring 使用IOC或者AOP创建bean时，或者使用cglib，反射的形式动态生成class信息等）。</p><h4 id="方法区结构"><a href="#方法区结构" class="headerlink" title="方法区结构"></a>方法区结构</h4><h5 id="classLoader是如何加载class文件和存储文件信息的"><a href="#classLoader是如何加载class文件和存储文件信息的" class="headerlink" title="classLoader是如何加载class文件和存储文件信息的"></a>classLoader是如何加载class文件和存储文件信息的</h5><p>​ 当一个classLoder启动的时候，classLoader的生存地点在jvm中的堆，然后它会去主机硬盘上将A.class装载到jvm的方法区，方法区中的这个字节文件会被虚拟机拿来new A字节码()，然后在堆内存生成了一个A字节码的对象，然后A字节码这个内存文件有两个引用一个指向A的class对象，一个指向加载自己的classLoader。那么方法区中的字节码内存块，除了记录一个class自己的class对象引用和一个加载自己的ClassLoader引用之外，还记录了什么信息呢？？</p><p><img src="../images/jvm/jvm09.png" alt></p><h4 id="方法区关键信息介绍"><a href="#方法区关键信息介绍" class="headerlink" title="方法区关键信息介绍"></a>方法区关键信息介绍</h4><h5 id="类信息"><a href="#类信息" class="headerlink" title="类信息"></a>类信息</h5><ul><li>类型的全限定名</li><li>超类的全限定名</li><li>直接超接口的全限定名</li><li>类型标志（该类是类类型还是接口类型）</li><li>类的访问描述符（public、private、default、abstract、final、static）</li></ul><h5 id="类型的常量池"><a href="#类型的常量池" class="headerlink" title="类型的常量池"></a>类型的常量池</h5><pre><code>存放该类型所用到的常量的有序集合，包括直接常量（如字符串、整数、浮点数的常量）和对其他类型、字段、方法的符号引用。常量池中每一个保存的常量都有一个索引，就像数组中的字段一样。因为常量池中保存中所有类型使用到的类型、字段、方法的字符引用，所以它也是动态连接的主要对象（在动态链接中起到核心作用）。</code></pre><h5 id="字段信息（该类声明的所有字段）"><a href="#字段信息（该类声明的所有字段）" class="headerlink" title="字段信息（该类声明的所有字段）"></a>字段信息（该类声明的所有字段）</h5><ul><li>字段修饰符（public、protect、private、default）</li><li>字段的类型</li><li>字段名称</li></ul><h5 id="方法信息"><a href="#方法信息" class="headerlink" title="方法信息"></a>方法信息</h5><blockquote><p>方法信息中包含类的所有方法，每个方法包含以下信息</p></blockquote><ul><li>方法修饰符</li><li>方法返回类型</li><li>方法名</li><li>方法参数个数、类型、顺序等</li><li>方法字节码</li><li>操作数栈和该方法在栈帧中的局部变量区大小</li><li>异常表</li></ul><h5 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h5><p>​ 指该类所有对象共享的变量，即使没有任何实例对象时，也可以访问的类变量。它们与类进行绑定。</p><h5 id="指向类加载器的引用"><a href="#指向类加载器的引用" class="headerlink" title="指向类加载器的引用"></a>指向类加载器的引用</h5><p>​ 每一个被JVM加载的类型，都保存这个类加载器的引用，类加载器动态链接时会用到。</p><h5 id="指向Class实例的引用"><a href="#指向Class实例的引用" class="headerlink" title="指向Class实例的引用"></a>指向Class实例的引用</h5><p>​ 类加载的过程中，虚拟机会创建该类型的Class实例，方法区中必须保存对该对象的引用。通过Class.forName(String className)来查找获得该实例的引用，然后创建该类的对象。</p><h5 id="方法表"><a href="#方法表" class="headerlink" title="方法表"></a>方法表</h5><p>​ 为了提高访问效率，JVM可能会对每个装载的非抽象类，都创建一个数组，数组的每个元素是实例可能调用的方法的直接引用，包括父类中继承过来的方法。这个表在抽象类或者接口中是没有的，类似C++虚函数表vtbl。</p><h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><h5 id="Class文件中的常量池"><a href="#Class文件中的常量池" class="headerlink" title="Class文件中的常量池"></a>Class文件中的常量池</h5><p>​ 在Class文件结构中，最头的4个字节用于存储Megic Number，用于确定一个文件是否能被JVM接受，再接着4个字节用于存储版本号，前2个字节存储次版本号，后2个存储主版本号，再接着是用于存放常量的常量池，由于常量的数量是不固定的，所以常量池的入口放置一个U2类型的数据(constant_pool_count)存储常量池容量计数值。</p><p>​ 常量池主要用于存放两大类常量：字面量(Literal)和符号引用量(Symbolic References)，字面量相当于Java语言层面常量的概念，如文本字符串，声明为final的常量值等，符号引用则属于编译原理方面的概念，包括了如下三种类型的常量：</p><ul><li>类和接口的全限定名</li><li>字段名称和描述符</li><li>方法名称和描述符</li></ul><h5 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h5><p>​ Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。</p><p>​ 运行时常量池相对于Class文件常量池的另外一个重要特征是具备动态性，Java语言并不要求常量一定只有编译期才能产生，也就是并非预置入Class文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用比较多的就是String类的intern()方法。</p><h5 id="常量池的好处"><a href="#常量池的好处" class="headerlink" title="常量池的好处"></a>常量池的好处</h5><p>​ 常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。</p><p>​ 例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p><ul><li>（1）节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li><li>（2）节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li></ul><h6 id="双等号-的含义"><a href="#双等号-的含义" class="headerlink" title="双等号==的含义"></a>双等号==的含义</h6><ul><li>基本数据类型之间应用双等号，比较的是他们的数值。</li><li>复合数据类型(类)之间应用双等号，比较的是他们在内存中的存放地址。</li></ul><h5 id="基本类型的包装类和常量池"><a href="#基本类型的包装类和常量池" class="headerlink" title="基本类型的包装类和常量池"></a>基本类型的包装类和常量池</h5><p>​ java中基本类型的包装类的大部分都实现了常量池技术，即Byte,Short,Integer,Long,Character,Boolean。</p><p>​ 这5种包装类默认创建了数值[-128，127]的相应类型的缓存数据，但是超出此范围仍然会去创建新的对象。 两种浮点数类型的包装类Float,Double并没有实现常量池技术。</p><h3 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h3><blockquote><p>堆是需要重点关注的一块区域，因为涉及到内存的分配(new关键字，反射等)与回收(回收算法，收集器等)</p><p>几乎所有的对象都是在堆中分配。</p></blockquote><p>​ 对于大多数应用来说，Java堆（Java Heap）是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，<strong>在虚拟机启动时创建</strong>。此内存区域的唯一目的就是存放对象实例，<strong>几乎所有的对象实例都在这里分配内存</strong>。这一点在Java虚拟机规范中的描述是：<strong>所有的对象实例以及数组都要在堆上分配</strong>。但是随着JIT编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得没那么绝对了。</p><p>​ Java堆是垃圾收集器管理的主要区域，因此很多时候也被称“GC堆”（Garbage Collected Heap）。从内存回收的角度看，现在收集器基本都是采用的分代收集算法，所以Java堆中还可以细分为：新生代和老年代；再细致一点的有Eden空间、F rom Survivor空间、To Survivor空间等。如果从内存分配的角度看，线程共享的Java堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer ,TLAB）。无论如何划分，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。</p><p>​ 根据虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可。在实现时，可以是固定大小的，也可以是扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx -Xms 控制）。如果在堆中没有内存完成 实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError异常。</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><p>存储的全部是对象，每个对象包含一个与之对应的class信息–class的目的是得到操作指令。</p></li><li><p>jvm只有一个堆区（heap）被所有线程共享，堆区中不存放基本类型和对象引用，只存放对象本身。</p></li><li><p>堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些不再使用的数据。</p></li><li><p>缺点是，由于要在运行时动态分配内存，存取速度较慢。</p></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><img src="../images/jvm/jvm13.png" style="zoom:48%"><p>​ 直接内存不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。在JDK1.4中新加入了<strong>NIO（New Input/Output）</strong>类，引入了一种基于<strong>通道（Channel）</strong>与<strong>缓冲区（Buffer）</strong>的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的<strong>DirectByteBuffer</strong>对象作为这块内存的引用 进行操作。<strong>这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据。</strong></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><img src="../images/jvm/jvm12.png" style="zoom:75%"><h4 id="堆栈方法区的区别"><a href="#堆栈方法区的区别" class="headerlink" title="堆栈方法区的区别"></a>堆栈方法区的区别</h4><h5 id="存储内容的区别"><a href="#存储内容的区别" class="headerlink" title="存储内容的区别"></a>存储内容的区别</h5><p><strong>栈：</strong>为即时调用的方法开辟空间，<strong>存储局部变量值(基本数据类型)</strong>，<strong>局部变量引用</strong>,<strong>对象属性的引用</strong>。当一段代码或者一个方法调用完毕后，栈中为这段代码所提供的基本数据类型或者对象的引用立即被释放；注意：局部变量必须手动初始化。</p><p><strong>堆</strong>：<strong>存放引用类型的对象</strong>，即new出来的<strong>对象、数组值、类的非静态成员变量值(基本数据类型)、非静态成员变量引用</strong>。其中非静态成员变量在实例化时开辟空间初始化值。（类中属于全局变量的基本数据类型也存放在堆中）。一个java对象占用的内存空间,除了一个固定大小的空间用于描述这个对象属于哪个类,其它的就用于保存它的字段的值;堆比栈要大。</p><p><strong>方法区</strong>：<strong>存放class二进制文件</strong>。包含<strong>类信息、静态变量，常量池（String字符串和final修饰的常量值等），类的版本号等基本信息</strong>。静态成员变量是在方法区的静态域里面，而静态成员方法是在方法区的class二进制信息里面(.class文件和方法区里面的二进制信息不一样，读取.class文件按照虚拟机需要的格式存储在方法区，这种格式包括数据结构方面。）因为是共享的区域，所以如果静态成员变量的值或者常量值(String类型的值能够非修改)被修改了直接就会反应到其它类的对象中。</p><p><strong>基本类型的地址和值都存在栈中，但是两个相同值的基本类型的地址不同，其中的==比较被重写</strong></p><p><strong>成员变量存放在堆中，就算是int a[]=new int[10]，也都是存放在堆中，包括a[2]=1.而局部变量存放于栈中</strong></p><h5 id="定义的区别"><a href="#定义的区别" class="headerlink" title="定义的区别"></a>定义的区别</h5><p><strong>堆</strong>：FIFO队列优先，先进先出。jvm只有一个堆区被所有线程所共享！堆存放在二级缓存中，调用对象的速度相对慢一些，生命周期由虚拟机的垃圾回收机制定。</p><p><strong>栈</strong>：FILO先进后出，暂存数据的地方。每个线程都包含一个栈区！栈存放在一级缓存中，存取速度较快，“栈是限定仅在表头进行插入和删除操作的线性表”。</p><p><strong>方法区</strong>：用来存放方法和static变量。</p><h5 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h5><p>堆的优点-可以动态的分配内存大小，生命周期不确定。缺点-速度略慢</p><p>栈的优点-速度快，缺点-存在栈中的数据大小和生命周期必须是明确的，缺少灵活性。</p><h5 id="直接内存（堆外内存）与堆内存比较"><a href="#直接内存（堆外内存）与堆内存比较" class="headerlink" title="直接内存（堆外内存）与堆内存比较"></a>直接内存（堆外内存）与堆内存比较</h5><ul><li><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显</p></li><li><p>直接内存IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM运行时数据区-线程私有
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/tags/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
      <category term="线程私有" scheme="http://www.baiyp.ren/tags/%E7%BA%BF%E7%A8%8B%E7%A7%81%E6%9C%89/"/>
    
  </entry>
  
  <entry>
    <title>JVM永久代与元空间</title>
    <link href="http://www.baiyp.ren/JVM%E6%B0%B8%E4%B9%85%E4%BB%A3%E4%B8%8E%E5%85%83%E7%A9%BA%E9%97%B4.html"/>
    <id>http://www.baiyp.ren/JVM永久代与元空间.html</id>
    <published>2019-09-08T06:10:53.000Z</published>
    <updated>2019-09-08T14:16:49.803Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JVM永久代与元空间"><a href="#JVM永久代与元空间" class="headerlink" title="JVM永久代与元空间"></a>JVM永久代与元空间</h2><p><img src="../images/jvm/jvm03.png" alt></p><h3 id="方法区与永久代"><a href="#方法区与永久代" class="headerlink" title="方法区与永久代"></a>方法区与永久代</h3><blockquote><p>方法区和永久代又有着本质的区别。<strong>前者是 JVM 的规范</strong>，<strong>而后者则是 JVM 规范的一种实现</strong>，并且只有 HotSpot 才有永久代，而对于其他类型的虚拟机，如 JRockit（Oracle）、J9（IBM） 并没有永久代。由于方法区主要存储类的相关信息，所以对于动态生成类的情况比较容易出现永久代的内存溢出</p></blockquote><p>​ 在Java虚拟机规范中，方法区在虚拟机启动的时候创建，虽然方法区是堆的逻辑组成部分，但是简单的虚拟机实现可以选择不在方法区实现垃圾回收与压缩。这个版本的虚拟机规范也不限定实现方法区的内存位置和编译代码的管理策略。所以不同的JVM厂商，针对自己的JVM可能有不同的方法区实现方式。</p><p>​ 在HotSpot中，设计者将方法区纳入GC分代收集。HotSpot虚拟机堆内存被分为新生代和老年代，对堆内存进行分代管理，所以HotSpot虚拟机使用者更愿意将方法区称为老年代。</p><p>​ 方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。</p><p>​ 我们知道在HotSpot虚拟机中存在三种垃圾回收现象，minor GC、major GC和full GC。对新生代进行垃圾回收叫做minor GC，对老年代进行垃圾回收叫做major GC，同时对新生代、老年代和永久代进行垃圾回收叫做full GC。许多major GC是由minor GC触发的，所以很难将这两种垃圾回收区分开。major GC和full GC通常是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是major GC。</p><h4 id="大小调节"><a href="#大小调节" class="headerlink" title="大小调节"></a>大小调节</h4><blockquote><p>在1.7之前，可以使用如下参数来调节方法区的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法区初始大小</span></span><br><span class="line">-XX:PermSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法区最大大小, 超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen</span></span><br><span class="line">-XX:MaxPermSize</span><br></pre></td></tr></table></figure><h3 id="jdk8中的方法区"><a href="#jdk8中的方法区" class="headerlink" title="jdk8中的方法区"></a>jdk8中的方法区</h3><p>​ 在jdk8中已经将永久带移除了。也就是说-XX:PermSize这些参数在jdk8中将是无效的。<br>移除了，肯定有人来代替他。就是新出现的元空间(Metaspace)来代替原来的永久带。</p><p>方法区中主要存放的是一些描述性信息，即元数据。</p><p>​ 方法区是堆的逻辑组成部分。实际上JDK1.7中，存储在永久代的部分数据就已经转移到了Java Heap或者是 Native Heap。但永久代仍存在于JDK1.7中，但是并没完全移除。</p><h4 id="大小调整"><a href="#大小调整" class="headerlink" title="大小调整"></a>大小调整</h4><blockquote><p>在1.8中，使用如下参数来调节方法区的大小</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//元空间初始大小</span></span><br><span class="line">-XX: MetaspaceSize</span><br><span class="line"></span><br><span class="line"><span class="comment">// 元空间最大大小, 超过这个值将会抛出OutOfMemoryError异常：java.lang.OutOfMemoryError: Metadata space</span></span><br><span class="line">-XX: MaxMetaspaceSize</span><br></pre></td></tr></table></figure><h3 id="永久代"><a href="#永久代" class="headerlink" title="永久代"></a>永久代</h3><p>​ 永久代中包含了虚拟机中所有可通过反射获取到的数据，比如Class和Method对象。不同的Java虚拟机之间可能会进行类共享，因此永久代又分为只读区和读写区。</p><p>​ JVM用于描述应用程序中用到的类和方法的元数据也存储在永久代中。JVM运行时会用到多少永久代的空间取决于应用程序用到了多少类。除此之外，Java SE库中的类和方法也都存储在这里。</p><p>​ 如果JVM发现有的类已经不再需要了，它会去回收（卸载）这些类，将它们的空间释放出来给其它类使用。Full GC会进行持久代的回收。</p><ul><li>JVM中类的元数据在Java堆中的存储区域。</li><li>Java类对应的HotSpot虚拟机中的内部表示也存储在这里。</li><li>类的层级信息，字段，名字。</li><li>方法的编译信息及字节码。</li><li>变量</li><li>常量池和符号解析</li></ul><h4 id="永久代大小"><a href="#永久代大小" class="headerlink" title="永久代大小"></a>永久代大小</h4><ul><li>它的上限是MaxPermSize，默认是64M</li><li>Java堆中的连续区域 : 如果存储在非连续的堆空间中的话，要定位出持久代到新对象的引用非常复杂并且耗时。卡表（card table），是一种记忆集（Remembered Set），它用来记录某个内存代中普通对象指针（oops）的修改。</li><li>持久代用完后，会抛出OutOfMemoryError “PermGen space”异常。解决方案：应用程序清理引用来触发类卸载；增加MaxPermSize的大小。</li><li>需要多大的持久代空间取决于类的数量，方法的大小，以及常量池的大小。</li></ul><h4 id="为什么移除持久代"><a href="#为什么移除持久代" class="headerlink" title="为什么移除持久代"></a>为什么移除持久代</h4><ul><li>它的大小是在启动时固定好的——很难进行调优。-XX:MaxPermSize，设置成多少好呢？</li><li>HotSpot的内部类型也是Java对象：它可能会在Full GC中被移动，同时它对应用不透明，且是非强类型的，难以跟踪调试，还需要存储元数据的元数据信息（meta-metadata）。</li><li>简化Full GC：每一个回收器有专门的元数据迭代器。</li><li>可以在GC不进行暂停的情况下并发地释放类数据。</li><li>使得原来受限于持久代的一些改进未来有可能实现</li></ul><h3 id="元空间-metaspace"><a href="#元空间-metaspace" class="headerlink" title="元空间(metaspace)"></a>元空间(metaspace)</h3><blockquote><p>JDK 8的HotSpot JVM现在使用的是本地内存来表示类的元数据，这个区域就叫做元空间。</p></blockquote><p>​ 持久代的空间被彻底地删除了，它被一个叫元空间的区域所替代了。持久代删除了之后，很明显，JVM会忽略PermSize和MaxPermSize这两个参数，还有就是你再也看不到java.lang.OutOfMemoryError: PermGen error的异常了。原来类的静态变量和Interned Strings 都被转移到了java堆区，只有class元数据才在元空间。</p><h4 id="元空间的特点"><a href="#元空间的特点" class="headerlink" title="元空间的特点"></a>元空间的特点</h4><ul><li>充分利用了Java语言规范中的好处：类及相关的元数据的生命周期与类加载器的一致。</li><li>每个加载器有专门的存储空间</li><li>只进行线性分配</li><li>不会单独回收某个类</li><li>省掉了GC扫描及压缩的时间</li><li>元空间里的对象的位置是固定的</li><li>如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉</li></ul><h4 id="元空间的内存分配模型"><a href="#元空间的内存分配模型" class="headerlink" title="元空间的内存分配模型"></a>元空间的内存分配模型</h4><ul><li>绝大多数的类元数据的空间都从本地内存中分配</li><li>用来描述类元数据的类也被删除了</li><li>分元数据分配了多个虚拟内存空间</li><li>给每个类加载器分配一个内存块的列表。块的大小取决于类加载器的类型; sun/反射/代理对应的类加载器的块会小一些</li><li>归还内存块，释放内存块列表</li><li>一旦元空间的数据被清空了，虚拟内存的空间会被回收掉</li><li>减少碎片的策略</li></ul><h4 id="元空间内存管理"><a href="#元空间内存管理" class="headerlink" title="元空间内存管理"></a>元空间内存管理</h4><p>​ <strong>元空间的内存管理由元空间虚拟机来完成</strong>。先前，对于类的元数据我们需要不同的垃圾回收器进行处理，现在只需要执行元空间虚拟机的C++代码即可完成。在元空间中，<strong>类和其元数据的生命周期和其对应的类加载器是相同的</strong>。话句话说，只要类加载器存活，其加载的类的元数据也是存活的，因而不会被回收掉。</p><p>​ 准确的来说，<strong>每一个类加载器的存储区域都称作一个元空间，所有的元空间合在一起就是我们一直说的元空间</strong>。当一个类加载器被垃圾回收器标记为不再存活，其对应的元空间会被回收。在元空间的回收过程中没有重定位和压缩等操作。但是元空间内的元数据会进行扫描来确定Java引用。</p><p>​ <strong>元空间虚拟机负责元空间的分配</strong>，其采用的形式为<strong>组块分配</strong>。组块的大小因类加载器的类型而异。在元空间虚拟机中存在一个<strong>全局的空闲组块列表</strong>。当一个类加载器需要组块时，它就会从这个全局的组块列表中获取并维持一个自己的组块列表。当一个类加载器不再存活，那么其持有的组块将会被释放，并返回给全局组块列表。类加载器持有的组块又会被分成多个块，每一个块存储一个单元的元信息。<strong>组块中的块是线性分配（指针碰撞分配形式）</strong>。组块分配自内存映射区域。这些全局的虚拟内存映射区域以链表形式连接，一旦某个虚拟内存映射区域清空，这部分内存就会返回给操作系统。</p><p>​ 运行时常量池在<strong>JDK1.6及之前版本的JVM中是方法区的一部分</strong>，而在HotSpot虚拟机中方法区放在了”永久代(Permanent Generation)”。所以运行时常量池也是在永久代的，但是<strong>JDK1.7及之后版本的JVM已经将字符串常量池从方法区中移了出来，在Java 堆（Heap）中开辟了一块区域存放运行时常量池</strong>。</p><p>​ String.intern()是一个Native方法，它的作用是：如果运行时常量池中已经包含一个等于此String对象内容的字符串，则返回常量池中该字符串的引用；如果没有，则在常量池中创建与此String内容相同的字符串，并返回常量池中创建的字符串的<strong>引用</strong>。</p><h3 id="永久代与元空间"><a href="#永久代与元空间" class="headerlink" title="永久代与元空间"></a>永久代与元空间</h3><blockquote><p>JDK8 HotSpot JVM 将移除永久区，使用本地内存来存储类元数据信息并称之为：元空间（Metaspace）</p></blockquote><p>以下是JVM内存模型中方法区的变动</p><p><img src="../images/jvm/jvm11.jpg" alt></p><p>1.新生代：Eden+From Survivor+To Survivor</p><p>2.老年代：OldGen</p><p>3.永久代（方法区的实现） : PermGen—–&gt;替换为Metaspace(本地内存中)</p><p>​ 元空间的本质和永久代类似，<strong>都是对JVM规范中方法区的实现</strong>。不过元空间与永久代之间<strong>最大的区别在于：元空间并不在虚拟机中，而是使用本地内存</strong>。因此，默认情况下，元空间的大小仅受本地内存限制，但可以通过以下参数来指定元空间的大小：</p><p>​ 《Java虚拟机规范(JavaSE7)》中也说了<strong>方法区是堆的逻辑组成部分</strong>。<br>实际上JDK1.7中，存储在永久代的部分数据就已经转移到了<code>Java Heap</code>或者是 <code>Native Heap</code>。但永久代在JDK1.8才被移除</p><h4 id="移除永久代的影响"><a href="#移除永久代的影响" class="headerlink" title="移除永久代的影响"></a>移除永久代的影响</h4><p>​ 由于类的元数据分配在本地内存中，元空间的最大可分配空间就是系统可用内存空间。因此，<strong>我们就不会遇到永久代存在时的内存溢出错误，也不会出现泄漏的数据移到交换区这样的事情</strong>。最终用户可以为元空间设置一个可用空间最大值，如果不进行设置，JVM会<strong>自动</strong>根据类的元数据大小动态增加元空间的容量。</p><p><strong>注意</strong>：永久代的移除并不代表自定义的类加载器泄露问题就解决了。因此，你还必须监控你的内存消耗情况，因为一旦发生泄漏，会占用你的大量本地内存，并且还可能导致交换区交换更加糟糕。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM永久代与元空间
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="运行时数据区" scheme="http://www.baiyp.ren/categories/jvm/%E8%BF%90%E8%A1%8C%E6%97%B6%E6%95%B0%E6%8D%AE%E5%8C%BA/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="永久代" scheme="http://www.baiyp.ren/tags/%E6%B0%B8%E4%B9%85%E4%BB%A3/"/>
    
      <category term="元空间" scheme="http://www.baiyp.ren/tags/%E5%85%83%E7%A9%BA%E9%97%B4/"/>
    
  </entry>
  
  <entry>
    <title>并发面试题总结</title>
    <link href="http://www.baiyp.ren/%E5%B9%B6%E5%8F%91%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93.html"/>
    <id>http://www.baiyp.ren/并发面试题总结.html</id>
    <published>2019-09-07T09:12:30.000Z</published>
    <updated>2019-09-07T09:56:25.851Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="并发面试题总结"><a href="#并发面试题总结" class="headerlink" title="并发面试题总结"></a>并发面试题总结</h2><h3 id="谈面试"><a href="#谈面试" class="headerlink" title="谈面试"></a>谈面试</h3><ol><li><p>面试主要分为两块：</p><ul><li>一块是考查工程师对基础知识（包括了技术广度、深度、对技术的热情度等）的掌握程度，因为<strong>基础知识决定了一个技术人员发展的上限</strong>；</li><li>另一块是考察工程师的工程能力，比如：做过哪些项目？遇到最难的问题怎样解决的？说说最有成就感的一项任务？<strong>工程能力是考察工程师当下能为公司带来的利益</strong>。当然还有其它考核方面：抗压性、合作能力。</li></ul></li><li><p>Java只是一门语言，即使是Java工程师也不能局限于Java，要从面向对象语言本身，甚至从整个计算机体系，从工程实际出发看Java。</p></li><li><p>很多知识在一般公司的开发中是用不到的，常有人戏称：“面试造火箭，工作拧螺丝”，但这只是通常情况下公司对程序员的标准——迅速产出，完成任务。所以，工程师为了自己职业的发展不能局限于公司对自己的要求，不能停留在应用层面，要能够很好地掌握基础知识，要多看源码，自己多实践，学成记得产出，比如多为开源社区贡献代码，帮助初学者指路等。</p></li></ol><p>其实“面试造火箭，工作拧螺丝”的背后其实是大家都普遍认可基础知识的重要性。</p><h3 id="常见面试题"><a href="#常见面试题" class="headerlink" title="常见面试题"></a>常见面试题</h3><h4 id="1-在java中守护线程和用户线程的区别？"><a href="#1-在java中守护线程和用户线程的区别？" class="headerlink" title="1.在java中守护线程和用户线程的区别？"></a>1.在java中守护线程和用户线程的区别？</h4><p>java中的线程分为两种：</p><ul><li>守护线程（Daemon）</li><li>用户线程（User）。</li></ul><p>任何线程都可以设置为守护线程和用户线程，通过方法Thread.setDaemon(bool on)；true则把该线程设置为守护线程，反之则为用户线程。Thread.setDaemon()必须在Thread.start()之前调用，否则运行时会抛出异常。</p><p><strong>两者的区别：</strong></p><p>唯一的区别是判断虚拟机(JVM)何时离开，Daemon是为其他线程提供服务，如果全部的User Thread已经结束，Daemon 没有可服务的线程，JVM关闭。</p><p>扩展：Thread Dump打印出来的线程信息，含有daemon字样的线程即为守护进程</p><h4 id="2-线程与进程的区别"><a href="#2-线程与进程的区别" class="headerlink" title="2.线程与进程的区别"></a>2.线程与进程的区别</h4><p>​ 进程是操作系统分配资源的最小单元，线程是操作系统调度的最小单元。</p><p>​ 一个程序至少有一个进程,一个进程至少有一个线程。</p><h4 id="3-什么是多线程中的上下文切换"><a href="#3-什么是多线程中的上下文切换" class="headerlink" title="3.什么是多线程中的上下文切换"></a>3.什么是多线程中的上下文切换</h4><p>多线程会共同使用一组计算机上的CPU，而线程数大于给程序分配的CPU数量时，为了让各个线程都有执行的机会，就需要轮转使用CPU。不同的线程切换使用CPU发生的切换数据等就是上下文切换。</p><h4 id="4-死锁与活锁的区别，死锁与饥饿的区别？"><a href="#4-死锁与活锁的区别，死锁与饥饿的区别？" class="headerlink" title="4.死锁与活锁的区别，死锁与饥饿的区别？"></a>4.死锁与活锁的区别，死锁与饥饿的区别？</h4><p><strong>死锁</strong>：是指两个或两个以上的进程（或线程）在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。</p><p><strong>产生死锁的必要条件：</strong></p><ul><li><p>互斥条件：所谓互斥就是进程在某一时间内独占资源。</p></li><li><p>请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。</p></li><li><p>不剥夺条件:进程已获得资源，在末使用完之前，不能强行剥夺。</p></li><li><p>循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。</p></li></ul><p><strong>活锁</strong>：任务或者执行者没有被阻塞，由于某些条件没有满足，导致一直重复尝试，失败，尝试，失败。</p><p>活锁和死锁的区别在于，处于活锁的实体是在不断的改变状态，所谓的“活”， 而处于死锁的实体表现为等待；活锁有可能自行解开，死锁则不能。</p><p><strong>饥饿</strong>：一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态。</p><h4 id="5-synchronized底层实现原理"><a href="#5-synchronized底层实现原理" class="headerlink" title="5.synchronized底层实现原理"></a>5.synchronized底层实现原理</h4><p>​ synchronized (this)原理：涉及两条指令：<strong>monitorenter</strong>，<strong>monitorexit</strong>；再说同步方法，从同步方法反编译的结果来看，方法的同步并没有通过指令monitorenter和monitorexit来实现，相对于普通方法，其常量池中多了ACC_SYNCHRONIZED标示符。</p><p>​ JVM就是根据该标示符来实现方法的同步的：当方法被调用时，调用指令将会检查方法的 ACC_SYNCHRONIZED 访问标志是否被设置，如果设置了，执行线程将先获取monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</p><p>注意，这个问题可能会接着追问，java对象头信息，偏向锁，轻量锁，重量级锁及其他们相互间转化。</p><h4 id="6-什么是线程组，为什么在Java中不推荐使用？"><a href="#6-什么是线程组，为什么在Java中不推荐使用？" class="headerlink" title="6.什么是线程组，为什么在Java中不推荐使用？"></a>6.什么是线程组，为什么在Java中不推荐使用？</h4><p>ThreadGroup类，可以把线程归属到某一个线程组中，线程组中可以有线程对象，也可以有线程组，组中还可以有线程，这样的组织结构有点类似于树的形式。</p><ul><li><p>线程组ThreadGroup对象中比较有用的方法是stop、resume、suspend等方法，由于这几个方法会导致线程的安全问题（主要是死锁问题），已经被官方废弃掉了，所以线程组本身的应用价值就大打折扣了。</p></li><li><p>线程组ThreadGroup不是线程安全的，这在使用过程中获取的信息并不全是及时有效的，这就降低了它的统计使用价值。</p></li></ul><h4 id="7-什么是Executors框架？为什么使用Executor框架？"><a href="#7-什么是Executors框架？为什么使用Executor框架？" class="headerlink" title="7.什么是Executors框架？为什么使用Executor框架？"></a>7.什么是Executors框架？为什么使用Executor框架？</h4><ul><li><p>Executor框架是一个根据一组执行策略调用，调度，执行和控制的异步任务的框架。</p></li><li><p>每次执行任务创建线程 new Thread()比较消耗性能，创建一个线程是比较耗时、耗资源的。</p></li><li><p>调用 new Thread()创建的线程缺乏管理，而且可以无限制的创建，线程之间的相互竞争会导致过多占用系统资源而导致系统瘫痪，还有线程之间的频繁交替也会消耗很多系统资源。</p></li><li><p>直接使用new Thread() 启动的线程不利于扩展，比如定时执行、定期执行、定时定期执行、线程中断等都不便实现。</p></li></ul><h4 id="8-在Java中Executor和Executors的区别？"><a href="#8-在Java中Executor和Executors的区别？" class="headerlink" title="8.在Java中Executor和Executors的区别？"></a>8.在Java中Executor和Executors的区别？</h4><ul><li><p>Executors 工具类的不同方法按照我们的需求创建了不同的线程池，来满足业务的需求。</p></li><li><p>Executor 接口对象能执行我们的线程任务。</p></li><li><p>ExecutorService接口继承了Executor接口并进行了扩展，提供了更多的方法我们能获得任务执行的状态并且可以获取任务的返回值。</p></li><li><p>使用ThreadPoolExecutor 可以创建自定义线程池。</p></li></ul><h4 id="9-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？"><a href="#9-什么是原子操作？在Java-Concurrency-API中有哪些原子类-atomic-classes-？" class="headerlink" title="9.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？"></a>9.什么是原子操作？在Java Concurrency API中有哪些原子类(atomic classes)？</h4><blockquote><p><strong>原子操作（atomic operation）</strong>意为”不可被中断的一个或一系列操作” 。</p></blockquote><p>处理器使用基于对缓存加锁或总线加锁的方式来实现多处理器之间的原子操作。</p><p>在Java中可以通过锁和循环CAS的方式来实现原子操作。</p><p>CAS操作——Compare And Set，或是 Compare And Swap，现在几乎所有的CPU指令都支持CAS的原子操作。java.util.concurrent.atomic下提供了大量的原子操作类，比如原子类：AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference ，原子数组：AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray ，原子属性更新器：AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater</p><h4 id="10-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比synchronized它有什么优势？"><a href="#10-Java-Concurrency-API中的Lock接口-Lock-interface-是什么？对比synchronized它有什么优势？" class="headerlink" title="10.Java Concurrency API中的Lock接口(Lock interface)是什么？对比synchronized它有什么优势？"></a>10.Java Concurrency API中的Lock接口(Lock interface)是什么？对比synchronized它有什么优势？</h4><ul><li><p>Lock接口比同步方法和同步块提供了更具扩展性的锁操作。</p></li><li><p>他们允许更灵活的结构，可以具有完全不同的性质，并且可以支持多个相关类的条件对象。</p></li></ul><p><strong>它的优势有</strong>：可以使锁更公平，可以使线程在等待锁的时候响应中断，可以让线程尝试获取锁，并在无法获取锁的时候立即返回或者等待一段时间，可以在不同的范围，以不同的顺序获取和释放锁。</p><p>整体上来说Lock是synchronized的扩展版，Lock提供了无条件的、可轮询的(tryLock方法)、定时的(tryLock带参方法)、可中断的(lockInterruptibly)、可多条件队列的(newCondition方法)锁操作。另外Lock的实现类基本都支持非公平锁(默认)和公平锁，synchronized只支持非公平锁，当然，在大部分情况下，非公平锁是高效的选择。</p><h4 id="11-什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"><a href="#11-什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？" class="headerlink" title="11.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？"></a>11.什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻塞队列来实现生产者-消费者模型？</h4><blockquote><p>阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。</p></blockquote><p>这两个附加的操作是：</p><ul><li>在队列为空时，获取元素的线程会等待队列变为非空。</li><li>当队列满时，存储元素的线程会等待队列可用。</li></ul><p>阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。</p><p>JDK7提供了7个阻塞队列。在实现上，主要是利用了Condition和Lock的等待通知模式。</p><h4 id="12-什么是Callable和Future"><a href="#12-什么是Callable和Future" class="headerlink" title="12.什么是Callable和Future?"></a>12.什么是Callable和Future?</h4><p>Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回值。</p><p>可以认为是带有回调的Runnable。</p><p>Future接口表示异步任务，是还没有完成的任务给出的未来结果。所以说Callable用于产生结果，Future用于获取结果。</p><h4 id="13-什么是FutureTask"><a href="#13-什么是FutureTask" class="headerlink" title="13.什么是FutureTask?"></a>13.什么是FutureTask?</h4><p>​ 在Java并发程序中FutureTask表示一个可以取消的异步运算。它有启动和取消运算、查询运算是否完成和取回运算结果等方法。只有当运算完成的时候结果才能取回，如果运算尚未完成get方法将会阻塞。一个FutureTask对象可以对调用了Callable和Runnable的对象进行包装，由于FutureTask也是调用了Runnable接口所以它可以提交给Executor来执行。</p><h4 id="14-什么是并发容器的实现？"><a href="#14-什么是并发容器的实现？" class="headerlink" title="14.什么是并发容器的实现？"></a>14.什么是并发容器的实现？</h4><p><strong>何为同步容器</strong>：可以简单地理解为通过<strong>synchronized</strong>来实现同步的容器，如果有多个线程调用同步容器的方法，它们将会串行执行。</p><p>比如Vector，Hashtable，以及Collections.synchronizedSet，synchronizedList等方法返回的容器。</p><p>并发容器使用了与同步容器完全不同的加锁策略来提供更高的并发性和伸缩性，例如在ConcurrentHashMap中采用了一种粒度更细的加锁机制，可以称为分段锁，在这种锁机制下，允许任意数量的读线程并发地访问map，并且执行读操作的线程和写操作的线程也可以并发的访问map，同时允许一定数量的写操作线程并发地修改map，所以它可以在并发环境下实现更高的吞吐量。</p><h4 id="15-多线程同步和互斥有几种实现方法，都是什么？"><a href="#15-多线程同步和互斥有几种实现方法，都是什么？" class="headerlink" title="15.多线程同步和互斥有几种实现方法，都是什么？"></a>15.多线程同步和互斥有几种实现方法，都是什么？</h4><p><strong>线程同步</strong>：是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。</p><p><strong>线程互斥</strong>：是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。</p><p>线程间的同步方法大体可分为两类：</p><p>用户模式和内核模式。顾名思义，内核模式就是指利用系统内核对象的单一性来进行同步，使用时需要切换内核态与用户态，而用户模式就是不需要切换到内核态，只在用户态完成操作。</p><p>用户模式下的方法有：原子操作（例如一个单一的全局变量），临界区。内核模式下的方法有：事件，信号量，互斥量。</p><h4 id="16-什么是竞争条件？"><a href="#16-什么是竞争条件？" class="headerlink" title="16.什么是竞争条件？"></a>16.什么是竞争条件？</h4><p>​ 当多个进程都企图对共享数据进行某种处理，而最后的结果又取决于进程运行的顺序时，则我们认为这发生了竞争条件（race condition）。</p><h4 id="17-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#17-为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="17.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>17.为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h4><p>当你调用start()方法时你将创建新的线程，并且执行在run()方法里的代码。</p><p>但是如果你直接调用run()方法，它不会创建新的线程也不会执行调用线程的代码，只会把run方法当作普通方法去执行。</p><h4 id="18-在Java中CycliBarriar和CountdownLatch有什么区别？"><a href="#18-在Java中CycliBarriar和CountdownLatch有什么区别？" class="headerlink" title="18.在Java中CycliBarriar和CountdownLatch有什么区别？"></a>18.在Java中CycliBarriar和CountdownLatch有什么区别？</h4><p>CyclicBarrier可以重复使用，而CountdownLatch不能重复使用。</p><h4 id="19-什么是不可变对象，它对写并发应用有什么帮助？"><a href="#19-什么是不可变对象，它对写并发应用有什么帮助？" class="headerlink" title="19.什么是不可变对象，它对写并发应用有什么帮助？"></a>19.什么是不可变对象，它对写并发应用有什么帮助？</h4><blockquote><p>不可变对象(Immutable Objects)即对象一旦被创建它的状态（对象的数据，也即对象属性值）就不能改变，反之即为可变对象(Mutable Objects)。</p></blockquote><p>不可变对象的类即为不可变类(Immutable Class)。Java平台类库中包含许多不可变类，如String、基本类型的包装类、BigInteger和BigDecimal等。</p><p>不可变对象天生是线程安全的。它们的常量（域）是在构造函数中创建的。既然它们的状态无法修改，这些常量永远不会变。</p><p><strong>不可变对象永远是线程安全的。</strong></p><p>只有满足如下状态，一个对象才是不可变的：</p><ul><li><p>它的状态不能在创建后再被修改；</p></li><li><p>所有域都是final类型；并且， 它被正确创建</p></li></ul><h4 id="20-notify-和notifyAll-有什么区别？"><a href="#20-notify-和notifyAll-有什么区别？" class="headerlink" title="20.notify()和notifyAll()有什么区别？"></a>20.notify()和notifyAll()有什么区别？</h4><p>当一个线程进入wait之后，就必须等其他线程notify/notifyall,使用notifyall,可以唤醒所有处于wait状态的线程，使其重新进入锁的争夺队列中，而notify只能唤醒一个。</p><p>如果没把握，建议notifyAll，防止notigy因为信号丢失而造成程序异常。</p><h4 id="21-什么是可重入锁（ReentrantLock）？谈谈它的实现。"><a href="#21-什么是可重入锁（ReentrantLock）？谈谈它的实现。" class="headerlink" title="21.什么是可重入锁（ReentrantLock）？谈谈它的实现。"></a>21.什么是可重入锁（ReentrantLock）？谈谈它的实现。</h4><p>​ 线程可以重复进入任何一个它已经拥有的锁所同步着的代码块，synchronized、ReentrantLock都是可重入的锁。在实现上，就是线程每次获取锁时判定如果获得锁的线程是它自己时，简单将计数器累积即可，每 释放一次锁，进行计数器累减，直到计算器归零，表示线程已经彻底释放锁。</p><h4 id="22-当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"><a href="#22-当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？" class="headerlink" title="22.当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？"></a>22.当一个线程进入某个对象的一个synchronized的实例方法后，其它线程是否可进入此对象的其它方法？</h4><p>如果其他方法没有synchronized的话，其他线程是可以进入的。</p><p>所以要开放一个线程安全的对象时，得保证每个方法都是线程安全的。</p><h4 id="23-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"><a href="#23-乐观锁和悲观锁的理解及如何实现，有哪些实现方式？" class="headerlink" title="23.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？"></a>23.乐观锁和悲观锁的理解及如何实现，有哪些实现方式？</h4><p><strong>悲观锁：</strong>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。Java里面的同步原语synchronized关键字的实现是悲观锁。</p><p><strong>乐观锁：</strong>顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。在Java中j原子变量类就是使用了乐观锁的一种实现方式CAS实现的。</p><p>乐观锁的实现方式：</p><ul><li><p>使用版本标识来确定读到的数据与提交时的数据是否一致。提交后修改版本标识，不一致时可以采取丢弃和再次尝试的策略。</p></li><li><p>java中的Compare and Swap即CAS ，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。</p></li></ul><h4 id="24-什么是CAS操作，缺点是什么？"><a href="#24-什么是CAS操作，缺点是什么？" class="headerlink" title="24.什么是CAS操作，缺点是什么？"></a>24.什么是CAS操作，缺点是什么？</h4><p>CAS的基本思路就是，如果这个地址上的值和期望的值相等，则给其赋予新值，否则不做任何事儿，但是要返回原值是多少。每一个CAS操作过程都包含三个运算符：一个内存地址V，一个期望的值A和一个新值B，操作的时候如果这个地址上存放的值等于这个期望的值A，则将地址上的值赋为新值B，否则不做任何操作。</p><p><strong>CAS缺点：</strong></p><ul><li><p>ABA问题：</p><p>​ 比如说一个线程one从内存位置V中取出A，这时候另一个线程two也从内存中取出A，并且two进行了一些操作变成了B，然后two又将V位置的数据变成A，这时候线程one进行CAS操作发现内存中仍然是A，然后one操作成功。尽管线程one的CAS操作成功，但可能存在潜藏的问题。从Java1.5开始JDK的atomic包里提供了一个类AtomicStampedReference来解决ABA问题。</p></li><li><p>循环时间长开销大：</p><p>​ 对于资源竞争严重（线程冲突严重）的情况，CAS自旋的概率会比较大，从而浪费更多的CPU资源，效率低于synchronized。</p></li><li><p>只能保证一个共享变量的原子操作：</p><p>​ 当对一个共享变量执行操作时，我们可以使用循环CAS的方式来保证原子操作，但是对多个共享变量操作时，循环CAS就无法保证操作的原子性，这个时候就可以用锁。</p></li></ul><h4 id="25-SynchronizedMap和ConcurrentHashMap有什么区别？"><a href="#25-SynchronizedMap和ConcurrentHashMap有什么区别？" class="headerlink" title="25.SynchronizedMap和ConcurrentHashMap有什么区别？"></a>25.SynchronizedMap和ConcurrentHashMap有什么区别？</h4><ul><li><p>SynchronizedMap一次锁住整张表来保证线程安全，所以每次只能有一个线程来访为map。</p></li><li><p>ConcurrentHashMap使用分段锁来保证在多线程下的性能。</p></li></ul><h4 id="26-写时复制容器可以用于什么应用场景？"><a href="#26-写时复制容器可以用于什么应用场景？" class="headerlink" title="26.写时复制容器可以用于什么应用场景？"></a>26.写时复制容器可以用于什么应用场景？</h4><p>CopyOnWrite并发容器用于对于绝大部分访问都是读，且<strong>只是偶尔写</strong>的并发场景。比如白名单，黑名单，商品类目的访问和更新场景。</p><p>透露的思想：</p><ul><li><p>读写分离，读和写分开</p></li><li><p>最终一致性</p></li><li><p>使用另外开辟空间的思路，来解决并发冲突</p></li></ul><h4 id="27-volatile有什么用？能否用一句话说明下volatile的应用场景？"><a href="#27-volatile有什么用？能否用一句话说明下volatile的应用场景？" class="headerlink" title="27.volatile有什么用？能否用一句话说明下volatile的应用场景？"></a>27.volatile有什么用？能否用一句话说明下volatile的应用场景？</h4><ul><li><p>volatile保证内存可见性和禁止指令重排。</p></li><li><p>volatile用于多线程环境下的一写多读，或者无关联的多写。</p></li></ul><h4 id="28-为什么代码会重排序？"><a href="#28-为什么代码会重排序？" class="headerlink" title="28.为什么代码会重排序？"></a>28.为什么代码会重排序？</h4><p>​ 在执行程序时，为了提供性能，处理器和编译器常常会对指令进行重排序，但是不能随意重排序，不是你想怎么排序就怎么排序，它需要满足以下两个条件：</p><ul><li><p>在单线程环境下不能改变程序运行的结果；</p></li><li><p>存在数据依赖关系的不允许重排序</p></li></ul><h4 id="29-在java中wait和sleep方法的不同？"><a href="#29-在java中wait和sleep方法的不同？" class="headerlink" title="29.在java中wait和sleep方法的不同？"></a>29.在java中wait和sleep方法的不同？</h4><p>​ 最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。</p><h4 id="30-一个线程运行时发生异常会怎样？"><a href="#30-一个线程运行时发生异常会怎样？" class="headerlink" title="30.一个线程运行时发生异常会怎样？"></a>30.一个线程运行时发生异常会怎样？</h4><p>​ 如果异常没有被捕获该线程将会停止执行。hread.UncaughtExceptionHandler是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候JVM会使用Thread.getUncaughtExceptionHandler()来查询线程的UncaughtExceptionHandler并将线程和异常作为参数传递给handler的uncaughtException()方法进行处理。</p><h4 id="31-为什么wait-notify-和-notifyAll这些方法不在thread类里面？"><a href="#31-为什么wait-notify-和-notifyAll这些方法不在thread类里面？" class="headerlink" title="31.为什么wait, notify 和 notifyAll这些方法不在thread类里面？"></a>31.为什么wait, notify 和 notifyAll这些方法不在thread类里面？</h4><p>​ JAVA提供的锁是对象级的而不是线程级的，每个对象都有锁，通过线程获得。如果线程需要等待某些锁那么调用对象中的wait()方法就有意义了。如果wait()方法定义在Thread类中，线程正在等待的是哪个锁就不明显了。简单的说，由于wait，notify和notifyAll都是锁级别的操作，所以把他们定义在Object类中因为锁属于对象。</p><h4 id="32-什么是ThreadLocal变量？"><a href="#32-什么是ThreadLocal变量？" class="headerlink" title="32.什么是ThreadLocal变量？"></a>32.什么是ThreadLocal变量？</h4><p>​ ThreadLocal是Java里一种特殊的变量。每个线程都有一个ThreadLocal就是每个线程都拥有了自己独立的一个变量，竞争条件被彻底消除了。</p><h4 id="33-Java中interrupted-和-isInterrupted方法的区别？"><a href="#33-Java中interrupted-和-isInterrupted方法的区别？" class="headerlink" title="33.Java中interrupted 和 isInterrupted方法的区别？"></a>33.Java中interrupted 和 isInterrupted方法的区别？</h4><p>​ <strong>interrupted()</strong> 和 <strong>isInterrupted()</strong>的主要区别是前者会将中断状态清除而后者不会。</p><p>​ Java多线程的中断机制是用内部标识来实现的，调用Thread.interrupt()来中断一个线程就会设置中断标识为true。当中断线程调用静态方法Thread.interrupted()来检查中断状态时，中断状态会被清零。而非静态方法isInterrupted()用来查询其它线程的中断状态且不会改变中断状态标识。</p><h4 id="34-为什么wait和notify方法要在同步块中调用？"><a href="#34-为什么wait和notify方法要在同步块中调用？" class="headerlink" title="34.为什么wait和notify方法要在同步块中调用？"></a>34.为什么wait和notify方法要在同步块中调用？</h4><p>​ 主要是因为Java API强制要求这样做，如果你不这么做，你的代码会抛出IllegalMonitorStateException异常。</p><h4 id="35-为什么你应该在循环中检查等待条件"><a href="#35-为什么你应该在循环中检查等待条件" class="headerlink" title="35.为什么你应该在循环中检查等待条件?"></a>35.为什么你应该在循环中检查等待条件?</h4><p>​ 处于等待状态的线程可能会收到错误警报和伪唤醒，如果不在循环中检查等待条件，程序就会在没有满足结束条件的情况下退出。因此，当一个等待线程醒来时，不能认为它原来的等待状态仍然是有效的，在notify()方法调用之后和等待线程醒来之前这段时间它可能会改变。这就是在循环中使用wait()方法效果更好的原因</p><h4 id="36-怎么检测一个线程是否拥有锁？"><a href="#36-怎么检测一个线程是否拥有锁？" class="headerlink" title="36.怎么检测一个线程是否拥有锁？"></a>36.怎么检测一个线程是否拥有锁？</h4><p>​ 在java.lang.Thread中有一个方法叫holdsLock()，它返回true如果当且仅当当前线程拥有某个具体对象的锁。</p><h4 id="37-你如何在Java中获取线程堆栈？"><a href="#37-你如何在Java中获取线程堆栈？" class="headerlink" title="37.你如何在Java中获取线程堆栈？"></a>37.你如何在Java中获取线程堆栈？</h4><p><strong>kill -3 [java pid]</strong></p><p>不会在当前终端输出，它会输出到代码执行的或指定的地方去。比如，kill -3 tomcat pid, 输出堆栈到log目录下。</p><p><strong>Jstack [java pid]</strong></p><p>这个比较简单，在当前终端显示，也可以重定向到指定文件中。</p><p>或者使用Java提供的拟机线程系统的管理接口ManagementFactory.getThreadMXBean()。</p><h4 id="38-Java线程池中submit-和-execute-方法有什么区别？"><a href="#38-Java线程池中submit-和-execute-方法有什么区别？" class="headerlink" title="38.Java线程池中submit() 和 execute()方法有什么区别？"></a>38.Java线程池中submit() 和 execute()方法有什么区别？</h4><p>​ 两个方法都可以向线程池提交任务，execute()方法的返回类型是void，它定义在Executor接口中。</p><p>而submit()方法可以返回持有计算结果的Future对象，它定义在ExecutorService接口中，它扩展了Executor接口</p><h4 id="39-你对线程优先级的理解是什么？"><a href="#39-你对线程优先级的理解是什么？" class="headerlink" title="39.你对线程优先级的理解是什么？"></a>39.你对线程优先级的理解是什么？</h4><p>​ 每一个线程都是有优先级的，一般来说，高优先级的线程在运行时会具有优先权，但这依赖于线程调度的实现，这个实现是和操作系统相关的(OS dependent)。我们可以定义线程的优先级，但是这并不能保证高优先级的线程会在低优先级的线程前执行。线程优先级是一个int变量(从1-10)，1代表最低优先级，10代表最高优先级。</p><p>​ java的线程优先级调度会委托给操作系统去处理，所以与具体的操作系统优先级有关，如非特别需要，一般无需设置线程优先级。</p><h4 id="40-你如何确保main-方法所在的线程是Java-程序最后结束的线程？"><a href="#40-你如何确保main-方法所在的线程是Java-程序最后结束的线程？" class="headerlink" title="40.你如何确保main()方法所在的线程是Java 程序最后结束的线程？"></a>40.你如何确保main()方法所在的线程是Java 程序最后结束的线程？</h4><p>​ 可以使用Thread类的join()方法（或者CountDownLatch工具类）来确保所有程序创建的线程在main()方法退出前结束。</p><h4 id="41-为什么Thread类的sleep-和yield-方法是静态的？"><a href="#41-为什么Thread类的sleep-和yield-方法是静态的？" class="headerlink" title="41.为什么Thread类的sleep()和yield ()方法是静态的？"></a>41.为什么Thread类的sleep()和yield ()方法是静态的？</h4><p>​ Thread类的sleep()和yield()方法将在当前正在执行的线程上运行。所以在其他处于等待状态的线程上调用这些方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</p><p>现在有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？</p><p>​ 可以用join方法实现。</p><h4 id="42-你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"><a href="#42-你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？" class="headerlink" title="42.你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？"></a>42.你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？</h4><p>​ volatile关键字，读写锁，写时复制等等都可以实现。</p><h4 id="43-用Java实现阻塞队列"><a href="#43-用Java实现阻塞队列" class="headerlink" title="43.用Java实现阻塞队列"></a>43.用Java实现阻塞队列</h4><p>​ 适用Lock或者synchronize，队列空的时候进行阻塞，有新的入队的时候唤醒阻塞。</p><h4 id="44-用Java写代码来解决生产者——消费者问题。"><a href="#44-用Java写代码来解决生产者——消费者问题。" class="headerlink" title="44.用Java写代码来解决生产者——消费者问题。"></a>44.用Java写代码来解决生产者——消费者问题。</h4><p>​ 阻塞队列实现即可，也可以用wait和notify来解决这个问题，或者用Semaphore</p><h4 id="45-用Java编程一个会导致死锁的程序，你将怎么解决？"><a href="#45-用Java编程一个会导致死锁的程序，你将怎么解决？" class="headerlink" title="45.用Java编程一个会导致死锁的程序，你将怎么解决？"></a>45.用Java编程一个会导致死锁的程序，你将怎么解决？</h4><blockquote><p>参照 JAVA中的死锁一章</p></blockquote><h4 id="46-Java中如何停止一个线程？"><a href="#46-Java中如何停止一个线程？" class="headerlink" title="46.Java中如何停止一个线程？"></a>46.Java中如何停止一个线程？</h4><ul><li><p>使用共享变量的方式</p><p>​ 在这种方式中，之所以引入共享变量，是因为该变量可以被多个执行相同任务的线程用来作为是否中断的信号，通知中断线程的执行。</p></li><li><p>使用interrupt方法终止线程</p><p>​ 如果一个线程由于等待某些事件的发生而被阻塞，又该怎样停止该线程呢？比如当一个线程由于需要等候键盘输入而被阻塞，或者调用Thread.join()方法，或者Thread.sleep()方法，在网络中调用ServerSocket.accept()方法，或者调用了DatagramSocket.receive()方法时，都有可能导致线程阻塞，使线程处于处于不可运行状态时，即使主程序中将该线程的共享变量设置为true，但该线程此时根本无法检查循环标志，当然也就无法立即中断。所以应该尽量使用Thread提供的interrupt()方法，因为该方法虽然不会中断一个正在运行的线程，但是它可以使一个被阻塞的线程抛出一个中断异常，从而使线程提前结束阻塞状态。</p></li></ul><h4 id="47-JVM中哪个参数是用来控制线程的栈堆栈大小的"><a href="#47-JVM中哪个参数是用来控制线程的栈堆栈大小的" class="headerlink" title="47.JVM中哪个参数是用来控制线程的栈堆栈大小的"></a>47.JVM中哪个参数是用来控制线程的栈堆栈大小的</h4><p><strong>-Xss</strong></p><h4 id="48-如果同步块内的线程抛出异常锁会释放吗？"><a href="#48-如果同步块内的线程抛出异常锁会释放吗？" class="headerlink" title="48.如果同步块内的线程抛出异常锁会释放吗？"></a>48.如果同步块内的线程抛出异常锁会释放吗？</h4><p><strong>会</strong></p><h4 id="49-单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？"><a href="#49-单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？" class="headerlink" title="49.单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？"></a>49.单例模式的双重检查实现是什么？为什么并不安全？如何在Java中创建线程安全的Singleton？</h4><p>​ 不安全的根本原因是重排序会导致未初始化完成的对象可以被其他线程看见而导致错误。创建安全的单例模式有：延迟占位模式、在声明的时候就new这个类的实例、枚举</p><h4 id="50-写出3条你遵循的多线程最佳实践"><a href="#50-写出3条你遵循的多线程最佳实践" class="headerlink" title="50.写出3条你遵循的多线程最佳实践"></a>50.写出3条你遵循的多线程最佳实践</h4><ul><li>给你的线程起个有意义的名字。 这样可以方便找bug或追踪。OrderProcessor, QuoteProcessor or TradeProcessor 这种名字比 Thread-1. Thread-2 and Thread-3 好多了，给线程起一个和它要完成的任务相关的名字，所有的主要框架甚至JDK都遵循这个最佳实践。</li><li>避免锁定和缩小同步的范围 锁花费的代价高昂且上下文切换更耗费时间空间，试试最低限度的使用同步和锁，缩小临界区。因此相对于同步方法我更喜欢同步块，它给我拥有对锁的绝对控制权。</li><li>多用同步类少用wait 和 notify 首先，CountDownLatch, Semaphore, CyclicBarrier 和 Exchanger 这些同步类简化了编码操作，而用wait和notify很难实现对复杂控制流的控制。其次，这些类是由最好的企业编写和维护在后续的JDK中它们还会不断优化和完善，使用这些更高等级的同步工具你的程序可以不费吹灰之力获得优化。</li><li>多用并发集合少用同步集合 这是另外一个容易遵循且受益巨大的最佳实践，并发集合比同步集合的可扩展性更好，所以在并发编程时使用并发集合效果更好。</li><li>比如并发编程的黄金原则，尽量无锁化编程等等……..</li></ul><h4 id="51-合理地配置线程池"><a href="#51-合理地配置线程池" class="headerlink" title="51.合理地配置线程池"></a>51.合理地配置线程池</h4><ul><li><p>CPU密集型任务应配置尽可能小的线程，如配置Ncpu+1个线程的线程池。</p></li><li><p>IO密集型任务线程并不是一直在执行任务，则应配置尽可能多的线程，如2*Ncpu。</p></li><li><p>混合型的任务，如果可以拆分，将其拆分成一个CPU密集型任务和一个IO密集型任务，只要这两个任务执行的时间相差不是太大，那么分解后执行的吞吐量将高于串行执行的吞吐量。如果这两个任务执行时间相差太大，则没必要进行分解。可以通过Runtime.getRuntime().availableProcessors()方法获得当前设备的CPU个数。</p><p>对于IO型的任务的最佳线程数，有个公式可以计算 Nthreads = NCPU * UCPU * (1 + W/C)</p></li></ul><h4 id="52-请概述锁的公平和非公平，JDK内部是如何实现的。"><a href="#52-请概述锁的公平和非公平，JDK内部是如何实现的。" class="headerlink" title="52.请概述锁的公平和非公平，JDK内部是如何实现的。"></a>52.请概述锁的公平和非公平，JDK内部是如何实现的。</h4><ul><li><p><strong>公平锁</strong>：是指所有试图获得锁的线程按照获取锁的顺序依次获得锁，而非公平锁则是当前的锁状态没有被占用时,当前线程可以直接占用,而不需要等待。在实现上，非公平锁逻辑基本跟公平锁一致，唯一的区别是，当前线程不需要判断同步队列中是否有等待线程。</p></li><li><p><strong>非公平锁</strong>：性能高于公平锁性能。首先，在恢复一个被挂起的线程与该线程真正运行之间存在着严重的延迟。而且，非公平锁能更充分的利用cpu的时间片，尽量的减少cpu空闲的状态时间。</p></li></ul><p>​ 使用场景的话呢，其实还是和他们的属性一一相关，比如：如果业务中线程占用(处理)时间要远长于线程等待，那用非公平锁其实效率并不明显，但是用公平锁可以保证不会有线程被饿死。</p><h4 id="53-请概述AQS"><a href="#53-请概述AQS" class="headerlink" title="53.请概述AQS"></a>53.请概述AQS</h4><p>​ 是用来构建锁或者其他同步组件的基础框架，比如ReentrantLock、ReentrantReadWriteLock和CountDownLatch就是基于AQS实现的。它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作。它是CLH队列锁的一种变体实现。它可以实现2种同步方式：独占式，共享式。</p><p>​ AQS的主要使用方式是继承，子类通过继承AQS并实现它的抽象方法来管理同步状态，同步器的设计基于模板方法模式，所以如果要实现我们自己的同步工具类就需要覆盖其中几个可重写的方法，如tryAcquire、tryReleaseShared等等。</p><p>​ 这样设计的目的是同步组件（比如锁）是面向使用者的，它定义了使用者与同步组件交互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。这样就很好地隔离了使用者和实现者所需关注的领域。</p><p>​ 在内部，AQS维护一个共享资源state，通过内置的FIFO来完成获取资源线程的排队工作。该队列由一个一个的Node结点组成，每个Node结点维护一个prev引用和next引用，分别指向自己的前驱和后继结点，构成一个双端双向链表。</p><p>同时与Condition相关的等待队列，节点类型也是Node，构成一个单向链表。</p><h4 id="54-请概述volatile"><a href="#54-请概述volatile" class="headerlink" title="54.请概述volatile"></a>54.请概述volatile</h4><p>volatile关键字的作用主要有两点：</p><p>​ 多线程主要围绕可见性和原子性两个特性而展开，使用volatile关键字修饰的变量，保证了其在多线程之间的可见性，即每次读取到volatile变量，一定是最新的数据。但是volatile不能保证操作的原子，对任意单个volatile变量的读/写具有原子性，但类似于++这种复合操作不具有原子性。。</p><p>​ 代码底层在执行时为了获取更好的性能会对指令进行重排序，多线程下可能会出现一些意想不到的问题。使用volatile则会对禁止重排序，当然这也一定程度上降低了代码执行效率。</p><p>​ 同时在内存语义上，当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存，当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</p><p>​ 在Java中对于volatile修饰的变量，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序问题、强制刷新和读取。</p><p>​ 在具体实现上，volatile关键字修饰的变量会存在一个“lock:”的前缀。它不是一种内存屏障，但是它能完成类似内存屏障的功能。Lock会对CPU总线和高速缓存加锁，可以理解为CPU指令级的一种锁。</p><p>​ 同时该指令会将当前处理器缓存行的数据直接写会到系统内存中，且这个写回内存的操作会使在其他CPU里缓存了该地址的数据无效。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      并发面试题总结
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="面试题" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="面试题" scheme="http://www.baiyp.ren/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized锁优化</title>
    <link href="http://www.baiyp.ren/Synchronized%E9%94%81%E4%BC%98%E5%8C%96.html"/>
    <id>http://www.baiyp.ren/Synchronized锁优化.html</id>
    <published>2019-09-07T01:11:04.000Z</published>
    <updated>2019-09-08T14:18:08.409Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="Synchronized锁优化"><a href="#Synchronized锁优化" class="headerlink" title="Synchronized锁优化"></a>Synchronized锁优化</h2><blockquote><p>jdk1.6对锁的实现引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销。<br>锁主要存在四中状态，依次是：<strong>无锁</strong>-&gt; <strong>偏向锁</strong> -&gt; <strong>轻量级锁</strong> -&gt; <strong>重量级锁</strong>，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p></blockquote><p><img src="../images/thread/synchronized/synchronized010.png" alt></p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>​ 线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说是一件负担很重的工作，势必会给系统的并发性能带来很大的压力。同时我们发现在许多应用上面，对象锁的锁状态只会持续很短一段时间，为了这一段很短的时间频繁地阻塞和唤醒线程是非常不值得的。所以引入自旋锁。</p><p><strong>何谓自旋锁？</strong><br>所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋），和CAS类似。<br>自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。所以说，自旋等待的时间（自旋的次数）必须要有一个限度，如果自旋超过了定义的时间仍然没有获取到锁，则应该被挂起。<br>自旋锁在JDK 1.4.2中引入，默认关闭，但是可以使用-XX:+UseSpinning开开启，在JDK1.6中默认开启。同时自旋的默认次数为10次，可以通过参数-XX:PreBlockSpin来调整；<br>如果通过参数-XX:preBlockSpin来调整自旋锁的自旋次数，会带来诸多不便。假如我将参数调整为10，但是系统很多线程都是等你刚刚退出的时候就释放了锁（假如你多自旋一两次就可以获取锁），你是不是很尴尬。于是JDK1.6引入自适应的自旋锁，让虚拟机会变得越来越聪明。</p><h4 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h4><p>​ JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。<br>​ 有了自适应自旋锁，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测会越来越准确，虚拟机会变得越来越聪明。</p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>​ 为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。<br>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如StringBuffer的append()方法，Vector的add()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">vectorTest</span><span class="params">()</span></span>&#123;</span><br><span class="line">       Vector&lt;String&gt; vector = <span class="keyword">new</span> Vector&lt;String&gt;();</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i++)&#123;</span><br><span class="line">           vector.add(i + <span class="string">""</span>);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       System.out.println(vector);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在运行这段代码时，JVM可以明显检测到变量vector没有逃逸出方法vectorTest()之外，所以JVM可以大胆地将vector内部的加锁操作消除。</p><h6 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h6><p>如果证明一个对象不会逃逸方法外或者线程外，则可针对此变量进行优化：</p><p>同步消除synchronization Elimination，如果一个对象不会逃逸出线程，则对此变量的同步措施可消除。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>​ 我们知道在使用同步锁的时候，需要让同步块的作用范围尽可能小—仅在共享数据的实际作用域中才进行同步，这样做的目的是为了使需要同步的操作数量尽可能缩小，如果存在锁竞争，那么等待锁的线程也能尽快拿到锁。<br>​ 在大多数的情况下，上述观点是正确的，LZ也一直坚持着这个观点。但是如果一系列的连续加锁解锁操作，可能会导致不必要的性能损耗，所以引入锁粗话的概念。<br>锁粗话概念比较好理解，就是将多个连续的加锁、解锁操作连接在一起，扩展成一个范围更大的锁。如下面的例子，一个方法由两个加锁,因为num = x + y;耗时较短，对比两次锁短的多，就会锁粗化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 因为一个方法需要两个加锁解锁耗费资源</span></span><br><span class="line"><span class="comment">    * 对于  num = x + y; 耗费时间很短 就会将</span></span><br><span class="line"><span class="comment">    * 代码包裹进去组成一个锁</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lockCoarsening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">//对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           x++;</span><br><span class="line">           <span class="comment">//todo 处理部分业务</span></span><br><span class="line">       &#125;</span><br><span class="line">       num = x + y;</span><br><span class="line">       <span class="comment">//对象锁</span></span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           y++;</span><br><span class="line">           <span class="comment">//todo 处理部分业务</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> num;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>粗化后</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> x, y;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 使用一个锁</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lockCoarsening</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">      <span class="comment">//只进行一次加锁解锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">          x++;</span><br><span class="line">          <span class="comment">//todo 处理部分业务</span></span><br><span class="line">          num = x + y;</span><br><span class="line">          y++;</span><br><span class="line">          <span class="comment">//todo 处理部分业务</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> num;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><blockquote><p>​ 引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁。</p></blockquote><p><img src="../images/thread/synchronized/synchronized02.png" alt></p><h5 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h5><ol><li><p>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</p></li><li><p>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</p></li><li><p>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；</p></li></ol><h5 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h5><blockquote><p>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p></blockquote><ol><li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li><li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li><li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li></ol><p>对于轻量级锁，其性能提升的依据是“对于绝大部分的锁，在整个生命周期内都是不会存在竞争的”，如果打破这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程竞争的情况下，轻量级锁比重量级锁更慢；</p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><blockquote><p>引入偏向锁主要目的是：为了在无多线程竞争的情况下尽量减少不必要的轻量级锁执行路径。上面提到了轻量级锁的加锁解锁操作是需要依赖多次CAS原子指令的。那么偏向锁是如何来减少不必要的CAS操作呢？我们可以查看Mark work的结构就明白了。只需要检查是否为偏向锁、锁标识为以及ThreadID即可</p></blockquote><p><img src="../images/thread/synchronized/synchronized03.png" alt></p><p>获取锁</p><ol><li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li><li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li><li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li><li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li><li>执行同步代码块</li></ol><p>释放锁<br>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：</p><ol><li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li><li>撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；</li></ol><h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p>​ 重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p><blockquote><p>为什么重量级锁的开销比较大呢</p></blockquote><p>​ 原因是当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现，也就是相当于从用户态转化到内核态，而转化状态是需要消耗时间的</p><h4 id="三种锁的区别"><a href="#三种锁的区别" class="headerlink" title="三种锁的区别"></a>三种锁的区别</h4><table><thead><tr><th>锁</th><th>优点</th><th>缺点</th><th>使用场景</th></tr></thead><tbody><tr><td>偏向锁</td><td>加锁和解锁不需要CAS，没有额外的性能消耗，和执行非同步方法相比，仅存在纳秒级的差距</td><td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</td><td>只有一个线程访问同步块或者同步方法的场景</td></tr><tr><td>轻量级锁</td><td>竞争的线程不会阻塞提高响应速度</td><td>若线程长时间抢不到锁，自旋会消耗CPU性能</td><td>线程交替执行同步块或者同步方法的场景</td></tr><tr><td>重量级锁</td><td>线程竞争不使用自旋，不消耗CPU</td><td>线程阻塞，响应时间缓慢,在多线程下,频繁的获取释放锁，会带来巨大的性能消耗</td><td>追求吞吐量，同步块或者同步方法执行时间较长的场景</td></tr></tbody></table><h3 id="锁升级"><a href="#锁升级" class="headerlink" title="锁升级"></a>锁升级</h3><p><strong>偏向锁升级轻量级锁</strong>：当一个对象持有偏向锁，一旦第二个线程访问这个对象，如果产生竞争，偏向锁升级为轻量级锁。</p><p><strong>轻量级锁升级重量级锁</strong>：一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p><h3 id="wait和notify的原理"><a href="#wait和notify的原理" class="headerlink" title="wait和notify的原理"></a>wait和notify的原理</h3><blockquote><p>调用wait方法，首先会获取监视器锁，获得成功以后，会让当前线程进入等待状态进入等待队列并且释放锁。</p><p>当其他线程调用notify后，会选择从等待队列中唤醒任意一个线程，而执行完notify方法以后，并不会立马唤醒线程，原因是当前的线程仍然持有这把锁，处于等待状态的线程无法获得锁。必须要等到当前的线程执行完按monitorexit指令以后，也就是锁被释放以后，处于等待队列中的线程就可以开始竞争锁了。</p></blockquote><p><strong>wait和notify为什么需要在synchronized里面？</strong></p><p>wait方法的语义有两个，<strong>一个是释放当前的对象锁、另一个是使得当前线程进入阻塞队列</strong>，而这些操作都和监视器是相关的，所以wait必须要获得一个监视器锁。</p><p>而对于notify来说也是一样，它是唤醒一个线程，既然要去唤醒，首先得知道它在哪里，所以就必须要找到这个对象获取到这个对象的锁，然后到这个对象的等待队列中去唤醒一个线程。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Synchronized锁优化
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/synchronized/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://www.baiyp.ren/tags/synchronized/"/>
    
      <category term="锁优化" scheme="http://www.baiyp.ren/tags/%E9%94%81%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>Synchronized实现原理</title>
    <link href="http://www.baiyp.ren/Synchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/Synchronized实现原理.html</id>
    <published>2019-09-07T01:11:04.000Z</published>
    <updated>2019-09-08T14:18:00.858Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="Synchronized实现原理"><a href="#Synchronized实现原理" class="headerlink" title="Synchronized实现原理"></a>Synchronized实现原理</h2><p><img src="../images/thread/synchronized/synchronized01.png" alt></p><h3 id="三种应用方式"><a href="#三种应用方式" class="headerlink" title="三种应用方式"></a>三种应用方式</h3><ol><li>修饰实例方法，作用于当前实例加锁，进入同步代码前要获得当前实例的锁。</li><li>修饰静态方法，作用于当前类对象加锁，进入同步代码前要获得当前类对象的锁。</li><li>修饰代码块，指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象。</li></ol><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>被 synchronized 修饰的代码在同一时间只能被一个线程访问，在锁未释放之前，无法被其他线程访问到。因此，在 Java 中可以使用 synchronized 来保证方法和代码块内的操作是原子性的。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>对一个变量解锁之前，必须先把此变量同步回主存中。这样解锁后，后续线程就可以访问到被修改后的值。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>synchronized 本身是无法禁止指令重排和处理器优化的，</p><p>as-if-serial 语义：不管怎么重排序（编译器和处理器为了提高并行度），单线程程序的执行结果都不能被改变。</p><p>编译器和处理器无论如何优化，都必须遵守 as-if-serial 语义。</p><p>synchronized 修饰的代码，同一时间只能被同一线程执行。所以，可以保证其有序性。</p><h4 id="可重入性"><a href="#可重入性" class="headerlink" title="可重入性"></a>可重入性</h4><p>​ 从互斥锁的设计上来说，当一个线程试图操作一个由其他线程持有的对象锁的临界资源时，将会处于阻塞状态，但当一个线程再次请求自己持有对象锁的临界资源时，这种情况属于重入锁，请求将会成功，在java中synchronized是基于原子性的内部锁机制，是可重入的，因此在一个线程调用synchronized方法的同时在其方法体内部调用该对象另一个synchronized方法，也就是说一个线程得到一个对象锁后再次请求该对象锁，是允许的，这就是synchronized的可重入性。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入到临界区，同时它还可以保证共享变量的内存可见性</p></blockquote><h4 id="字节码指令"><a href="#字节码指令" class="headerlink" title="字节码指令"></a>字节码指令</h4><p>​ synchronized同步块使用了monitorenter和monitorexit指令实现同步，这两个指令，本质上都是对一个对象的监视器(monitor)进行获取，这个过程是排他的，也就是说同一时刻只能有一个线程获取到由synchronized所保护对象的监视器。</p><p>​ 线程执行到monitorenter指令时，会尝试获取对象所对应的monitor所有权，也就是尝试获取对象的锁，而执行monitorexit，就是释放monitor的所有权。</p><h4 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h4><p><strong>当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中</strong></p><p><strong>当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量</strong></p><p><strong>所以锁的释放-获取和volatile的写-读具有相同的内存语义。volatile可以看过轻量级的锁，</strong></p><p>小结下：</p><ul><li>A释放锁 ，即 A向后来将拿锁的线程B发送一个消息</li><li>B拿锁，即B接收了之前释放锁的线程A的一个消息</li><li>A释放锁、B拿锁，其实就是A向B发送个消息。</li></ul><h3 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h3><p>Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：</p><ol><li>普通同步方法，锁是当前实例对象</li><li>静态同步方法，锁是当前类的class对象</li><li>同步方法块，锁是括号里面的对象</li></ol><p>当一个线程访问同步代码块时，它首先是需要得到锁才能执行同步代码，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用javap工具查看生成的class文件信息来分析Synchronize的实现</p><p><img src="../images/thread/synchronized/synchronized09.jpg" alt></p><p>从上面可以看出，同步代码块是使用<strong>monitorenter</strong>和<strong>monitorexit</strong>指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的ACC_SYNCHRONIZED实现。<br><strong>同步代码块</strong>：monitorenter指令插入到同步代码块的开始位置，monitorexit指令插入到同步代码块的结束位置，JVM需要保证每一个monitorenter都有一个monitorexit与之相对应。任何对象都有一个monitor与之相关联，当且一个monitor被持有之后，他将处于锁定状态。线程执行到monitorenter指令时，将会尝试获取对象所对应的monitor所有权，即尝试获取对象的锁；<br><strong>同步方法</strong>：synchronized方法则会被翻译成普通的方法调用和返回指令如:invokevirtual、areturn指令，在VM字节码层面并没有任何特别的指令来实现被synchronized修饰的方法，而是在Class文件的方法表中将该方法的access_flags字段中的synchronized标志位置1，表示该方法是同步方法并使用调用该方法的对象或该方法所属的Class在JVM的内部对象表示Klass做为锁对象</p><p>下面我们来继续分析，但是在深入之前我们需要了解两个重要的概念：Java对象头，Monitor。</p><h4 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h4><blockquote><p>在Hotspot虚拟机中，对象在内存中的布局分为三块区域：对象头（Mark Word、Class Metadata Address）、实例数据和对齐填充；Java对象头是实现synchronized的锁对象的基础。一般而言，synchronized使用的锁对象是存储在Java对象头里。它是轻量级锁和偏向锁的关键。</p></blockquote><p><img src="../images/thread/synchronized/synchronized05.jpg" alt></p><h5 id="Mark-Word"><a href="#Mark-Word" class="headerlink" title="Mark Word"></a>Mark Word</h5><blockquote><p>Mark Word用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等等。Java对象头一般占有两个机器码（在32位虚拟机中，1个机器码等于4字节，也就是32bit）。</p></blockquote><p><img src="../images/thread/synchronized/synchronized04.png" alt></p><h5 id="Class-Metadata-Address"><a href="#Class-Metadata-Address" class="headerlink" title="Class Metadata Address"></a>Class Metadata Address</h5><blockquote><p>类型指针，即是对象指向它的类的元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。</p></blockquote><h5 id="Array-length"><a href="#Array-length" class="headerlink" title="Array length"></a>Array length</h5><blockquote><p>如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据。</p></blockquote><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><blockquote><p>我们可以把它理解为一个同步工具，也可以描述为一种同步机制，它通常被描述为一个对象。与一切皆对象一样，所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者Monitor锁。Monitor 是线程私有的数据结构，每一个线程都有一个可用monitor record列表，同时还有一个全局的可用列表。每一个被锁住的对象都会和一个monitor关联（对象头的MarkWord中的LockWord指向monitor的起始地址），同时monitor中有一个Owner字段存放拥有该锁的线程的唯一标识，表示该锁被这个线程占用。其结构如下：</p></blockquote><p><img src="../images/thread/synchronized/synchronized06.png" alt></p><ul><li><strong>Owner</strong>：初始时为NULL表示当前没有任何线程拥有该monitor record，当线程成功拥有该锁后保存线程唯一标识，当锁被释放时又设置为NULL；</li><li><strong>EntryQ</strong>:关联一个系统互斥锁（semaphore），阻塞所有试图锁住monitor record失败的线程。</li><li><strong>RcThis</strong>:表示blocked或waiting在该monitor record上的所有线程的个数。</li><li><strong>Nest</strong>:用来实现重入锁的计数。</li><li><strong>HashCode</strong>:保存从对象头拷贝过来的HashCode值（可能还包含GC age）。</li><li><strong>Candidate</strong>:用来避免不必要的阻塞或等待线程唤醒，因为每一次只有一个线程能够成功拥有锁，如果每次前一个释放锁的线程唤醒所有正在阻塞或等待的线程，会引起不必要的上下文切换（从阻塞到就绪然后因为竞争锁失败又被阻塞）从而导致性能严重下降。Candidate只有两种可能的值0表示没有需要唤醒的线程1表示要唤醒一个继任线程来竞争锁。</li></ul><p>在hotspot虚拟机中，通过ObjectMonitor类来实现monitor。</p><p><img src="../images/thread/synchronized/synchronized07.png" alt></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      Synchronized实现原理
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/synchronized/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="synchronized" scheme="http://www.baiyp.ren/tags/synchronized/"/>
    
      <category term="实现原理" scheme="http://www.baiyp.ren/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-03缓存模块</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-03%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-03缓存模块.html</id>
    <published>2019-09-04T08:58:57.000Z</published>
    <updated>2019-09-09T07:36:52.662Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS缓存模块"><a href="#MYBATIS缓存模块" class="headerlink" title="MYBATIS缓存模块"></a>MYBATIS缓存模块</h2><p><img src="../images/mybatis/cache02.png" alt></p><h3 id="mybatis缓存"><a href="#mybatis缓存" class="headerlink" title="mybatis缓存"></a>mybatis缓存</h3><p>​ MyBatis作为一个强大的持久层框架，缓存是其必不可少的功能之一，MyBatis中的缓存是两层结构的，分为一级缓存，二级缓存，但本质上市相同的，它们使用的都是Cache接口的实现。</p><p>​ MyBatis缓存的实现是基于Map的，从缓存里面读写数据是缓存模块的核心基础功能</p><p>​ 除核心功能之外，有很多额外的附加功能，如：防止缓存击穿，添加缓存情况策略（fifo、LRU），序列化功能，日志能力和定时清空能力等</p><p>​ 附加功能可以以任意的组合附加到核心基础功能之上</p><h4 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h4><blockquote><p>mybatis 缓存模块使用了装饰器模式</p></blockquote><p>​ Mybatis缓存的核心模块就是在缓存中读写数据，但是除了在缓存中读写数据wait，还有其他的附加功能，这些附加功能可以任意的加在缓存这个核心功能上。</p><p>​ 加载附加功能可以有很多种方法，动态代理或者继承都可以实现，但是附加功能存在多种组合，用这两种方法，会导致生成大量的子类，所以mybatis选择使用装饰器模式.(灵活性、扩展性)</p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>Mybatis 数据源的实现主要是在 cache包：</p><img src="../images/mybatis/cache01.jpg" style="zoom:50%"><p>​</p><h3 id="Cache-接口"><a href="#Cache-接口" class="headerlink" title="Cache 接口"></a>Cache 接口</h3><blockquote><p>一级缓存和二级缓存都是通过cache接口来实现的</p><p>Cache 接口是缓存模块的核心接口，定义了缓存的基本操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存核心接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存ID</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">String <span class="title">getId</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 根据Key获取缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">getObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 删除缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">Object <span class="title">removeObject</span><span class="params">(Object key)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存大小</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取读写锁</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> A ReadWriteLock</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">default</span> ReadWriteLock <span class="title">getReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存实现类PerpetualCache"><a href="#缓存实现类PerpetualCache" class="headerlink" title="缓存实现类PerpetualCache"></a>缓存实现类PerpetualCache</h3><blockquote><p>在缓存模块使用了装饰器模式PerpetualCache在其中扮演ConcreteComponent 角色，使用 HashMap来实现 cache 的相关操作</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存的核心实现类</span></span><br><span class="line"><span class="comment"> * 在装饰者模式中扮演了 ConcreteComponent(具体组件) 角色</span></span><br><span class="line"><span class="comment"> * 使用HashMao实现了缓存</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PerpetualCache</span> <span class="keyword">implements</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓存的ID</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String id;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 缓存的主体对象 hashMap</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;Object, Object&gt; cache = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> id</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PerpetualCache</span><span class="params">(String id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.id = id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> id;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存的大小</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.size();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 涉资缓存</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key 缓存key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value 缓存的Value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">putObject</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    cache.put(key, value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取缓存</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">getObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 删除缓存</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key The key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">removeObject</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cache.remove(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空缓存</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cache.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == o) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(o <span class="keyword">instanceof</span> Cache)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Cache otherCache = (Cache) o;</span><br><span class="line">    <span class="keyword">return</span> getId().equals(otherCache.getId());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (getId() == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> CacheException(<span class="string">"Cache instances require an ID."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getId().hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存项CacheKey"><a href="#缓存项CacheKey" class="headerlink" title="缓存项CacheKey"></a>缓存项CacheKey</h3><blockquote><p>为什么需要一个复杂的对象表示缓存项的key？通常来说表示一个对象的key可以用一个String对象，为什么不可以吗？</p></blockquote><p>​ 在cache中唯一确定一个缓存项需要使用缓存项的key，Mybatis中因为涉及到动态SQL等多方面因素，其缓存项的key不等仅仅通过一个String表示，所以MyBatis 提供了CacheKey类来表示缓存项的key，在一个CacheKey对象中可以封装多个影响缓存项的因素。</p><p>​ 怎么样的查询条件算和上一次查询是一样的查询，从而返回同样的结果回去？这个问题，得从CacheKey说起。<br>我们先看一下CacheKey的数据结构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 缓存项cacheKey</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheKey</span> <span class="keyword">implements</span> <span class="title">Cloneable</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1146682552656046210L</span>;</span><br><span class="line">  <span class="comment">//定义为Null的缓存key</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> CacheKey NULL_CACHE_KEY = <span class="keyword">new</span> NullCacheKey();</span><br><span class="line">  <span class="comment">//默认的乘数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MULTIPLYER = <span class="number">37</span>;</span><br><span class="line">  <span class="comment">//默认的hashCode</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_HASHCODE = <span class="number">17</span>;</span><br><span class="line">  <span class="comment">//定义乘数变量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> multiplier;</span><br><span class="line">  <span class="comment">//hashCode</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> hashcode;</span><br><span class="line">  <span class="comment">//校验码</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checksum;</span><br><span class="line">  <span class="comment">//统计</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">  <span class="comment">//更新列表</span></span><br><span class="line">  <span class="keyword">private</span> List&lt;Object&gt; updateList;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置hashCode</span></span><br><span class="line">    <span class="keyword">this</span>.hashcode = DEFAULT_HASHCODE;</span><br><span class="line">    <span class="comment">//设置乘数</span></span><br><span class="line">    <span class="keyword">this</span>.multiplier = DEFAULT_MULTIPLYER;</span><br><span class="line">    <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//更新列表 为空的list</span></span><br><span class="line">    <span class="keyword">this</span>.updateList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> objects 需要缓存的数据</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">CacheKey</span><span class="params">(Object[] objects)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//调用空的构造方法初始化缓存key</span></span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    <span class="comment">//更新所有数据</span></span><br><span class="line">    updateAll(objects);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h4><blockquote><p>其中最重要的是<strong>第41行</strong>的updateList这个属性，为什么这么说，因为HashMap的Key是CacheKey，而HashMap的get方法是先判断hashCode，在hashCode冲突的情况下再进行equals判断，因此最终无论如何都会进行一次equals的判断。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 生成的equals方法</span></span><br><span class="line"><span class="comment">   * &lt;p&gt;</span></span><br><span class="line"><span class="comment">   * 如果是CacheKey</span></span><br><span class="line"><span class="comment">   * 先比较CacheKey的hashCode</span></span><br><span class="line"><span class="comment">   * 一样在比较 校验码</span></span><br><span class="line"><span class="comment">   * 还一样比较更新次数</span></span><br><span class="line"><span class="comment">   * 还是一样比较更新的每个值的hashCode</span></span><br><span class="line"><span class="comment">   * 保证每一个比较的一致性</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> == object) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(object <span class="keyword">instanceof</span> CacheKey)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> CacheKey cacheKey = (CacheKey) object;</span><br><span class="line">    <span class="comment">//比较cachekey的hashCode</span></span><br><span class="line">    <span class="keyword">if</span> (hashcode != cacheKey.hashcode) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较校验码</span></span><br><span class="line">    <span class="keyword">if</span> (checksum != cacheKey.checksum) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较更新次数</span></span><br><span class="line">    <span class="keyword">if</span> (count != cacheKey.count) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//比较每个值的hashCode</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; updateList.size(); i++) &#123;</span><br><span class="line">      Object thisObject = updateList.get(i);</span><br><span class="line">      Object thatObject = cacheKey.updateList.get(i);</span><br><span class="line">      <span class="keyword">if</span> (!ArrayUtil.equals(thisObject, thatObject)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>进行equals的时候经过了几次比较</p><ul><li>对象不为空</li><li>对象是CacheKey类型</li><li>cacheKey的hashcode一致</li><li>cacheKey的校验码checksum一致</li><li>cacheKey的更新次数count一致</li><li>updateList列表中每一个数据的hashCode一致</li></ul><p>经过这样负责的比较，保证每一个cacheKey是完全一致才会计算equals一致。</p><h4 id="更新方法update"><a href="#更新方法update" class="headerlink" title="更新方法update"></a>更新方法update</h4><h5 id="如何生产hashcode"><a href="#如何生产hashcode" class="headerlink" title="如何生产hashcode"></a>如何生产hashcode</h5><p>17是质子数中一个“不大不小”的存在，如果你使用的是一个如2的较小质数，<br>那么得出的乘积会在一个很小的范围，很容易造成哈希值的冲突。<br>而如果选择一个100以上的质数，得出的哈希值会超出int的最大范围，这两种都不合适。<br>而如果对超过 50,000 个英文单词（由两个不同版本的 Unix 字典合并而成）进行 hash code 运算，<br>并使用常数 31, 33, 37, 39 和 41 作为乘子（cachekey使用37），每个常数算出的哈希值冲突数都小于7个（国外大神做的测试），<br>那么这几个数就被作为生成hashCode值得备选乘数了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 更新数据</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">  <span class="comment">//获取hashCode 为null 则hashCode是1 否则是计算出来的hash值</span></span><br><span class="line">  <span class="keyword">int</span> baseHashCode = object == <span class="keyword">null</span> ? <span class="number">1</span> : ArrayUtil.hashCode(object);</span><br><span class="line">  <span class="comment">//统计更新次数</span></span><br><span class="line">  count++;</span><br><span class="line">  <span class="comment">//校验码更新</span></span><br><span class="line">  checksum += baseHashCode;</span><br><span class="line">  <span class="comment">//计算对象初始的hashCode 防止hash冲突</span></span><br><span class="line">  baseHashCode *= count;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * hashCode更新方法</span></span><br><span class="line"><span class="comment">   * newHashCode = oldHashCode*乘数(31,33,37,39,41)中选择一个+ObjectHashCode</span></span><br><span class="line"><span class="comment">   * 每次迭代乘以 乘数</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  hashcode = multiplier * hashcode + baseHashCode;</span><br><span class="line">  <span class="comment">//将缓存对象添加到更新列表</span></span><br><span class="line">  updateList.add(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="缓存增强"><a href="#缓存增强" class="headerlink" title="缓存增强"></a>缓存增强</h3><blockquote><p>PerpetualCache是基类，其它实现的Cache的类都是对基类的扩<br>展，也就是装饰来包裹真实的对象。扩展了类的功能，也可以说是附加了一些方法。使得具有很好的灵活性</p></blockquote><p><img src="../images/mybatis/cache03.png" alt></p><p>用于装饰PerpetualCache的标准装饰器共有8个（全部在 org.apache.ibatis.cache.decorators包中）：</p><ul><li><p>BlockingCache：是阻塞版本的缓存装饰器，它保证只有一个线程到数据库中查找指定key对应的数据。</p></li><li><p>FifoCache：先进先出算法，缓存回收策略</p></li><li><p>LoggingCache：输出缓存命中的日志信息</p></li><li><p>LruCache：最近最少使用算法，缓存回收策略</p></li><li><p>ScheduledCache：调度缓存，负责定时清空缓存</p></li><li><p>SerializedCache：缓存序列化和反序列化存储</p></li><li><p>SoftCache：基于软引用实现的缓存管理策略</p></li><li><p>SynchronizedCache：同步的缓存装饰器，用于防止多线程并发访问</p></li><li><p>WeakCache：基于弱引用实现的缓存管理策略</p></li><li><p>TransactionalCache：事务性的缓存</p></li></ul><h3 id="一级缓存和二级缓存"><a href="#一级缓存和二级缓存" class="headerlink" title="一级缓存和二级缓存"></a>一级缓存和二级缓存</h3><ul><li>一级缓存，又叫本地缓存，是PerpetualCache类型的永久缓存，保存在执行器中<br>(BaseExecutor)，而执行器又在SqlSession(DefaultSqlSession)中，所以<br>一级缓存的生命周期与SqlSession是相同的。</li><li>二级缓存，又叫自定义缓存，实现了Cache接口的类都可以作为二级缓存，所以可配<br>置如encache等的第三方缓存。二级缓存以namespace名称空间为其唯一标识，被保<br>存在Configuration核心配置对象中</li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><blockquote><p>二级缓存对象的默认类型为PerpetualCache，如果配置的缓存是默认类型，则mybatis<br>会根据配置自动追加一系列装饰器。</p></blockquote><h5 id="Cache对象之间的引用顺序"><a href="#Cache对象之间的引用顺序" class="headerlink" title="Cache对象之间的引用顺序"></a>Cache对象之间的引用顺序</h5><blockquote><p>SynchronizedCache–&gt;LoggingCache–&gt;SerializedCache–&gt;ScheduledCache–&gt;LruCache–&gt;PerpetualCache</p></blockquote><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis缓存模块
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="缓存模块" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="缓存模块" scheme="http://www.baiyp.ren/tags/%E7%BC%93%E5%AD%98%E6%A8%A1%E5%9D%97/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-02数据库连接池</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-02%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0%20-%20%E5%89%AF%E6%9C%AC.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-02数据库连接池 - 副本.html</id>
    <published>2019-09-04T08:58:57.000Z</published>
    <updated>2019-09-08T14:17:40.647Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS数据库连接池"><a href="#MYBATIS数据库连接池" class="headerlink" title="MYBATIS数据库连接池"></a>MYBATIS数据库连接池</h2><h3 id="什么是数据库连接池"><a href="#什么是数据库连接池" class="headerlink" title="什么是数据库连接池"></a>什么是数据库连接池</h3><p>​ 数据库连接池负责分配、管理和释放数据库连接，它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个；释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏。这项技术能明显提高对数据库操作的性能。</p><p>​ 在使用 Mybatis 的时候，数据库的连接一般都会使用第三方的数据源组件，如 C3P0，DBCP 和 Druid 等，其实 Mybatis 也有自己的数据源实现，可以连接数据库，还有连接池的功能，下面就来看看 Mybatis 自己实现的数据源头和连接池的一个实现原理。</p><h3 id="类结构"><a href="#类结构" class="headerlink" title="类结构"></a>类结构</h3><p>Mybatis 数据源的实现主要是在 datasource 包：</p><p><img src="../images/mybatis/pool01.jpg" alt></p><p>​ 我们常见的数据库连接池都需要实现javax.sql.DataSource接口mybatis提供了UnpooledDataSource和PooledDataSource的实现， 一个使用连接池，一个不使用连接池此外，对于这两个类，Mybatis 还提供了两个工厂类进行创建对象，是工厂方法模式的一个应用，首先来看下它们的一个类图：</p><p><img src="../images/mybatis/pool02.jpg" alt></p><p>我们先看下工厂类</p><h3 id="DataSourceFactory"><a href="#DataSourceFactory" class="headerlink" title="DataSourceFactory"></a>DataSourceFactory</h3><blockquote><p>数据源连接池工厂类接口</p></blockquote><p>该类是 JndiDataSourceFactory 和 UnpooledDataSourceFactory 两个工厂类的顶层接口，只定义了两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 数据源连接池 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置属性</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> props</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties props)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取数据源连接池</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function">DataSource <span class="title">getDataSource</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UnpooledDataSourceFactory"><a href="#UnpooledDataSourceFactory" class="headerlink" title="UnpooledDataSourceFactory"></a>UnpooledDataSourceFactory</h3><blockquote><p>UnpooledDataSourceFactory 主要用来创建 UnpooledDataSource 对象，它会在构造方法中初始化 UnpooledDataSource 对象，并在 setProperties 方法中完成对 UnpooledDataSource 对象的配置</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * UnpooledDataSource 连接工厂</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSourceFactory</span> <span class="keyword">implements</span> <span class="title">DataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数据库驱动前缀</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DRIVER_PROPERTY_PREFIX = <span class="string">"driver."</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DRIVER_PROPERTY_PREFIX_LENGTH = DRIVER_PROPERTY_PREFIX.length();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对应的数据源，即 UnpooledDataSource</span></span><br><span class="line">  <span class="keyword">protected</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//构造方法</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 对数据源 UnpooledDataSource 进行配置</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> properties</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProperties</span><span class="params">(Properties properties)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//数据源属性文件</span></span><br><span class="line">    Properties driverProperties = <span class="keyword">new</span> Properties();</span><br><span class="line">    <span class="comment">// 创建 DataSource 相应的 MetaObject</span></span><br><span class="line">    MetaObject metaDataSource = SystemMetaObject.forObject(dataSource);</span><br><span class="line">    <span class="comment">// 遍历 properties 集合，该集合中存放了数据源需要的信息</span></span><br><span class="line">    <span class="keyword">for</span> (Object key : properties.keySet()) &#123;</span><br><span class="line">      String propertyName = (String) key;</span><br><span class="line">      <span class="comment">// 以 "driver." 开头的配置项是对 DataSource 的配置，记录到 driverProperties  中</span></span><br><span class="line">      <span class="keyword">if</span> (propertyName.startsWith(DRIVER_PROPERTY_PREFIX)) &#123;</span><br><span class="line">        String value = properties.getProperty(propertyName);</span><br><span class="line">        <span class="comment">//设置连接的属性和值</span></span><br><span class="line">        driverProperties.setProperty(propertyName.substring(DRIVER_PROPERTY_PREFIX_LENGTH), value);</span><br><span class="line">        <span class="comment">// 该属性是否有 set 方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (metaDataSource.hasSetter(propertyName)) &#123;</span><br><span class="line">        <span class="comment">// 获取对应的属性值</span></span><br><span class="line">        String value = (String) properties.get(propertyName);</span><br><span class="line">        <span class="comment">// 根据属性类型进行类型的转换，主要是 Integer, Long, Boolean 三种类型的转换</span></span><br><span class="line">        Object convertedValue = convertValue(metaDataSource, propertyName, value);</span><br><span class="line">        <span class="comment">// 设置DataSource 的相关属性值</span></span><br><span class="line">        metaDataSource.setValue(propertyName, convertedValue);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> DataSourceException(<span class="string">"Unknown DataSource property: "</span> + propertyName);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 DataSource.driverProerties 属性值</span></span><br><span class="line">    <span class="keyword">if</span> (driverProperties.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      metaDataSource.setValue(<span class="string">"driverProperties"</span>, driverProperties);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回数据源</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> DataSource <span class="title">getDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dataSource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 类型转</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> Object <span class="title">convertValue</span><span class="params">(MetaObject metaDataSource, String propertyName, String value)</span> </span>&#123;</span><br><span class="line">    Object convertedValue = value;</span><br><span class="line">    Class&lt;?&gt; targetType = metaDataSource.getSetterType(propertyName);</span><br><span class="line">    <span class="keyword">if</span> (targetType == Integer.class || targetType == <span class="keyword">int</span>.class) &#123;</span><br><span class="line">      convertedValue = Integer.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Long.class || targetType == <span class="keyword">long</span>.class) &#123;</span><br><span class="line">      convertedValue = Long.valueOf(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (targetType == Boolean.class || targetType == <span class="keyword">boolean</span>.class) &#123;</span><br><span class="line">      convertedValue = Boolean.valueOf(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> convertedValue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JndiDataSourceFactory 依赖 JNDI 服务器中获取用户配置的 DataSource，这里可以不看。</p></blockquote><p>UnpooledDataSourceFactory工厂类主要的作用是对数据源进行配置。</p><h3 id="PooledDataSourceFactory"><a href="#PooledDataSourceFactory" class="headerlink" title="PooledDataSourceFactory"></a>PooledDataSourceFactory</h3><blockquote><p>PooledDataSourceFactory 主要用来创建 PooledDataSource 对象，它继承了 UnpooledDataSource 类，设置 DataSource 参数的方法复用UnpooledDataSource 中的 setProperties 方法，只是数据源返回的是 PooledDataSource 对象而已。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池工厂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSourceFactory</span> <span class="keyword">extends</span> <span class="title">UnpooledDataSourceFactory</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建连接池对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>以上这些就是 Mybatis 用来创建数据源的工厂类，下面就来看下数据源的主要实现。</p></blockquote><h3 id="UnpooledDataSource"><a href="#UnpooledDataSource" class="headerlink" title="UnpooledDataSource"></a>UnpooledDataSource</h3><blockquote><p>UnpooledDataSource 不使用连接池来创建数据库连接，每次获取数据库连接时都会创建一个新的连接进行返回；</p></blockquote><h4 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h4><blockquote><p>在static静态块中进行驱动注册</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未使用连接池的类</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnpooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 加载 Driver 类的类加载器</span></span><br><span class="line">  <span class="keyword">private</span> ClassLoader driverClassLoader;</span><br><span class="line">  <span class="comment">// 数据库连接驱动的相关配置</span></span><br><span class="line">  <span class="keyword">private</span> Properties driverProperties;</span><br><span class="line">  <span class="comment">// 缓存所有已注册的数据库连接驱动</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Driver&gt; registeredDrivers = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">//数据源配置相关</span></span><br><span class="line">  <span class="keyword">private</span> String driver;</span><br><span class="line">  <span class="keyword">private</span> String url;</span><br><span class="line">  <span class="keyword">private</span> String username;</span><br><span class="line">  <span class="keyword">private</span> String password;</span><br><span class="line">  <span class="comment">// 是否自动提交</span></span><br><span class="line">  <span class="keyword">private</span> Boolean autoCommit;</span><br><span class="line">  <span class="comment">//默认事务隔离级别</span></span><br><span class="line">  <span class="keyword">private</span> Integer defaultTransactionIsolationLevel;</span><br><span class="line">  <span class="comment">//默认超时时间</span></span><br><span class="line">  <span class="keyword">private</span> Integer defaultNetworkTimeout;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  静态块，在初始化的时候，从 DriverManager 中获取所有的已注册的驱动信息，并缓存到该类的 registeredDrivers集合中</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//获取驱动信息</span></span><br><span class="line">    Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();</span><br><span class="line">    <span class="keyword">while</span> (drivers.hasMoreElements()) &#123;</span><br><span class="line">      Driver driver = drivers.nextElement();</span><br><span class="line">      <span class="comment">//注册进集合中</span></span><br><span class="line">      registeredDrivers.put(driver.getClass().getName(), driver);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 无参构造</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.username = username;</span><br><span class="line">    <span class="keyword">this</span>.password = password;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">UnpooledDataSource</span><span class="params">(String driver, String url, Properties driverProperties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.driver = driver;</span><br><span class="line">    <span class="keyword">this</span>.url = url;</span><br><span class="line">    <span class="keyword">this</span>.driverProperties = driverProperties;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取一个连接"><a href="#获取一个连接" class="headerlink" title="获取一个连接"></a>获取一个连接</h4><blockquote><p>这里面没有提供连接销毁的方法，在连接池中有销毁连接的方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line"> * 获取一个连接</span><br><span class="line"> *</span><br><span class="line"> * <span class="meta">@return</span> 连接对象</span><br><span class="line"> * <span class="meta">@throws</span> SQLException</span><br><span class="line"> */</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(username, password);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个数据库连接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">  <span class="keyword">if</span> (driverProperties != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.putAll(driverProperties);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置用户</span></span><br><span class="line">  <span class="keyword">if</span> (username != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.setProperty(<span class="string">"user"</span>, username);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置密码</span></span><br><span class="line">  <span class="keyword">if</span> (password != <span class="keyword">null</span>) &#123;</span><br><span class="line">    props.setProperty(<span class="string">"password"</span>, password);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> doGetConnection(props);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建一个连接对象</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> properties 数据库属性文件</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 数据库连接</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Connection <span class="title">doGetConnection</span><span class="params">(Properties properties)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//初始化驱动信息</span></span><br><span class="line">  initializeDriver();</span><br><span class="line">  <span class="comment">// 通过 DriverManager 来获取一个数据库连接</span></span><br><span class="line">  Connection connection = DriverManager.getConnection(url, properties);</span><br><span class="line">  <span class="comment">//配置连接信息</span></span><br><span class="line">  configureConnection(connection);</span><br><span class="line">  <span class="keyword">return</span> connection;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化驱动信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initializeDriver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">// 如果当前的驱动还没有注册，则进行注册</span></span><br><span class="line">  <span class="keyword">if</span> (!registeredDrivers.containsKey(driver)) &#123;</span><br><span class="line">    Class&lt;?&gt; driverType;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//驱动的类加载器不为空</span></span><br><span class="line">      <span class="keyword">if</span> (driverClassLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//获取驱动类型</span></span><br><span class="line">        driverType = Class.forName(driver, <span class="keyword">true</span>, driverClassLoader);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driverType = Resources.classForName(driver);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// DriverManager requires the driver to be loaded via the system ClassLoader.</span></span><br><span class="line">      <span class="comment">// http://www.kfu.com/~nsayer/Java/dyn-jdbc.html</span></span><br><span class="line">      <span class="comment">//创建驱动</span></span><br><span class="line">      Driver driverInstance = (Driver) driverType.newInstance();</span><br><span class="line">      <span class="comment">//向JDBC注册驱动</span></span><br><span class="line">      DriverManager.registerDriver(<span class="keyword">new</span> DriverProxy(driverInstance));</span><br><span class="line">      <span class="comment">//向registeredDrivers注册驱动</span></span><br><span class="line">      registeredDrivers.put(driver, driverInstance);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error setting driver on UnpooledDataSource. Cause: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置数据库连接信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureConnection</span><span class="params">(Connection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="comment">//设置超时时间</span></span><br><span class="line">  <span class="keyword">if</span> (defaultNetworkTimeout != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conn.setNetworkTimeout(Executors.newSingleThreadExecutor(), defaultNetworkTimeout);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置是否自动提交</span></span><br><span class="line">  <span class="keyword">if</span> (autoCommit != <span class="keyword">null</span> &amp;&amp; autoCommit != conn.getAutoCommit()) &#123;</span><br><span class="line">    conn.setAutoCommit(autoCommit);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//设置事务隔离等级</span></span><br><span class="line">  <span class="keyword">if</span> (defaultTransactionIsolationLevel != <span class="keyword">null</span>) &#123;</span><br><span class="line">    conn.setTransactionIsolation(defaultTransactionIsolationLevel);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 以上代码就是 UnpooledDataSource 类的主要实现逻辑，每次获取连接都是从数据库新创建一个连接进行返回，又因为，数据库连接的创建是一个耗时的操作，且数据库连接是非常珍贵的资源，如果每次获取连接都创建一个，则可能会造成系统的瓶颈，拖垮响应速度等，这时就需要数据库连接池了，Mybatis 也提供了自己数据库连接池的实现，就是 PooledDataSource 类。</p><h3 id="PooledDataSource"><a href="#PooledDataSource" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><blockquote><p>PooledDataSource 是一个比较复杂的类，PooledDataSource 新创建数据库连接是使用 UnpooledDataSource 来实现的，且 PooledDataSource 并不会管理 java.sql.Connection 对象，而是管理 PooledConnection 对象，在 PooledConnection 中封装了真正的数据库连接对象和其代理对象；此外，由于它是一个连接池，所以还需要管理连接池的状态，比如有多少连接是空闲的，还可以创建多少连接，此时，就需要一个类来管理连接池的对象，即 PoolState 对象；先来看下 PooledDataSource 的一个 UML 图：</p></blockquote><p><img src="../images/mybatis/pool03.jpg" alt></p><h3 id="PooledConnection"><a href="#PooledConnection" class="headerlink" title="PooledConnection"></a>PooledConnection</h3><blockquote><p>它主要是用来管理数据库连接的，它是一个代理类，实现了 InvocationHandler 接口</p></blockquote><h4 id="主体方法"><a href="#主体方法" class="headerlink" title="主体方法"></a>主体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis 连接池对象 使用的是 动态代理</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PooledConnection</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">//关闭方法</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CLOSE = <span class="string">"close"</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] IFACES = <span class="keyword">new</span> Class&lt;?&gt;[]&#123;Connection.class&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> hashCode;</span><br><span class="line">  <span class="comment">// 记录当前的 PooledConnection 对象所在的 PooledDataSource 对象，该 PooledConnection 对象是从 PooledDataSource 对象中获取的，当调用 close 方法时会将 PooledConnection 放回该 PooledDataSource 中去</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PooledDataSource dataSource;</span><br><span class="line">  <span class="comment">//真实连接</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection realConnection;</span><br><span class="line">  <span class="comment">// 数据库连接的代理对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection proxyConnection;</span><br><span class="line">  <span class="comment">// 从连接池中取出该连接的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> checkoutTimestamp;</span><br><span class="line">  <span class="comment">// 该连接创建的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> createdTimestamp;</span><br><span class="line">  <span class="comment">// 该连接最后一次被使用的时间戳</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> lastUsedTimestamp;</span><br><span class="line">  <span class="comment">// 用于标识该连接所在的连接池，由URL+username+password 计算出来的hash值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> connectionTypeCode;</span><br><span class="line">  <span class="comment">// 该连接是否有效</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> valid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Constructor for SimplePooledConnection that uses the Connection and PooledDataSource passed in.</span></span><br><span class="line"><span class="comment">   * 创建连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> connection - the connection that is to be presented as a pooled connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource - the dataSource that the connection is from</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledConnection</span><span class="params">(Connection connection, PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.hashCode = connection.hashCode();</span><br><span class="line">    <span class="keyword">this</span>.realConnection = connection;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    <span class="keyword">this</span>.createdTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.lastUsedTimestamp = System.currentTimeMillis();</span><br><span class="line">    <span class="keyword">this</span>.valid = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">this</span>.proxyConnection = (Connection) Proxy.newProxyInstance(Connection.class.getClassLoader(), IFACES, <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Invalidates the connection.</span></span><br><span class="line"><span class="comment">   *   废弃该连接 设置连接未不可用</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    valid = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Method to see if the connection is usable.</span></span><br><span class="line"><span class="comment">   * 检查连接是否可用 连接可用并且能够被ping，</span></span><br><span class="line"><span class="comment">   *   1.判断 valid 字段</span></span><br><span class="line"><span class="comment">   *   2.向数据库中发送检测测试的SQL，查看真正的连接还是否有效</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> True if the connection is usable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> valid &amp;&amp; realConnection != <span class="keyword">null</span> &amp;&amp; dataSource.pingConnection(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 检查连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!valid) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"Error accessing PooledConnection. Connection is invalid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="invok代理方法"><a href="#invok代理方法" class="headerlink" title="invok代理方法"></a>invok代理方法</h4><blockquote><p>该方法是 proxyConnection 这个连接代理对象的真正代理逻辑，它会对 close 方法进行代理，并且在调用真正的连接之前对连接进行检测。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Required for InvocationHandler implementation.</span></span><br><span class="line"><span class="comment">   * 动态代理的入口方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy  - not used</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method - the method to be executed</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> args   - the parameters to be passed to the method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@see</span> java.lang.reflect.InvocationHandler#invoke(Object, java.lang.reflect.Method, Object[])</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    String methodName = method.getName();</span><br><span class="line">    <span class="comment">//如果关闭连接 将当前连接放回连接池 资源复用</span></span><br><span class="line">    <span class="keyword">if</span> (CLOSE.hashCode() == methodName.hashCode() &amp;&amp; CLOSE.equals(methodName)) &#123;</span><br><span class="line">      dataSource.pushConnection(<span class="keyword">this</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//不是Object对象的一些方法例如 toString等方法</span></span><br><span class="line">      <span class="keyword">if</span> (!Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="comment">// issue #579 toString() should never fail</span></span><br><span class="line">        <span class="comment">// throw an SQLException instead of a Runtime</span></span><br><span class="line">        <span class="comment">// 执行之前，需要进行连接的检测</span></span><br><span class="line">        checkConnection();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 调用数据库真正的连接进行执行</span></span><br><span class="line">      <span class="keyword">return</span> method.invoke(realConnection, args);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="PoolState"><a href="#PoolState" class="headerlink" title="PoolState"></a>PoolState</h3><blockquote><p>PoolState 类主要是用来管理连接池的状态，比如哪些连接是空闲的，哪些是活动的，还可以创建多少连接等。该类中只是定义了一些属性来进行控制连接池的状态，并没有任何的方法。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接池状态</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PoolState</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 该 PoolState 属于哪个 PooledDataSource</span></span><br><span class="line">  <span class="keyword">protected</span> PooledDataSource dataSource;</span><br><span class="line">  <span class="comment">// 来用存放空闲的 pooledConnection 连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; idleConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 用来存放活跃的 PooledConnection 连接</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> List&lt;PooledConnection&gt; activeConnections = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="comment">// 请求数据库连接的次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> requestCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 请求数据库连接的次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedRequestTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// checkoutTime 表示从连接池中获取连接到归还连接的时间</span></span><br><span class="line">  <span class="comment">// accumulatedCheckoutTime 记录了所有连接的累计 checkoutTime 时长</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 连接超时的连接个数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> claimedOverdueConnectionCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 累计超时时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedCheckoutTimeOfOverdueConnections = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 累计等待时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> accumulatedWaitTime = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 等待次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> hadToWaitCount = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 无效的连接数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">long</span> badConnectionCount = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PoolState</span><span class="params">(PooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PooledDataSource-1"><a href="#PooledDataSource-1" class="headerlink" title="PooledDataSource"></a>PooledDataSource</h3><blockquote><p>终于等来了我们的主角，PooledDataSource 它是一个简单的，同步的，线程安全的数据库连接池</p></blockquote><p>​ 知道了 UnpooledDataSource 用来创建数据库新的连接，PooledConnection 用来管理连接池中的连接，PoolState 用来管理连接池的状态之后，来看下 PooledDataSource 的一个逻辑，该类中主要有以下几个方法：获取数据库连接的方法 popConnection，把连接放回连接池的方法 pushConnection，检测数据库连接是否有效的方法 pingConnection ，还有 关闭连接池中所有连接的方法 forceCloseAll</p><h4 id="主体方法-1"><a href="#主体方法-1" class="headerlink" title="主体方法"></a>主体方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is a simple, synchronous, thread-safe database connection pool.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * 简单的 带有锁的 线程安全的 数据库连接池</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PooledDataSource</span> <span class="keyword">implements</span> <span class="title">DataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(PooledDataSource.class);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据库连接池状态</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PoolState state = <span class="keyword">new</span> PoolState(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用来创建真正的数据库连接对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> UnpooledDataSource dataSource;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OPTIONAL CONFIGURATION FIELDS</span></span><br><span class="line">  <span class="comment">// 最大活跃的连接数，默认为 10</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumActiveConnections = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// 最大空闲连接数，默认为 5</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumIdleConnections = <span class="number">5</span>;</span><br><span class="line">  <span class="comment">// 最大获取连接的时长</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumCheckoutTime = <span class="number">20000</span>;</span><br><span class="line">  <span class="comment">// 在无法获取到连接时，最大等待的时间</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolTimeToWait = <span class="number">20000</span>;</span><br><span class="line">  <span class="comment">//脸是失败重试次数</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolMaximumLocalBadConnectionTolerance = <span class="number">3</span>;</span><br><span class="line">  <span class="comment">// 在检测一个连接是否可用时，会向数据库发送一个测试 SQL</span></span><br><span class="line">  <span class="keyword">protected</span> String poolPingQuery = <span class="string">"NO PING QUERY SET"</span>;</span><br><span class="line">  <span class="comment">//是否启动连接池ping</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">boolean</span> poolPingEnabled;</span><br><span class="line">  <span class="comment">// 当连接超过 poolPingConnectionsNotUsedFor 毫秒未使用时，会发送一次测试 SQL 语句，测试连接是否正常</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">int</span> poolPingConnectionsNotUsedFor;</span><br><span class="line">  <span class="comment">// 标志着当前的连接池，是 url+username+password 的 hash 值</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> expectedConnectionTypeCode;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 创建连接池</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    dataSource = <span class="keyword">new</span> UnpooledDataSource();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">PooledDataSource</span><span class="params">(UnpooledDataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">   *  生成 连接的hash 值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> url</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">assembleConnectionTypeCode</span><span class="params">(String url, String username, String password)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="string">""</span> + url + username + password).hashCode();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="获取连接"><a href="#获取连接" class="headerlink" title="获取连接"></a>获取连接</h4><blockquote><p>从 连接池中获取连接的方法主要是在 popConnection 中实现的，先来看下它的一个流程图：</p></blockquote><p><img src="../images/mybatis/pool04.jpg" alt></p><p>代码逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br></pre></td><td class="code"><pre><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> popConnection(dataSource.getUsername(), dataSource.getPassword()).getProxyConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> popConnection(username, password).getProxyConnection();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 从连接池中获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> username</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> password</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> PooledConnection <span class="title">popConnection</span><span class="params">(String username, String password)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待个数</span></span><br><span class="line">    <span class="keyword">boolean</span> countedWait = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// PooledConnection 对象</span></span><br><span class="line">    PooledConnection conn = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//耗时计算</span></span><br><span class="line">    <span class="keyword">long</span> t = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 无效的连接个数</span></span><br><span class="line">    <span class="keyword">int</span> localBadConnectionCount = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//自旋</span></span><br><span class="line">    <span class="keyword">while</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">        <span class="comment">// 检测是否还有空闲的连接</span></span><br><span class="line">        <span class="keyword">if</span> (!state.idleConnections.isEmpty()) &#123;</span><br><span class="line">          <span class="comment">// Pool has available connection</span></span><br><span class="line">          <span class="comment">// 连接池中还有空闲的连接，则直接获取连接返回</span></span><br><span class="line">          conn = state.idleConnections.remove(<span class="number">0</span>);</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Checked out connection "</span> + conn.getRealHashCode() + <span class="string">" from pool."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 连接池中已经没有空闲连接了</span></span><br><span class="line">          <span class="comment">// Pool does not have available connection</span></span><br><span class="line">          <span class="keyword">if</span> (state.activeConnections.size() &lt; poolMaximumActiveConnections) &#123;</span><br><span class="line">            <span class="comment">// Can create new connection</span></span><br><span class="line">            <span class="comment">// 活跃的连接数没有达到最大值，则创建一个新的数据库连接</span></span><br><span class="line">            conn = <span class="keyword">new</span> PooledConnection(dataSource.getConnection(), <span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">"Created connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Cannot create new connection</span></span><br><span class="line">            <span class="comment">// 如果活跃的连接数已经达到允许的最大值了，则不能创建新的数据库连接</span></span><br><span class="line">            <span class="comment">// 获取最先创建的那个活跃的连接</span></span><br><span class="line">            PooledConnection oldestActiveConnection = state.activeConnections.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">long</span> longestCheckoutTime = oldestActiveConnection.getCheckoutTime();</span><br><span class="line">            <span class="comment">// 检测该连接是否超时</span></span><br><span class="line">            <span class="keyword">if</span> (longestCheckoutTime &gt; poolMaximumCheckoutTime) &#123;</span><br><span class="line">              <span class="comment">// 如果该连接超时，则进行相应的统计</span></span><br><span class="line">              <span class="comment">// Can claim overdue connection</span></span><br><span class="line">              <span class="comment">//超时连接个数统计</span></span><br><span class="line">              state.claimedOverdueConnectionCount++;</span><br><span class="line">              <span class="comment">//统计过期的连接超时时间</span></span><br><span class="line">              state.accumulatedCheckoutTimeOfOverdueConnections += longestCheckoutTime;</span><br><span class="line">              <span class="comment">//统计超时时间</span></span><br><span class="line">              state.accumulatedCheckoutTime += longestCheckoutTime;</span><br><span class="line">              <span class="comment">// 将超时连接移出 activeConnections 集合</span></span><br><span class="line">              state.activeConnections.remove(oldestActiveConnection);</span><br><span class="line">              <span class="comment">//如果没有设置自动提交</span></span><br><span class="line">              <span class="keyword">if</span> (!oldestActiveConnection.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                  <span class="comment">// 如果超时未提交，则自动回滚</span></span><br><span class="line">                  oldestActiveConnection.getRealConnection().rollback();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                  <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     Just log a message for debug and continue to execute the following</span></span><br><span class="line"><span class="comment">                     statement like nothing happened.</span></span><br><span class="line"><span class="comment">                     Wrap the bad connection with a new PooledConnection, this will help</span></span><br><span class="line"><span class="comment">                     to not interrupt current executing thread and give current thread a</span></span><br><span class="line"><span class="comment">                     chance to join the next competition for another valid/good database</span></span><br><span class="line"><span class="comment">                     connection. At the end of this loop, bad &#123;@link @conn&#125; will be set as null.</span></span><br><span class="line"><span class="comment">                   */</span></span><br><span class="line">                  log.debug(<span class="string">"Bad connection. Could not roll back"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// 创建新的 PooledConnection 对象，但是真正的数据库连接并没有创建</span></span><br><span class="line">              <span class="comment">//刚刚获取的真实连接 新瓶装旧酒</span></span><br><span class="line">              conn = <span class="keyword">new</span> PooledConnection(oldestActiveConnection.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">              <span class="comment">//设置创建时间</span></span><br><span class="line">              conn.setCreatedTimestamp(oldestActiveConnection.getCreatedTimestamp());</span><br><span class="line">              <span class="comment">//设置最后使用时间</span></span><br><span class="line">              conn.setLastUsedTimestamp(oldestActiveConnection.getLastUsedTimestamp());</span><br><span class="line">              <span class="comment">// 设置该超时的旧的连接为无效</span></span><br><span class="line">              oldestActiveConnection.invalidate();</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"Claimed overdue connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="comment">//如果第一个连接还没有超时，说明其他的都没有超时，只能等待了</span></span><br><span class="line">              <span class="comment">// Must wait</span></span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//等待个数统计</span></span><br><span class="line">                <span class="keyword">if</span> (!countedWait) &#123;</span><br><span class="line">                  <span class="comment">//等待计数</span></span><br><span class="line">                  state.hadToWaitCount++;</span><br><span class="line">                  <span class="comment">//下次不进行计数</span></span><br><span class="line">                  countedWait = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                  log.debug(<span class="string">"Waiting as long as "</span> + poolTimeToWait + <span class="string">" milliseconds for connection."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">long</span> wt = System.currentTimeMillis();</span><br><span class="line">                <span class="comment">//超时等待 阻塞等待</span></span><br><span class="line">                state.wait(poolTimeToWait);</span><br><span class="line">                <span class="comment">//统计等待的时长</span></span><br><span class="line">                state.accumulatedWaitTime += System.currentTimeMillis() - wt;</span><br><span class="line">              &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//异常退出</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 已经获取到连接，如果连接不为空</span></span><br><span class="line">        <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">          <span class="comment">// ping to server and check the connection is valid or not</span></span><br><span class="line">          <span class="comment">//连接状态可用</span></span><br><span class="line">          <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">            <span class="comment">// 如果连连接有效，事务未提交则回滚</span></span><br><span class="line">            <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">              <span class="comment">//进行回滚 恢复到最初状态</span></span><br><span class="line">              conn.getRealConnection().rollback();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置连接类型</span></span><br><span class="line">            conn.setConnectionTypeCode(assembleConnectionTypeCode(dataSource.getUrl(), username, password));</span><br><span class="line">            <span class="comment">//设置检查超时的时间</span></span><br><span class="line">            conn.setCheckoutTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">//设置最后使用时间</span></span><br><span class="line">            conn.setLastUsedTimestamp(System.currentTimeMillis());</span><br><span class="line">            <span class="comment">// 把连接加入到活跃集合中去</span></span><br><span class="line">            state.activeConnections.add(conn);</span><br><span class="line">            <span class="comment">//统计请求计数</span></span><br><span class="line">            state.requestCount++;</span><br><span class="line">            <span class="comment">//统计请求时长</span></span><br><span class="line">            state.accumulatedRequestTime += System.currentTimeMillis() - t;</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果验证连接失败</span></span><br><span class="line">            <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">              log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") was returned from the pool, getting another connection."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//统计错误连接个数</span></span><br><span class="line">            state.badConnectionCount++;</span><br><span class="line">            localBadConnectionCount++;</span><br><span class="line">            <span class="comment">//连接置为null 进行GC</span></span><br><span class="line">            conn = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//无效连接个数 &gt; 最大空闲连接数 + 失败尝试次数</span></span><br><span class="line">            <span class="comment">//大部分无效连接，可以停止服务了</span></span><br><span class="line">            <span class="keyword">if</span> (localBadConnectionCount &gt; (poolMaximumIdleConnections + poolMaximumLocalBadConnectionTolerance)) &#123;</span><br><span class="line">              <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">                log.debug(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//抛异常 因为获取的都是不可用的连接</span></span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Could not get a good connection to the database."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果连接还未空</span></span><br><span class="line">    <span class="keyword">if</span> (conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SQLException(<span class="string">"PooledDataSource: Unknown severe error condition.  The connection pool returned a null connection."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回连接</span></span><br><span class="line">    <span class="keyword">return</span> conn;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>以上就是从连接池获取连接的主要逻辑。</p><h4 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h4><blockquote><p>把连接放入的连接池中以供下次重新使用，把连接放入到连接池中的方法为 pushConnection 方法,它也是 PooledDataSource 类的一个主要方法。</p></blockquote><p><img src="../images/mybatis/pool05.jpg" alt></p><p>代码逻辑如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  把不用的连接放入到连接池中</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">pushConnection</span><span class="params">(PooledConnection conn)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    <span class="comment">// 首先从活跃的集合中移除掉该连接</span></span><br><span class="line">    state.activeConnections.remove(conn);</span><br><span class="line">    <span class="comment">//验证连接是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (conn.isValid()) &#123;</span><br><span class="line">      <span class="comment">// 如果空闲连接数没有达到最大值，且 PooledConnection 为该连接池的连接</span></span><br><span class="line">      <span class="keyword">if</span> (state.idleConnections.size() &lt; poolMaximumIdleConnections &amp;&amp; conn.getConnectionTypeCode() == expectedConnectionTypeCode) &#123;</span><br><span class="line">        <span class="comment">//验证超时时间汇总</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">//如果没有自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//进行回滚</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据真实连接创建一个新的池化的连接 真是链接还用当前的连接</span></span><br><span class="line">        PooledConnection newConn = <span class="keyword">new</span> PooledConnection(conn.getRealConnection(), <span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">//添加到空闲连接</span></span><br><span class="line">        state.idleConnections.add(newConn);</span><br><span class="line">        <span class="comment">//设置创建时间</span></span><br><span class="line">        newConn.setCreatedTimestamp(conn.getCreatedTimestamp());</span><br><span class="line">        <span class="comment">//设置最后使用时间</span></span><br><span class="line">        newConn.setLastUsedTimestamp(conn.getLastUsedTimestamp());</span><br><span class="line">        <span class="comment">//设置原来的连接为无效</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">"Returned connection "</span> + newConn.getRealHashCode() + <span class="string">" to pool."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//唤醒阻塞等待的线程</span></span><br><span class="line">        state.notifyAll();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果空闲连接数已经达到最大值</span></span><br><span class="line">        <span class="comment">//计算超时时间汇总</span></span><br><span class="line">        state.accumulatedCheckoutTime += conn.getCheckoutTime();</span><br><span class="line">        <span class="comment">//未设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!conn.getRealConnection().getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//回滚</span></span><br><span class="line">          conn.getRealConnection().rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真正的数据库连接</span></span><br><span class="line">        conn.getRealConnection().close();</span><br><span class="line">        <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">          log.debug(<span class="string">"Closed connection "</span> + conn.getRealHashCode() + <span class="string">"."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置该连接为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//如果连接状态失败</span></span><br><span class="line">      <span class="comment">//打印日志</span></span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"A bad connection ("</span> + conn.getRealHashCode() + <span class="string">") attempted to return to the pool, discarding connection."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//无效连接个数加1</span></span><br><span class="line">      state.badConnectionCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码就是把不用的连接放入到连接池中以供下次使用，</p><p>在上面两个方法中，都调用了 isValid 方法来检测连接是否可用。</p><h4 id="检查连接"><a href="#检查连接" class="headerlink" title="检查连接"></a>检查连接</h4><blockquote><p>该方法除了检测 valid 字段外，还会调用 pingConnection 方法来尝试让数据库执行测试 SQL 语句，从而检测真正的数据库连接对象是否依然正常可用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Method to check to see if a connection is still usable</span></span><br><span class="line"><span class="comment"> *   向数据库发送测试 SQL 来检测真正的数据库连接是否可用</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> conn - the connection to check</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if the connection is still usable</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">pingConnection</span><span class="params">(PooledConnection conn)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 结果</span></span><br><span class="line">  <span class="keyword">boolean</span> result = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 检测真正的数据库连接是否已经关闭</span></span><br><span class="line">    result = !conn.getRealConnection().isClosed();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">      log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果真正的数据库连接还没关闭</span></span><br><span class="line">  <span class="keyword">if</span> (result) &#123;</span><br><span class="line">    <span class="comment">// 是否执行测试 SQL 语句</span></span><br><span class="line">    <span class="keyword">if</span> (poolPingEnabled) &#123;</span><br><span class="line">      <span class="comment">// 长时间（poolPingConnectionsNotUsedFor 指定的时长）未使用的连接，才需要ping操作来检测连接是否正常</span></span><br><span class="line">      <span class="keyword">if</span> (poolPingConnectionsNotUsedFor &gt;= <span class="number">0</span> &amp;&amp; conn.getTimeElapsedSinceLastUse() &gt; poolPingConnectionsNotUsedFor) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Testing connection "</span> + conn.getRealHashCode() + <span class="string">" ..."</span>);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 发送测试 SQL 语句执行</span></span><br><span class="line">          Connection realConn = conn.getRealConnection();</span><br><span class="line">          <span class="keyword">try</span> (Statement statement = realConn.createStatement()) &#123;</span><br><span class="line">            statement.executeQuery(poolPingQuery).close();</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">//回滚</span></span><br><span class="line">          <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">            realConn.rollback();</span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">true</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is GOOD!"</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          log.warn(<span class="string">"Execution of ping query '"</span> + poolPingQuery + <span class="string">"' failed: "</span> + e.getMessage());</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//关闭真实连接</span></span><br><span class="line">            conn.getRealConnection().close();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception e2) &#123;</span><br><span class="line">            <span class="comment">//ignore</span></span><br><span class="line">          &#125;</span><br><span class="line">          result = <span class="keyword">false</span>;</span><br><span class="line">          <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">            log.debug(<span class="string">"Connection "</span> + conn.getRealHashCode() + <span class="string">" is BAD: "</span> + e.getMessage());</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关闭所有连接"><a href="#关闭所有连接" class="headerlink" title="关闭所有连接"></a>关闭所有连接</h4><blockquote><p>当修改 PooledDataSource 相应的字段，如 数据库的 URL，用户名或密码等，需要将连接池中连接全部关闭，之后获取连接的时候从重新初始化</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Closes all active and idle connections in the pool.</span></span><br><span class="line"><span class="comment"> * 关闭所有的活动以及空闲连接</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">forceCloseAll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (state) &#123;</span><br><span class="line">    expectedConnectionTypeCode = assembleConnectionTypeCode(dataSource.getUrl(), dataSource.getUsername(), dataSource.getPassword());</span><br><span class="line">    <span class="comment">//遍历关闭活动的连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.activeConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.activeConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置连接为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="comment">//获取真实连接</span></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="comment">//是否设置了自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//否则进行回滚，保证数据一致性</span></span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真实连接</span></span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//遍历关闭空闲的连接</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = state.idleConnections.size(); i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        PooledConnection conn = state.idleConnections.remove(i - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 设置为无效状态</span></span><br><span class="line">        conn.invalidate();</span><br><span class="line">        <span class="comment">//获取真实连接</span></span><br><span class="line">        Connection realConn = conn.getRealConnection();</span><br><span class="line">        <span class="comment">//如果没有设置自动提交</span></span><br><span class="line">        <span class="keyword">if</span> (!realConn.getAutoCommit()) &#123;</span><br><span class="line">          <span class="comment">//进行数据回滚</span></span><br><span class="line">          realConn.rollback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关闭真实的链接</span></span><br><span class="line">        realConn.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">    log.debug(<span class="string">"PooledDataSource forcefully closed/removed all connections."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在连接池中提到了 连接池中的最大连接数和最大空闲数，在 获取连接和把连接放入连接池中都有判断，</p><ol><li><p>获取连接：首先从连接池中进行获取，如果连接池中已经没有空闲的连接了，则会判断当前的活跃连接数是否已经达到允许的最大值了，如果没有，则还可以创建新的连接，之后把它放到活跃的集合中进行使用，如果当前活跃的已达到最大值，则阻塞。</p></li><li><p>返还连接到连接池，在返还连接的时候，进行判断，如果空闲连接数已达到允许的最大值，则直接关闭真正的数据库连接，否则把该连接放入到空闲集合中以供下次使用。</p></li></ol><p>Mybatis 数据源中，主要的代码逻辑还是在连接池类 PooledDataSource 中，对于获取连接的方法 popConnection，返还连接的方法 pushConnection ，需要结合上图来看，才能看得清楚。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis数据库连接池
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据库连接池" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="数据库连接池" scheme="http://www.baiyp.ren/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    
  </entry>
  
  <entry>
    <title>MYBATIS源码解析-01日志模块</title>
    <link href="http://www.baiyp.ren/MYBATIS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-01%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97.html"/>
    <id>http://www.baiyp.ren/MYBATIS源码解析-01日志模块.html</id>
    <published>2019-09-04T06:58:57.000Z</published>
    <updated>2019-09-08T14:17:33.060Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="MYBATIS日志模块解析"><a href="#MYBATIS日志模块解析" class="headerlink" title="MYBATIS日志模块解析"></a>MYBATIS日志模块解析</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>​ mybatis 没有提供日志的实现类，需要接入第三方的日志组件，但第三方日志组件都有各自的Log级别，且各不相同。而Mybatis统一提供了trace/ debug/ warn/ error四个级别，mybatis使用适配器模式进行日志加载，我们来欣赏下mybatis源码的魅力。</p><h3 id="日志接口Log"><a href="#日志接口Log" class="headerlink" title="日志接口Log"></a>日志接口Log</h3><blockquote><p>mybatis 封装了统一的日志接口，其他日志接口接入需要实现该日志接口。</p><p>该接口只提供了trace/ debug/ warn/ error四个级别的日志输出</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * mybatis log日志接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="comment">//是否启动debug</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//是否启动Trace</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//error日志级别</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="日志工厂LogFactory"><a href="#日志工厂LogFactory" class="headerlink" title="日志工厂LogFactory"></a>日志工厂LogFactory</h3><blockquote><p>在这里定义了日志框架的加载顺序</p><p>slf4j -&gt; commonsLoging -&gt; Log4J2 -&gt; Log4J -&gt; JdkLog</p><p>使得日志框架优雅的嵌入到mybatis中</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mybatis log 工厂类</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Marker to be used by logging implementations that support markers.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MARKER = <span class="string">"MYBATIS"</span>;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 记录正在使用的是那个日志框架的构造方法</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Log&gt; logConstructor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 顺序尝试找到一个可用的日志框架</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * :: 双冒号运算符就是java中的方法引用 方法引用的格式是 类名::方法名。</span></span><br><span class="line"><span class="comment">   * person -&gt;person.getAge(); 可以替换为 Person::getAge</span></span><br><span class="line"><span class="comment">   * （）-&gt; new HashMap&lt;&gt;(); 可以替换为 HashMap::new</span></span><br><span class="line"><span class="comment">   * 双冒号操作符返回的是一个接口的匿名实现</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">     <span class="comment">//尝试使用某一种日志框架 第一个不成功到第二个 一直找到一个合适的</span></span><br><span class="line">    tryImplementation(LogFactory::useSlf4jLogging);</span><br><span class="line">    tryImplementation(LogFactory::useCommonsLogging);</span><br><span class="line">    tryImplementation(LogFactory::useLog4J2Logging);</span><br><span class="line">    tryImplementation(LogFactory::useLog4JLogging);</span><br><span class="line">    tryImplementation(LogFactory::useJdkLogging);</span><br><span class="line">    tryImplementation(LogFactory::useNoLogging);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">LogFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// disable construction</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回具体实现的实现类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> aClass</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getLog(aClass.getName());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 返回具体实现的接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> logger 具体需要日志的 类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Log <span class="title">getLog</span><span class="params">(String logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//使用当前可用的构造方法进行创建对象</span></span><br><span class="line">      <span class="keyword">return</span> logConstructor.newInstance(logger);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">"Error creating logger for logger "</span> + logger + <span class="string">".  Cause: "</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useCustomLogging</span><span class="params">(Class&lt;? extends Log&gt; clazz)</span> </span>&#123;</span><br><span class="line">    setImplementation(clazz);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useSlf4jLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.slf4j.Slf4jImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useCommonsLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.commons.JakartaCommonsLoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useLog4JLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.log4j.Log4jImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useLog4J2Logging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.log4j2.Log4j2Impl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useJdkLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.jdk14.Jdk14LoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useStdOutLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.stdout.StdOutImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">useNoLogging</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    setImplementation(org.apache.ibatis.logging.nologging.NoLoggingImpl.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 咋一看好像是多线程</span></span><br><span class="line"><span class="comment">   * 其实不然，只用用了下Runnable接口的钩子方法</span></span><br><span class="line"><span class="comment">   * 不用再自定义接口内部类实现了，用现成的Runnable接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> runnable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">tryImplementation</span><span class="params">(Runnable runnable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果构造方法为空就调用匿名内部类</span></span><br><span class="line">    <span class="keyword">if</span> (logConstructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//调用具体接口的方法</span></span><br><span class="line">        runnable.run();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置日志实现类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> implClass</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setImplementation</span><span class="params">(Class&lt;? extends Log&gt; implClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//获取具体实现类的构造方法</span></span><br><span class="line">      Constructor&lt;? extends Log&gt; candidate = implClass.getConstructor(String.class);</span><br><span class="line">      <span class="comment">//创建一个实现类 并打印日志</span></span><br><span class="line">      Log log = candidate.newInstance(LogFactory.class.getName());</span><br><span class="line">      <span class="keyword">if</span> (log.isDebugEnabled()) &#123;</span><br><span class="line">        log.debug(<span class="string">"Logging initialized using '"</span> + implClass + <span class="string">"' adapter."</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//设置否则方法为当前可用构造方法</span></span><br><span class="line">      logConstructor = candidate;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> LogException(<span class="string">"Error setting Log implementation.  Cause: "</span> + t, t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里是整个日志的加载顺序，尝试找到一个可用的构造方法，找到后返回该日志框架的实例。</p><p>这里面用到了Runable接口的钩子方法，也可以叫做接口回调，并没有使用多线程编程。</p><h3 id="日志系统转换"><a href="#日志系统转换" class="headerlink" title="日志系统转换"></a>日志系统转换</h3><blockquote><p>这里采用了很多日志框架，使用了适配器模式进行日志的转换，装饰着模式可以查看我的设计模式一节</p><p>这里我们就拿比较负责的sl4j来查看源码</p></blockquote><p><img src="../images/mybatis%5Cmybatis_log01.png" alt></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器模式 Sl4j 实现类</span></span><br><span class="line"><span class="comment"> * 实现Log 接口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Slf4jImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 当前类的实现类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> Log log;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法 初始化 log</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> clazz 需要打印日志的类</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Slf4jImpl</span><span class="params">(String clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//logger的方式创建日志类</span></span><br><span class="line">    Logger logger = LoggerFactory.getLogger(clazz);</span><br><span class="line">    <span class="comment">//如果返回的是 LocationAwareLogger 对象</span></span><br><span class="line">    <span class="keyword">if</span> (logger <span class="keyword">instanceof</span> LocationAwareLogger) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check for slf4j &gt;= 1.6 method signature</span></span><br><span class="line">        <span class="comment">//检查sl4j 版本是否&gt;=1.6</span></span><br><span class="line">        logger.getClass().getMethod(<span class="string">"log"</span>, Marker.class, String.class, <span class="keyword">int</span>.class, String.class, Object[].class, Throwable.class);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用 Slf4jLocationAwareLoggerImpl 实例</span></span><br><span class="line">        log = <span class="keyword">new</span> Slf4jLocationAwareLoggerImpl((LocationAwareLogger) logger);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SecurityException | NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="comment">// fail-back to Slf4jLoggerImpl</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Logger is not LocationAwareLogger or slf4j version &lt; 1.6</span></span><br><span class="line">    <span class="comment">//sl4j 版本小于1.6 使用Slf4jLoggerImpl</span></span><br><span class="line">    log = <span class="keyword">new</span> Slf4jLoggerImpl(logger);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.error(s, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.error(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.trace(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.warn(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里注意下Slf4j版本控制，如果Slf4j版本&gt;=1.6 使用 Slf4jLocationAwareLoggerImpl 否则使用Slf4jLoggerImpl</p><p>我们再拿Slf4jLoggerImpl看一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Slf4jLoggerImpl</span> <span class="keyword">implements</span> <span class="title">Log</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Logger log;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Slf4jLoggerImpl</span><span class="params">(Logger logger)</span> </span>&#123;</span><br><span class="line">    log = logger;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> log.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s, Throwable e)</span> </span>&#123;</span><br><span class="line">    log.error(s, e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">error</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.error(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.debug(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.trace(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">warn</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    log.warn(s);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到这里就是mybatis日志框架的优雅封装实现，通过依次尝试加载，使用适配器模式进行日志接口的统一</p><h3 id="JDBC日志增强"><a href="#JDBC日志增强" class="headerlink" title="JDBC日志增强"></a>JDBC日志增强</h3><h4 id="JDBC模板类BaseJdbcLogger"><a href="#JDBC模板类BaseJdbcLogger" class="headerlink" title="JDBC模板类BaseJdbcLogger"></a>JDBC模板类BaseJdbcLogger</h4><blockquote><p>BaseJdbcLogger初始化了日志框架Log，SET_METHODS和jdbc执行方法列表EXECUTE_METHODS</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Base class for proxies to do logging.</span></span><br><span class="line"><span class="comment"> * 基类 JDBC操作日志</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseJdbcLogger</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; SET_METHODS;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;String&gt; EXECUTE_METHODS = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, Object&gt; columnMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; columnNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> List&lt;Object&gt; columnValues = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> Log statementLog;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> queryStack;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">   * Default constructor</span></span><br><span class="line"><span class="comment">   * 默认构造方法，将日志接口以及查询</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">BaseJdbcLogger</span><span class="params">(Log log, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.statementLog = log;</span><br><span class="line">    <span class="keyword">if</span> (queryStack == <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>.queryStack = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.queryStack = queryStack;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将Set方法设置进SET_METHODS</span></span><br><span class="line">    SET_METHODS = Arrays.stream(PreparedStatement.class.getDeclaredMethods())</span><br><span class="line">            .filter(method -&gt; method.getName().startsWith(<span class="string">"set"</span>))</span><br><span class="line">            .filter(method -&gt; method.getParameterCount() &gt; <span class="number">1</span>)</span><br><span class="line">            .map(Method::getName)</span><br><span class="line">            .collect(Collectors.toSet());</span><br><span class="line">    <span class="comment">//添加执行方法</span></span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"execute"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"executeUpdate"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"executeQuery"</span>);</span><br><span class="line">    EXECUTE_METHODS.add(<span class="string">"addBatch"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 设置参数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setColumn</span><span class="params">(Object key, Object value)</span> </span>&#123;</span><br><span class="line">    columnMap.put(key, value);</span><br><span class="line">    columnNames.add(key);</span><br><span class="line">    columnValues.add(value);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> Object <span class="title">getColumn</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> columnMap.get(key);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取参数值</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getParameterValueString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    List&lt;Object&gt; typeList = <span class="keyword">new</span> ArrayList&lt;&gt;(columnValues.size());</span><br><span class="line">    <span class="keyword">for</span> (Object value : columnValues) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value == <span class="keyword">null</span>) &#123;</span><br><span class="line">        typeList.add(<span class="string">"null"</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        typeList.add(objectValueString(value) + <span class="string">"("</span> + value.getClass().getSimpleName() + <span class="string">")"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> String parameters = typeList.toString();</span><br><span class="line">    <span class="keyword">return</span> parameters.substring(<span class="number">1</span>, parameters.length() - <span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 将Object转换为String</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">objectValueString</span><span class="params">(Object value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value <span class="keyword">instanceof</span> Array) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ArrayUtil.toString(((Array) value).getArray());</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> value.toString();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取参数名称列表</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">getColumnString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> columnNames.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清空参数map</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">clearColumnInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    columnMap.clear();</span><br><span class="line">    columnNames.clear();</span><br><span class="line">    columnValues.clear();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 清除换行符以及制表符</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> original</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> String <span class="title">removeBreakingWhitespace</span><span class="params">(String original)</span> </span>&#123;</span><br><span class="line">    StringTokenizer whitespaceStripper = <span class="keyword">new</span> StringTokenizer(original);</span><br><span class="line">    StringBuilder builder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (whitespaceStripper.hasMoreTokens()) &#123;</span><br><span class="line">      builder.append(whitespaceStripper.nextToken());</span><br><span class="line">      builder.append(<span class="string">" "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> builder.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否启用debug</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementLog.isDebugEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 是否启用Trace</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statementLog.isTraceEnabled();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 日志打印</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> text</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> input</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String text, <span class="keyword">boolean</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (statementLog.isDebugEnabled()) &#123;</span><br><span class="line">      statementLog.debug(prefix(input) + text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String text, <span class="keyword">boolean</span> input)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (statementLog.isTraceEnabled()) &#123;</span><br><span class="line">      statementLog.trace(prefix(input) + text);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 获取输出的前缀</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> isInput</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> String <span class="title">prefix</span><span class="params">(<span class="keyword">boolean</span> isInput)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] buffer = <span class="keyword">new</span> <span class="keyword">char</span>[queryStack * <span class="number">2</span> + <span class="number">2</span>];</span><br><span class="line">    Arrays.fill(buffer, <span class="string">'='</span>);</span><br><span class="line">    buffer[queryStack * <span class="number">2</span> + <span class="number">1</span>] = <span class="string">' '</span>;</span><br><span class="line">    <span class="keyword">if</span> (isInput) &#123;</span><br><span class="line">      buffer[queryStack * <span class="number">2</span>] = <span class="string">'&gt;'</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      buffer[<span class="number">0</span>] = <span class="string">'&lt;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(buffer);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Connection日志增强"><a href="#Connection日志增强" class="headerlink" title="Connection日志增强"></a>Connection日志增强</h4><blockquote><p>Connection日志增加是基于动态代理实现的，具有很高的参考价值，他创建预处理等对象的时候并返回预处理对象的代理方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Connection proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 基于动态代理的日志增强</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 数据库连接</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn 连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ConnectionLogger</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.connection = conn;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理的核心处理类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果是预处理方法 打印debug信息</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"prepareStatement"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">" Preparing: "</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用prepareStatement方法</span></span><br><span class="line">        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">        <span class="comment">//如果是调用存储过程</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"prepareCall"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//打印日志</span></span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">" Preparing: "</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用prepareCall 方法</span></span><br><span class="line">        PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">        <span class="comment">//如果创建createStatement 方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"createStatement"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用 createStatement 方法</span></span><br><span class="line">        Statement stmt = (Statement) method.invoke(connection, params);</span><br><span class="line">        <span class="comment">//链式创建预处理代理对象</span></span><br><span class="line">        stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//并返回预处理代理对象</span></span><br><span class="line">        <span class="keyword">return</span> stmt;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//其他方法直接调用</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(connection, params);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a connection.</span></span><br><span class="line"><span class="comment">   * 创建 连接的代理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> conn - the original connection</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the connection with logging</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">newInstance</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> ConnectionLogger(conn, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = Connection.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;Connection.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * return the wrapped connection.</span></span><br><span class="line"><span class="comment">   * 获取连接</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the connection</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> connection;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="PreparedStatementLogger预处理日志增强"><a href="#PreparedStatementLogger预处理日志增强" class="headerlink" title="PreparedStatementLogger预处理日志增强"></a>PreparedStatementLogger预处理日志增强</h4><blockquote><p>预处理日志增强，对其中一些方法进行增强，对于查询以及获取结果集，返回结果集的日志动态代理增强。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * PreparedStatement proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 基于动态代理的预处理日志增强</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 原始的预处理对象</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 私有的构造方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stmt         预处理对象</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">PreparedStatementLogger</span><span class="params">(PreparedStatement stmt, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.statement = stmt;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理和核心方法</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//如果是Object对象直接调用</span></span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//如果包含定义的可执行方法 则打印日志 以及值列表</span></span><br><span class="line">      <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">          debug(<span class="string">"Parameters: "</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//清空 参数</span></span><br><span class="line">        clearColumnInfo();</span><br><span class="line">        <span class="comment">//如果是查询方法</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"executeQuery"</span>.equals(method.getName())) &#123;</span><br><span class="line">          <span class="comment">//调用 executeQuery 方法 并返回结果集</span></span><br><span class="line">          ResultSet rs = (ResultSet) method.invoke(statement, params);</span><br><span class="line">          <span class="comment">//返回结果集的 动态代理日志增强</span></span><br><span class="line">          <span class="keyword">return</span> rs == <span class="keyword">null</span> ? <span class="keyword">null</span> : ResultSetLogger.newInstance(rs, statementLog, queryStack);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其他方法直接调用不进行日志增强</span></span><br><span class="line">          <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果方法在SET_METHODS列表中</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SET_METHODS.contains(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//如果是 setNull 的方法 则设置为null</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"setNull"</span>.equals(method.getName())) &#123;</span><br><span class="line">          setColumn(params[<span class="number">0</span>], <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//其他设置具体参数的值</span></span><br><span class="line">          setColumn(params[<span class="number">0</span>], params[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//调用set方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//如果是getResultSet方法</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"getResultSet"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用具体的getResultSet方法</span></span><br><span class="line">        ResultSet rs = (ResultSet) method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//返回结果集日志曾倩</span></span><br><span class="line">        <span class="keyword">return</span> rs == <span class="keyword">null</span> ? <span class="keyword">null</span> : ResultSetLogger.newInstance(rs, statementLog, queryStack);</span><br><span class="line">        <span class="comment">//如果是获取更新条数</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"getUpdateCount"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//调用具体方法获取条数</span></span><br><span class="line">        <span class="keyword">int</span> updateCount = (Integer) method.invoke(statement, params);</span><br><span class="line">        <span class="comment">//如果是不等于-1 打印结果日志</span></span><br><span class="line">        <span class="keyword">if</span> (updateCount != -<span class="number">1</span>) &#123;</span><br><span class="line">          debug(<span class="string">"   Updates: "</span> + updateCount, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回更新条数</span></span><br><span class="line">        <span class="keyword">return</span> updateCount;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//不进行增加的方法</span></span><br><span class="line">        <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a PreparedStatement.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * 创建动态代理的实例</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> stmt         - the statement</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog - the statement log</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack   - the query stack</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the proxy</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PreparedStatement <span class="title">newInstance</span><span class="params">(PreparedStatement stmt, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> PreparedStatementLogger(stmt, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = PreparedStatement.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (PreparedStatement) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;PreparedStatement.class, CallableStatement.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Return the wrapped prepared statement.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the PreparedStatement</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> PreparedStatement <span class="title">getPreparedStatement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> statement;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>StatementLogger日志增加和PreparedStatementLogger这个类基本上一样，大家可以看一下。</p><h4 id="ResultSetLogger结果集日志增强"><a href="#ResultSetLogger结果集日志增强" class="headerlink" title="ResultSetLogger结果集日志增强"></a>ResultSetLogger结果集日志增强</h4><blockquote><p>结果集打印没有什么可说的了，基本上就是判断是否是blob类型，特殊处理，其他情况进行字符串拼接</p><p>这里使用了JDK1.8的StringJoiner 进行字符串拼接，可以简单的方式进行包含有分隔符的字符串拼接</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ResultSet proxy to add logging.</span></span><br><span class="line"><span class="comment"> * 结果集处理日志动态代理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Clinton Begin</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> Eduardo Macarron</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultSetLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Bolb 字段类型列表</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Set&lt;Integer&gt; BLOB_TYPES = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> first = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> rows;</span><br><span class="line">  <span class="comment">//结果集原始对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResultSet rs;</span><br><span class="line">  <span class="comment">//blob参数</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Integer&gt; blobColumns = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">//设置blob数据类型</span></span><br><span class="line">    BLOB_TYPES.add(Types.BINARY);</span><br><span class="line">    BLOB_TYPES.add(Types.BLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.CLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGNVARCHAR);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGVARBINARY);</span><br><span class="line">    BLOB_TYPES.add(Types.LONGVARCHAR);</span><br><span class="line">    BLOB_TYPES.add(Types.NCLOB);</span><br><span class="line">    BLOB_TYPES.add(Types.VARBINARY);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 私有构造方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rs 结果集</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> statementLog 日志接口</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> queryStack</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">ResultSetLogger</span><span class="params">(ResultSet rs, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">    <span class="keyword">this</span>.rs = rs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 动态代理的核心方法</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> method</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> params</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//方法是Object类型 直接调用</span></span><br><span class="line">      <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">//调用原始的方法</span></span><br><span class="line">      Object o = method.invoke(rs, params);</span><br><span class="line">      <span class="comment">//如果调用next方法</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="string">"next"</span>.equals(method.getName())) &#123;</span><br><span class="line">        <span class="comment">//如果有下一行</span></span><br><span class="line">        <span class="keyword">if</span> ((Boolean) o) &#123;</span><br><span class="line">          <span class="comment">//行数++</span></span><br><span class="line">          rows++;</span><br><span class="line">          <span class="comment">//日志打印</span></span><br><span class="line">          <span class="keyword">if</span> (isTraceEnabled()) &#123;</span><br><span class="line">            <span class="comment">//获取元数据</span></span><br><span class="line">            ResultSetMetaData rsmd = rs.getMetaData();</span><br><span class="line">            <span class="comment">//获取列数</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> columnCount = rsmd.getColumnCount();</span><br><span class="line">            <span class="comment">//如果是第一行 用来判断是否是第一行</span></span><br><span class="line">            <span class="keyword">if</span> (first) &#123;</span><br><span class="line">              <span class="comment">//设置第一行不显示</span></span><br><span class="line">              first = <span class="keyword">false</span>;</span><br><span class="line">              <span class="comment">//打印列标题</span></span><br><span class="line">              printColumnHeaders(rsmd, columnCount);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//打印参数结果集数据</span></span><br><span class="line">            printColumnValues(columnCount);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          debug(<span class="string">"     Total: "</span> + rows, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      clearColumnInfo();</span><br><span class="line">      <span class="keyword">return</span> o;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">      <span class="keyword">throw</span> ExceptionUtil.unwrapThrowable(t);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打印结果集日志</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rsmd 结果集元数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> columnCount 列行数</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printColumnHeaders</span><span class="params">(ResultSetMetaData rsmd, <span class="keyword">int</span> columnCount)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    StringJoiner row = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>, <span class="string">"   Columns: "</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (BLOB_TYPES.contains(rsmd.getColumnType(i))) &#123;</span><br><span class="line">        blobColumns.add(i);</span><br><span class="line">      &#125;</span><br><span class="line">      row.add(rsmd.getColumnLabel(i));</span><br><span class="line">    &#125;</span><br><span class="line">    trace(row.toString(), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * 打印结果集数据</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> columnCount</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printColumnValues</span><span class="params">(<span class="keyword">int</span> columnCount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//StringJoiner 进行字符串拼接</span></span><br><span class="line">    StringJoiner row = <span class="keyword">new</span> StringJoiner(<span class="string">", "</span>, <span class="string">"       Row: "</span>, <span class="string">""</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= columnCount; i++) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//如果包是blob类型 添加BLOB 标识</span></span><br><span class="line">        <span class="keyword">if</span> (blobColumns.contains(i)) &#123;</span><br><span class="line">          row.add(<span class="string">"&lt;&lt;BLOB&gt;&gt;"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">//将值添加到字符串中</span></span><br><span class="line">          row.add(rs.getString(i));</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        <span class="comment">// generally can't call getString() on a BLOB column</span></span><br><span class="line">        row.add(<span class="string">"&lt;&lt;Cannot Display&gt;&gt;"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    trace(row.toString(), <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Creates a logging version of a ResultSet.</span></span><br><span class="line"><span class="comment">   * 创建结果集代理类</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> rs - the ResultSet to proxy</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> - the ResultSet with logging</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ResultSet <span class="title">newInstance</span><span class="params">(ResultSet rs, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">    InvocationHandler handler = <span class="keyword">new</span> ResultSetLogger(rs, statementLog, queryStack);</span><br><span class="line">    ClassLoader cl = ResultSet.class.getClassLoader();</span><br><span class="line">    <span class="keyword">return</span> (ResultSet) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;ResultSet.class&#125;, handler);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the wrapped result set.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> the resultSet</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ResultSet <span class="title">getRs</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ mybatis 日志模块使用适配器模式进行不同类型的日志框架的统一，使用动态代理对连接执行sql，结果集进行日志的增强，使其无缝的与mybatis结合起来，你们的日志是怎么打印的呢？</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      mybatis日志模块解析
    
    </summary>
    
      <category term="mybatis" scheme="http://www.baiyp.ren/categories/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/"/>
    
      <category term="日志" scheme="http://www.baiyp.ren/categories/mybatis/%E6%BA%90%E7%A0%81/%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="mybatis" scheme="http://www.baiyp.ren/tags/mybatis/"/>
    
      <category term="源码" scheme="http://www.baiyp.ren/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="日志" scheme="http://www.baiyp.ren/tags/%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>volatile实现原理</title>
    <link href="http://www.baiyp.ren/volatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/volatile实现原理.html</id>
    <published>2019-09-03T01:11:04.000Z</published>
    <updated>2019-09-07T09:10:09.807Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="volatile实现原理"><a href="#volatile实现原理" class="headerlink" title="volatile实现原理"></a>volatile实现原理</h2><p><img src="../images/thread/volatile/volatile01.png" alt></p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​ volatile是Java提供的一种轻量级的同步机制。Java 语言包含两种内在的同步机制：同步块（或方法）和 volatile 变量，相比于synchronized（synchronized通常称为重量级锁），volatile更轻量级，因为它不会引起线程上下文的切换和调度。但是volatile 变量的同步性较差（有时它更简单并且开销更低），而且其使用也更容易出错。</p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote><p>可以把对volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写操作做了同步</p></blockquote><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><blockquote><p>即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p></blockquote><p>​ 原子性是拒绝多线程操作的，不论是多核还是单核，具有原子性的量，同一时刻只能有一个线程来对它进行操作。简而言之，在整个操作过程中不会被线程调度器中断的操作，都可认为是原子性。例如 a=1是原子性操作，但是a++和a +=1就不是原子性操作。Java中的原子性操作包括：</p><ul><li>基本类型的读取和赋值操作，且赋值必须是数字赋值给变量，变量之间的相互赋值不是原子性操作。</li><li>所有引用reference的赋值操作</li><li>java.concurrent.Atomic.* 包中所有类的一切操作</li></ul><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><blockquote><p>指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。</p></blockquote><p>​ 在多线程环境下，一个线程对共享变量的操作对其他线程是不可见的。Java提供了volatile来保证可见性，当一个变量被volatile修饰后，表示着线程本地内存无效，当一个线程修改共享变量后他会立即被更新到主内存中，其他线程读取共享变量时，会直接从主内存中读取。当然，synchronize和Lock都可以保证可见性。synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。</p><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><blockquote><p>即程序执行的顺序按照代码的先后顺序执行。</p></blockquote><p>​ java内存模型中的有序性可以总结为：如果在本线程内观察，所有操作都是有序的；如果在一个线程中观察另一个线程，所有操作都是无序的。前半句是指“线程内表现为串行语义”，后半句是指“指令重排序”现象和“工作内存主主内存同步延迟”现象。<br>​ 在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。最著名的例子就是单例模式里面的DCL（双重检查锁）。另外，可以通过synchronized和Lock来保证有序性，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。</p><h3 id="volatile变量的特性"><a href="#volatile变量的特性" class="headerlink" title="volatile变量的特性"></a>volatile变量的特性</h3><h4 id="保证可见性，不保证原子性"><a href="#保证可见性，不保证原子性" class="headerlink" title="保证可见性，不保证原子性"></a>保证可见性，不保证原子性</h4><p><img src="../images/thread/volatile/volatile07.png" alt></p><ul><li><p>当写一个volatile变量时，JMM会把该线程本地内存中的变量强制刷新到主内存中去；</p></li><li><p>这个写会操作会导致其他线程中的缓存无效。</p></li></ul><h4 id="禁止指令重排"><a href="#禁止指令重排" class="headerlink" title="禁止指令重排"></a>禁止指令重排</h4><blockquote><p>重排序是指编译器和处理器为了优化程序性能而对指令序列进行排序的一种手段。重排序需要遵守一定规则：</p></blockquote><ul><li><p>重排序操作不会对存在数据依赖关系的操作进行重排序。</p><p>比如：a=1;b=a; 这个指令序列，由于第二个操作依赖于第一个操作，所以在编译时和处理器运</p><p>​ 行时这两个操作不会被重排序。</p></li><li><p>重排序是为了优化性能，但是不管怎么重排序，单线程下程序的执行结果不能被改变</p><p>比如：a=1;b=2;c=a+b这三个操作，第一步（a=1)和第二步(b=2)由于不存在数据依赖关系， 所以可能会发</p></li></ul><p>​ 生重排序，但是c=a+b这个操作是不会被重排序的，因为需要保证最终的结果一定是c=a+b=3。</p><p>​ 重排序在单线程下一定能保证结果的正确性，但是在多线程环境下，可能发生重排序，影响结果，下例中的1和2由于不存在数据依赖关系，则有可能会被重排序，先执行status=true再执行a=2。而此时线程B会顺利到达4处，而线程A中a=2这个操作还未被执行，所以b=a+1的结果也有可能依然等于2。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><blockquote><p>volatile可以保证线程可见性且提供了一定的有序性，但是无法保证原子性。在JVM底层volatile是采用“内存屏障”来实现的。观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令，lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：</p></blockquote><ul><li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li><li>它会强制将对缓存的修改操作立即写入主存；</li><li>如果是写操作，它会导致其他CPU中对应的缓存行无效。</li></ul><h4 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h4><ul><li><p><strong>当写一个 volatile 变量时，JMM 会把该线程对应的本地内存中的共享变量值刷新到主内存。</strong></p></li><li><p><strong>当读一个 volatile 变量时，JMM 会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</strong></p><p>​ 当主线程对stop进行修改后且子线程尚未对stop进行读时，主线程已经把stop的值刷新到了主内存。其示意图如下：</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile02.png" alt></p><p>​ 当子线程进行读取时，会把本地内存置为无效直接去主内存中读取。（这里的主线程和子线程可以了解为两个普通线程没有父子关系）其示意图如下：</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile03.png" alt></p></li></ul><h4 id="volatile内存语义的实现"><a href="#volatile内存语义的实现" class="headerlink" title="volatile内存语义的实现"></a>volatile内存语义的实现</h4><p>​ 为了实现volatile的内存语义，JMM会分别限制这两种类型的重排序。下图是JMM针对编译器指定的volatile重排序规则表。</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile04.png" alt></p><ul><li><strong>当第二个操作为volatile写操作时,不管第一个操作是什么(普通读写或者volatile读写),都不能进行重排序。这个规则确保volatile写之前的所有操作都不会被重排序到volatile写之后;</strong></li><li><strong>当第一个操作为volatile读操作时,不管第二个操作是什么,都不能进行重排序。这个规则确保volatile读之后的所有操作都不会被重排序到volatile读之前;</strong></li><li><strong>当第一个操作是volatile写操作时,第二个操作是volatile读操作,不能进行重排序。</strong></li></ul><p>为了实现 volatile 的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。下面是基于保守策略的 JMM 内存屏障插入策略：</p><ul><li><p><strong>在每个 volatile 写操作的前面插入一个 StoreStore 屏障（禁止前面的写与volatile写重排序）。</strong></p></li><li><p><strong>在每个 volatile 写操作的后面插入一个 StoreLoad 屏障（禁止volatile写与后面可能有的读和写重排序）。</strong></p></li><li><p><strong>在每个 volatile 读操作的后面插入一个 LoadLoad 屏障（禁止volatile读与后面的读操作重排序）。</strong></p></li><li><p><strong>在每个 volatile 读操作的后面插入一个 LoadStore 屏障（禁止volatile读与后面的写操作重排序）。</strong></p><p><strong>其中重点说下StoreLaod屏障，它是确保可见性的关键，因为它会将屏障之前的写缓冲区中的数据全部刷新到主内存中</strong>。上述内存屏障插入策略非常保守，但它可以保证在任意处理平台，任意的程序中都能得到正确的volatile语义。下面是保守策略（为什么说保守呢，因为有些在实际的场景是可省略的）下，volatile 写操作 插入内存屏障后生成的指令序列示意图：</p></li></ul><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile05.png" alt></p><p>​ 其中StoreStore屏障可以保证在volatile写之前，其前面的所有普通写操作对任意处理器可见（把它刷新到主内存）。另外volatile写后面有StoreLoad屏障，此屏障的作用是避免volatile写与后面可能有的读或写操作进行重排序。因为编译器常常无法准确判断在一个volatile写的后面是否需要插入一个StoreLoad屏障（比如，一个volatile写之后方法立即return）为了保证能正确实现volatile的内存语义，JMM采取了保守策略：<strong>在每个volatile写的后面插入一个StoreLoad屏障</strong>。因为volatile写-读内存语义的常见模式是：一个写线程写volatile变量，多个度线程读同一个volatile变量。当读线程的数量大大超过写线程时，选择在volatile写之后插入StoreLoad屏障将带来可观的执行效率的提升。从这里也可看出JMM在实现上的一个特点：首先确保正确性，然后再去追求效率（其实我们工作中编码也是一样）。</p><p>下面是在保守策略下，volatile读插入内存屏障后生产的指令序列示意图：</p><p><img src="E:/%E5%8D%9A%E5%AE%A2/blog/source/images/thread/volatile/volatile06.png" alt></p><p>上述volatile写和volatile读的内存屏障插入策略非常保守。在实际执行时，只要不改变volatile写-读的内存语义，编译器可以根据具体情况忽略不必要的屏障。在JMM基础中就有提到过各个处理器对各个屏障的支持度，其中x86处理器仅会对写-读操作做重排序。</p><h3 id="单例模式的双重锁为什么要加volatile"><a href="#单例模式的双重锁为什么要加volatile" class="headerlink" title="单例模式的双重锁为什么要加volatile"></a>单例模式的双重锁为什么要加volatile</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要volatile关键字的原因是，在并发情况下，如果没有volatile关键字，在第8行会出现问题。</p><p>singleton = new Singleton();可以分解为3行伪代码</p><ol><li><p>memory = allocate() //分配内存</p><ol start="2"><li>ctorInstanc(memory) //初始化对象<ol start="3"><li>singleton= memory //设置instance指向刚分配的地址</li><li>上面的代码在编译运行时，可能会出现重排序从1-2-3排序为1-3-2。在多线程的情况下会出现以下问题。线程A在执行第5行代码时，B线程进来，而此时A执行了1和3，没有执行2，此时B线程判断instance不为null，直接返回一个未初始化的对象。</li></ol></li></ol></li></ol><h3 id="synchronize"><a href="#synchronize" class="headerlink" title="synchronize"></a>synchronize</h3><ul><li>volatile是线程同步的轻量级实现，所以volatile的性能要比synchronize好；volatile只能用于修饰变量，synchronize可以用于修饰方法、代码块。随着jdk技术的发展，synchronize在执行效率上会得到较大提升，所以synchronize在项目过程中还是较为常见的；</li><li>多线程访问volatile不会发生阻塞；而synchronize会发生阻塞；</li><li>volatile能保证变量在私有内存和主内存间的同步，但不能保证变量的原子性；synchronize可以保证变量原子性；</li><li>volatile是变量在多线程之间的可见性；synchronize是多线程之间访问资源的同步性；<br>对于volatile修饰的变量，可以解决变量读时可见性问题，无法保证原子性。对于多线程访问同一个实例变量还是需要加锁同步。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      volatile实现原理
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="volatile" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/volatile/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="实现原理" scheme="http://www.baiyp.ren/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="volatile" scheme="http://www.baiyp.ren/tags/volatile/"/>
    
  </entry>
  
  <entry>
    <title>final实现原理</title>
    <link href="http://www.baiyp.ren/final%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.html"/>
    <id>http://www.baiyp.ren/final实现原理.html</id>
    <published>2019-09-01T01:11:04.000Z</published>
    <updated>2019-09-07T04:48:19.073Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="final实现原理"><a href="#final实现原理" class="headerlink" title="final实现原理"></a>final实现原理</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>​ <strong>final</strong>关键字，实际的含义就一句话，不可改变。什么是不可改变？就是初始化完成之后就不能再做任何的修改，修饰成员变量的时候，成员变量变成一个常数；修饰方法的时候，方法不允许被重写；修饰类的时候，类不允许被继承；修饰参数列表的时候，入参的对象也是不可以改变。这个就是不可变，无论是引用新的对象，重写还是继承，都是改变的方法，而final就是把这个变更的路给堵死</p><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><h4 id="final修饰变量"><a href="#final修饰变量" class="headerlink" title="final修饰变量"></a>final修饰变量</h4><ul><li>final成员变量表示常量，只能被赋值一次，赋值后值不再改变（final要求地址值不能改变）</li><li>当final修饰一个基本数据类型时，表示该基本数据类型的值一旦在初始化后便不能发生变化；</li><li>如果final修饰一个引用类型时，则在对其初始化之后便不能再让其指向其他对象了，但该引用所指向的对象的内容是可以发生变化的。本质上是一回事，因为引用的值是一个地址，final要求值，即地址的值不发生变化。</li><li>final修饰一个成员变量（属性），必须要显示初始化。这里有两种初始化方式。<ul><li>一种是在变量声明的时候初始化。</li><li>第二种方法是在声明变量的时候不赋初值，但是要在这个变量所在的类的所有的构造函数中对这个变量赋初值。</li></ul></li></ul><h4 id="final修饰方法"><a href="#final修饰方法" class="headerlink" title="final修饰方法"></a>final修饰方法</h4><blockquote><p>使用final方法的原因有两个。</p></blockquote><ul><li><p>第一个原因是把方法锁定，以防任何继承类修改它的含义，不能被重写；</p></li><li><p>第二个原因是效率，final方法比非final方法要快，因为在编译的时候已经静态绑定了，不需要在运行时再动态绑定。</p></li></ul><p><strong>注：类的private方法会隐式地被指定为final方法</strong></p><h4 id="final修饰类"><a href="#final修饰类" class="headerlink" title="final修饰类"></a>final修饰类</h4><blockquote><p>当用final修饰一个类时，表明这个类不能被继承。</p></blockquote><p>final类中的成员变量可以根据需要设为final，但是要注意final类中的所有成员方法都会被隐式地指定为final方法。</p><p>在使用final修饰类的时候，要注意谨慎选择，除非这个类真的在以后不会用来继承或者出于安全的考虑，尽量不要将类设计为final类。</p><h3 id="final关键字的好处"><a href="#final关键字的好处" class="headerlink" title="final关键字的好处"></a>final关键字的好处</h3><ul><li><p>final关键字提高了性能。JVM和Java应用都会缓存final变量。</p></li><li><p>final变量可以安全的在多线程环境下进行共享，而不需要额外的同步开销。</p></li><li><p>使用final关键字，JVM会对方法、变量及类进行优化。</p></li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>final关键字可以用于成员变量、本地变量、方法以及类。</li><li>final成员变量必须在声明的时候初始化或者在构造器中初始化，否则就会报编译错误。</li><li>你不能够对final变量再次赋值。</li><li>本地变量必须在声明时赋值。</li><li>在匿名类中所有变量都必须是final变量。</li><li>final方法不能被重写。</li><li>final类不能被继承。</li><li>final关键字不同于finally关键字，后者用于异常处理。</li><li>final关键字容易与finalize()方法搞混，后者是在Object类中定义的方法，是在垃圾回收之前被JVM调用的方法。</li><li>接口中声明的所有变量本身是final的。</li><li>final和abstract这两个关键字是反相关的，final类就不可能是abstract的。</li><li>final方法在编译阶段绑定，称为静态绑定(static binding)。</li><li>没有在声明时初始化final变量的称为空白final变量(blank final variable)，它们必须在构造器中初始化，或者调用this()初始化。不这么做的话，编译器会报错“final变量(变量名)需要进行初始化”。</li><li>将类、方法、变量声明为final能够提高性能，这样JVM就有机会进行估计，然后优化。</li><li>按照Java代码惯例，final变量就是常量，而且通常常量名要大写。</li><li>对于集合对象声明为final指的是引用不能被更改，但是你可以向其中增加，删除或者改变内容。</li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><h4 id="内存语义"><a href="#内存语义" class="headerlink" title="内存语义"></a>内存语义</h4><blockquote><p>写内存语义可以确保在对象的引用为任意线程可见之前，final 域已经被初始化过了。</p><p>读内存语义可以确保如果对象的引用不为 null，则说明 final 域已经被初始化过了。</p><p>总之，final 域的内存语义提供了初始化安全保证。</p></blockquote><ul><li><strong>写内存语义</strong>：在构造函数内对一个 final 域的写入，与随后将对象引用赋值给引用变量，这两个操作不能重排序。</li><li><strong>读内存语义</strong>：初次读一个包含 final 域的对象的引用，与随后初次读这个 final 域，这两个操作不能重排序。</li></ul><h4 id="Final域是普通类型"><a href="#Final域是普通类型" class="headerlink" title="Final域是普通类型"></a>Final域是普通类型</h4><blockquote><p>对于final域，编译器和处理器要遵守两个重排序规则</p></blockquote><ol><li><p>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p><p>（先写入final变量，后调用该对象引用）</p><p>原因：编译器会在final域的写之后，插入一个StoreStore屏障</p></li><li><p>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</p><p>（先读对象的引用，后读final变量）</p></li></ol><p>​ 编译器会在读final域操作的前面插入一个LoadLoad屏障</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 普通变量</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="comment">// final 变量</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">static</span> FinalExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FinalExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 写普通域</span></span><br><span class="line">        i = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 写 final 域</span></span><br><span class="line">        j = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写方法A执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> FinalExample();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程B执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 读对象引用</span></span><br><span class="line">        FinalExample object = obj;</span><br><span class="line">        <span class="comment">// 读普通域         a=1或者a=0或者直接报错i没有初始化</span></span><br><span class="line">        <span class="keyword">int</span> a = object.i;</span><br><span class="line">        <span class="comment">/// 读 final域</span></span><br><span class="line">        <span class="keyword">int</span> b = object.j;</span><br><span class="line">        b = <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="第一种情况"><a href="#第一种情况" class="headerlink" title="第一种情况"></a>第一种情况</h5><p>写普通域的操作被编译器重排序到了构造函数之外</p><p>而写 final 域的操作，被写 final 域的重排序规则“限定”在了构造函数之内，读线程 B 正确的读取了 final 变量初始化之后的值。</p><p><strong>写 final 域的重排序规则可以确保</strong>：在对象引用为任意线程可见之前，对象的 final 域已经被正确初始化过了，而普通域不具有这个保障。</p><p><img src="../images/thread/final/final01.png" alt></p><h5 id="第二种情况"><a href="#第二种情况" class="headerlink" title="第二种情况"></a>第二种情况</h5><p>读对象的普通域的操作被处理器重排序到读对象引用之前</p><p>而读 final 域的重排序规则会把读对象 final 域的操作“限定”在读对象引用之后，此时该 final 域已经被 A 线程初始化过了，这是一个正确的读取操作。</p><p><strong>读 final 域的重排序规则可以确保</strong>：在读一个对象的 final 域之前，一定会先读包含这个 final 域的对象的引用。</p><p><img src="../images/thread/final/final02.png" alt></p><h4 id="final-域是引用类型"><a href="#final-域是引用类型" class="headerlink" title="final 域是引用类型"></a>final 域是引用类型</h4><blockquote><p>对于引用类型，写 final 域的重排序规则对编译器和处理器增加了如下约束：</p><p>在构造函数内对一个 final 引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * final域是引用类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalReferenceExample</span> </span>&#123;</span><br><span class="line">    <span class="comment">// final 是引用类型</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] intArray;</span><br><span class="line">    <span class="keyword">static</span> FinalReferenceExample obj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FinalReferenceExample</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        intArray = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>]; <span class="comment">// 1</span></span><br><span class="line">        intArray[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">// 2</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程 A 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerOne</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj = <span class="keyword">new</span> FinalReferenceExample(); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 写线程 B 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">writerTwo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        obj.intArray[<span class="number">0</span>] = <span class="number">2</span>; <span class="comment">// 4</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 读线程 C 执行</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">reader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123; <span class="comment">// 5</span></span><br><span class="line">            <span class="comment">// temp1=1或者temp1=2，不可能等于0</span></span><br><span class="line">            <span class="keyword">int</span> temp1 = obj.intArray[<span class="number">0</span>]; <span class="comment">// 6</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设首先线程 A 执行 writerOne() 方法，执行完后线程 B 执行 writerTwo() 方法，执行完后线程 C 执行 reader () 方法。</p><p><img src="../images/thread/final/final03.png" alt></p><p>在上图中<br>1 是对 final 域的写入；<br>2 是对这个 final 域引用的对象的成员域的写入；<br>3 是把被构造的对象的引用赋值给某个引用变量。这里除了前面提到的 1 不能和 3 重排序外，2 和 3 也不能重排序。</p><p>JMM 可以确保读线程 C 至少能看到写线程 A 在构造函数中对 final 引用对象的成员域的写入。即 C 至少能看到数组下标 0 的值为 1。而写线程 B 对数组元素的写入，读线程 C 可能看的到，也可能看不到。JMM 不保证线程 B 的写入对读线程 C 可见，因为写线程 B 和读线程 C 之间存在数据竞争，此时的执行结果不可预知。</p><h3 id="final、finally、-finalize区别"><a href="#final、finally、-finalize区别" class="headerlink" title="final、finally、 finalize区别"></a>final、finally、 finalize区别</h3><ul><li>final可以用来修饰类、方法、变量，分别有不同的意义，final修饰的class代表不可以继承扩展，final的变量是不可以修改的，而final的方法也是不可以重写的（override）。</li><li>finally则是Java保证重点代码一定要被执行的一种机制。我们可以使用try-finally或者try-catch-finally来进行类似关闭JDBC连接、保证unlock锁等动作。</li><li>finalize是基础类java.lang.Object的一个方法，它的设计目的是保证对象在被垃圾收集前完成特定资源的回收。finalize机制现在已经不推荐使用，并且在JDK 9开始被标记为deprecated。</li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      final实现原理
    
    </summary>
    
      <category term="并发" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="final" scheme="http://www.baiyp.ren/categories/%E5%B9%B6%E5%8F%91/final/"/>
    
    
      <category term="并发" scheme="http://www.baiyp.ren/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="实现原理" scheme="http://www.baiyp.ren/tags/%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"/>
    
      <category term="final" scheme="http://www.baiyp.ren/tags/final/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式08-建造者模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F08.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式08.html</id>
    <published>2019-08-31T01:42:30.000Z</published>
    <updated>2019-09-08T11:51:00.731Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-建造者模式（Builder-Pattern）"><a href="#JAVA设计模式-建造者模式（Builder-Pattern）" class="headerlink" title="JAVA设计模式-建造者模式（Builder Pattern）"></a>JAVA设计模式-建造者模式（Builder Pattern）</h2><p><img src="../images/design-patterns/builderpattern01.png" alt></p><h3 id="什么是建造者模式"><a href="#什么是建造者模式" class="headerlink" title="什么是建造者模式"></a>什么是建造者模式</h3><p>​ 建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p><p>一个 Builder 类会一步一步构造最终的对象。该 Builder 类是独立于其他对象的</p><p>​ 创建者模式又叫建造者模式，是将一个复杂的对象的<strong>构建</strong>与它的<strong>表示</strong>分离，使<br>得同样的构建过程可以创建不同的表示。创建者模式隐藏了复杂对象的创建过程，它把复杂对象的创建过程加以抽象，通过子类继承或者重载的方式，动态的创建具有复合属性的对象。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><strong>Product（产品角色）：</strong> 一个具体的产品对象。</li><li><strong>Builder（抽象建造者）：</strong>创建一个Product对象的各个部件指定的抽象接口。</li><li><strong>ConcreteBuilder（具体建造者）：</strong>实现抽象接口，构建和装配各个部件。</li><li><strong>Director（指挥者）：</strong>构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离了客户与对象的生产过程，二是：负责控制产品对象的生产过程。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合 “开闭原则”</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>产品之间差异性很大的情况：建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果</li><li>多个部件都可以装配到一个对象中，但产生的运行结果不相同</li><li>产品类非常复杂或者产品类因为调用顺序不同而产生不同作用</li><li>初始化一个对象时，参数过多，或者很多参数具有默认值</li><li>Builder模式不适合创建差异性很大的产品类</li><li>产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本</li><li>需要生成的产品对象有复杂的内部结构，这些产品对象具备共性；</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ul><h3 id="主要作用"><a href="#主要作用" class="headerlink" title="主要作用"></a>主要作用</h3><blockquote><p>在用户不知道对象的建造过程和细节的情况下就可以直接创建复杂的对象。</p></blockquote><ul><li>用户只需要给出指定复杂对象的类型和内容；</li><li>建造者模式负责按顺序创建复杂对象（把内部的建造过程和细节隐藏起来)</li></ul><h3 id="解决的问题"><a href="#解决的问题" class="headerlink" title="解决的问题"></a>解决的问题</h3><ul><li>方便用户创建复杂的对象（不需要知道实现过程）</li><li>代码复用性 &amp; 封装性（将对象构建过程和细节进行封装 &amp; 复用）</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><h4 id="产品类"><a href="#产品类" class="headerlink" title="产品类"></a>产品类</h4><blockquote><p>需要进行构建的原始的产品类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 需要进行构建的产品类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Product</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单价</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Product&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", price="</span> + price +</span><br><span class="line">                <span class="string">", num="</span> + num +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Builder-接口"><a href="#Builder-接口" class="headerlink" title="Builder 接口"></a>Builder 接口</h4><blockquote><p>Builder 可以是接口也可以是抽象类，定义需要实现的构建模板</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="comment">//构建产品名称</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建单价</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建数量</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取构建的对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体建造者（ConcreteBuilder）"><a href="#具体建造者（ConcreteBuilder）" class="headerlink" title="具体建造者（ConcreteBuilder）"></a>具体建造者（ConcreteBuilder）</h4><h5 id="构建苹果手机"><a href="#构建苹果手机" class="headerlink" title="构建苹果手机"></a>构建苹果手机</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建苹果手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MobileBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">"iphone手机"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPrice(<span class="number">8000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setNum(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="构建手表"><a href="#构建手表" class="headerlink" title="构建手表"></a>构建手表</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 构建手表</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WatchBuilder</span> <span class="keyword">implements</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Product product = <span class="keyword">new</span> Product();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setName(<span class="string">"手表"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setPrice(<span class="number">10000</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        product.setNum(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> product;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="指挥者-Director"><a href="#指挥者-Director" class="headerlink" title="指挥者(Director)"></a>指挥者(Director)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 指挥者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Director</span> </span>&#123;</span><br><span class="line">    <span class="comment">//建造者接口</span></span><br><span class="line">    <span class="keyword">private</span> Builder builder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Director</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.builder = builder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构建具体的对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 构建出来的对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">getProduct</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.buildName();</span><br><span class="line">        builder.buildPrice();</span><br><span class="line">        builder.buildNum();</span><br><span class="line">        <span class="keyword">return</span> builder.build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端使用"><a href="#客户端使用" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 建造者测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//打印手机</span></span><br><span class="line">        printBuild(<span class="keyword">new</span> MobileBuilder());</span><br><span class="line">        <span class="comment">//打印手表</span></span><br><span class="line">        printBuild(<span class="keyword">new</span> WatchBuilder());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印建造后的对象数据</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printBuild</span><span class="params">(Builder builder)</span></span>&#123;</span><br><span class="line">        Director director = <span class="keyword">new</span> Director(builder);</span><br><span class="line">        Product product = director.getProduct();</span><br><span class="line">        System.out.println(product.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Product&#123;name=<span class="string">'iphone手机'</span>, price=<span class="number">8000.0</span>, num=<span class="number">1000</span>&#125;</span><br><span class="line">Product&#123;name=<span class="string">'手表'</span>, price=<span class="number">10000.0</span>, num=<span class="number">10</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="通过链式调用优化-非常推荐"><a href="#通过链式调用优化-非常推荐" class="headerlink" title="通过链式调用优化(非常推荐)"></a>通过链式调用优化(非常推荐)</h3><blockquote><p>链式写法是在原型写法的基础上做优化，有些时候<code>Builder</code>的创建部分有默认值，或者不需要的情况下，而产生不同的<code>Product</code>，通过以上方式，就需要修改<code>Director</code>类和<code>Builder</code>类，再或者根据不同的创建顺序，生成不同的结果，也需要修改<code>Director</code>类。<code>Director</code>似乎显得很不稳定和多余。可以通过<code>Builder</code>自身的调用逻辑来生成<code>Product</code>，即链式调用</p></blockquote><h4 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h4><blockquote></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链式的建造者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamProductBuilder</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 产品名称</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 单价</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamProductBuilder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StreamProductBuilder</span><span class="params">(String name, <span class="keyword">float</span> price, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 静态类 Builder</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 产品名称</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 单价</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">float</span> price;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> num;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//空的构造方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 进行建造</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> name</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">name</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">price</span><span class="params">(<span class="keyword">float</span> prie)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.price = price;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">num</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.num = num;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 返回建造的对象</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> StreamProductBuilder <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> StreamProductBuilder(name, price, num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPrice</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPrice</span><span class="params">(<span class="keyword">float</span> price)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.price = price;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNum</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.num = num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端使用-1"><a href="#客户端使用-1" class="headerlink" title="客户端使用"></a>客户端使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BuildTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StreamProductBuilder builder = <span class="keyword">new</span> StreamProductBuilder.Builder().name(<span class="string">"iphone手机"</span>).price(<span class="number">8000</span>).num(<span class="number">100</span>).build();</span><br><span class="line">        System.out.println(builder.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的示例代码只是传入三个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性，代码更加简洁。</p><h4 id="相比于普通JavaBean的好处"><a href="#相比于普通JavaBean的好处" class="headerlink" title="相比于普通JavaBean的好处"></a>相比于普通JavaBean的好处</h4><p>​ 在建造者模式中,提供一个辅助的静态建造器<code>Builder</code>(静态内部类),可以在里面<code>set</code>实体类的属性,与<code>JavaBean</code>不同的是,建造者是先<code>set</code>,在通过<code>build</code>实例化实体类,这样既可以提高代码的阅读性,也可以防止对象没有实例化,就被调用;不会造成不一致性,同时解决了<code>Javabean</code>模式的线程安全问题</p><h3 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族 。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象 。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​ <strong>Director角色并非多余，能把复杂的Product创建过程对外隐藏，使Builder部件和创建过程分离，各方易于扩展，降低了耦合度。当需要对一个对象设置很多属性，此时就能方便的使用链式调用来提高编码速度和代码可读性。</strong></p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之建造者模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="建造者模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="建造者模式" scheme="http://www.baiyp.ren/tags/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式09-责任链模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F09.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式09.html</id>
    <published>2019-08-31T01:42:30.000Z</published>
    <updated>2019-09-08T15:10:00.276Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-责任链模式（Chain-of-Responsibility-Pattern）"><a href="#JAVA设计模式-责任链模式（Chain-of-Responsibility-Pattern）" class="headerlink" title="JAVA设计模式-责任链模式（Chain of Responsibility Pattern）"></a>JAVA设计模式-责任链模式（Chain of Responsibility Pattern）</h2><p><img src="../images/design-patterns/chainofresponsibility01.png" alt></p><h3 id="什么是责任链模式"><a href="#什么是责任链模式" class="headerlink" title="什么是责任链模式"></a>什么是责任链模式</h3><blockquote><p>使多个对象都有机会处理请求，从而避免请求的发送者与请求处理者耦合在一起。将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p></blockquote><p>​ 顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。</p><p>​ 在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p><p><strong>注意：责任链模式也叫职责链模式。</strong></p><p>​ 在责任链模式中，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递过程，所以责任链将请求的发送者和请求的处理者解耦了。</p><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><strong>抽象处理者（Handler）:</strong> 定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li><li><strong>具体处理者（Concrete Handler）：</strong>实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li><li><strong>客户类（Client）：</strong>创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>降低了对象之间的耦合度。该模式使得一个对象无须知道到底是哪一个对象处理其请求以及链的结构，发送者和接收者也无须拥有对方的明确信息。</li><li>增强了系统的可扩展性。可以根据需要增加新的请求处理类，满足开闭原则。</li><li>增强了给对象指派职责的灵活性。当工作流程发生变化，可以动态地改变链内的成员或者调动它们的次序，也可动态地新增或者删除责任。</li><li>责任链简化了对象之间的连接。每个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</li><li>责任分担。每个类只需要处理自己该处理的工作，不该处理的传递给下一个对象完成，明确各类的责任范围，符合类的单一职责原则。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li><li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li><li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li><li>可能不容易观察运行时的特征，有碍于除错。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求。</li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>​ 我们创建抽象类 <em>AbstractLogger</em>，带有详细的日志记录级别。然后我们创建三种类型的记录器，都扩展了 <em>AbstractLogger</em>。每个记录器消息的级别是否属于自己的级别，如果是则相应地打印出来，否则将不打印并把消息传给下一个记录器。</p><p><img src="../images/design-patterns/chainofresponsibility02.jpg" alt></p><h4 id="抽象的记录器类"><a href="#抽象的记录器类" class="headerlink" title="抽象的记录器类"></a>抽象的记录器类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 抽象的记录器类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> INFO = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> DEBUG = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> ERROR = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> level;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//责任链中的下一个元素</span></span><br><span class="line">    <span class="keyword">protected</span> AbstractLogger nextLogger;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置下一个元素</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> nextLogger</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNextLogger</span><span class="params">(AbstractLogger nextLogger)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nextLogger = nextLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logMessage</span><span class="params">(<span class="keyword">int</span> level, String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.level &lt;= level) &#123;</span><br><span class="line">            write(message);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nextLogger != <span class="keyword">null</span>) &#123;</span><br><span class="line">            nextLogger.logMessage(level, message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印日志</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="具体处理者"><a href="#具体处理者" class="headerlink" title="具体处理者"></a>具体处理者</h4><blockquote><p>创建扩展了该记录器类的实体类。</p></blockquote><h5 id="控制台日志"><a href="#控制台日志" class="headerlink" title="控制台日志"></a>控制台日志</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 控制台日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsoleLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConsoleLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Standard Console::Logger: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="错误日志"><a href="#错误日志" class="headerlink" title="错误日志"></a>错误日志</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 错误日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Error Console::Logger: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="文件日志"><a href="#文件日志" class="headerlink" title="文件日志"></a>文件日志</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 文件日志</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">AbstractLogger</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 构造方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> level</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(<span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.level = level;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 打印日志</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> message</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"File::Logger: "</span> + message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户类"><a href="#客户类" class="headerlink" title="客户类"></a>客户类</h4><blockquote><p>创建不同类型的记录器。赋予它们不同的错误级别，并在每个记录器中设置下一个记录器。每个记录器中的下一个记录器代表的是链的一部分。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 责任链模式测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChainPatternDemo</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取责任链</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AbstractLogger <span class="title">getChainOfLoggers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建错误日志</span></span><br><span class="line">        AbstractLogger errorLogger = <span class="keyword">new</span> ErrorLogger(AbstractLogger.ERROR);</span><br><span class="line">        <span class="comment">//构建debug日志</span></span><br><span class="line">        AbstractLogger fileLogger = <span class="keyword">new</span> FileLogger(AbstractLogger.DEBUG);</span><br><span class="line">        <span class="comment">//构建info日志</span></span><br><span class="line">        AbstractLogger consoleLogger = <span class="keyword">new</span> ConsoleLogger(AbstractLogger.INFO);</span><br><span class="line">        <span class="comment">//构建责任链</span></span><br><span class="line">        <span class="comment">//设置下一级日志为fileLogger</span></span><br><span class="line">        errorLogger.setNextLogger(fileLogger);</span><br><span class="line">        <span class="comment">//设置下一级日志为consoleLogger</span></span><br><span class="line">        fileLogger.setNextLogger(consoleLogger);</span><br><span class="line">        <span class="keyword">return</span> errorLogger;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        AbstractLogger loggerChain = getChainOfLoggers();</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.INFO, <span class="string">"打印INFO日志"</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.DEBUG,</span><br><span class="line">                <span class="string">"打印DEBUG日志"</span>);</span><br><span class="line">        loggerChain.logMessage(AbstractLogger.ERROR,</span><br><span class="line">                <span class="string">"打印ERROR日志"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Standard Console::Logger: 打印INFO日志</span><br><span class="line">File::Logger: 打印DEBUG日志</span><br><span class="line">Standard Console::Logger: 打印DEBUG日志</span><br><span class="line">Error Console::Logger: 打印ERROR日志</span><br><span class="line">File::Logger: 打印ERROR日志</span><br><span class="line">Standard Console::Logger: 打印ERROR日志</span><br></pre></td></tr></table></figure><h3 id="责任链模式的纯与非纯模式"><a href="#责任链模式的纯与非纯模式" class="headerlink" title="责任链模式的纯与非纯模式"></a>责任链模式的纯与非纯模式</h3><blockquote><p>职责链模式可分为纯的职责链模式和不纯的职责链模式两种</p></blockquote><ul><li><p>纯的职责链模式</p><p>​ 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的职责链模式。</p></li><li><p>不纯的职责链模式</p><p>​ 在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。Java AWT 1.0中的事件处理模型应用的是不纯的职责链模式，其基本原理如下：由于窗口组件（如按钮、文本框等）一般都位于容器组件中，因此当事件发生在某一个组件上时，先通过组件对象的handleEvent()方法将事件传递给相应的事件处理方法，该事件处理方法将处理此事件，然后决定是否将该事件向上一级容器组件传播；上级容器组件在接到事件之后可以继续处理此事件并决定是否继续向上级容器组件传播，如此反复，直到事件到达顶层容器组件为止；如果一直传到最顶层容器仍没有处理方法，则该事件不予处理。每一级组件在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况。显然，这就是不纯的职责链模式，早期的Java AWT事件模型(JDK 1.0及更早)中的这种事件处理机制又叫事件浮升(Event Bubbling)机制。从Java.1.1以后，JDK使用观察者模式代替职责链模式来处理事件。目前，在JavaScript中仍然可以使用这种事件浮升机制来进行事件处理。</p></li></ul><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之责任链模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="责任链模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="责任链模式" scheme="http://www.baiyp.ren/tags/%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JAVA设计模式07-代理模式</title>
    <link href="http://www.baiyp.ren/JAVA%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F07.html"/>
    <id>http://www.baiyp.ren/JAVA设计模式07.html</id>
    <published>2019-08-30T01:42:30.000Z</published>
    <updated>2019-09-10T06:35:25.565Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JAVA设计模式-代理模式（Proxy-Pattern）"><a href="#JAVA设计模式-代理模式（Proxy-Pattern）" class="headerlink" title="JAVA设计模式-代理模式（Proxy Pattern）"></a>JAVA设计模式-代理模式（Proxy Pattern）</h2><p><img src="../images/design-patterns/proxyparrern01.png" alt></p><h3 id="什么是代理模式"><a href="#什么是代理模式" class="headerlink" title="什么是代理模式"></a>什么是代理模式</h3><p>​ 在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个称之为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。</p><p>​ 代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、保护代理、虚拟代理、缓冲代理、智能引用代理等，后面将学习这些不同的代理形式。</p><p>​ 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。</p><p>​ 代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。</p><h4 id="为什么要用代理模式"><a href="#为什么要用代理模式" class="headerlink" title="为什么要用代理模式"></a>为什么要用代理模式</h4><ul><li><strong>中介隔离作用：</strong>在某些情况下，一个客户类不想或者不能直接引用一个委托对象，而代理类对象可以在客户类和委托对象之间起到中介的作用，其特征是代理类和委托类实现相同的接口。</li><li><strong>开闭原则，增加功能：</strong>代理类除了是客户类和委托类的中介之外，我们还可以通过给代理类增加额外的功能来扩展委托类的功能，这样做我们只需要修改代理类而不需要再修改委托类，符合代码设计的开闭原则。代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是同过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</li></ul><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><ul><li><strong>Subject（抽象主题角色）：</strong> 它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li><li><strong>Proxy（代理主题角色）：</strong> 它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</li><li><strong>RealSubject（真实主题角色）：</strong> 它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>职责清晰。</li><li>高扩展性。</li><li>智能化。</li></ul><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。</li><li>实现代理模式需要额外的工作，有些代理模式的实现非常复杂。</li></ul><h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul><li>远程代理。</li><li>虚拟代理。</li><li>Copy-on-Write 代理。</li><li>保护（Protect or Access）代理。</li><li>Cache代理。</li><li>防火墙（Firewall）代理。</li><li>同步化（Synchronization）代理。</li><li>智能引用（Smart Reference）代理。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</li><li>和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</li></ul><h3 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h3><blockquote><p>其实代理的一般模式就是静态代理的实现模式：首先创建一个接口（JDK代理都是面向接口的），然后创建具体实现类来实现这个接口，在创建一个代理类同样实现这个接口，不同之处在于，具体实现类的方法中需要将接口中定义的方法的业务逻辑功能实现，而代理类中的方法只要调用具体类中的对应方法即可，这样我们在需要使用接口中的某个方法的功能时直接调用代理类的方法即可，将具体的实现类隐藏在底层。</p></blockquote><p><img src="../images/design-patterns/proxyparrern02.png" alt></p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><h5 id="公用接口"><a href="#公用接口" class="headerlink" title="公用接口"></a>公用接口</h5><blockquote><p>代理类和真实类的公用接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="真实类的请求"><a href="#真实类的请求" class="headerlink" title="真实类的请求"></a>真实类的请求</h5><blockquote><p>实现公有的接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"真实请求"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="创建代理类"><a href="#创建代理类" class="headerlink" title="创建代理类"></a>创建代理类</h5><blockquote><p>代理请求，引入了真实类对象，对方法进行了增强。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line"><span class="comment">//真实请求接口</span></span><br><span class="line">    <span class="keyword">private</span> Subject realSubject;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realSubject == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realSubject = <span class="keyword">new</span> RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//转发真实请求</span></span><br><span class="line">        realSubject.request();</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Proxy proxy = <span class="keyword">new</span> Proxy();</span><br><span class="line">        proxy.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="静态代理总结"><a href="#静态代理总结" class="headerlink" title="静态代理总结"></a>静态代理总结</h4><p>优点：可以做到在符合开闭原则的情况下对目标对象进行功能扩展。</p><p>缺点：我们得为每一个服务都得创建代理类，工作量太大，不易管理。同时接口一旦发生改变，代理类也得相应修改。</p><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><blockquote><p>在动态代理中我们不再需要再手动的创建代理类，我们只需要编写一个动态处理器就可以了。真正的代理对象由JDK再运行时为我们动态的来创建。</p></blockquote><h4 id="编写动态处理器"><a href="#编写动态处理器" class="headerlink" title="编写动态处理器"></a>编写动态处理器</h4><blockquote><p>动态代理需要实现InvocationHandler接口</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理类只能代理接口（不支持抽象类），代理类都需要实现InvocationHandler类，实现invoke方法。</span></span><br><span class="line"><span class="comment"> * 该invoke方法就是调用被代理接口的所有方法时需要调用的，该invoke方法返回的值是被代理接口的一个实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 绑定关系，也就是关联到哪个接口（与具体的实现类绑定）的哪些方法将被调用时，执行invoke方法。</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> targetObject</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">newProxyInstance</span><span class="params">(Object targetObject)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.targetObject=targetObject;</span><br><span class="line">        <span class="comment">//该方法用于为指定类装载器、一组接口及调用处理器生成动态代理类实例</span></span><br><span class="line">        <span class="comment">//第一个参数指定产生代理对象的类加载器，需要将其指定为和目标对象同一个类加载器</span></span><br><span class="line">        <span class="comment">//第二个参数要实现和目标对象一样的接口，所以只需要拿到目标对象的实现接口</span></span><br><span class="line">        <span class="comment">//第三个参数表明这些被拦截的方法在被拦截时需要执行哪个InvocationHandler的invoke方法</span></span><br><span class="line">        <span class="comment">//根据传入的目标返回一个代理对象</span></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(targetObject.getClass().getClassLoader(),</span><br><span class="line">                targetObject.getClass().getInterfaces(),<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 关联的这个实现类的方法被调用时将被执行</span></span><br><span class="line"><span class="comment">     * InvocationHandler接口的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 原对象被调用的方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 表示方法的参数*</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//调用目标方法</span></span><br><span class="line">        Object result = method.invoke(targetObject, args);</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试-1"><a href="#测试-1" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        DynamicProxyHandler dynamicProxyHandler=<span class="keyword">new</span> DynamicProxyHandler();</span><br><span class="line">        UserManager userManager=(UserManager)dynamicProxyHandler.newProxyInstance(<span class="keyword">new</span> UserManagerImpl());</span><br><span class="line">        UserManager userManager=<span class="keyword">new</span> UserManagerImpl();</span><br><span class="line">        userManager.addUser(<span class="string">"1111"</span>, <span class="string">"张三"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="动态代理总结"><a href="#动态代理总结" class="headerlink" title="动态代理总结"></a>动态代理总结</h4><p>​ 虽然相对于静态代理，动态代理大大减少了我们的开发任务，同时减少了对业务接口的依赖，降低了耦合度。但是还是有一点点小小的遗憾之处，那就是它始终无法摆脱仅支持interface代理的桎梏，因为它的设计注定了这个遗憾。回想一下那些动态生成的代理类的继承关系图，它们已经注定有一个共同的父类叫Proxy。Java的继承机制注定了这些动态代理类们无法实现对class的动态代理，原因是多继承在Java中本质上就行不通。有很多条理由，人们可以否定对 class代理的必要性，但是同样有一些理由，相信支持class动态代理会更美好。接口和类的划分，本就不是很明显，只是到了Java中才变得如此的细化。如果只从方法的声明及是否被定义来考量，有一种两者的混合体，它的名字叫抽象类。实现对抽象类的动态代理，相信也有其内在的价值。此外，还有一些历史遗留的类，它们将因为没有实现任何接口而从此与动态代理永世无缘。如此种种，不得不说是一个小小的遗憾。但是，不完美并不等于不伟大，伟大是一种本质，Java动态代理就是佐例。</p><h3 id="CGLIB动态代理"><a href="#CGLIB动态代理" class="headerlink" title="CGLIB动态代理"></a>CGLIB动态代理</h3><blockquote><p>JDK实现动态代理需要实现类通过接口定义业务方法，对于没有接口的类，如何实现动态代理呢，这就需要CGLib了。CGLib采用了非常底层的字节码技术，其原理是通过字节码技术为一个类创建子类，并在子类中采用方法拦截的技术拦截所有父类方法的调用，顺势织入横切逻辑。但因为采用的是继承，所以不能对final修饰的类进行代理。JDK动态代理与CGLib动态代理均是实现Spring AOP的基础。</p></blockquote><h4 id="创建CGLIB代理类"><a href="#创建CGLIB代理类" class="headerlink" title="创建CGLIB代理类"></a>创建CGLIB代理类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxy</span> <span class="keyword">implements</span> <span class="title">MethodInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 目标对象</span></span><br><span class="line">    <span class="keyword">private</span> Object targetObject;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getInstance</span><span class="params">(<span class="keyword">final</span> Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">        <span class="comment">//CGLIB enhancer增强类对象</span></span><br><span class="line">        Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">        <span class="comment">//设置代理类</span></span><br><span class="line">        enhancer.setSuperclass(<span class="keyword">this</span>.targetObject.getClass());</span><br><span class="line">        <span class="comment">//定义代理逻辑对象为当前对象   ，对象要继承MethodInterceptor。并实现逻辑方法intercept</span></span><br><span class="line">        enhancer.setCallback(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> enhancer.create();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 代理逻辑方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> proxy 代理对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> method 方法</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> args 方法参数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> methodProxy 方法代理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Throwable</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object proxy, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"前置增强"</span>);</span><br><span class="line">        <span class="comment">//真的是代理对象，不像JDk代理，还是真实对象</span></span><br><span class="line">        Object result = methodProxy.invokeSuper(proxy, args);</span><br><span class="line">        System.out.println(<span class="string">"后置增强"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里用了CGLIB的加强者Enhancer,通过设置超类的方法setSuperclass，然后通过setCallback方法设置哪个类为它的代理类。其中，参数为this就意味着是当前对象，那就要求用this这个对象实现接口Methodlnterceptor的方法intercept，然后返回代理对象。那么此时当前类的intercept方法就是其代理逻辑方法，其参数内容见代码注解，我们在反射真实对象方法前后进行了打印，CGLIB是通过如下代码完成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object result=methodProxy.invokeSuper(proxy,args);</span><br></pre></td></tr></table></figure><h4 id="测试-2"><a href="#测试-2" class="headerlink" title="测试"></a>测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CglibProxyDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String arg[])</span> </span>&#123;</span><br><span class="line">        CglibProxy cglib = <span class="keyword">new</span> CglibProxy();</span><br><span class="line">        Dog dog = (Dog) cglib.getInstance(Dog.class);</span><br><span class="line">        <span class="comment">//调用代理对象的isAnimal()方法</span></span><br><span class="line">        dog.isAnimal(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="CGLIB代理总结"><a href="#CGLIB代理总结" class="headerlink" title="CGLIB代理总结"></a>CGLIB代理总结</h4><p>​ CGLIB创建的动态代理对象比JDK创建的动态代理对象的性能更高，但是CGLIB创建代理对象时所花费的时间却比JDK多得多。所以对于单例的对象，因为无需频繁创建对象，用CGLIB合适，反之使用JDK方式要更为合适一些。同时由于CGLib由于是采用动态创建子类的方法，对于final修饰的方法无法进行代理。</p><h3 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h3><h4 id="使用对比"><a href="#使用对比" class="headerlink" title="使用对比"></a>使用对比</h4><ul><li>JDK动态代理是面向接口的。</li><li>CGLib动态代理是通过字节码底层继承要代理类来实现（如果被代理类被final关键字所修饰，那么抱歉会失败）。</li></ul><h4 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h4><blockquote><p>传言的 cglib 比 jdk动态代理高出 10 倍</p></blockquote><h5 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h5><p>JDK 1.8</p><p>win10 i7</p><h5 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h5><p>我们经过测试并不是这样，或者说以前是这样，大家可以测试下，我把结果贴出来</p><p>JDKProxy创建耗时：1</p><p>JDKProxy调用耗时：2</p><hr><p>CjLibProxy创建耗时：110</p><p>CjLibProxy调用耗时：21</p><blockquote><p>创建耗时JDK比CGLIB快了将近100倍</p><p>调用也比CGLIB快了将近十倍</p></blockquote><p>所以使用代理的时候最好使用面向接口的JDK的动态代理。</p><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JAVA设计模式之代理模式
    
    </summary>
    
      <category term="设计模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://www.baiyp.ren/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://www.baiyp.ren/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="代理模式" scheme="http://www.baiyp.ren/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>JVM字节码指令</title>
    <link href="http://www.baiyp.ren/JVM%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4.html"/>
    <id>http://www.baiyp.ren/JVM字节码指令.html</id>
    <published>2019-08-29T06:20:57.000Z</published>
    <updated>2019-09-08T14:16:35.479Z</updated>
    
    <content type="html"><![CDATA[<!-- build time:Sun Sep 15 2019 16:51:27 GMT+0800 (GMT+08:00) --><h2 id="JAVA字节码指令"><a href="#JAVA字节码指令" class="headerlink" title="JAVA字节码指令"></a>JAVA字节码指令</h2><h2 id="JVM字节码指令"><a href="#JVM字节码指令" class="headerlink" title="JVM字节码指令"></a>JVM字节码指令</h2><p>​ Java程序是运行在Java虚拟机上的，而这里的“虚拟”是对什么东西进行虚拟呢？答案当然就是对“实体”机进行虚拟啦，虚拟机可以看做是对实体机进行了进一步的封装和抽象，隐藏了不同实体机之间的差别，从而达成“Write Once,Run AnyWhere”的目标。既然虚拟机是对实体机的虚拟，所以我认为虚拟机和实体机在结构和功能上必然存在某种程度上的对应与关联。因此我们在学习时应该注意发掘和类比两者之间的关系。<br>​ 本着这样的思想，我们进行Java字节码指令的学习。JAVA字节码在JAVA虚拟机中的地位相当于实体机的机器码，一切在Java虚拟机上运行的程序都要被解释或编译成字节码，一切在实体机上运行的程序最后也都要编译成机器码。Java字节码指令可以对字节码进行操作，在实体机中对机器码进行操作的是汇编语言。所以Java字节码指令对应汇编语言，Java字节码指令集对应汇编指令集。</p><h3 id="字节码简介"><a href="#字节码简介" class="headerlink" title="字节码简介"></a>字节码简介</h3><blockquote><p>Java汇编指令就是Java虚拟机能够听得懂、可执行的指令，也可以说是Java代码的最小执行单元。</p></blockquote><p>​ Java字节码指令由<em>一个</em>字节长度的，代表某种特定操作含义的数字（操作码）以及其后的零至多个代表此操作所需参数（操作数）。此外字节码指令是面向操作数栈的，这里操作数栈在功能上对应实体机的寄存器但是结构上有所区别。</p><h3 id="java字节码指令集"><a href="#java字节码指令集" class="headerlink" title="java字节码指令集"></a>java字节码指令集</h3><h4 id="常用指令集"><a href="#常用指令集" class="headerlink" title="常用指令集"></a>常用指令集</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x01</td><td>aconst_null</td><td></td><td>null值入栈。</td></tr><tr><td>0x02</td><td>iconst_m1</td><td></td><td>-1(int)值入栈。</td></tr><tr><td>0x03</td><td>iconst_0</td><td></td><td>0(int)值入栈。</td></tr><tr><td>0x04</td><td>iconst_1</td><td></td><td>1(int)值入栈。</td></tr><tr><td>0x05</td><td>iconst_2</td><td></td><td>2(int)值入栈。</td></tr><tr><td>0x06</td><td>iconst_3</td><td></td><td>3(int)值入栈。</td></tr><tr><td>0x07</td><td>iconst_4</td><td></td><td>4(int)值入栈。</td></tr><tr><td>0x08</td><td>iconst_5</td><td></td><td>5(int)值入栈。</td></tr><tr><td>0x09</td><td>lconst_0</td><td></td><td>0(long)值入栈。</td></tr><tr><td>0x0a</td><td>lconst_1</td><td></td><td>1(long)值入栈。</td></tr><tr><td>0x0b</td><td>fconst_0</td><td></td><td>0(float)值入栈。</td></tr><tr><td>0x0c</td><td>fconst_1</td><td></td><td>1(float)值入栈。</td></tr><tr><td>0x0d</td><td>fconst_2</td><td></td><td>2(float)值入栈。</td></tr><tr><td>0x0e</td><td>dconst_0</td><td></td><td>0(double)值入栈。</td></tr><tr><td>0x0f</td><td>dconst_1</td><td></td><td>1(double)值入栈。</td></tr><tr><td>0x10</td><td>bipush</td><td>valuebyte</td><td>valuebyte值带符号扩展成int值入栈。</td></tr><tr><td>0x11</td><td>sipush</td><td>valuebyte1，valuebyte2</td><td>(valuebyte1 &lt;&lt; 8) | valuebyte2 值带符号扩展成int值入栈。</td></tr><tr><td>0x12</td><td>ldc</td><td>indexbyte1</td><td>常量池中的常量值（int, float, string reference, object reference）入栈。</td></tr><tr><td>0x13</td><td>ldc_w</td><td>indexbyte1，indexbyte2</td><td>常量池中常量（int, float, string reference, object reference）入栈。</td></tr><tr><td>0x14</td><td>ldc2_w</td><td>indexbyte1，indexbyte2</td><td>常量池+A1:D24中常量（long, double）入栈。</td></tr></tbody></table><h4 id="局部变量值转载到栈中指令"><a href="#局部变量值转载到栈中指令" class="headerlink" title="局部变量值转载到栈中指令"></a>局部变量值转载到栈中指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x19</td><td>(wide)aload</td><td>indexbyte</td><td>从局部变量indexbyte中装载引用类型值入栈。</td></tr><tr><td>0x2a</td><td>aload_0</td><td></td><td>从局部变量0中装载引用类型值入栈。</td></tr><tr><td>0x2b</td><td>aload_1</td><td></td><td>从局部变量1中装载引用类型值入栈。</td></tr><tr><td>0x2c</td><td>aload_2</td><td></td><td>从局部变量2中装载引用类型值入栈。</td></tr><tr><td>0x2d</td><td>aload_3</td><td></td><td>从局部变量3中装载引用类型值入栈。</td></tr><tr><td>0x15</td><td>(wide)iload</td><td>indexbyte</td><td>从局部变量indexbyte中装载int类型值入栈。</td></tr><tr><td>0x1a</td><td>iload_0</td><td></td><td>从局部变量0中装载int类型值入栈。</td></tr><tr><td>0x1b</td><td>iload_1</td><td></td><td>从局部变量1中装载int类型值入栈。</td></tr><tr><td>0x1c</td><td>iload_2</td><td></td><td>从局部变量2中装载int类型值入栈。</td></tr><tr><td>0x1d</td><td>iload_3</td><td></td><td>从局部变量3中装载int类型值入栈。</td></tr><tr><td>0x16</td><td>(wide)lload</td><td>indexbyte</td><td>从局部变量indexbyte中装载long类型值入栈。</td></tr><tr><td>0x1e</td><td>lload_0</td><td></td><td>从局部变量0中装载int类型值入栈。</td></tr><tr><td>0x1f</td><td>lload_1</td><td></td><td>从局部变量1中装载int类型值入栈。</td></tr><tr><td>0x20</td><td>lload_2</td><td></td><td>从局部变量2中装载int类型值入栈。</td></tr><tr><td>0x21</td><td>lload_3</td><td></td><td>从局部变量3中装载int类型值入栈。</td></tr><tr><td>0x17</td><td>(wide)fload</td><td>indexbyte</td><td>从局部变量indexbyte中装载float类型值入栈。</td></tr><tr><td>0x22</td><td>fload_0</td><td></td><td>从局部变量0中装载float类型值入栈。</td></tr><tr><td>0x23</td><td>fload_1</td><td></td><td>从局部变量1中装载float类型值入栈。</td></tr><tr><td>0x24</td><td>fload_2</td><td></td><td>从局部变量2中装载float类型值入栈。</td></tr><tr><td>0x25</td><td>fload_3</td><td></td><td>从局部变量3中装载float类型值入栈。</td></tr><tr><td>0x18</td><td>(wide)dload</td><td>indexbyte</td><td>从局部变量indexbyte中装载double类型值入栈。</td></tr><tr><td>0x26</td><td>dload_0</td><td></td><td>从局部变量0中装载double类型值入栈。</td></tr><tr><td>0x27</td><td>dload_1</td><td></td><td>从局部变量1中装载double类型值入栈。</td></tr><tr><td>0x28</td><td>dload_2</td><td></td><td>从局部变量2中装载double类型值入栈。</td></tr><tr><td>0x29</td><td>dload_3</td><td></td><td>从局部变量3中装载double类型值入栈。</td></tr><tr><td>0x32</td><td>aaload</td><td></td><td>从引用类型数组中装载指定项的值。</td></tr><tr><td>0x2e</td><td>iaload</td><td></td><td>从int类型数组中装载指定项的值。</td></tr><tr><td>0x2f</td><td>laload</td><td></td><td>从long类型数组中装载指定项的值。</td></tr><tr><td>0x30</td><td>faload</td><td></td><td>从float类型数组中装载指定项的值。</td></tr><tr><td>0x31</td><td>daload</td><td></td><td>从double类型数组中装载指定项的值。</td></tr><tr><td>0x33</td><td>baload</td><td></td><td>从boolean类型数组或byte类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td>0x34</td><td>caload</td><td></td><td>从char类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr><tr><td>0x35</td><td>saload</td><td></td><td>从short类型数组中装载指定项的值（先转换为int类型值，后压栈）。</td></tr></tbody></table><h4 id="wide指令"><a href="#wide指令" class="headerlink" title="wide指令"></a>wide指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xc4</td><td>wide</td><td></td><td>使用附加字节扩展局部变量索引（iinc指令特殊）。</td></tr></tbody></table><h4 id="将栈顶值保存到局部变量中指令"><a href="#将栈顶值保存到局部变量中指令" class="headerlink" title="将栈顶值保存到局部变量中指令"></a>将栈顶值保存到局部变量中指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x3a</td><td>(wide)astore</td><td>indexbyte</td><td>将栈顶引用类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x4b</td><td>astroe_0</td><td></td><td>将栈顶引用类型值保存到局部变量0中。</td></tr><tr><td>0x4c</td><td>astore_1</td><td></td><td>将栈顶引用类型值保存到局部变量1中。</td></tr><tr><td>0x4d</td><td>astore_2</td><td></td><td>将栈顶引用类型值保存到局部变量2中。</td></tr><tr><td>0x4e</td><td>astore_3</td><td></td><td>将栈顶引用类型值保存到局部变量3中。</td></tr><tr><td>0x36</td><td>(wide)istore</td><td>indexbyte</td><td>将栈顶int类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x3b</td><td>istore_0</td><td></td><td>将栈顶int类型值保存到局部变量0中。</td></tr><tr><td>0x3c</td><td>istore_1</td><td></td><td>将栈顶int类型值保存到局部变量1中。</td></tr><tr><td>0x3d</td><td>istore_2</td><td></td><td>将栈顶int类型值保存到局部变量2中。</td></tr><tr><td>0x3e</td><td>istore_3</td><td></td><td>将栈顶int类型值保存到局部变量3中。</td></tr><tr><td>0x37</td><td>(wide)lstore</td><td>indexbyte</td><td>将栈顶long类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x3f</td><td>lstore_0</td><td></td><td>将栈顶long类型值保存到局部变量0中。</td></tr><tr><td>0x40</td><td>lstore_1</td><td></td><td>将栈顶long类型值保存到局部变量1中。</td></tr><tr><td>0x41</td><td>lstore_2</td><td></td><td>将栈顶long类型值保存到局部变量2中。</td></tr><tr><td>0x42</td><td>lstroe_3</td><td></td><td>将栈顶long类型值保存到局部变量3中。</td></tr><tr><td>0x38</td><td>(wide)fstore</td><td>indexbyte</td><td>将栈顶float类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x43</td><td>fstore_0</td><td></td><td>将栈顶float类型值保存到局部变量0中。</td></tr><tr><td>0x44</td><td>fstore_1</td><td></td><td>将栈顶float类型值保存到局部变量1中。</td></tr><tr><td>0x45</td><td>fstore_2</td><td></td><td>将栈顶float类型值保存到局部变量2中。</td></tr><tr><td>0x46</td><td>fstore_3</td><td></td><td>将栈顶float类型值保存到局部变量3中。</td></tr><tr><td>0x39</td><td>(wide)dstore</td><td>indexbyte</td><td>将栈顶double类型值保存到局部变量indexbyte中。</td></tr><tr><td>0x47</td><td>dstore_0</td><td></td><td>将栈顶double类型值保存到局部变量0中。</td></tr><tr><td>0x48</td><td>dstore_1</td><td></td><td>将栈顶double类型值保存到局部变量1中。</td></tr><tr><td>0x49</td><td>dstore_2</td><td></td><td>将栈顶double类型值保存到局部变量2中。</td></tr><tr><td>0x4a</td><td>dstore_3</td><td></td><td>将栈顶double类型值保存到局部变量3中。</td></tr><tr><td>0x53</td><td>aastore</td><td></td><td>将栈顶引用类型值保存到指定引用类型数组的指定项。</td></tr><tr><td>0x4f</td><td>iastore</td><td></td><td>将栈顶int类型值保存到指定int类型数组的指定项。</td></tr><tr><td>0x50</td><td>lastore</td><td></td><td>将栈顶long类型值保存到指定long类型数组的指定项。</td></tr><tr><td>0x51</td><td>fastore</td><td></td><td>将栈顶float类型值保存到指定float类型数组的指定项。</td></tr><tr><td>0x52</td><td>dastore</td><td></td><td>将栈顶double类型值保存到指定double类型数组的指定项。</td></tr><tr><td>0x54</td><td>bastroe</td><td></td><td>将栈顶boolean类型值或byte类型值保存到指定boolean类型数组或byte类型数组的指定项。</td></tr><tr><td>0x55</td><td>castore</td><td></td><td>将栈顶char类型值保存到指定char类型数组的指定项。</td></tr><tr><td>0x56</td><td>sastore</td><td></td><td>将栈顶short类型值保存到指定short类型数组的指定项。</td></tr></tbody></table><h4 id="通用（无类型）栈操作指令"><a href="#通用（无类型）栈操作指令" class="headerlink" title="通用（无类型）栈操作指令"></a>通用（无类型）栈操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x00</td><td>nop</td><td></td><td>空操作。</td></tr><tr><td>0x57</td><td>pop</td><td></td><td>从栈顶弹出一个字长的数据。</td></tr><tr><td>0x58</td><td>pop2</td><td></td><td>从栈顶弹出两个字长的数据。</td></tr><tr><td>0x59</td><td>dup</td><td></td><td>复制栈顶一个字长的数据，将复制后的数据压栈。</td></tr><tr><td>0x5a</td><td>dup_x1</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶两个字长数据，先将复制后的数据压栈，再将弹出的两个字长数据压栈。</td></tr><tr><td>0x5b</td><td>dup_x2</td><td></td><td>复制栈顶一个字长的数据，弹出栈顶三个字长的数据，将复制后的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5c</td><td>dup2</td><td></td><td>复制栈顶两个字长的数据，将复制后的两个字长的数据压栈。</td></tr><tr><td>0x5d</td><td>dup2_x1</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶三个字长的数据，将复制后的两个字长的数据压栈，再将弹出的三个字长的数据压栈。</td></tr><tr><td>0x5e</td><td>dup2_x2</td><td></td><td>复制栈顶两个字长的数据，弹出栈顶四个字长的数据，将复制后的两个字长的数据压栈，再将弹出的四个字长的数据压栈。</td></tr><tr><td>0x5f</td><td>swap</td><td></td><td>交换栈顶两个字长的数据的位置。Java指令中没有提供以两个字长为单位的交换指令。</td></tr></tbody></table><h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x86</td><td>i2f</td><td></td><td>将栈顶int类型值转换为float类型值。</td></tr><tr><td>0x85</td><td>i2l</td><td></td><td>将栈顶int类型值转换为long类型值。</td></tr><tr><td>0x87</td><td>i2d</td><td></td><td>将栈顶int类型值转换为double类型值。</td></tr><tr><td>0x8b</td><td>f2i</td><td></td><td>将栈顶float类型值转换为int类型值。</td></tr><tr><td>0x8c</td><td>f2l</td><td></td><td>将栈顶float类型值转换为long类型值。</td></tr><tr><td>0x8d</td><td>f2d</td><td></td><td>将栈顶float类型值转换为double类型值。</td></tr><tr><td>0x88</td><td>l2i</td><td></td><td>将栈顶long类型值转换为int类型值。</td></tr><tr><td>0x89</td><td>l2f</td><td></td><td>将栈顶long类型值转换为float类型值。</td></tr><tr><td>0x8a</td><td>l2d</td><td></td><td>将栈顶long类型值转换double类型值。</td></tr><tr><td>0x8e</td><td>d2i</td><td></td><td>将栈顶double类型值转换为int类型值。</td></tr><tr><td>0x90</td><td>d2f</td><td></td><td>将栈顶double类型值转换为float类型值。</td></tr><tr><td>0x8f</td><td>d2l</td><td></td><td>将栈顶double类型值转换为long类型值。</td></tr><tr><td>0x91</td><td>i2b</td><td></td><td>将栈顶int类型值截断成byte类型，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x92</td><td>i2c</td><td></td><td>将栈顶int类型值截断成char类型值，后带符号扩展成int类型值入栈。</td></tr><tr><td>0x93</td><td>i2s</td><td></td><td>将栈顶int类型值截断成short类型值，后带符号扩展成int类型值入栈。</td></tr></tbody></table><h4 id="整数运算"><a href="#整数运算" class="headerlink" title="整数运算"></a>整数运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x60</td><td>iadd</td><td></td><td>将栈顶两int类型数相加，结果入栈。</td></tr><tr><td>0x64</td><td>isub</td><td></td><td>将栈顶两int类型数相减，结果入栈。</td></tr><tr><td>0x68</td><td>imul</td><td></td><td>将栈顶两int类型数相乘，结果入栈。</td></tr><tr><td>0x6c</td><td>idiv</td><td></td><td>将栈顶两int类型数相除，结果入栈。</td></tr><tr><td>0x70</td><td>irem</td><td></td><td>将栈顶两int类型数取模，结果入栈。</td></tr><tr><td>0x74</td><td>ineg</td><td></td><td>将栈顶int类型值取负，结果入栈。</td></tr><tr><td>0x61</td><td>ladd</td><td></td><td>将栈顶两long类型数相加，结果入栈。</td></tr><tr><td>0x65</td><td>lsub</td><td></td><td>将栈顶两long类型数相减，结果入栈。</td></tr><tr><td>0x69</td><td>lmul</td><td></td><td>将栈顶两long类型数相乘，结果入栈。</td></tr><tr><td>0x6d</td><td>ldiv</td><td></td><td>将栈顶两long类型数相除，结果入栈。</td></tr><tr><td>0x71</td><td>lrem</td><td></td><td>将栈顶两long类型数取模，结果入栈。</td></tr><tr><td>0x75</td><td>lneg</td><td></td><td>将栈顶long类型值取负，结果入栈。</td></tr><tr><td>0x84</td><td>(wide)iinc</td><td>indexbyte，constbyte</td><td>将整数值constbyte加到indexbyte指定的int类型的局部变量中。</td></tr></tbody></table><h4 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x62</td><td>fadd</td><td></td><td>将栈顶两float类型数相加，结果入栈。</td></tr><tr><td>0x66</td><td>fsub</td><td></td><td>将栈顶两float类型数相减，结果入栈。</td></tr><tr><td>0x6a</td><td>fmul</td><td></td><td>将栈顶两float类型数相乘，结果入栈。</td></tr><tr><td>0x6e</td><td>fdiv</td><td></td><td>将栈顶两float类型数相除，结果入栈。</td></tr><tr><td>0x72</td><td>frem</td><td></td><td>将栈顶两float类型数取模，结果入栈。</td></tr><tr><td>0x76</td><td>fneg</td><td></td><td>将栈顶float类型值取反，结果入栈。</td></tr><tr><td>0x63</td><td>dadd</td><td></td><td>将栈顶两double类型数相加，结果入栈。</td></tr><tr><td>0x67</td><td>dsub</td><td></td><td>将栈顶两double类型数相减，结果入栈。</td></tr><tr><td>0x6b</td><td>dmul</td><td></td><td>将栈顶两double类型数相乘，结果入栈。</td></tr><tr><td>0x6f</td><td>ddiv</td><td></td><td>将栈顶两double类型数相除，结果入栈。</td></tr><tr><td>0x73</td><td>drem</td><td></td><td>将栈顶两double类型数取模，结果入栈。</td></tr><tr><td>0x77</td><td>dneg</td><td></td><td>将栈顶double类型值取负，结果入栈。</td></tr></tbody></table><h4 id="逻辑运算——移位运算"><a href="#逻辑运算——移位运算" class="headerlink" title="逻辑运算——移位运算"></a>逻辑运算——移位运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x78</td><td>ishl</td><td></td><td>左移int类型值。</td></tr><tr><td>0x79</td><td>lshl</td><td></td><td>左移long类型值。</td></tr><tr><td>0x7a</td><td>ishr</td><td></td><td>算术右移int类型值。</td></tr><tr><td>0x7b</td><td>lshr</td><td></td><td>算术右移long类型值。</td></tr><tr><td>0x7c</td><td>iushr</td><td></td><td>逻辑右移int类型值。</td></tr><tr><td>0x7d</td><td>lushr</td><td></td><td>逻辑右移long类型值。</td></tr></tbody></table><h4 id="逻辑运算——按位布尔运算"><a href="#逻辑运算——按位布尔运算" class="headerlink" title="逻辑运算——按位布尔运算"></a>逻辑运算——按位布尔运算</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x73</td><td>iand</td><td></td><td>对int类型按位与运算。</td></tr><tr><td>0x7f</td><td>land</td><td></td><td>对long类型的按位与运算。</td></tr><tr><td>0x80</td><td>ior</td><td></td><td>对int类型的按位或运算。</td></tr><tr><td>0x81</td><td>lor</td><td></td><td>对long类型的按位或运算。</td></tr><tr><td>0x82</td><td>ixor</td><td></td><td>对int类型的按位异或运算。</td></tr><tr><td>0x83</td><td>lxor</td><td></td><td>对long类型的按位异或运算。</td></tr></tbody></table><h4 id="控制流指令——条件跳转指令"><a href="#控制流指令——条件跳转指令" class="headerlink" title="控制流指令——条件跳转指令"></a>控制流指令——条件跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0x99</td><td>ifeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值为0则跳转。</td></tr><tr><td>0x9a</td><td>ifne</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值不为0则跳转。</td></tr><tr><td>0x9b</td><td>iflt</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值小于0则跳转。</td></tr><tr><td>0x9e</td><td>ifle</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值小于等于0则跳转。</td></tr><tr><td>0x9d</td><td>ifgt</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值大于0则跳转。</td></tr><tr><td>0x9c</td><td>ifge</td><td>branchbyte1，branchbyte2</td><td>若栈顶int类型值大于等于0则跳转。</td></tr><tr><td>0x9f</td><td>if_icmpeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值相等则跳转。</td></tr><tr><td>0xa0</td><td>if_icmpne</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值不相等则跳转。</td></tr><tr><td>0xa1</td><td>if_icmplt</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前小于后则跳转。</td></tr><tr><td>0xa4</td><td>if_icmple</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前小于等于后则跳转。</td></tr><tr><td>0xa3</td><td>if_icmpgt</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前大于后则跳转。</td></tr><tr><td>0xa2</td><td>if_icmpge</td><td>branchbyte1，branchbyte2</td><td>若栈顶两int类型值前大于等于后则跳转。</td></tr><tr><td>0xc6</td><td>ifnull</td><td>branchbyte1，branchbyte2</td><td>若栈顶引用值为null则跳转。</td></tr><tr><td>0xc7</td><td>ifnonnull</td><td>branchbyte1，branchbyte2</td><td>若栈顶引用值不为null则跳转。</td></tr><tr><td>0xa5</td><td>if_acmpeq</td><td>branchbyte1，branchbyte2</td><td>若栈顶两引用类型值相等则跳转。</td></tr><tr><td>0xa6</td><td>if_acmpne</td><td>branchbyte1，branchbyte2</td><td>若栈顶两引用类型值不相等则跳转。</td></tr></tbody></table><h4 id="控制流指令——比较指令"><a href="#控制流指令——比较指令" class="headerlink" title="控制流指令——比较指令"></a>控制流指令——比较指令</h4><table><thead><tr><th>0x94</th><th>lcmp</th><th></th><th>比较栈顶两long类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈。</th></tr></thead><tbody><tr><td>0x95</td><td>fcmpl</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x96</td><td>fcmpg</td><td></td><td>比较栈顶两float类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x97</td><td>dcmpl</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr><tr><td>0x98</td><td>dcmpg</td><td></td><td>比较栈顶两double类型值，前者大，1入栈；相等，0入栈；后者大，-1入栈；有NaN存在，-1入栈。</td></tr></tbody></table><h4 id="控制流指令——无条件跳转指令"><a href="#控制流指令——无条件跳转指令" class="headerlink" title="控制流指令——无条件跳转指令"></a>控制流指令——无条件跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xa7</td><td>goto</td><td>branchbyte1，branchbyte2</td><td>无条件跳转到指定位置。</td></tr><tr><td>0xc8</td><td>goto_w</td><td>branchbyte1，branchbyte2，branchbyte3，branchbyte4</td><td>无条件跳转到指定位置（宽索引）。</td></tr></tbody></table><h4 id="控制流指令——表跳转指令"><a href="#控制流指令——表跳转指令" class="headerlink" title="控制流指令——表跳转指令"></a>控制流指令——表跳转指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xaa</td><td>tableswitch</td><td>&lt;0-3bytepad&gt;,<br>defaultbyte1,<br>defaultbyte2,<br>defaultbyte3,<br>defaultbyte4,<br>lowbyte1,<br>lowbyte2,<br>lowbyte3,<br>lowbyte4,<br>highbyte1,<br>highbyte2,<br>highbyte3,<br>highbyte4,<br>jump offsets…</td><td>通过索引访问跳转表，并跳转。</td></tr><tr><td>0xab</td><td>lookupswitch</td><td>&lt;0-3bytepad&gt;,<br>defaultbyte1,<br>defaultbyte2,<br>defaultbyte3,<br>defaultbyte4,<br>npairs1,<br>npairs2,<br>npairs3,<br>npairs4,<br>match offsets</td><td>通过键值访问跳转表，并跳转。</td></tr></tbody></table><h4 id="控制流指令——异常和finally"><a href="#控制流指令——异常和finally" class="headerlink" title="控制流指令——异常和finally"></a>控制流指令——异常和finally</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbf</td><td>athrow</td><td></td><td>抛出异常。</td></tr><tr><td>0xa8</td><td>jsr</td><td>branchbyte1,<br>branchbyte2</td><td>跳转到子例程序。</td></tr><tr><td>0xc9</td><td>jsr_w</td><td>branchbyte1,<br>branchbyte2,<br>branchbyte3,<br>branchbyte4</td><td>跳转到子例程序（宽索引）。</td></tr><tr><td>0xa9</td><td>(wide)ret</td><td>indexbyte</td><td>返回子例程序。</td></tr></tbody></table><h4 id="对象操作指令"><a href="#对象操作指令" class="headerlink" title="对象操作指令"></a>对象操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbb</td><td>new</td><td>indexbyte1,indexbyte2</td><td>创建新的对象实例。</td></tr><tr><td>0xc0</td><td>checkcast</td><td>indexbyte1,indexbyte2</td><td>类型强转。</td></tr><tr><td>0xc1</td><td>instanceof</td><td>indexbyte1,indexbyte2</td><td>判断类型。</td></tr><tr><td>0xb4</td><td>getfield</td><td>indexbyte1,indexbyte2</td><td>获取对象字段的值。</td></tr><tr><td>0xb5</td><td>putfield</td><td>indexbyte1,indexbyte2</td><td>给对象字段赋值。</td></tr><tr><td>0xb2</td><td>getstatic</td><td>indexbyte1,indexbyte2</td><td>获取静态字段的值。</td></tr><tr><td>0xb3</td><td>putstatic</td><td>indexbyte1,indexbyte2</td><td>给静态字段赋值。</td></tr></tbody></table><h4 id="数组操作指令"><a href="#数组操作指令" class="headerlink" title="数组操作指令"></a>数组操作指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xbc</td><td>newarray</td><td>atype</td><td>创建type类型的数组。</td></tr><tr><td>0xbd</td><td>anewarray</td><td>indexbyte1,indexbyte2</td><td>创建引用类型的数组。</td></tr><tr><td>0xbe</td><td>arraylength</td><td></td><td>获取一维数组的长度。</td></tr><tr><td>0xc5</td><td>multianewarray</td><td>indexbyte1,indexbyte2,dimension</td><td>创建dimension维度的数组。</td></tr></tbody></table><h4 id="方法调用指令"><a href="#方法调用指令" class="headerlink" title="方法调用指令"></a>方法调用指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xb7</td><td>invokespecial</td><td>indexbyte1,indexbyte2</td><td>编译时方法绑定调用方法。</td></tr><tr><td>0xb6</td><td>invokevirtual</td><td>indexbyte1,indexbyte2</td><td>运行时方法绑定调用方法。</td></tr><tr><td>0xb8</td><td>invokestatic</td><td>indexbyte1,indexbyte2</td><td>调用静态方法。</td></tr><tr><td>0xb9</td><td>invokeinterface</td><td>indexbyte1,indexbyte2,count,0</td><td>调用接口方法。</td></tr></tbody></table><h4 id="方法返回指令"><a href="#方法返回指令" class="headerlink" title="方法返回指令"></a>方法返回指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xac</td><td>ireturn</td><td></td><td>返回int类型值。</td></tr><tr><td>0xad</td><td>lreturn</td><td></td><td>返回long类型值。</td></tr><tr><td>0xae</td><td>freturn</td><td></td><td>返回float类型值。</td></tr><tr><td>0xaf</td><td>dreturn</td><td></td><td>返回double类型值。</td></tr><tr><td>0xb0</td><td>areturn</td><td></td><td>返回引用类型值。</td></tr><tr><td>0xb1</td><td>return</td><td></td><td>void函数返回。</td></tr></tbody></table><h4 id="线程同步指令"><a href="#线程同步指令" class="headerlink" title="线程同步指令"></a>线程同步指令</h4><table><thead><tr><th>指令码</th><th>操作码（助记符）</th><th>操作数</th><th>描述（栈指操作数栈）</th></tr></thead><tbody><tr><td>0xc2</td><td>monitorenter</td><td></td><td>进入并获得对象监视器。</td></tr><tr><td>0xc3</td><td>monitorexit</td><td></td><td>释放并退出对象监视器。</td></tr></tbody></table><!-- rebuild by neat -->]]></content>
    
    <summary type="html">
    
      JVM字节码指令
    
    </summary>
    
      <category term="jvm" scheme="http://www.baiyp.ren/categories/jvm/"/>
    
      <category term="指令" scheme="http://www.baiyp.ren/categories/jvm/%E6%8C%87%E4%BB%A4/"/>
    
    
      <category term="jvm" scheme="http://www.baiyp.ren/tags/jvm/"/>
    
      <category term="指令" scheme="http://www.baiyp.ren/tags/%E6%8C%87%E4%BB%A4/"/>
    
  </entry>
  
</feed>
