<!-- build time:Sun Aug 04 2019 22:35:56 GMT+0800 (GMT+08:00) --><!DOCTYPE HTML><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta name="viewport" content="width=device-width,user-scalable=no,initial-scale=1,maximum-scale=1,minimum-scale=1"><meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"><meta http-equiv="Cache-Control" content="no-siteapp"><meta http-equiv="Cache-Control" content="no-transform"><meta name="renderer" content="webkit|ie-comp|ie-stand"><meta name="apple-mobile-web-app-capable" content="晓风残月的博客"><meta name="apple-mobile-web-app-status-bar-style" content="black"><meta name="format-detection" content="telephone=no,email=no,adress=no"><meta name="browsermode" content="application"><meta name="screen-orientation" content="portrait"><meta name="theme-version" content="1.2.3"><meta name="root" content="/"><link rel="dns-prefetch" href="http://www.baiyp.ren"><meta name="keywords" content="{{ page.keywords }}"><meta name="description" content="java流式计算Stream详解Stream 是什么​ Stream是Java 8新增的重要特性, 它提供函数式编程支持并允许以管道方式操作集合. 流操作会遍历数据源, 使用管道式操作处理数据后..."><meta name="robots" content="all"><meta name="google" content="all"><meta name="googlebot" content="all"><meta name="verify" content="all"><title>java流式计算Stream详解 | 晓风残月的博客</title><link rel="alternate" href="/atom.xml" title="晓风残月的博客" type="application/atom+xml"><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7"><link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.5.0"><link rel="stylesheet" href="/css/style.css?rev=@@hash"><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?a475efbbf07ecf405a82aa9bd596d186";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script></head></html><!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]--><!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]--><body><header class="main-header" style="background-image:url(./img/banner5.jpg)"><div class="main-header-box"><a class="header-avatar" href="/" title="晓风残月"><img src="img/avatar.jpg" alt="logo头像" class="img-responsive center-block"></a><div class="branding"><h2>学而时习之,不亦说乎</h2></div></div></header><nav class="main-navigation"><div class="container"><div class="row"><div class="col-sm-12"><div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav"><span class="sr-only"></span> <i class="fa fa-bars"></i> </span><a class="navbar-brand" href="http://www.baiyp.ren">晓风残月的博客</a></div><div class="collapse navbar-collapse" id="main-menu"><ul class="menu"><li role="presentation" class="text-center"><a href="/"><i class="fa"></i>首页</a></li><li role="presentation" class="text-center"><a href="/categories/JAVA/"><i class="fa"></i>JAVA</a></li><li role="presentation" class="text-center"><a href="/categories/架构/"><i class="fa"></i>架构</a></li><li role="presentation" class="text-center"><a href="/categories/片段/"><i class="fa"></i>片段</a></li><li role="presentation" class="text-center"><a href="/archives/"><i class="fa"></i>时间轴</a></li><li role="presentation" class="text-center"><a href="/about.html"><i class="fa"></i>关于我</a></li></ul></div></div></div></div></nav><section class="content-wrap"><div class="container"><div class="row"><main class="col-md-8 main-content m-post"><p id="process"></p><article class="post"><div class="post-head"><h1 id="java流式计算Stream详解">java流式计算Stream详解</h1><div class="post-meta"><span class="categories-meta fa-wrap"><i class="fa fa-folder-open-o"></i> <a class="category-link" href="categories/java/">java</a> <a class="category-link" href="categories/java/stream/">stream</a> </span><span class="fa-wrap"><i class="fa fa-tags"></i> <span class="tags-meta"><a class="tag-link" href="tags/java/">java</a> <a class="tag-link" href="tags/stream/">stream</a> </span></span><span class="fa-wrap"><i class="fa fa-clock-o"></i> <span class="date-meta">2019/07/17</span> </span><span class="fa-wrap"><i class="fa fa-eye"></i> <span id="busuanzi_value_page_pv"></span></span><div style="margin-top:10px"><span class="post-time" style="margin-right:0"><span class="post-meta-item-icon" style="margin-right:0"><i class="fa fa-keyboard-o"></i> <span class="post-meta-item-text" style="margin-right:0">字数统计: </span><span class="post-count" style="margin-right:0">2.4k字</span> </span></span><span class="post-time" style="margin-right:0">&nbsp; | &nbsp; <span class="post-meta-item-icon" style="margin-right:0"><i class="fa fa-hourglass-half"></i> <span class="post-meta-item-text" style="margin-right:0">阅读时长: </span><span class="post-count" style="margin-right:0">11分</span></span></span></div></div></div><div class="post-body post-content"><h2 id="java流式计算Stream详解"><a href="#java流式计算Stream详解" class="headerlink" title="java流式计算Stream详解"></a>java流式计算Stream详解</h2><p><img src="../images/stream01.png" alt></p><h3 id="Stream-是什么"><a href="#Stream-是什么" class="headerlink" title="Stream 是什么"></a>Stream 是什么</h3><p>​ Stream是Java 8新增的重要特性, 它提供函数式编程支持并允许以管道方式操作集合. 流操作会遍历数据源, 使用管道式操作处理数据后生成结果集合, 这个过程通常不会对数据源造成影响.</p><h3 id="函数对象"><a href="#函数对象" class="headerlink" title="函数对象"></a>函数对象</h3><p>​ 使用Stream进行函数式编程时经常需要将操作作为参数传入流方法中, 函数对象即将方法或lambda表达式作为对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strArray =  Arrays.asList(stringArrays).stream().filter(x&gt;x.contains(<span class="string">"Tomas"</span>)).collect(Collectors.toList());</span><br></pre></td></tr></table></figure><p>上述示例中<code>filter</code>的参数<code>x&gt;x.contains(&quot;Tomas&quot;)</code>即为一个lambda表达式.</p><h3 id="流的创建"><a href="#流的创建" class="headerlink" title="流的创建"></a>流的创建</h3><p>可以使用集合类的<code>stream()</code>或者<code>parallelStream()</code>方法创建流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream1 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).stream();</span><br><span class="line">Stream&lt;Integer&gt; stream2 = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).parallelStream();</span><br></pre></td></tr></table></figure><p><code>java.util.stream.Stream</code>是一个<code>interface</code>, 各种管道中间操作的返回值都是它的实现类, 这允许我们方便地进行参数传递。</p><p><code>Stream</code>的静态方法<code>of()</code>也可以用来创建流:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 =   Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>&#125;);</span><br></pre></td></tr></table></figure><p>`</p><p>Arrays<code>也提供了创建流的静态方法</code>stream()`:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Arrays.stream(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure><p>一些类也提供了创建流的方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntStream.range(start, stop);</span><br><span class="line">BufferedReader.lines();</span><br><span class="line">Random.ints();</span><br></pre></td></tr></table></figure><h3 id="中间操作"><a href="#中间操作" class="headerlink" title="中间操作"></a>中间操作</h3><p>​ 流操作是惰性执行的, 中间操作会返回一个新的流对象, 当执行终点操作时才会真正进行计算，下面介绍流的中间操作，除非传入的操作函数有副作用, 函数本身不会对数据源进行任何修改。</p><h4 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h4><p><code>distinct</code>保证数据源中的重复元素在结果中只出现一次, 它使用<code>equals()</code>方法判断两个元素是否相等.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;);</span><br><span class="line">System.out.println(stream3.distinct().collect(Collectors.toList()));</span><br></pre></td></tr></table></figure><p>输出<br>[1, 2, 3, 4]</p><h4 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h4><p><code>filter</code>根据传入的断言函数对所有元素进行检查, 只有使断言函数返回真的元素才会出现在结果中. <code>filter</code>不会对数据源进行修改.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;);</span><br><span class="line">List&lt;String&gt; stringList = stream3.filter(x-&gt; Integer.parseInt(x)%<span class="number">2</span>==<span class="number">0</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(stringList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[2, 4, 6, 8]</p><h4 id="map"><a href="#map" class="headerlink" title="map"></a>map</h4><p>​ <strong>map</strong>方法根据传入的mapper函数对元素进行一对一映射, 即数据源中的每一个元素都会在结果中被替换(映射)为mapper函数的返回值，也可以根据处理返回不同的数据类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;String&gt; stream3 = Stream.of(<span class="keyword">new</span> String[]&#123;<span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"6"</span>, <span class="string">"7"</span>, <span class="string">"8"</span>, <span class="string">"9"</span>&#125;);</span><br><span class="line">List&lt;Integer&gt; integerList = stream3.map(x -&gt; Integer.parseInt(x)).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[1, 2, 3, 4, 6, 7, 8, 9]</p><h4 id="peek"><a href="#peek" class="headerlink" title="peek"></a>peek</h4><p>​ <strong>peek</strong>方法会对数据源中所有元素进行给定操作, 但在结果中仍然是数据源中的元素. 通常我们利用操作的副作用, 修改其它数据或进行输入输出.</p><p>​ <strong>peek</strong>接收一个没有返回值的λ表达式，可以做一些输出，外部处理等。map接收一个有返回值的λ表达式，之后Stream的泛型类型将转换为map参数λ表达式返回的类型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt;  stream3 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">List&lt;Integer&gt;  integerList = stream3.peek(x-&gt; System.out.println(x)).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>1 …</p><p>[1, 2, 3, 4, 5, 6, 7, 8, 9]</p><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><p>与<code>map</code>不同<code>flatMap</code>进行多对一映射, 它要求若数据源的元素类型为<code>R</code>, 则mapper函数的返回值必须为<code>Stream&lt;R&gt;</code>.</p><p><code>flatMap</code>会使用mapper函数将数据源中的元素一一映射为<code>Stream</code>对象, 然后把这些<code>Stream</code>拼装成一个流.因此我们可以使用<code>flatMap</code>进行合并列表之类的操作:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;List&lt;Integer&gt;&gt;  stream3 = Stream.of(Arrays.asList(<span class="number">1</span>), Arrays.asList(<span class="number">2</span>, <span class="number">3</span>), Arrays.asList(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>));</span><br><span class="line">List&lt;Integer&gt;  integerList = stream3.flatMap(x-&gt;x.stream()).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[1, 2, 3, 4, 5, 6]</p><h4 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h4><p><code>sorted</code>方法用于对数据源进行排序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">4</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">8</span>);</span><br><span class="line">        List&lt;Integer&gt; integerList = stream3.sorted((x, y) -&gt; x - y).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[0, 1, 2, 3, 4, 5, 6, 6, 8, 9]</p><p>使用<code>java.util.Comparator</code>是更方便的方法, 默认进行升序排序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Item</span> </span>&#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="title">Item</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> value;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">this</span>.value = value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">Stream&lt;Item&gt; stream3 = Stream.of(<span class="keyword">new</span> Item(<span class="number">4</span>), <span class="keyword">new</span> Item(<span class="number">3</span>), <span class="keyword">new</span> Item(<span class="number">6</span>), <span class="keyword">new</span> Item(<span class="number">9</span>));</span><br><span class="line">List&lt;Item&gt; itemList = stream3.sorted(Comparator.comparingInt(Item::getValue)).collect(Collectors.toList());</span><br><span class="line">itemList.forEach(x -&gt; System.out.print(x.getValue()+<span class="string">","</span>));</span><br></pre></td></tr></table></figure><p>输出</p><p>3,4,6,9,</p><p>使用<code>reversed()</code>方法进行降序排序:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Item&gt; stream3 = Stream.of(<span class="keyword">new</span> Item(<span class="number">4</span>), <span class="keyword">new</span> Item(<span class="number">3</span>), <span class="keyword">new</span> Item(<span class="number">6</span>), <span class="keyword">new</span> Item(<span class="number">9</span>));</span><br><span class="line">List&lt;Item&gt; itemList = stream3.sorted(Comparator.comparingInt(Item::getValue).reversed()).collect(Collectors.toList());</span><br><span class="line">itemList.forEach(x -&gt; System.out.print(x.getValue()+<span class="string">","</span>));</span><br></pre></td></tr></table></figure><p>输出</p><p>9,6,4,3,</p><h4 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h4><p><code>limit(int n)</code>当流中元素数大于n时丢弃超出的元素, 否则不进行处理, 达到限制流长度的目的.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br><span class="line">List&lt;Integer&gt; integerList = stream3.limit(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[3, 5, 1]</p><h4 id="skip"><a href="#skip" class="headerlink" title="skip"></a>skip</h4><p><code>skip(int)</code>返回丢弃了前n个元素的流. 如果流中的元素小于或者等于n，则返回空的流</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">8</span>,<span class="number">7</span>);</span><br><span class="line">List&lt;Integer&gt; integerList = stream3.skip(<span class="number">3</span>).collect(Collectors.toList());</span><br><span class="line">System.out.println(integerList);</span><br></pre></td></tr></table></figure><p>输出</p><p>[4, 2, 6, 8, 7]</p><h3 id="终点操作"><a href="#终点操作" class="headerlink" title="终点操作"></a>终点操作</h3><h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h4><p><code>reduce(accumulator)</code>是最基本的终点操作之一, 操作函数<code>accumulator</code>接受两个参数<code>x</code>,<code>y</code>返回<code>r</code>.</p><p><code>reduce</code>首先将数据源中的两个元素<code>x1</code>和<code>x2</code>传给<code>accumulator</code>得到<code>r1</code>, 然后将<code>r1</code>和<code>x3</code>传入得到<code>r2</code>. 如此进行直到处理完整个数据流.</p><p><code>reduce</code>方法还可以接受一个参数代替<code>x1</code>作为起始值:</p><h4 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h4><p><code>collect</code>是使用最广泛的终点操作, 也上文中多次出现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Stream.of(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;b&quot;)</span><br><span class="line">        .distinct()</span><br><span class="line">        .collect(Collectors.toList())</span><br></pre></td></tr></table></figure><p><code>toList()</code>将流转换为<code>List</code>实例, 是最常见的用法, <code>java.util.Collectors</code>类中还有求和, 计算均值, 取最值, 字符串连接等多种收集方法.</p><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h4><p><code>forEach</code>方法对流中所有元素执行给定操作, 没有返回值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stream.of(1,2,3,4,5).forEach(System.out::println);</span><br></pre></td></tr></table></figure><h3 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h3><ul><li><code>count()</code> 返回流中的元素数</li><li><code>toArray()</code>: 转换为数组</li></ul><h2 id="并发问题"><a href="#并发问题" class="headerlink" title="并发问题"></a>并发问题</h2><p>除非显式地创建并行流, 否则默认创建的都是串行流.<code>Collection.stream()</code>为集合创建串行流,而<code>Collection.parallelStream()</code>创建并行流.</p><p><code>stream.parallel()</code>方法可以将串行流转换成并行流,<code>stream.sequential()</code>方法将流转换成串行流.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;Integer&gt; stream3 = Stream.of(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>);</span><br><span class="line">stream3.forEach(x-&gt; System.out.print(x+<span class="string">","</span>));</span><br></pre></td></tr></table></figure><p>输出</p><p>1,2,3,4,5,6,7,8,9,</p><p>流可以在非线程安全的集合上创建, 流操作不应该对非线程安全的数据源产生任何副作用, 否则将发生<code>java.util.ConcurrentModificationException</code>异常.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new ArrayList(Arrays.asList(&quot;x&quot;, &quot;y&quot;));</span><br><span class="line">list.stream().forEach(x-&gt; list.add(&quot;z&quot;));</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.util.ConcurrentModificationException</span><br><span class="line">	at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:<span class="number">1388</span>)</span><br><span class="line">	at java.util.stream.ReferencePipeline$Head.forEach(ReferencePipeline.java:<span class="number">580</span>)</span><br><span class="line">	at com.test.lambda.LambdaTest.main(LambdaTest.java:<span class="number">15</span>)</span><br></pre></td></tr></table></figure><p>对于线程安全的容器不会存在这个问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = new CopyOnWriteArrayList(Arrays.asList(&quot;x&quot;, &quot;y&quot;));</span><br><span class="line">list.stream().forEach(x-&gt;&#123;</span><br><span class="line">	list.add(&quot;z&quot;);</span><br><span class="line">	System.out.println(list);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>输出</p><p>[x, y, z]<br>[x, y, z, z]</p><p>当然作者建议Stream操作不要对数据源进行任何修改. 当然, 修改其它数据或者输入输出是允许的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Set&lt;String&gt; set = new HashSet&lt;String&gt;();</span><br><span class="line">List&lt;String&gt; list = new CopyOnWriteArrayList(Arrays.asList(&quot;x&quot;, &quot;y&quot;));</span><br><span class="line">list.stream().forEach(x-&gt;&#123;</span><br><span class="line">    set.add(x);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>理想的管道操作应该是无状态且与访问顺序无关的. 无状态是指操作的结果只与输入有关, 下面即是一个有状态的操作示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">State state = getState();</span><br><span class="line">List&lt;String&gt; list = new ArrayList(Arrays.asList(&quot;a&quot;, &quot;b&quot;));</span><br><span class="line">list = list.stream().map(s -&gt; &#123;</span><br><span class="line">  if (state.isReady()) &#123;</span><br><span class="line">    return s;</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>无状态的操作保证无论系统状态如何管道的行为不变, 与顺序无关则有利于进行并行计算.</p><h2 id="函数式接口"><a href="#函数式接口" class="headerlink" title="函数式接口"></a>函数式接口</h2><p>函数式接口会将签名匹配的函数对象(lambda表达式或方法)视作接口的实现。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">interface Greeter</span><br><span class="line">&#123;</span><br><span class="line">    void hello(String message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数式接口中有且只有一个非抽象方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Greeter greeter = message -&gt; System.out.println(&quot;Hello &quot; + message);</span><br></pre></td></tr></table></figure><p>这在 Java 8 之前通常使用匿名内部类实现的:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Greeter greeter = new Greeter() &#123;</span><br><span class="line">            @Override</span><br><span class="line">            public void hello(String message) &#123;</span><br><span class="line">                System.out.println(&quot;Hello &quot; + message);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure><p>Java 8 将已有的一些接口实现为函数式接口:</p><ul><li>java.lang.Runnable</li><li>java.util.concurrent.Callable</li><li>java.util.Comparator</li><li>java.lang.reflect.InvocationHandler</li><li>java.io.FileFilter</li><li>java.nio.file.PathMatcher</li></ul><p><code>java.util.function</code>中定义了一些常用的函数式接口:</p><ul><li>Consumer: 接受参数无返回<ul><li><code>Consumer&lt;T&gt;</code> -&gt; <code>void accept(T t)</code>;</li><li><code>BiConsumer&lt;T,U&gt;</code> -&gt; <code>void accept(T t, U u);</code></li><li><code>DoubleConsumer</code> -&gt; <code>void accept(double value);</code></li></ul></li><li>Supplier: 不接受参数有返回<ul><li><code>Supplier&lt;T&gt;</code> -&gt; <code>T get();</code></li><li><code>DoubleSupplier</code> -&gt; <code>double getAsDouble();</code></li></ul></li><li>Function: 接受参数并返回<ul><li><code>Function&lt;T, R&gt;</code> -&gt; <code>R apply(T t);</code></li><li><code>BiFunction&lt;T, U, R&gt;</code> -&gt; <code>R apply(T t, U u);</code></li><li><code>DoubleFunction&lt;R&gt;</code> -&gt; <code>R apply(double value);</code></li><li><code>DoubleToIntFunction</code> -&gt; <code>int applyAsInt(double value);</code></li><li><code>BinaryOperator&lt;T&gt;</code> extends <code>BiFunction&lt;T,T,T&gt;</code></li></ul></li><li>Predicate: 接受参数返回boolean<ul><li><code>Predicate&lt;T&gt;</code> -&gt; <code>boolean test(T t);</code></li><li><code>BiPredicate&lt;T, U&gt;</code> -&gt; <code>boolean test(T t, U u);</code></li><li><code>DoublePredicate</code> -&gt; <code>boolean test(double value);</code></li></ul></li></ul><p>默认构造器可以作为supplier: <code>Supplier&lt;Item&gt; supplier = Item::new;</code></p></div><div class="post-footer"><div>转载声明：商业转载请联系作者获得授权,非商业转载请注明出处 © <a href target="_blank">Snippet</a></div><div></div></div></article><div class="article-nav prev-next-wrap clearfix"><a href="java多线程基础-03.html" class="pre-post btn btn-default" title="Java多线程更多了解"><i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span> <span class="hidden-xs">Java多线程更多了解</span> </a><a href="java多线程基础-02.html" class="next-post btn btn-default" title="认识Java里的线程"><span class="hidden-lg">下一篇</span> <span class="hidden-xs">认识Java里的线程</span><i class="fa fa-angle-right fa-fw"></i></a></div><div id="comments"><div id="vcomments" class="valine"></div><script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script><script src="assets/valine.min.js"></script><script>new Valine({av:AV,el:"#vcomments",appId:"xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz",appKey:"erIpQac4azoCmgfBB7Dl9maa",placeholder:"说点什么吧",notify:!1,verify:!0,avatar:"mm",meta:"nick,mail".split(","),pageSize:"10",path:window.location.pathname,lang:"zh-CN".toLowerCase()})</script></div></main><aside id="article-toc" role="navigation" class="col-md-4"><div class="widget"><h3 class="title">文章目录</h3><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#java流式计算Stream详解"><span class="toc-text">java流式计算Stream详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Stream-是什么"><span class="toc-text">Stream 是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数对象"><span class="toc-text">函数对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#流的创建"><span class="toc-text">流的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中间操作"><span class="toc-text">中间操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#distinct"><span class="toc-text">distinct</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#filter"><span class="toc-text">filter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#map"><span class="toc-text">map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#peek"><span class="toc-text">peek</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#flatMap"><span class="toc-text">flatMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#sorted"><span class="toc-text">sorted</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#limit"><span class="toc-text">limit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#skip"><span class="toc-text">skip</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#终点操作"><span class="toc-text">终点操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#reduce"><span class="toc-text">reduce</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#collect"><span class="toc-text">collect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#forEach"><span class="toc-text">forEach</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#其它"><span class="toc-text">其它</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#并发问题"><span class="toc-text">并发问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式接口"><span class="toc-text">函数式接口</span></a></li></ol></div></aside></div></div></section><footer class="main-footer"><div class="container"><div class="row"></div></div></footer><a id="back-to-top" class="icon-btn hide"><i class="fa fa-chevron-up"></i></a><div class="copyright"><div class="container"><div class="row"><div class="col-sm-12"><div class="busuanzi">访问量: <strong id="busuanzi_value_site_pv"><i class="fa fa-spinner fa-spin"></i> </strong>&nbsp; | &nbsp; 访客数: <strong id="busuanzi_value_site_uv"><i class="fa fa-spinner fa-spin"></i></strong></div></div><div class="col-sm-12"><span>Copyright &copy; 2017 </span>| <span>Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a> </span>| <span>Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a></span></div></div></div></div><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="js/app.js?rev=@@hash"></script></body><!-- rebuild by neat -->